+function() {
//'use strict';

if (window.twaver) {
    window.twaver.animateLoopId && cancelAnimationFrame(window.twaver.animateLoopId);
    window.twaver.animateLoopId = null;
}
if (!String.prototype.startsWith) {
    String.prototype.startsWith = function (searchString, position) {
        position = position || 0;
        return this.indexOf(searchString, position) === position;
    };
}

var twaver = {};
twaver._isInitializing = false;
var _twaver = {
    isDeserializing: false,
    isCalculatingBus: false,
    images: {},
    registerImage: function (name, source, width, height, svg) {
        _twaver.images[name] = new twaver.ImageAsset(name, source, width, height, svg);
        refresh_pattern_cache(name);
    },
    getRegisteredImageNames: function () {
        return Object.keys(_twaver.images);
    },
    unregisterImage: function (name) {
        delete _twaver.images[name];
    },
    getImageAsset: function (name) {
        if (typeof name !== 'string') return;
        var imageAsset = _twaver.images[name];

        return imageAsset;
    },
    showVersion: function (e) {
        if (_twaver.isCtrlDown(e) && e.shiftKey && e.keyCode == 76) {
            alert('TWaver HTML5 ' + twaver.Util.getVersion() + '\n' + $license);
        }
    },
    callLater: function (func, scope, args, delay) {
        return setTimeout(function () {
            func.apply(scope, args);
        }, delay || $Defaults.CALL_LATER_DELAY);
    },
    isEmptyObject: function (obj) {
        for (var name in obj) {
            return false;
        }
        return true;
    },
    xml: function (s) {
        if (window.DOMParser) {
            return new DOMParser().parseFromString(s, "text/xml");
        } else {
            var x = new ActiveXObject("Microsoft.XmlDOM");
            x.async = false;
            x.loadXml(s);
            return x;
        }
    },
    num: function (v) {
        return typeof v === "number" && !isNaN(v) && isFinite(v);
    },
    getter: function (n) {
        var N = n.charAt(0).toUpperCase() + n.slice(1);
        var G = (/ble$/.test(n) || /ed$/.test(n)) ? 'is' : 'get'
        return G + N;
    },
    setter: function (n) {
        var N = n.charAt(0).toUpperCase() + n.slice(1);
        return 'set' + N;
    },
    _id: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'],
    id: function () {
        var s = [];
        for (var i = 0; i < 32; i++) {
            s[i] = this._id[Math.floor(twaver.Util.random() * 0x10)];
        }
        s[12] = "4";
        s[16] = this._id[(s[16] & 0x3) | 0x8];
        return s.join("");
    },
    keys: function (o) {
        var list = new $List();
        for (var k in o) {
            list.add(k);
        }
        return list;
    },
    es: ['toString', 'toLocaleString', 'valueOf'],
    ip: function (o, n) {
        var _n = '_' + n;
        o[_twaver.getter(n)] = function () {
            return this[_n];
        };
        o[_twaver.setter(n)] = function (v) {
            var ov = this[_n];
            this[_n] = v;
            this.firePropertyChange(n, ov, v);
        };
    },
    validateLicense: function (license) {
        $license = license;
        __v();
    },
    ibool: function (o, n) {
        var _n = '_' + n;
        var N = n.charAt(0).toUpperCase() + n.slice(1);
        o['is' + N] = function () {
            return this[_n];
        };
        o[_twaver.setter(n)] = function (v) {
            var ov = this[_n];
            this[_n] = v;
            this.firePropertyChange(n, ov, v);
        };
    },
    getValue: function (o, n, t) {
        var N = n.charAt(0).toUpperCase() + n.slice(1),
            getF = 'get' + N,
            isF = 'is' + N;
        if (t) {
            if (t === 'boolean') {
                return o[isF]();
            } else {
                return o[getF]();
            }
        } else {
            if (o[getF]) {
                return o[getF]();
            } else if (o[isF]) {
                return o[isF]();
            } else {
                return o[n];
            }
        }
    },
    setValue: function (o, n, v) {
        o['set' + n.charAt(0).toUpperCase() + n.slice(1)](v);
    },

    clone: function (o) {
        if (!o) {
            return null;
        }
        var c = {};
        for (var name in o) {
            c[name] = o[name];
        }
        return c;
    },
    cloneRect: function (o) {
        if (!o) {
            return null;
        }
        return {
            x: o.x,
            y: o.y,
            width: o.width,
            height: o.height
        };
    },
    classCache: {},
    getClass: function (className) {
        var clazz = _twaver.classCache[className];
        if (!clazz) {
            var ss = className.split('.');
            var n = ss.length;
            clazz = window;
            for (var i = 0; i < n; i++) {
                clazz = clazz[ss[i]];
                if (!clazz) {
                    if ('twaver' === ss[i]) {
                        clazz = twaver;
                    }
                }
            }
            _twaver.classCache[className] = clazz;
        }
        return clazz;
    },
    newInstance: function (className) {
        var clazz = _twaver.getClass(className) || window[className];
        if (!clazz) {
            return null;
        }
        var len = arguments.length;
        var args = arguments;
        if (len === 1) {
            return new clazz();
        } else if (len === 2) {
            return new clazz(args[1]);
        } else if (len === 3) {
            return new clazz(args[1], args[2]);
        } else if (len === 4) {
            return new clazz(args[1], args[2], args[3]);
        } else if (len === 5) {
            return new clazz(args[1], args[2], args[3], args[4]);
        } else if (len === 6) {
            return new clazz(args[1], args[2], args[3], args[4], args[5]);
        } else if (len === 7) {
            return new clazz(args[1], args[2], args[3], args[4], args[5], args[6]);
        } else if (len === 8) {
            return new clazz(args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        }
        throw "don't support args more than 7";
    },
    addMethod: function (clazz, o) {
        var p = clazz.prototype;
        for (var name in o) {
            p[name] = o[name];
        }
    },
    ext: function (subClass, superClass, o) {
        var className;
        if (typeof subClass === 'string') {
            className = subClass;
            subClass = _twaver.getClass(subClass);
        }
        if (superClass) {
            var F = function () {};
            F.prototype = superClass.prototype;
            subClass.prototype = new F();
            subClass.prototype.constructor = subClass;

            subClass.superClass = superClass.prototype;
            if (superClass.prototype.constructor == Object.prototype.constructor) {
                superClass.prototype.constructor = superClass;
            }
        }
        if (className) {
            subClass.prototype.getClassName = function () {
                return className;
            };
        }
        if (o) {
            var p = subClass.prototype;
            for (var name in o) {
                $extend.ext(name, p, o);
            }
            var n = _twaver.es.length;
            for (var i = 0; i < n; i++) {
                name = _twaver.es[i];
                if (o.hasOwnProperty(name) && !o.propertyIsEnumerable(name)) {
                    p[name] = o[name];
                }
            }
        }
    },
    setViewBounds: function (view, rect) {
        if (!view) {
            return;
        }
        if (view.adjustBounds) {
            view.adjustBounds(rect);
        } else {
            var style = view.style;
            if (!style && view.getView()) {
                style = view.getView().style;
            }
            if (style) {
                style.position = 'absolute';
                style.left = rect.x + 'px';
                style.top = rect.y + 'px';
                style.width = rect.width + 'px';
                style.height = rect.height + 'px';
            }
        }
    },
    getImageSrc: function (name) {
        var imageAsset = _twaver.getImageAsset(name);
        if (imageAsset) {
            if (imageAsset.getSrc()) {
                return imageAsset.getSrc();
            } else {
                return imageAsset.getImage().getAttribute('src');
            }
        } else {
            return name;
        }
    },
    nextColorCount: 0,
    nextColor: function () {
        if (_twaver.nextColorCount >= $Defaults.COLORS.length) {
            _twaver.nextColorCount = 0;
        }
        return $Defaults.COLORS[_twaver.nextColorCount++];
    },
    isCtrlDown: function (evt) {
        return evt.ctrlKey || evt.metaKey;
    },
    isShiftDown: function (evt) {
        return evt.shiftKey;
    },
    isAltDown: function (evt) {
        return evt.altKey;
    },
    setText: function (element, text, isInnerText) {
        if (isInnerText) {
            if ($ua.isFirefox) {
                element.textContent = text;
            } else {
                element.innerText = text;
            }
        } else {
            element.innerHTML = text;
        }
    },
    fillDescendant: function (parent, list) {
        list.add(parent);
        if (parent.hasChildren()) {
            parent.getChildren().forEach(function (child) {
                _twaver.fillDescendant(child, list);
            });
        }
    }
};

var d = Date;

var $license =
    "l=1.0\n" +
    "type=1\n" +
    "gis=1\n" +
    "3d=0\n" +
    "start=2017-12-01\n" +
    "end=2018-04-01\n" +
    "note=This license applies to the evaluation version of TWaver. The License is limited to noncommercial use. Noncommercial use relates only to educational, research, personal or evaluation purposes. Any other use is commercial use. You may not use the Software in connection with any business activities.And You are not permitted to modify the software or attempt to decipher, decompile, disassemble or reverse engineer this Software.\n" +
    "signature=29db197aa8aa8977f8cf9c45989ade1067302a63ed3a5e024de67be106669c98ec88ae0d801b59a10f19d7f450c331e89ac99bfd0796d4d6cf8774e094b91e67b426ad544384b21f0fc6149463d0536db614a8e83562182065ab0fa964dce9b9dba0874bc4eea08de59fa8f3c3002689f0c39d842ec75fcb67483ccdb1ace9f70f7d12957279b2ff540917a2b2c0ca499925b8b2983fc489a9052d1910423454f585d6795e2e6b405e8b45d21b6cabc0000d7731f0915c65a17f129086cc30b79e9fe9a3160b0af906eab2f60cc299d0e8b92c66bd77aaf5005e1a6eb1fd40eb5f976c9b83f718a8d77e36a1f1f549b377bb182785cedc1c5c47c5d221db6218303d8257304425df08ae76d2bc35efb763594cf66ac31c1cc14db46515e232d27a55cef0ed4e81ecc4e5c26c01137c4e6126017235301770f8f061b96a27d43106233d7298df2a3d9f3b68b563a86459b513f102332c4e3ec2817b4b6f268f34c1c214be7c70099905a05a6f4c30007ec06e11eb6fa911c4af47b50b0f5e989c0f22b833060ee6ffb6909e316d32d2b74919ffb73950924b13c489cb9526c23108a2c4cc40bae552fd7037e46c9339711e1b51c3e7245b1144d17ad13f47646ddc23575e3e935bfa5f7b8b9ae3ed23d9bf761ab040378de4e38ccd0a8e51b79721514d2aaeea042b604e1c2b54e86c8967682037962659116c5098ea5ff3d84936977537b300e722dced2461406e84f9138adda268a26451d2ae2b13586f0e44694a6e95b3756d962bd6e2d66c9d3b96e36c909924fd553778cc528e4dcbae84258067aa38ffb3788c063bdcd5bc55e98878653dc9162361acd731fe4b21bfac7782f7768c719a6325cbab1328410ef66282d30c1562cab5acf3c125efd6bcd3"

if (typeof define === 'function') { //AMD
    define(function () {
        return twaver;
    });
} else if (typeof exports === 'object') { // Node.js
    module.exports = twaver;
}
if (window) {
    window.twaver = twaver;
    window._twaver = _twaver;
}
twaver.animate = {};
twaver.network = {};
twaver.network.interaction = {};
twaver.controls = {};
twaver.charts = {};
twaver.layout = {};

var Canvas, isNodejs, navigator = window.navigator,
    document = window.document,
    Image = window.Image;
if (!window.document) {
    isNodejs = true;
    Canvas = function () {}; //require('canvas');
    Image = Canvas.Image;
    navigator = {
        userAgent: ''
    };
    document = {};
}
var $ua = (function () {
    var o = {}
    var u = navigator.userAgent.toLowerCase();
    o.isOpera = (/opera/).test(u);
    o.isIE = (/msie/).test(u) || /trident/.test(u) || /edge/.test(u);
    o.isFirefox = (/firefox/i).test(u);
    o.isChrome = (/chrome/i).test(u);
    o.isSafari = !o.isChrome && (/safari/i).test(u);
    o.isIPhone = (/iphone/).test(u);
    o.isIPod = (/ipod/).test(u);
    o.isIPad = (/ipad/).test(u);
    o.isAndroid = (/android/i).test(u);
    o.isWebOS = (/webos/i).test(u);
    o.isMSTouchable = o.isIE && ((navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1) ||
        (navigator.maxTouchPoints && navigator.maxTouchPoints > 1));
    o.isTouchable = ("ontouchend" in document) || o.isMSTouchable;
    return o;
})();
_twaver.ua = $ua;


var $extend = {
    __accessor: function (p, o) {
        var ps = o['__accessor'];
        var n = ps.length;
        for (var i = 0; i < n; i++) {
            _twaver.ip(p, ps[i]);
        }
    },
    __bool: function (p, o) {
        var bs = o['__bool'];
        var n = bs.length;
        for (var i = 0; i < n; i++) {
            _twaver.ibool(p, bs[i]);
        }
    },
    __client: function (p, o) {
        p.getClient = function (clientProp) {
            return this._clientMap[clientProp];
        };
        p.setClient = function (clientProp, newValue) {
            var oldValue = this._clientMap[clientProp];
            if (newValue == null) {
                delete this._clientMap[clientProp];
            } else {
                this._clientMap[clientProp] = newValue;
            }
            if (this.firePropertyChange('C:' + clientProp, oldValue, newValue)) {
                this.onClientChanged(clientProp, oldValue, newValue);
            }
            return this;
        };
        p.getClientProperties = function () {
            return _twaver.keys(this._clientMap);
        };
        p.getClientMap = function () {
            return this._clientMap;
        };
        p.onClientChanged = function (clientProp, oldValue, newValue) {
        };
    },
    __style: function (p, o) {
        p.getStyle = function (styleProp) {
            var value = this._styleMap[styleProp];
            if (value == null) {
                return $Styles._m[styleProp];
            } else {
                return value;
            }
        };
        p.setStyle = function (styleProp, newValue) {
            var oldValue = this._styleMap[styleProp];
            if (newValue == null) {
                delete this._styleMap[styleProp];
            } else {
                this._styleMap[styleProp] = newValue;
            }
            if (this.firePropertyChange('S:' + styleProp, oldValue, newValue)) {
                this.onStyleChanged(styleProp, oldValue, newValue);
            }
            return this;
        };
        p.getStyleProperties = function () {
            return _twaver.keys(this._styleMap);
        };
        p.onStyleChanged = function (styleProp, oldValue, newValue) {
        };
    },
    __new: function (p, o) {
        p.newInstance = function () {
            var clazz = _twaver.getClass(this.getClassName());
            if (!clazz) {
                return null;
            }
            var len = arguments.length;
            var args = arguments;
            if (len === 0) {
                return new clazz();
            } else if (len === 1) {
                return new clazz(args[0]);
            } else if (len === 2) {
                return new clazz(args[0], args[1]);
            } else if (len === 3) {
                return new clazz(args[0], args[1], args[2]);
            } else if (len === 4) {
                return new clazz(args[0], args[1], args[2], args[3]);
            } else if (len === 5) {
                return new clazz(args[0], args[1], args[2], args[3], args[4]);
            } else if (len === 6) {
                return new clazz(args[0], args[1], args[2], args[3], args[4], args[5]);
            } else if (len === 7) {
                return new clazz(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            throw "don't support args more than 7";
        };
    },
    __property: function (p, o) {
        p.getValue = function (data, view) {
            if (this._propertyType === 'accessor') {
                return _twaver.getValue(data, this._propertyName);
            }
            else if (this._propertyType === 'style' && data.getStyle) {
                return data.getStyle(this._propertyName);
            }
            else if (this._propertyType === 'client' && data.getClient) {
                return data.getClient(this._propertyName);
            }
            else if (this._propertyType === 'field') {
                return data[this._propertyName];
            }
            return null;
        };
        p.setValue = function (data, value, view) {
            if (this._propertyType === 'accessor') {
                data[_twaver.setter(this._propertyName)](value);
            }
            else if (this._propertyType === 'style' && data.setStyle) {
                return data.setStyle(this._propertyName, value);
            }
            else if (this._propertyType === 'client' && data.setClient) {
                return data.setClient(this._propertyName, value);
            }
            else if (this._propertyType === 'field') {
                data[this._propertyName] = value;
            }
        };
    },
    map: {
        __accessor: 1,
        __bool: 1,
        __client: 1,
        __style: 1,
        __new: 1,
        __tree: 1,
        __property: 1
    },
    ext: function (name, p, o) {
        if ($extend.map[name] === 1) {
            $extend[name](p, o);
        } else {
            p[name] = o[name];
        }
    }
};
_twaver.extend = $extend;

var $Matrix = _twaver.Matrix = function (m11, m12, m21, m22, offsetX, offsetY) {
    this.setMatrix(m11, m12, m21, m22, offsetX, offsetY);
};
$Matrix.identity = function () {
    return new $Matrix(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
};
$Matrix.prototype.setMatrix = function (m11, m12, m21, m22, offsetX, offsetY) {
    this._m11 = m11;
    this._m12 = m12;
    this._m21 = m21;
    this._m22 = m22;
    this._offsetX = offsetX;
    this._offsetY = offsetY;
    this._type = 0;

    if ((this._m21 != 0.0) || (this._m12 != 0.0)) {
        this._type = 4;
    } else {
        if ((this._m11 != 1.0) || (this._m22 != 1.0)) {
            this._type = 2;
        }
        if ((this._offsetX != 0.0) || (this._offsetY != 0.0)) {
            this._type |= 1;
        }
        if ((this._type & (2 | 1)) == 0) {
            this._type = 0;
        }
    }
};
$Matrix.prototype.transform = function () {
    var point;
    if (arguments.length === 2) {
        point = { x: arguments[0], y: arguments[1] };
    } else {
        point = arguments[0];
    }
    if (!point || !_twaver.num(point.x) || !_twaver.num(point.y)) {
        throw "arguments should contain x, y";
    }
    switch (this._type) {
        //TRANSFORM_IS_IDENTITY    
        case 0:
            return { x: point.x, y: point.y };
            //TRANSFORM_IS_TRANSLATION
        case 1:
            return { x: this._offsetX + point.x, y: this._offsetY + point.y };
            //TRANSFORM_IS_SCALING
        case 2:
            return { x: point.x * this._m11, y: point.y * this._m22 };
            //TRANSFORM_IS_TRANSLATION && TRANSFORM_IS_SCALING
        case 3:
            return { x: point.x * this._m11 + this._offsetX, y: point.y * this._m22 + this._offsetY };
    }
    //TRANSFORM_IS_UNKNOWN
    return { x: this._m11 * point.x + point.y * this._m21 + this._offsetX, y: this._m22 * point.y + point.x * this._m12 + this._offsetY };
};
$Matrix.prototype.translate = function (translateX, translateY) {
    this.multiply(new $Matrix(1.0, 0, 0, 1.0, translateX, translateY));
};
$Matrix.prototype.scale = function (scaleX, scaleY) {
    this.multiply(new $Matrix(scaleX, 0, 0, scaleY, 0.0, 0.0));
};
$Matrix.prototype.rotate = function (angle, centerX, centerY) {
    angle = angle * Math.PI / 180;
    var num2 = Math.sin(angle);
    var num = Math.cos(angle);
    var offsetX = (centerX * (1.0 - num)) + (centerY * num2);
    var offsetY = (centerY * (1.0 - num)) - (centerX * num2);
    this.multiply(new $Matrix(num, num2, -num2, num, offsetX, offsetY));
};
$Matrix.prototype.skew = function (skewX, skewY) {
    this.multiply(new $Matrix(1.0, Math.tan(skewY * Math.PI / 180), Math.tan(skewX * Math.PI / 180), 1.0, 0.0, 0.0));
};
$Matrix.prototype.multiply = function (matrix) {
    var matrix1 = this;
    var matrix2 = matrix;
    var types2 = matrix1._type;
    var types = matrix2._type;
    if (types != 0)
    {
        if (types2 == 0)
        {
            matrix1.setMatrix(matrix2._m11, matrix2._m12, matrix2._m21, matrix2._m22, matrix2._offsetX, matrix2._offsetY);
        }
        else if (types == 1)
        {
            matrix1._offsetX += matrix2._offsetX;
            matrix1._offsetY += matrix2._offsetY;
            if (types2 != 4)
            {
                matrix1._type |= 1;
            }
        }
        else if (types2 == 1)
        {
            var num3 = matrix1._offsetX;
            var num2 = matrix1._offsetY;
            matrix1.setMatrix(matrix2._m11, matrix2._m12, matrix2._m21, matrix2._m22, matrix2._offsetX, matrix2._offsetY);
            matrix1._offsetX = ((num3 * matrix2._m11) + (num2 * matrix2._m21)) + matrix2._offsetX;
            matrix1._offsetY = ((num3 * matrix2._m12) + (num2 * matrix2._m22)) + matrix2._offsetY;
            if (types == 4)
            {
                matrix1._type = 4;
            }
            else
            {
                matrix1._type = 2 | 1;
            }
        }
        else
        {
            switch (((types2 << 4) | types))
            {
                case 0x22:
                    matrix1._m11 *= matrix2._m11;
                    matrix1._m22 *= matrix2._m22;
                    return;

                case 0x23:
                    matrix1._m11 *= matrix2._m11;
                    matrix1._m22 *= matrix2._m22;
                    matrix1._offsetX = matrix2._offsetX;
                    matrix1._offsetY = matrix2._offsetY;
                    matrix1._type = 2 | 1;
                    return;

                case 0x24:
                case 0x34:
                case 0x42:
                case 0x43:
                case 0x44:
                    matrix1.setMatrix((matrix1._m11 * matrix2._m11) + (matrix1._m12 * matrix2._m21), (matrix1._m11 * matrix2._m12) + (matrix1._m12 * matrix2._m22), (matrix1._m21 * matrix2._m11) + (matrix1._m22 * matrix2._m21), (matrix1._m21 * matrix2._m12) + (matrix1._m22 * matrix2._m22), ((matrix1._offsetX * matrix2._m11) + (matrix1._offsetY * matrix2._m21)) + matrix2._offsetX, ((matrix1._offsetX * matrix2._m12) + (matrix1._offsetY * matrix2._m22)) + matrix2._offsetY);
                    return;

                case 50:
                    matrix1._m11 *= matrix2._m11;
                    matrix1._m22 *= matrix2._m22;
                    matrix1._offsetX *= matrix2._m11;
                    matrix1._offsetY *= matrix2._m22;
                    return;

                case 0x33:
                    matrix1._m11 *= matrix2._m11;
                    matrix1._m22 *= matrix2._m22;
                    matrix1._offsetX = (matrix2._m11 * matrix1._offsetX) + matrix2._offsetX;
                    matrix1._offsetY = (matrix2._m22 * matrix1._offsetY) + matrix2._offsetY;
                    return;
                default: 
                    console.log("Matrix multiply hit an invalid case: " + combinedType); 
                    break;
            }
        }
    }
};

var $math = {
    getDistance: function (p1, p2) {
        var dx = p2.x - p1.x;
        var dy = p2.y - p1.y;
        return Math.sqrt(dx * dx + dy * dy);
    },
    getCenterPoint: function (p1, p2) {
    	if(p1 && p2){
           return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    	}else if(p2 == null && p1.width){
    		return {
    			x : p1.x + p1.width/2,
    			y : p1.y + p1.height/2
    		};
    	}
    },
    isPointInPolygon: function (points, point) {
        points = points._as ? points._as : points;
        var i = 0, j = 0, c = false, size = points.length;
        for (i = 0, j = size - 1; i < size; j = i++) {
            var p1 = points[i];
            var p2 = points[j];
            if (((p1.y > point.y) != (p2.y > point.y)) && (point.x < (p2.x - p1.x) * (point.y - p1.y) / (p2.y - p1.y) + p1.x)) {
                c = !c;
            }
        }
        return c;
    },
    unionRect: function (rect1, rect2) {
        if (rect1 && !rect2) {
            return _twaver.cloneRect(rect1);
        }
        if (!rect1 && rect2) {
            return _twaver.cloneRect(rect2);
        }
        if (rect1 && rect2) {
            var x = Math.min(rect1.x, rect2.x),
                y = Math.min(rect1.y, rect2.y),
                width = Math.max(rect1.x + rect1.width, rect2.x + rect2.width) - x,
                height = Math.max(rect1.y + rect1.height, rect2.y + rect2.height) - y;
            rect1.x = x;
            rect1.y = y;
            rect1.width = width;
            rect1.height = height;
            return rect1;
        }
        return null;
    },
    intersects: function (r, r2) {
        if (!r || !r2) {
            return false;
        }
        var tw = r2.width;
        var th = r2.height;
        var rw = r.width;
        var rh = r.height;
        if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {
            return false;
        }
        var tx = r2.x;
        var ty = r2.y;
        var rx = r.x;
        var ry = r.y;
        rw += rx;
        rh += ry;
        tw += tx;
        th += ty;
        //      overflow || intersect
        return ((rw < rx || rw > tx) &&
		    (rh < ry || rh > ty) &&
		    (tw < tx || tw > rx) &&
		    (th < ty || th > ry));
    },
    intersection: function (r, r2) {
        if (!r || !r2) {
            return false;
        }
        var tx1 = r2.x;
        var ty1 = r2.y;
        var rx1 = r.x;
        var ry1 = r.y;
        var tx2 = tx1; tx2 += r2.width;
        var ty2 = ty1; ty2 += r2.height;
        var rx2 = rx1; rx2 += r.width;
        var ry2 = ry1; ry2 += r.height;
        if (tx1 < rx1) tx1 = rx1;
        if (ty1 < ry1) ty1 = ry1;
        if (tx2 > rx2) tx2 = rx2;
        if (ty2 > ry2) ty2 = ry2;
        tx2 -= tx1;
        ty2 -= ty1;
        if (tx2 === 0 || ty2 === 0) {
            return null;
        }
        return { x: tx1, y: ty1, width: tx2, height: ty2 };
    },
    contains: function (rect, r2) {
        var X = r2.x, Y = r2.y, W = r2.width, H = r2.height;
        var w = rect.width;
        var h = rect.height;
        if ((w | h | W | H) < 0) {
            // At least one of the dimensions is negative...
            return false;
        }
        // Note: if any dimension is zero, tests below must return false...
        var x = rect.x;
        var y = rect.y;
        if (X < x || Y < y) {
            return false;
        }
        w += x;
        W += X;
        if (W <= X) {
            // X+W overflowed or W was zero, return false if...
            // either original w or W was zero or
            // x+w did not overflow or
            // the overflowed x+w is smaller than the overflowed X+W
            if (w >= x || W > w) return false;
        } else {
            // X+W did not overflow and W was not zero, return false if...
            // original w was zero or
            // x+w did not overflow and x+w is smaller than X+W
            if (w >= x && W > w) return false;
        }
        h += y;
        H += Y;
        if (H <= Y) {
            if (h >= y || H > h) return false;
        } else {
            if (h >= y && H > h) return false;
        }
        return true;
    },
    getLinePoints: function (points) {
        if (!points) {
            return null;
        }
        var list = new $List();
        points.forEach(function (point) {
            list.addAll(point);
        });
        return list;
    },
    getLineRect: function (points) {
        var ps = $math.getLinePoints(points);
        return $math.getRect(ps);
    },

	getRect: function (points,rect) {
		if (!points) {
			return null;
		}
		if (points._as) {
			points = points._as;
		}
		var count = points.length;
		if (count <= 0) {
			return null;
		}
		var point = points[0];
		rect = rect || {
			x : null,
			y : null,
			width : 0,
			height : 0
		};

		for (var i = 0; i < count; i++) {
			point = points[i];
			if ( point instanceof $List) {
				$math.getRect(point, rect);
			} else {
				if(rect.x == null){
					rect.x = point.x;
					rect.y = point.y;
				}
				var x1 = Math.min(rect.x, point.x);
				var y1 = Math.min(rect.y, point.y);
				var x2 = Math.max(rect.x + rect.width, point.x);
				var y2 = Math.max(rect.y + rect.height, point.y);
				rect.x = x1;
				rect.y = y1;
				rect.width = x2 - x1;
				rect.height = y2 - y1;
			}

		}
		return rect;
	},

    addPadding: function (rect, element, styleProp, plus) {
        plus = plus || -1;
        var padding = element.getStyle(styleProp) * plus;
        if (padding != 0) {
            $math.grow(rect, padding, padding);
        }
        padding = element.getStyle(styleProp + ".left") * plus;
        if (padding != 0) {
            rect.x -= padding;
            rect.width += padding;
        }
        padding = element.getStyle(styleProp + ".right") * plus;
        if (padding != 0) {
            rect.width += padding;
        }
        padding = element.getStyle(styleProp + ".top") * plus;
        if (padding != 0) {
            rect.y -= padding;
            rect.height += padding;
        }
        padding = element.getStyle(styleProp + ".bottom") * plus;
        if (padding != 0) {
            rect.height += padding;
        }
        if (rect.width < 0) {
            rect.width = -rect.width;
            rect.x -= rect.width;
        }
        if (rect.height < 0) {
            rect.height = -rect.height;
            rect.y -= rect.height;
        }
    },
    grow: function (rect, width, height) {
    	if(rect == null){
    		return null;
    	}
    	if(height == null){
    	    height = width;
    	}
        var w = rect.width + width + width;
        if (w < 0) {
            return;
        }
        var h = rect.height + height + height;
        if (h < 0) {
            return;
        }
        rect.x -= width;
        rect.y -= height;
        rect.width = w;
        rect.height = h;
        return rect;
    },
    containsPoint: function (rect, x, y) {
        if (arguments.length < 3) {
            y = x.y;
            x = x.x;
        }
        if (!rect || x < rect.x || y < rect.y ||
    				x > rect.x + rect.width || y > rect.y + rect.height) {
            return false;
        }
        return true;
    },
    getHotSpot: function (x, y, w, h, shape) {
        if (shape === 'oval') {
            var rate = 0.35;
            return { x: x + w * 0.5 + w * rate, y: y + h / 2 - Math.sqrt(0.25 - rate * rate) * h };
        }
        if (shape === 'circle') {
            var cx = x + w / 2;
            var cy = y + h / 2;
            var r = Math.min(w, h) / 2;
            x = cx - r;
            y = cy - r;
            w = r * 2;
            h = r * 2;
            var a = w / 2;
            var b = h / 2;
            var value = a * b / Math.sqrt(a * a + b * b);
            return { x: x + w / 2 + value, y: y + h / 2 - value };
        }
        var point = { x: x + w, y: y };
        if (w > 3) {
            point.x -= 3;
        }
        if (h > 3) {
            point.y += 3;
        }
        return point;
    },
    getCircleRect: function (rect) {
        var r = Math.min(rect.width, rect.height) / 2;
        return { x: rect.x + rect.width / 2 - r, y: rect.y + rect.height / 2 - r, width: r * 2, height: r * 2 };
    },
    getEllipsePoint: function (rect, point) {
        if (!rect || !point) {
            return null;
        }
        var cx = rect.x + rect.width / 2;
        var cy = rect.y + rect.height / 2;
        var x1 = point.x - cx;
        var y1 = point.y - cy;
        var w = rect.width / 2;
        var h = rect.height / 2;
        var x = Math.sqrt(1 / (1 / w / w + y1 * y1 / x1 / x1 / h / h));
        if (x1 < 0) {
            x = -x;
        }
        var y;
        if (x1 == 0) {
            if (y1 > 0) {
                y = h;
            } else {
                y = -h;
            }
        } else {
            y = x * y1 / x1;
        }
        return { x: cx + x, y: cy + y };
    },
    createMatrix: function (angle, centerX, centerY) {
        var num = Math.sin(angle);
        var num2 = Math.cos(angle);
        var offsetX = (centerX * (1 - num2)) + (centerY * num);
        var offsetY = (centerY * (1 - num2)) - (centerX * num);
        return new $Matrix(num2, num, -num, num2, offsetX, offsetY);
    },
    calculatePointInfoAlongLineBySegments: function (points, segments, isSource, xOffset, yOffset) {
        return $math.calculatePointInfoAlongLine($math.getPointObject(points, segments), isSource, xOffset, yOffset);
    },
    calculatePointInfoAlongLine: function (paths, isSource, xOffset, yOffset) {
        isSource = isSource === undefined ? true : isSource;
        xOffset = xOffset || 0;
        yOffset = yOffset || 0;
        if (!paths || paths.size() < 2) {
            throw "must more than two points";
        }
        // reverse collection
        if (!isSource) {
            var pointsReverse = $math.reversePath(paths);
            return $math.calculatePointInfoAlongLine(pointsReverse, true, xOffset, yOffset);
        }

        if (paths._as) {
            paths = paths._as;
        }
        var pointAngle, prev, sumDistance = 0, perDistance = 0, temp, index, c = paths.length, path;
        for (index = 0; index < c; index++) {
            path = paths[index];
            if (index == 0) {
                prev = path;
                continue;
            }
            if (xOffset <= 0) {
                temp = $math.calculatePointInfoOnStraightLine($math._getPoint(prev), $math._getControlPoint(path), xOffset, yOffset);
                pointAngle = temp;
                break;
            }
            perDistance = $math._getLength(path, prev);
            if (sumDistance + perDistance > xOffset) {
                temp = $math.getPathInfo(path, prev, xOffset - sumDistance, yOffset, perDistance);
                pointAngle = temp;
                break;
            }
            sumDistance += perDistance;
            prev = path;
        }
        if (pointAngle == null) {
            var first, next;
            prev = paths[c - 1];
            next = $math._getPoint(prev);
            if (prev instanceof $List) {
                prev = prev._as;
            }
            first = prev instanceof Array ? $math._getControlPoint(prev) : $math._getPoint(paths[c - 2]);
            var angle = Math.atan2(next.y - first.y, next.x - first.x);
            temp = $math.transformPoint(next, angle, xOffset - sumDistance, yOffset);
            temp.angle = angle;
            pointAngle = temp;
        }
        return pointAngle;
    },
    reversePath: function (paths) {
        var result = new $List();
        var prev = null, point;
        if (paths._as) {
            paths = paths._as;
        }
        for (var i = paths.length - 1; i >= 0; i--) {
            point = paths[i];
            result.add($math._getReversePath(point, prev));
            prev = point;
        }
        return result;
    },
    _getPoint: function (point) {
        if (point._as) {
            point = point._as;
        }
        if (point instanceof Array) {
            return point[point.length - 1];
        } else {
            return point;
        }
    },
    _getControlPoint: function (point) {
        if (point._as) {
            point = point._as;
        }
        if (point instanceof Array) {
            return point[point.length - 2];
        } else {
            return point;
        }
    },
    _getReversePath: function (point, prev) {
        var thisPoint = $math._getPoint(point);
        if (prev && prev._as) {
            prev = prev._as;
        }
        if (prev == null || !(prev instanceof Array)) {
            return thisPoint;
        }
        if (prev.length == 2) {
            return new $List([prev[0], thisPoint]);
        } else {
            return new $List([prev[1], prev[0], thisPoint]);
        }
    },
    _getLength: function (current, prev) {
        var first = $math._getPoint(prev);
        var point = $math._getPoint(current);
        if (current instanceof $List) {
            current = current._as;
        }
        if (current instanceof Array) {
            return $math.calculateCurveLength(first, current, 1);
        } else {
            var dy = point.y - first.y;
            var dx = point.x - first.x;
            return Math.sqrt(dx * dx + dy * dy);
        }
    },
    getPathInfo: function (current, prev, xOffset, yOffset, length) {
        var first = $math._getPoint(prev);
        var next = $math._getPoint(current);
        var angle;
        if (current instanceof $List) {
            current = current._as;
        }
        if (current instanceof Array) {
            if (length < 0) {
                length = $math._getLength(current, prev);
            }
            var t = xOffset / length;
            var curverInfo = $math.calculatePointInfoOnCurveLine(first, current, t);
            first = curverInfo.point;
            angle = curverInfo.angle;
            xOffset = 0;
        } else {
            angle = Math.atan2(next.y - first.y, next.x - first.x);
        }
        return $math.transformPoint(first, angle, xOffset, yOffset);
    },
    transformPoint: function (point, angle, xOffset, yOffset) {
        var result = { x: xOffset, y: yOffset };
        var m = $math.createMatrix(angle, 0, 0);
        result = m.transform(result);
        result.x += point.x;
        result.y += point.y;
        return {
            point: result,
            angle: angle
        };
    },
    calculatePointInfoOnStraightLine: function (from, next, xOffset, yOffset) {
        var angle = Math.atan2(next.y - from.y, next.x - from.x);
        return $math.transformPoint(from, angle, xOffset, yOffset);
    },
    calculatePointInfoOnCurveLine: function (prev, current, t) {
        if (t < 0 || t > 1) {
            throw "Illegal arguments";
        }
        if (current._as) {
            current = current._as;
        }
        if (current.length == 2) {
            return $math._calculatePointInfoOnCurveLine2(prev, current[0], current[1], t);
        } else {
            return $math._calculatePointInfoOnCurveLine3(prev, current[0], current[1], current[2], t);
        }
    },
    _calculatePointInfoOnCurveLine2: function (p1, p2, p3, t) {
        var dx = 2 * (p1.x + p3.x - 2 * p2.x) * t + 2 * p2.x - 2 * p1.x;
        var dy = 2 * (p1.y + p3.y - 2 * p2.y) * t + 2 * p2.y - 2 * p1.y;
        var angle = Math.atan2(dy, dx);
        var x = (p1.x + p3.x - 2 * p2.x) * t * t + (2 * p2.x - 2 * p1.x) * t + p1.x;
        var y = (p1.y + p3.y - 2 * p2.y) * t * t + (2 * p2.y - 2 * p1.y) * t + p1.y;
        return {
            point: {
                x: x,
                y: y
            },
            angle: angle
        };
    },
    _calculatePointInfoOnCurveLine3: function (p1, p2, p3, p4, mu) {
        var mum1, mum13, mu3;
        mum1 = 1 - mu;
        mum13 = mum1 * mum1 * mum1;
        mu3 = mu * mu * mu;
        var x = mum13 * p1.x + 3 * mu * mum1 * mum1 * p2.x + 3 * mu * mu * mum1 * p3.x + mu3 * p4.x;
        var y = mum13 * p1.y + 3 * mu * mum1 * mum1 * p2.y + 3 * mu * mu * mum1 * p3.y + mu3 * p4.y;
        return {
            point: {
                x: x,
                y: y
            },
            angle: Math.atan2($math._bezeSpeedY(p1, p2, p3, p4, mu), $math._bezeSpeedX(p1, p2, p3, p4, mu))
        };
    },
    calculateCurveLength: function (prev, current, t) {
        if (current._as) {
            current = current._as;
        }
        if (current.length == 2) {
            return $math._calculateCurveLength(prev, current[0], current[1], t);
        } else {
            return $math._calculateBezierCurveLength(prev, current[0], current[1], current[2], t);
        }
    },
    _calculateCurveLength: function (p1, p2, p3, t) {
        if (t <= 0 || t > 1) {
            return 0;
        }
        var pathNumber = Math.floor(t * (Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)) + Math.sqrt((p3.x - p2.x) * (p3.x - p2.x) + (p3.y - p2.y) * (p3.y - p2.y))) / 2);
        var subX = 0;
        if (pathNumber <= 0) {
            pathNumber = 1;
        }
        var dt = t / pathNumber;
        var dx, dy;
        var currentT = 0;
        for (var i = 0; i < pathNumber; i++) {
            currentT = dt * i;
            dx = 2 * (p1.x + p3.x - 2 * p2.x) * currentT + 2 * p2.x - 2 * p1.x;
            dy = 2 * (p1.y + p3.y - 2 * p2.y) * currentT + 2 * p2.y - 2 * p1.y;
            dx *= dt;
            dy *= dt;
            subX += Math.sqrt(dx * dx + dy * dy);
        }
        return subX;
    },
    _calculateBezierCurveLength: function (p1, p2, p3, p4, t) {
        if (t <= 0 || t > 1) {
            return 0;
        }
        var TOTAL_SIMPSON_STEP = 10000;
        var stepCounts = Math.floor(TOTAL_SIMPSON_STEP * t);
        if ((stepCounts & 1) == 1) stepCounts++;
        if (stepCounts == 0) return 0.0;

        var halfCounts = Math.floor(stepCounts / 2);
        var sum1 = 0.0, sum2 = 0.0;
        var dStep = t / stepCounts;

        var i;
        for (i = 0; i < halfCounts; i++) {
            sum1 += $math._bezeSpeed(p1, p2, p3, p4, (2 * i + 1) * dStep);
        }
        for (i = 1; i < halfCounts; i++) {
            sum2 += $math._bezeSpeed(p1, p2, p3, p4, (2 * i) * dStep);
        }
        return ($math._bezeSpeed(p1, p2, p3, p4, 0.0) + $math._bezeSpeed(p1, p2, p3, p4, 1.0) + 2 * sum2 + 4 * sum1) * dStep / 3.0;
    },
    _bezeSpeedX: function (p1, p2, p3, p4, t) {
        var it = 1 - t;
        return -3 * p1.x * it * it + 3 * p2.x * it * it - 6 * p2.x * it * t + 6 * p3.x * it * t - 3 * p3.x * t * t + 3 * p4.x * t * t;
    },
    _bezeSpeedY: function (p1, p2, p3, p4, t) {
        var it = 1 - t;
        return -3 * p1.y * it * it + 3 * p2.y * it * it - 6 * p2.y * it * t + 6 * p3.y * it * t - 3 * p3.y * t * t + 3 * p4.y * t * t;
    },
    _bezeSpeed: function (p1, p2, p3, p4, t) {
        var sx = $math._bezeSpeedX(p1, p2, p3, p4, t);
        var sy = $math._bezeSpeedY(p1, p2, p3, p4, t);

        return Math.sqrt(sx * sx + sy * sy);
    },
    getPointObject: function (points, segments) {
        if (!segments || segments.size() == 0) {
            return points;
        } else {
            var result = new $List();
            segments = segments._as;
            points = points._as;
            var pointIndex = 0, i, segment, segmentCount = segments.length, pointCount = points.length;
            for (i = 0; i < segmentCount; i++) {
                segment = segments[i];
                if (pointIndex == pointCount) {
                    break;
                }
                if ('cubicto' === segment) {
                    if (pointIndex < pointCount - 2) {
                        result.add([points[pointIndex++], points[pointIndex++], points[pointIndex++]]);
                    }
                } else if ('quadto' === segment) {
                    if (pointIndex < pointCount - 1) {
                        result.add([points[pointIndex++], points[pointIndex++]]);
                    }
                } else {
                    if (pointIndex < pointCount) {
                        result.add(points[pointIndex++]);
                    }
                }
            }
            for (; pointIndex < pointCount; pointIndex++) {
                result.add(points[pointIndex]);
            }
            return result;
        }
    },
    calculateLineLength: function (points, segments) {
        if (!points || points.size() < 2) {
            return 0;
        }
        if (segments) {
            return $math.calculateLineLength($math.getPointObject(points, segments));
        }
        points = points._as;
        var index, count = points.length, first, next, point, perDistance, dx, dy, sumDistance = 0;
        for (index = 0; index < count; index++) {
            point = points[index];
            if (index == 0) {
                first = point;
                continue;
            }
            next = point;
            if (next instanceof $List) {
                next = next._as;
            }
            if (next instanceof Array) {
                perDistance = $math.calculateCurveLength(first, next, 1);
                first = next[next.length - 1];
            } else {
                dy = point.y - first.y;
                dx = point.x - first.x;
                perDistance = Math.sqrt(dx * dx + dy * dy);
                first = next;
            }
            sumDistance += perDistance;
        }
        return sumDistance;
    },
    toDegrees: function (radian) {
        return radian * 180.0 / Math.PI
    },
    toRadians: function (degree) {
        return degree / 180.0 * Math.PI
    },
    getRadiansBetweenLines: function (from, to) {
        return Math.atan2(to.y-from.y,to.x-from.x);
    },
    getAngle: function (p1, p2) {
        if (p1.x === p2.x) {
            if (p2.y === p1.y) {
                return 0;
            } else if (p2.y > p1.y) {
                return Math.PI/2;
            } else {
                return -Math.PI/2;
            }
        }
        return Math.atan((p2.y - p1.y) / (p2.x - p1.x));
    }
};
_twaver.math = $math;

var $group = {
    getPoints: function (rects) {
        var points = new $List();
        rects.forEach(function (rect) {
            points.add({ x: rect.x, y: rect.y });
            points.add({ x: rect.x + rect.width, y: rect.y + rect.height });
            points.add({ x: rect.x + rect.width, y: rect.y });
            points.add({ x: rect.x, y: rect.y + rect.height });
        });
        return points;
    },
    rectangle: function (rects) {
        var rect;
        rects.forEach(function (r) {
            rect = $math.unionRect(rect, r);
        });
        return rect;
    },
    oval: function (rects) {
        var unionRect = $group.rectangle(rects);
        var maxWidth = 0;
        var a = unionRect.height / unionRect.width;
        var a2 = a * a;
        var cx = unionRect.x + unionRect.width / 2;
        var cy = unionRect.y + unionRect.height / 2;
        var points = $group.getPoints(rects);
        points.forEach(function (point) {
            var x = point.x - cx;
            var y = point.y - cy;
            var width = x * x + y * y / a2;
            if (width > maxWidth) {
                maxWidth = width;
            }
        });
        maxWidth = Math.sqrt(maxWidth);
        var maxHeight = a * maxWidth;
        return { x: cx - maxWidth, y: cy - maxHeight, width: maxWidth * 2, height: maxHeight * 2 };
    },
    circle: function (rects) {
        var unionRect = $group.rectangle(rects);
        var maxRadius = 0;
        var cx = unionRect.x + unionRect.width / 2;
        var cy = unionRect.y + unionRect.height / 2;
        var points = $group.getPoints(rects);
        points.forEach(function (point) {
            var x = point.x - cx;
            var y = point.y - cy;
            var radius = x * x + y * y;
            if (radius > maxRadius) {
                maxRadius = radius;
            }
        });
        maxRadius = Math.sqrt(maxRadius);
        return { x: cx - maxRadius, y: cy - maxRadius, width: maxRadius * 2, height: maxRadius * 2 };
    },
    roundrect: function (rects) {
        var rect = $group.rectangle(rects);
        var r = Math.min(rect.width, rect.height) / 16;
        $math.grow(rect, r, r);
        return rect;
    },
    star: function (rects) {
        var rect = $group.rectangle(rects);
        $math.grow(rect, rect.width, rect.height);
        return rect;
    },
    triangle: function (rects) {
        var rect = $group.rectangle(rects);
        rect.x -= rect.width / 2;
        rect.width *= 2;
        rect.y -= rect.height;
        rect.height *= 2;
        return rect;
    },
    hexagon: function (rects) {
        var rect = $group.rectangle(rects);
        rect.x -= rect.width / 2;
        rect.width *= 2;
        return rect;
    },
    pentagon: function (rects) {
        var rect = $group.rectangle(rects);
        rect.x -= rect.width / 6;
        rect.width += rect.width / 3;
        rect.y -= rect.height / 4;
        rect.height += rect.height / 4;
        return rect;
    },
    diamond: function (rects) {
        var rect = $group.rectangle(rects);
        rect.x -= rect.width / 2;
        rect.width += rect.width;
        rect.y -= rect.height / 2;
        rect.height += rect.height;
        return rect;
    },
    trapezoidal: function(rects) {
        var rect = $group.rectangle(rects);
        rect.x -= rect.width / 2;
        rect.width += rect.width;
        rect.y -= rect.height / 2;
        rect.height += rect.height;
        return rect;
    }
};
_twaver.group = $group;

var $position = {
    'topleft.topleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width,
            y: refRect.y - tarSize.height
        };
    },
    'topleft.topright': function (refRect, tarSize) {
        return {
            x: refRect.x,
            y: refRect.y - tarSize.height
        };
    },
    'top.top': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y - tarSize.height
        };
    },
    'topright.topleft': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width,
            y: refRect.y - tarSize.height
        };
    },
    'topright.topright': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width,
            y: refRect.y - tarSize.height
        };
    },
    'topleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width / 2,
            y: refRect.y - tarSize.height / 2
        };
    },
    'top': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width / 2 + refRect.width / 2,
            y: refRect.y - tarSize.height / 2
        };
    },
    'topright': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width / 2 + refRect.width,
            y: refRect.y - tarSize.height / 2
        };
    },
    'topleft.bottomleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width,
            y: refRect.y
        };
    },
    'topleft.bottomright': function (refRect, tarSize) {
        return {
            x: refRect.x,
            y: refRect.y
        };
    },
    'top.bottom': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y
        };
    },
    'topright.bottomleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width + refRect.width,
            y: refRect.y
        };
    },
    'topright.bottomright': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width,
            y: refRect.y
        };
    },
    'left.left': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'left': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width / 2,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'left.right': function (refRect, tarSize) {
        return {
            x: refRect.x,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'center': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'right.left': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'right': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width / 2,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'right.right': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width,
            y: refRect.y + refRect.height / 2 - tarSize.height / 2
        };
    },
    'bottomleft.topleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width,
            y: refRect.y + refRect.height - tarSize.height
        };
    },
    'bottomleft.topright': function (refRect, tarSize) {
        return {
            x: refRect.x,
            y: refRect.y + refRect.height - tarSize.height
        };
    },
    'bottom.top': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y + refRect.height - tarSize.height
        };
    },
    'bottomright.topleft': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width,
            y: refRect.y + refRect.height - tarSize.height
        };
    },
    'bottomright.topright': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width,
            y: refRect.y + refRect.height - tarSize.height
        };
    },
    'bottomleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width / 2,
            y: refRect.y + refRect.height - tarSize.height / 2
        };
    },
    'bottom': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y + refRect.height - tarSize.height / 2
        };
    },
    'bottomright': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width / 2,
            y: refRect.y + refRect.height - tarSize.height / 2
        };
    },
    'bottomleft.bottomleft': function (refRect, tarSize) {
        return {
            x: refRect.x - tarSize.width,
            y: refRect.y + refRect.height
        };
    },
    'bottomleft.bottomright': function (refRect, tarSize) {
        return {
            x: refRect.x,
            y: refRect.y + refRect.height
        };
    },
    'bottom.bottom': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width / 2 - tarSize.width / 2,
            y: refRect.y + refRect.height
        };
    },
    'bottomright.bottomleft': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width - tarSize.width,
            y: refRect.y + refRect.height
        };
    },
    'bottomright.bottomright': function (refRect, tarSize) {
        return {
            x: refRect.x + refRect.width,
            y: refRect.y + refRect.height
        };
    },
    get: function (position, refRect, tarSize) {
        if (!refRect) {
            throw "refRect can not be null";
        }
        if (!tarSize) {
            tarSize = { width: 0, height: 0 };
        }
        var func = $position[position];
        if (func) {
            return func(refRect, tarSize);
        }
        throw "Can not resolve '" + position + "' position";
    }
};
_twaver.position = $position;

var $html = {
    preventDefault: function (e) {
        if ($Defaults.KEEP_DEFAULT_FUNCTION(e)) {
            return;
        }
        if (e.preventDefault) {
            e.preventDefault();
        } else if (e.preventManipulation) {
            e.preventManipulation();
        } else {
            e.returnValue = false;
        }
    },
    insertAfter: function (e, ref) {
        if (ref) {
            ref.parentNode.insertBefore(e, ref.nextSibling);
        } else {
            e.parentNode.insertBefore(e, e.parentNode.firstChild);
        }
        return e;
    },
    forEach: function (parent, func, scope) {
        if (!$html.isVisible(parent)) {
            return;
        }
        var count = parent.childNodes.length;
        for (var i = 0; i < count; i++) {
            $html.forEach(parent.childNodes[i], func, scope);
        }
        if (scope) {
            func.call(scope, parent);
        } else {
            func(parent);
        }
    },
    setVisible: function (e, visible) {
        e.style.display = visible ? 'block' : 'none';
    },
    isVisible: function (e) {
        return 'style' in e && e.style.display !== 'none';
    },
    release: function (parent) {
        var count = parent.childNodes.length;
        for (var i = 0; i < count; i++) {
            $html.release(parent.childNodes[i]);
        }
        if (count > 0) {
            $html.clear(parent);
        }
        if (parent._pool) {
            parent._pool.release(parent);
        }
    },
    clear: function (e) {
        while (e.firstChild) {
            e.removeChild(e.firstChild);
        }
    },
    setZoom: function (e, zoom) {
        var s = e.style;
        if (s.setProperty) {
            if ($ua.isFirefox) {
                s.setProperty("-moz-transform", "scale(" + zoom + ")", null);
                s.setProperty("-moz-transform-origin", "0 0", null);
            } else if ($ua.isOpera) {
                s.setProperty("-o-transform", "scale(" + zoom + ")", null);
                s.setProperty("-o-transform-origin", "0 0", null);
            } else if ($ua.isChrome || $ua.isSafari) {
                s.setProperty("-webkit-transform", "scale(" + zoom + ")", null);
                s.setProperty("-webkit-transform-origin", "0 0", null);

                var webkitInvaildateDiv = null;
                if (e._webkitInvaildateDiv) {
                    webkitInvaildateDiv = e._webkitInvaildateDiv;
                } else {
                    webkitInvaildateDiv = document.createElement("div");
                    e._webkitInvaildateDiv = webkitInvaildateDiv;
                }
                if (!webkitInvaildateDiv.parentNode || webkitInvaildateDiv.parentNode != e) {
                    e.appendChild(webkitInvaildateDiv);
                } else {
                    e.removeChild(webkitInvaildateDiv);
                }
            } else if ($ua.isIE) {
                s.setProperty("-ms-transform", "scale(" + zoom + ")", null);
                s.setProperty("-ms-transform-origin", "0 0", null);
            } else {
                s.setProperty("transform", "scale(" + zoom + ")", null);
                s.setProperty("transform-origin", "0 0", null);
            }
        }
    },
    setRotate: function (e, zoom) {
        var s = e.style;
        if (s.setProperty) {
            if ($ua.isFirefox) {
                s.setProperty("-moz-transform", "scale(" + zoom + ")", null);
                s.setProperty("-moz-transform-origin", "0 0", null);
            } else if ($ua.isOpera) {
                s.setProperty("-o-transform", "scale(" + zoom + ")", null);
                s.setProperty("-o-transform-origin", "0 0", null);
            } else if ($ua.isChrome || $ua.isSafari) {
                s.setProperty("-webkit-transform", "scale(" + zoom + ")", null);
                s.setProperty("-webkit-transform-origin", "0 0", null);

                var webkitInvaildateDiv = null;
                if (e._webkitInvaildateDiv) {
                    webkitInvaildateDiv = e._webkitInvaildateDiv;
                } else {
                    webkitInvaildateDiv = document.createElement("div");
                    e._webkitInvaildateDiv = webkitInvaildateDiv;
                }
                if (!webkitInvaildateDiv.parentNode || webkitInvaildateDiv.parentNode != e) {
                    e.appendChild(webkitInvaildateDiv);
                } else {
                    e.removeChild(webkitInvaildateDiv);
                }
            } else if ($ua.isIE) {
                s.setProperty("-ms-transform", "scale(" + zoom + ")", null);
                s.setProperty("-ms-transform-origin", "0 0", null);
            } else {
                s.setProperty("transform", "scale(" + zoom + ")", null);
                s.setProperty("transform-origin", "0 0", null);
            }
        }
    },
    setCSSStyle: function (domObject, styleName, styleValue) {
        domObject.style.setProperty(styleName, styleValue, null);
    },
    removeCSSStyle: function (domObject, styleName) {
        domObject.style.removeProperty(styleName);
    },
    getCSSStyle: function (domObject, styleName) {
        return domObject.style.getPropertyValue(styleName);
    },
    setBorderRaidus: function (e, radius) {
        if ($ua.isFirefox) {
            e.style.MozBorderRadius = radius;
        } else {
            e.style.borderRadius = radius;
        }
    },
    // {map:{1:'male', 2:'female'}, values:[1, 2]}  or  ['male', 'female']
    createSelect: function (info, currentValue) {
        var select = document.createElement('select'), i, value, option;
        if (Array.isArray(info)) {
            for (i = 0; i < info.length; i++) {
                value = info[i];
                option = document.createElement('option');
                option.innerHTML = value;
                option.setAttribute('value', value);
                if (value === currentValue) {
                    option.setAttribute('selected', 'true');
                }
                select.appendChild(option);
            }
        } else {
            for (i = 0; i < info.values.length; i++) {
                value = info.values[i];
                option = document.createElement('option');
                option.innerHTML = info.map[value];
                option.setAttribute('value', value);
                if (value === currentValue) {
                    option.setAttribute('selected', 'true');
                }
                select.appendChild(option);
            }
        }
        return select;
    },
    createImg: function (src) {
        var e = document.createElement('img');
        e.style.position = 'absolute';
        if (typeof src === 'string') {
            e.setAttribute('src', src);
        }
        return e;
    },
    createView: function (overflow, keepDefault) {
        var e = document.createElement('div');
        e.style.position = $Defaults.VIEW_POSITION;
        e.style.fontSize = $Defaults.VIEW_FONT_SIZE;
        e.style.fontFamily = $Defaults.VIEW_FONT_FAMILY;
        e.style.cursor = 'default';
        e.style.outline = 'none';
        e.style.textAlign = "left";
        e.style.msTouchAction = "none";
        e.style.touchAction = "none";
        e.tabIndex = 0;

        if (keepDefault) {
            // do nothing
        } else {
            e.onmousedown = $html.preventDefault;
        }
        if (e.style.setProperty) {
            e.style.setProperty("-khtml-user-select", "none", null);
            e.style.setProperty("-webkit-user-select", "none", null);
            e.style.setProperty("-moz-user-select", "none", null);
            e.style.setProperty("-webkit-tap-highlight-color", "rgba(0, 0, 0, 0)", null);
        }
        if (overflow) {
            e.style.overflow = overflow;
        }
        return e;
    },
    createDiv: function () {
        var e = document.createElement('div');
        e.style.position = 'absolute';
        e.style.msTouchAction = "none";
        e.style.touchAction = "none";
        return e;
    },
    createCanvas: function (width, height) {
        width = width || 0;
        height = height || 0;
        if (isNodejs) {
            return new Canvas(width, height);
        } else {
            var e = document.createElement('canvas');
            e.style.position = 'absolute';
            e.style.msTouchAction = "none";
            e.style.touchAction = "none";
            e.width = width;
            e.height = height;
            return e;
        }
    },
    setCanvas: function (c, x, y, w, h) {
        if (arguments.length === 2) {
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x;
        }
        c.style.left = x + 'px';
        c.style.top = y + 'px';
        c.setAttribute('width', w);
        c.setAttribute('height', h);
        c._viewRect = { x: x, y: y, width: w, height: h };
        var g = c.getContext('2d');
        if (g.shadowBlur !== 0) {
            g.shadowOffsetX = 0;
            g.shadowOffsetY = 0;
            g.shadowBlur = 0;
            g.shadowColor = 'rgba(0,0,0,0.0)';
        }
        g.clearRect(0, 0, w, h);
        g.translate(-x, -y);
        return g;
    },
    setImg: function (img, src, bounds) {
        img.setAttribute('src', src);
        img.style.left = bounds.x + 'px';
        img.style.top = bounds.y + 'px';
        img.style.width = bounds.width + 'px';
        img.style.height = bounds.height + 'px';
        img._viewRect = _twaver.clone(bounds);
    },
    setDiv: function (div, bounds, fillColor, width, outlineColor) {
        width = _twaver.num(width) ? width : 0;
        div.style.left = (bounds.x - width) + 'px';
        div.style.top = (bounds.y - width) + 'px';
        div.style.width = bounds.width + 'px';
        div.style.height = bounds.height + 'px';
        div._viewRect = _twaver.clone(bounds);
        if (fillColor) {
            div.style.backgroundColor = fillColor;
        } else {
            div.style.backgroundColor = '';
        }
        if (width > 0) {
            div.style.border = width + "px " + outlineColor + ' solid';
        } else {
            div.style.border = '';
        }
    },
    changeTypeForMS :function(type){
      var newType = type;
      if(type.indexOf("MSPointer") === 0 || type.indexOf("pointer") === 0){
        var mainName;
        if(type.indexOf("MSPointer") === 0 ){
          mainName = type.substring(9,10).toLowerCase();
          mainName = mainName + type.substring(10);
        }else{
          mainName = type.substring(7,8);
        }
        if(window.MSPointerEvent){
          newType = "MSPointer" + mainName.substring(0,1).toUpperCase() + mainName.substring(1);
        }else if(window.PointerEvent){
          newType = "pointer" + mainName;
        }
      }
      return newType;
    },
    addEventListener: function (type, handler, view, scope) {
        type = this.changeTypeForMS(type);
        var name = '_' + type + '_';
        if (scope[name]) {
            return;
        }
        var func = function (e) {
            func.instance[func.method](e);
        };
        func.method = handler;
        func.instance = scope;
        scope[name] = func;
        view.addEventListener(type, func, false);
    },
    removeEventListener: function (type, view, scope) {
        type = this.changeTypeForMS(type);
        var name = '_' + type + '_';
        var func = scope[name];
        if (func) {
            view.removeEventListener(type, func, false);
            delete scope[name];
        }
    },
    isValidEvent: function (view, e) {
        if (!e) {
            return false;
        }
        if (e.target === view) {
            if ($ua.isFirefox) {
                if (view.clientHeight < view.scrollHeight && e.layerX < 25) {
                    return false;
                }
                if (view.clientWidth < view.scrollWidth && e.layerY < 25) {
                    return false;
                }
            } else {
                if (e.offsetX > view.clientWidth || e.offsetY > view.clientHeight) {
                    return false;
                }
            }
        }
        return true;
    },
    getLogicalPoint: function (view, e, zoom, rootDiv) {
        zoom = zoom ? zoom : 1;
        var point;
        var bound = view.getBoundingClientRect();
        if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
            //touch
            var touch = e.changedTouches[0];
            var scrollLeft = $ua.isAndroid ? 0 : $touch.scrollLeft();
            var scrollTop = $ua.isAndroid ? 0 : $touch.scrollTop();
            point = { x: (touch.clientX + view.scrollLeft - bound.left - scrollLeft) / zoom,
                y: (touch.clientY + view.scrollTop - bound.top - scrollTop) / zoom
            };
        } else {
            //pc
            if (!$html.isValidEvent(view, e)) {
                return null;
            }
            point = { x: (e.clientX - bound.left + view.scrollLeft) / zoom, y: (e.clientY - bound.top + view.scrollTop) / zoom };
        }
        return point;
    },
    handle_mousedown: function (target, e) {
        if ($html.target) {
            $html.handle_mouseup(e);
        }
        window.addEventListener('mousemove', $html.handle_mousemove, false);
        window.addEventListener('mouseup', $html.handle_mouseup, false);
        $html.target = target;
    },
    handle_mousemove: function (e) {
        if ($html.target.handle_mousemove) {
            $html.target.handle_mousemove(e);
        }
        if ($html.target.handleMouseMove) {
            $html.target.handleMouseMove(e);
        }
    },
    handle_mouseup: function (e) {
        if ($html.target.handle_mouseup) {
            $html.target.handle_mouseup(e);
        }
        if ($html.target.handleMouseUp) {
            $html.target.handleMouseUp(e);
        }
        window.removeEventListener('mousemove', $html.handle_mousemove, false);
        window.removeEventListener('mouseup', $html.handle_mouseup, false);
        delete $html.target;
    },
    getClientPoint: function (e) {
        return {
            x: e.clientX,
            y: e.clientY
        };
    },
    windowWidth: function () {
        if (typeof (window.innerWidth) === 'number') {
            return window.innerWidth;
        }
        if (document.documentElement && document.documentElement.clientWidth) {
            return document.documentElement.clientWidth;
        }
        if (document.body && document.body.clientWidth) {
            return document.body.clientWidth;
        }
        return 0;
    },
    windowHeight: function () {
        if (typeof (window.innerHeight) === 'number') {
            return window.innerHeight;
        }
        if (document.documentElement && document.documentElement.clientHeight) {
            return document.documentElement.clientHeight;
        }
        if (document.body && document.body.clientHeight) {
            return document.body.clientHeight;
        }
        return 0;
    }
};
_twaver.html = $html;

var $g = {
    cache: {},
    g: $html.createCanvas().getContext('2d'),
    getTextSize: function (font, text) {
        $g.g.font = font ? font : $Defaults.FONT;
        var h = $g.cache[$g.g.font];
        if (!h) {
            h = $g.g.measureText('e').width * 2 + 4;
            $g.cache[$g.g.font] = h;
        }
        text = text || '';
        text = String(text);
        var lines = text.split('\n'),
            lineCount = lines.length,
            maxWidth = 0,
            width;
        for (var i = lineCount - 1; i >= 0; i--) {
            width = $g.g.measureText(lines[i]).width;
            width > maxWidth && (maxWidth = width);
        }
        return {
            width: maxWidth + 4,
            height: h * lineCount
        };
    },
    getSubStringInLength: function (font, string, length) {
        var that = this;
        var binarySearchSubStringInLength = function (min, max, font, string, length) {
            if (min >= max) {
                return string.substring(0, min + 1);
            } else {
                var middleFloor = Math.floor((min + max) / 2);
                var floorString = string.substring(0, middleFloor + 1);
                var floorWidth = that.getTextSize(font, floorString).width;
                if (floorWidth > length) {
                    return binarySearchSubStringInLength(min, middleFloor - 1, font, string, length);
                } else {
                    var middleCeil = middleFloor + 1;
                    var ceilString = string.substring(0, middleCeil + 1);
                    var ceilWidth = that.getTextSize(font, ceilString).width;
                    if (ceilWidth > length) {
                        return floorString;
                    } else {
                        return binarySearchSubStringInLength(middleCeil, max, font, string, length);
                    }
                }
            }
        };
        var originalWidth = this.getTextSize(font, string).width;
        if (originalWidth > length) {
            return binarySearchSubStringInLength(0, string.length - 1, font, string, length);
        } else {
            return string;
        }
    },

    _getCollapseTextInLength: function(font, string, length) {
        var originalWidth = this.getTextSize(font, string).width;
        if (originalWidth > length) {
            var allSubStringLength = 0;
            var collapsedString = "";
            var leftString = string;
            var leftWidth = originalWidth;
            while (leftWidth > length) {
                var subString = this.getSubStringInLength(font, leftString, length);
                collapsedString = collapsedString + subString + "\n";
                allSubStringLength = allSubStringLength + subString.length;
                leftString = string.substring(allSubStringLength);
                leftWidth = this.getTextSize(font, leftString).width;
            }
            return collapsedString + leftString;
        } else {
            return string;
        }
    },
    getCollapseTextInLength: function(font, string, length) {
        var input = string,
            name = string;
        var code = '';
        for (var x = 0; x < input.length; x++) {
            var char = input.charAt(x);
            if (char.match(/[^\x00-\x80]/g)) {
                code += '2';
            } else if(char.match(/\s/)){
                code += '3';
            }else {
                code += '1';
            }
        }
        for(var i = 1;i<4;i++){
            for(var j = 1;j<4;j++){
                if(i === j) continue;
                code = code.replace(new RegExp(i+''+j,'g'),i+'^'+j);
            }
        }
        // code = code.replace(/21/g, '2^1');
        
        for (var i = 0; i < code.length; i++) {
            var char = code.charAt(i);
            if (char.match(/\^/g)) {
                name = this.replacePos(name, i + 1, '^');
            }
        }
        var array = name.split('^');
        var result = '';
        var width = length;
        var preSize = 0;
        var flag = false;
        for(var i = 0; i < array.length; i++) {
                var currentSize = _twaver.g.getTextSize(font, array[0]);
                var a = array[0],
                    b = _twaver.g._getCollapseTextInLength(font, a, width).split('\n');;
                var col = Math.ceil(currentSize.width / width);
                for (var j = 0; j < col; j++) {
                    if(result === ''){
                        result = b[j];
                    }else{
                        if(b[j] === ''){
                            break;
                        }
                        result += '\n' + b[j];
                    }
                }

                if(i === 0) break;
            }
        for (var i = 1; i < array.length; i++) {
            if (!flag) {
                preSize = _twaver.g.getTextSize(font, array[i - 1]).width;
            } else {
                preSize += _twaver.g.getTextSize(font, array[i - 1]).width;
            }
            var currentSize = _twaver.g.getTextSize(font, array[i]);
            if (currentSize.width + preSize % width < width) {
                result += array[i];
                flag = true;
            } else {
                var a = array[i],
                    b = _twaver.g._getCollapseTextInLength(font, a, width).split('\n');
                var col = Math.ceil(currentSize.width / width);
                for (var j = 0; j < col; j++) {
                    result += '\n' + b[j];
                    preSize = 0;
                }
            }
        }
        return result;
    },
    replacePos: function(str, pos, text) {
        var str = str.substr(0, pos - 1) + text + str.substring(pos - 1, str.length);
        return str;
    },
    drawText: function(g, text, rect, font, color, align, linespacing) {
        text = text || '';
        text = String(text);
        if (!font) {
            font = $Defaults.FONT;
        }
        var textAlign = "center";
        if (align) {
            textAlign = align;
        }
        g.font = font;
        g.fillStyle = color;
        g.textAlign = textAlign;
        g.textBaseline = 'middle';
        var lines = text.split('\n'),
            lineCount = lines.length,
            height = 0,
            x, y;
        if (!rect) {
            x = 0;
            y = 0;
        } else if (rect.width === undefined) {
            x = rect.x;
            y = rect.y;
        } else {
            // height = rect.height / lineCount;
            if (linespacing) {
                height = linespacing; //
            } else {
                height = rect.height / lineCount;
            }
            if (textAlign == "left") {
                x = rect.x;
            } else if (textAlign == "center") {
                x = rect.x + rect.width / 2;
            }
            y = rect.y + height / 2;
        }
        if ($ua.isOpera) {
            y -= 2;
        }
        for (var i = 0; i < lineCount; i++) {
            if (textAlign == "right") {
                g.textAlign = "left";
                x = rect.x + rect.width - $g.getTextSize(font, lines[i]).width;
            }
            g.fillText(lines[i], x, y);
            y += height;
        }
    },
    drawArc: function (g, x, y, startAngle, arc, radius, yRadius, continueFlag) {
        var segAngle;
        var theta;
        var angle;
        var angleMid;
        var segs;
        var ax;
        var ay;
        var bx;
        var by;
        var cx;
        var cy;

        if (Math.abs(arc) > 2 * Math.PI) {
            arc = 2 * Math.PI;
        }

        segs = Math.ceil(Math.abs(arc) / (Math.PI / 4));
        segAngle = arc / segs;
        theta = -segAngle;
        angle = -startAngle;

        if (segs > 0) {
            ax = x + Math.cos(startAngle) * radius;
            ay = y + Math.sin(-startAngle) * yRadius;

            if (continueFlag) {
                g.lineTo(ax, ay);
            } else {
                g.moveTo(ax, ay);
            }

            for (var i = 0; i < segs; i++) {
                angle += theta;
                angleMid = angle - theta / 2;

                bx = x + Math.cos(angle) * radius;
                by = y + Math.sin(angle) * yRadius;
                cx = x + Math.cos(angleMid) * (radius / Math.cos(theta / 2));
                cy = y + Math.sin(angleMid) * (yRadius / Math.cos(theta / 2));
                g.quadraticCurveTo(cx, cy, bx, by);
            }
        }
    },
    dashedLine: function (g, pattern, drawingState, x0, y0, x1, y1) {
        var dX = x1 - x0;
        var dY = y1 - y0;
        var len = Math.sqrt(dX * dX + dY * dY);
        if (len == 0) {
            return;
        }
        dX /= len;
        dY /= len;
        var tMax = len;

        var t = -drawingState.offset;
        var bDrawing = drawingState.drawing;
        var patternIndex = drawingState.patternIndex;
        while (t < tMax) {
            t += pattern[patternIndex];
            if (t >= tMax) {
                drawingState.offset = pattern[patternIndex] - (t - tMax);
                drawingState.patternIndex = patternIndex;
                drawingState.drawing = bDrawing;
                t = tMax;
            }

            if (bDrawing) {
                g.lineTo(x0 + t * dX, y0 + t * dY);
            } else {
                g.moveTo(x0 + t * dX, y0 + t * dY);
            }

            bDrawing = !bDrawing;
            patternIndex = (patternIndex + 1) % pattern.length;
        }
    },
    drawLinePoints: function (g, points, pattern, segments, close) {
        var pointIndex = 0,
            segment, p0, p1, p2, segmentCount, segmentIndex = 0,
            dashedLine, pointCount = points.size();
        if (pattern && pattern.length > 0 && pattern[0] && pattern[1]) {
            dashedLine = new $DashedLine(g, pattern[0], pattern.length > 1 ? pattern[1] : pattern[0]);
        } else {
            dashedLine = g;
        }
        if (segments) {
            for (segmentIndex = 0, segmentCount = segments.size(); segmentIndex < segmentCount; segmentIndex++) {
                segment = segments.get(segmentIndex);
                if ('moveto' === segment && pointIndex < pointCount) {
                    p0 = points.get(pointIndex++);
                    dashedLine.moveTo(p0.x, p0.y);
                } else if ('lineto' === segment && pointIndex < pointCount) {
                    p0 = points.get(pointIndex++);
                    dashedLine.lineTo(p0.x, p0.y);
                } else if ('cubicto' === segment && pointIndex < pointCount - 2) {
                    p0 = points.get(pointIndex++);
                    p1 = points.get(pointIndex++);
                    p2 = points.get(pointIndex++);
                    dashedLine.bezierCurveTo(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);
                } else if ('quadto' === segment && pointIndex < pointCount - 1) {
                    p0 = points.get(pointIndex++);
                    p1 = points.get(pointIndex++);
                    dashedLine.quadraticCurveTo(p0.x, p0.y, p1.x, p1.y);
                } else {
                    throw "Can not resolve segment '" + segment + "'";
                }
            }
        } else {
            this._drawLine(points, dashedLine);
        }
        if (close) {
            dashedLine.closePath();
        }
    },
    _drawLine: function (points, g) {
        var pointIndex = 0,
            p0, p1, p2, s, value, pointCount = points.size();
        p0 = points.get(0);
        g.moveTo(p0.x, p0.y);
        for (pointIndex = 1; pointIndex < pointCount; pointIndex++) {
            value = points.get(pointIndex);
            if (value.size) {
                s = value.size();
                if (s === 2) {
                    p0 = value.get(0);
                    p1 = value.get(1);
                    g.quadraticCurveTo(p0.x, p0.y, p1.x, p1.y);
                } else if (s === 3) {
                    p0 = value.get(0);
                    p1 = value.get(1);
                    p2 = value.get(2);
                    g.bezierCurveTo(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);
                }
            } else {
                g.lineTo(value.x, value.y);
            }
        }
    },
    drawRoundRect: function (g, x, y, width, height,
        topLeftRadius, topRightRadius,
        bottomLeftRadius, bottomRightRadius) {
        if (arguments.length === 6) {
            topRightRadius = topLeftRadius;
            bottomLeftRadius = topLeftRadius;
            bottomRightRadius = topLeftRadius;
        }

        var xw = x + width;
        var yh = y + height;

        // Make sure none of the radius values are greater than w/h.
        // These are all inlined to avoid function calling overhead
        var minSize = width < height ? width * 2 : height * 2;
        topLeftRadius = topLeftRadius < minSize ? topLeftRadius : minSize;
        topRightRadius = topRightRadius < minSize ? topRightRadius : minSize;
        bottomLeftRadius = bottomLeftRadius < minSize ? bottomLeftRadius : minSize;
        bottomRightRadius = bottomRightRadius < minSize ? bottomRightRadius : minSize;

        // bottom-right corner
        var a = bottomRightRadius * 0.292893218813453;
        var s = bottomRightRadius * 0.585786437626905;
        g.moveTo(xw, yh - bottomRightRadius);
        g.quadraticCurveTo(xw, yh - s, xw - a, yh - a);
        g.quadraticCurveTo(xw - s, yh, xw - bottomRightRadius, yh);

        // bottom-left corner
        a = bottomLeftRadius * 0.292893218813453;
        s = bottomLeftRadius * 0.585786437626905;
        g.lineTo(x + bottomLeftRadius, yh);
        g.quadraticCurveTo(x + s, yh, x + a, yh - a);
        g.quadraticCurveTo(x, yh - s, x, yh - bottomLeftRadius);

        // top-left corner
        a = topLeftRadius * 0.292893218813453;
        s = topLeftRadius * 0.585786437626905;
        g.lineTo(x, y + topLeftRadius);
        g.quadraticCurveTo(x, y + s, x + a, y + a);
        g.quadraticCurveTo(x + s, y, x + topLeftRadius, y);

        // top-right corner
        a = topRightRadius * 0.292893218813453;
        s = topRightRadius * 0.585786437626905;
        g.lineTo(xw - topRightRadius, y);
        g.quadraticCurveTo(xw - s, y, xw - a, y + a);
        g.quadraticCurveTo(xw, y + s, xw, y + topRightRadius);
        g.lineTo(xw, yh - bottomRightRadius);
    },
    drawVector: function (g, shape, pattern, x, y, w, h) {
        var roundRectRadius;
        if (arguments.length === 4) {
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x;
        } else if (arguments.length === 5) {
            if (shape === "roundrect") {
                roundRectRadius = {};
                roundRectRadius.topLeft = y;
                roundRectRadius.topRight = y;
                roundRectRadius.bottomLeft = y;
                roundRectRadius.bottomRight = y;
                y = x.y;
                w = x.width;
                h = x.height;
                x = x.x;
            }
        }
        var func = $g['_' + shape];
        if (func) {
            g.beginPath();
            if (pattern && pattern.length > 0) {
                g = new $DashedLine(g, pattern[0], pattern.length > 1 ? pattern[1] : pattern[0]);
            }
            if (arguments.length === 5 && shape === "roundrect") {
                func(g, { x: x, y: y, width: w, height: h }, roundRectRadius);
            } else {
                func(g, x, y, w, h);
            }
        }
    },
    _rectangle: function (g, x, y, w, h) {
        g.rect(x, y, w, h);
    },
    _circle: function (g, x, y, w, h) {
        var cx = x + w / 2,
            cy = y + h / 2,
            radius = Math.min(w, h) / 2;
        if (g instanceof $DashedLine) {
            $g.drawArc(g, cx, cy, 0, Math.PI * 2, radius, radius, false);
        } else {
            g.arc(cx, cy, radius, 0, Math.PI * 2, true);
        }
    },
    _oval: function (g, x, y, w, h) {
        if (g instanceof $DashedLine) {
            $g.drawArc(g, x + w / 2, y + h / 2, 0, Math.PI * 2, w / 2, h / 2, false);
        } else {
            var kappa = .5522848,
                ox = (w / 2) * kappa,
                oy = (h / 2) * kappa,
                xe = x + w,
                ye = y + h,
                xm = x + w / 2,
                ym = y + h / 2;

            g.moveTo(x, ym);
            g.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            g.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            g.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            g.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
        }
    },
    _roundrect: function (g, x, y, w, h) {
        if (arguments.length === 3) {
            var roundRectRadius = y;
            y = x.y;
            w = x.width;
            h = x.height;
            x = x.x;
            if (roundRectRadius.topLeft) {
                $g.drawRoundRect(g, x, y, w, h, roundRectRadius.topLeft);
            } else {
                $g.drawRoundRect(g, x, y, w, h, Math.min(Math.min(w, h) / 4, 10));
            }
        } else {
            $g.drawRoundRect(g, x, y, w, h, Math.min(Math.min(w, h) / 4, 10));
        }
    },
    _star: function (g, x, y, width, height) {
        var w = width * 2;
        var h = height * 2;
        var ox = x + width / 2;
        var oy = y + height / 2;

        g.moveTo(ox - w / 4.0, oy - h / 12.0);
        g.lineTo(x + width * 0.306, y + height * 0.579);
        g.lineTo(ox - w / 6.0, oy + h / 4.0);
        g.lineTo(x + width / 2, y + height * 0.733);
        g.lineTo(ox + w / 6.0, oy + h / 4.0);
        g.lineTo(x + width * 0.693, y + height * 0.579);
        g.lineTo(ox + w / 4.0, oy - h / 12.0);
        g.lineTo(x + width * 0.611, y + height * 0.332);
        g.lineTo(ox + 0.0, oy - h / 4.0);
        g.lineTo(x + width * 0.388, y + height * 0.332);
        g.closePath();
    },
    _triangle: function (g, x, y, w, h) {
        g.moveTo(x + w / 2, y);
        g.lineTo(x + w, y + h);
        g.lineTo(x, y + h);
        g.closePath();
    },
    _hexagon: function (g, x, y, w, h) {
        g.moveTo(x, y + h / 2);
        g.lineTo(x + w / 4, y + h);
        g.lineTo(x + w * 3 / 4, +y + h);
        g.lineTo(x + w, y + h / 2);
        g.lineTo(x + w * 3 / 4, y);
        g.lineTo(x + w / 4, y);
        g.closePath();
    },
    _pentagon: function (g, x, y, width, height) {
        var w = width * 2;
        var h = height * 2;
        var ox = x + width / 2;
        var oy = y + height / 2;
        g.moveTo(ox - w / 4.0, oy - h / 12.0);
        g.lineTo(ox - w / 6.0, oy + h / 4.0);
        g.lineTo(ox + w / 6.0, oy + h / 4.0);
        g.lineTo(ox + w / 4.0, oy - h / 12.0);
        g.lineTo(ox + 0.0, oy - h / 4.0);
        g.closePath();
    },
    _trapezoidal: function (g, x, y, w, h) {
        g.moveTo(x + w / 4, y);
        g.lineTo(x, y + h);
        g.lineTo(x + w, y + h);
        g.lineTo(x + w * 3 / 4, y);
        g.closePath();
    },
    _diamond: function (g, x, y, w, h) {
        g.moveTo(x + w / 2, y);
        g.lineTo(x, y + h / 2);
        g.lineTo(x + w / 2, y + h);
        g.lineTo(x + w, y + h / 2);
        g.closePath();
    },
    fill: function (g, fillColor, gradient, gradientColor, x, y, w, h) {
        var func = gradient_types[gradient];
        if (func) {
            if (arguments.length === 5) {
                g.fillStyle = func(g, fillColor, gradientColor, x.x, x.y, x.width, x.height);
            } else {
                g.fillStyle = func(g, fillColor, gradientColor, x, y, w, h);
            }
        } else {
            g.fillStyle = fillColor;
        }
    },
    createRadialGradient: function (g, fillColor, gradientColor, x, y, w, h, px, py) {
        var t = g.createRadialGradient(x + w * px, y + h * py, Math.min(w, h) / 24, x + w / 2, y + h / 2, Math.max(w, h) / 2);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    drawPath: function (ui, canvas, prefix, padding, pattern, points, segments, close) {
        var node = ui._element;
        var rect = ui.getBodyRect();
        if (padding) {
            $math.addPadding(rect, node, prefix + '.padding', 1);
        }
        var bounds = _twaver.clone(rect);
        var lineWidth = node.getStyle(prefix + '.outline.width');
        if (lineWidth > 0) {
            $math.grow(bounds, lineWidth / 2, lineWidth / 2);
        }
        var g = ui.setShadow(ui, canvas, bounds);
        if (node.getAngle() != 0) {
            if (!(node instanceof $Group)) {
                rect = node.getOriginalRect();
            }
            twaver.Util.rotateCanvas(g, rect, node.getAngle());
        }
        var fill = node.getStyle(prefix + '.fill');
        var fillColor;
        if (fill) {
            if (ui._innerColor && !$element.hasDefault(ui._element)) {
                fillColor = ui._innerColor;
            } else {
                fillColor = node.getStyle(prefix + '.fill.color');
            }
            var gradient = node.getStyle(prefix + '.gradient');
            if (gradient) {
                $g.fill(g, fillColor, gradient, node.getStyle(prefix + '.gradient.color'), rect);
            } else {
                g.fillStyle = fillColor;
            }
        }
        var shape = node.getStyle(prefix + '.shape');
        var roundRectRadiusValue = node.getStyle("group.shape.roundrect.radius");
        if (fill) {
            g.beginPath();
            if (points) {
                $g.drawLinePoints(g, points, null, segments, close);
            } else {
                if (shape === "roundrect" && prefix === "group") {
                    $g.drawVector(g, shape, null, rect, roundRectRadiusValue);
                } else {
                    $g.drawVector(g, shape, null, rect);
                }
            }
            g.fill();
        }
        if (lineWidth > 0) {
            g.lineWidth = lineWidth;
            g.lineCap = node.getStyle(prefix + '.cap');
            g.lineJoin = node.getStyle(prefix + '.join');
            g.strokeStyle = node.getStyle(prefix + '.outline.color');
            g.beginPath();
            if (points) {
                $g.drawLinePoints(g, points, pattern, segments, close);
            } else {
                if (shape === "roundrect" && prefix === "group") {
                    $g.drawVector(g, shape, pattern, rect, roundRectRadiusValue);
                } else {
                    $g.drawVector(g, shape, pattern, rect);
                };
            }
            g.stroke();
        }
        return bounds;
    },
    draw3DRect: function (g, color, deep, x, y, width, height) {
        if (deep === 0) {
            return;
        }
        if (arguments.length <= 4) {
            height = x.height;
            width = x.width;
            y = x.y;
            x = x.x;
        }
        var raised = deep > 0;
        deep = Math.abs(deep);

        var brighterColor;
        var darkerColor;
        g.lineWidth = 1;
        g.lineCap = 'square';
        if (deep === 1) {
            brighterColor = $g.brighter(color);
            darkerColor = $g.darker(color);

            g.strokeStyle = raised ? brighterColor : darkerColor;
            g.beginPath();
            g.moveTo(x, y);
            g.lineTo(x, y + height);
            g.moveTo(x, y);
            g.lineTo(x + width, y);
            g.closePath();
            g.stroke();

            g.strokeStyle = raised ? darkerColor : brighterColor;
            g.beginPath();
            g.moveTo(x, y + height);
            g.lineTo(x + width, y + height);
            g.moveTo(x + width, y);
            g.lineTo(x + width, y + height);
            g.closePath();
            g.stroke();
        } else {
            var count = deep * 2;
            var step = 50.0 / count;
            for (var i = 0; i < count; i++) {
                brighterColor = $g.brighter(color, 50 - i * step);
                darkerColor = $g.darker(color, 50 - i * step);

                x += 0.5;
                y += 0.5;
                width -= 1;
                height -= 1;

                g.strokeStyle = raised ? brighterColor : darkerColor;
                g.beginPath();
                g.moveTo(x, y);
                g.lineTo(x, y + height);
                g.moveTo(x, y);
                g.lineTo(x + width, y);
                g.closePath();
                g.stroke();

                g.strokeStyle = raised ? darkerColor : brighterColor;
                g.beginPath();
                g.moveTo(x, y + height);
                g.lineTo(x + width, y + height);
                g.moveTo(x + width, y);
                g.lineTo(x + width, y + height);
                g.closePath();
                g.stroke();
            }
        }
    },
    brighter: function (color, degree) {
        if (!degree) {
            degree = 50;
        }
        return $g.adjustBrightness2(color, degree);
    },
    darker: function (color, degree) {
        if (!degree) {
            degree = 50;
        }
        return $g.adjustBrightness2(color, -degree);
    },
    adjustBrightness2: function (color, brite) {
        var r, g, b;

        if (brite === 0)
            return color;

        var rgb = getColorValue(color);
        if (brite < 0) {
            brite = (100 + brite) / 100;
            r = Math.ceil(rgb.r * brite);
            g = Math.ceil(rgb.g * brite);
            b = Math.ceil(rgb.b * brite);
        } else // bright > 0
        {
            brite /= 100;
            r = rgb.r;
            g = rgb.g;
            b = rgb.b;

            r += ((0xFF - r) * brite);
            g += ((0xFF - g) * brite);
            b += ((0xFF - b) * brite);

            r = Math.min(Math.ceil(r), 255);
            g = Math.min(Math.ceil(g), 255);
            b = Math.min(Math.ceil(b), 255);
        }

        return 'rgba(' + r + ',' + g + ',' + b + ',1)';
    },
    getColorArray: function (color) {
        color_g.clearRect(0, 0, 1, 1);
        color_g.fillStyle = color;
        color_g.fillRect(0, 0, 1, 1);
        return color_g.getImageData(0, 0, 1, 1).data;
    },
    hit: function (c, x, y, grow) {
        if (!c) {
            return false;
        }
        var rect = c._viewRect;
        if (!rect) {
            return false;
        }
        //var targetRect = {x:x-grow,y:y-grow,width:2*grow,height:2*grow};
        x -= rect.x;
        y -= rect.y;
        if (x < 0 || y < 0 || x >= rect.width || y >= rect.height) {
            return false;
        }
        try {
            var imageData = c.getContext('2d').getImageData(x, y, 1, 1);
            var pix = imageData.data;
            for (var i = 0, n = pix.length; i < n; i += 4) {
                if (pix[i + 3] !== 0) {
                    return true;
                }
            }
        } catch (e) {
            return true;
        }
        return false;
    },
    intersects: function (c, rect) {
        if (!c) {
            return false;
        }
        rect = $math.intersection(rect, c._viewRect);
        if (!rect) {
            return false;
        }
        rect.x -= c._viewRect.x;
        rect.y -= c._viewRect.y;
        try {
            var imageData = c.getContext('2d').getImageData(rect.x, rect.y, rect.width, rect.height);
            var pix = imageData.data;
            for (var i = 0, n = pix.length; i < n; i += 4) {
                if (pix[i + 3] !== 0) {
                    return true;
                }
            }
        } catch (e) {}
        return false;
    },
    strokeRect: function (ctx, rect, strokeStyle, lineWidth) {
        if (!rect) {
            return;
        }
        ctx.beginPath();
        ctx.strokeStyle = strokeStyle ? strokeStyle : twaver.Util.randomColor();
        ctx.lineWidth = lineWidth ? lineWidth : 2;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.stroke();
    },
};
_twaver.g = $g;

var gradient_types = {
    'linear.southwest': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y + h, x + w, y);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'linear.southeast': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x + w, y + h, x, y);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'linear.northwest': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x + w, y + h, x, y);
        t.addColorStop(0, fillColor);
        t.addColorStop(1, gradientColor);
        return t;
    },
    'linear.northeast': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x + w, y, x, y + h);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'linear.north': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x, y + h);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'linear.south': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x, y + h);
        t.addColorStop(0, fillColor);
        t.addColorStop(1, gradientColor);
        return t;
    },
    'linear.west': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x + w, y);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'linear.east': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x + w, y);
        t.addColorStop(0, fillColor);
        t.addColorStop(1, gradientColor);
        return t;
    },
    'radial.center': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.5, 0.5);
    },
    'radial.southwest': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.25, 0.75);
    },
    'radial.southeast': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.75, 0.75);
    },
    'radial.northwest': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.25, 0.25);
    },
    'radial.northeast': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.75, 0.25);
    },
    'radial.north': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.5, 0.25);
    },
    'radial.south': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.5, 0.75);
    },
    'radial.west': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.25, 0.5);
    },
    'radial.east': function (g, fillColor, gradientColor, x, y, w, h) {
        return $g.createRadialGradient(g, fillColor, gradientColor, x, y, w, h, 0.75, 0.5);
    },
    'spread.horizontal': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x + w, y);
        t.addColorStop(0, fillColor);
        t.addColorStop(0.5, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'spread.vertical': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x, y + h);
        t.addColorStop(0, fillColor);
        t.addColorStop(0.5, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'spread.diagonal': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x + w, y, x, y + h);
        t.addColorStop(0, fillColor);
        t.addColorStop(0.5, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'spread.antidiagonal': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y, x + w, y + h);
        t.addColorStop(0, fillColor);
        t.addColorStop(0.5, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'spread.north': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y - h / 4, x, y + h + h / 4);
        t.addColorStop(0, fillColor);
        t.addColorStop(1 / 3, gradientColor);
        t.addColorStop(2 / 3, fillColor);
        t.addColorStop(1, gradientColor);
        return t;
    },
    'spread.south': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x, y - h / 4, x, y + h + h / 4);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1 / 3, fillColor);
        t.addColorStop(2 / 3, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    },
    'spread.west': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x - w / 4, y, x + w + w / 4, y);
        t.addColorStop(0, fillColor);
        t.addColorStop(1 / 3, gradientColor);
        t.addColorStop(2 / 3, fillColor);
        t.addColorStop(1, gradientColor);
        return t;
    },
    'spread.east': function (g, fillColor, gradientColor, x, y, w, h) {
        var t = g.createLinearGradient(x - w / 4, y, x + w + w / 4, y);
        t.addColorStop(0, gradientColor);
        t.addColorStop(1 / 3, fillColor);
        t.addColorStop(2 / 3, gradientColor);
        t.addColorStop(1, fillColor);
        return t;
    }
};
twaver.Util = {
    getVersion: function () {
        return '5.8.4';
    },
    registerImage: function (name, source, width, height, svg) {
        _twaver.registerImage(name, source, width, height, svg);
    },
    registerImageByUrl: function (url, name, network, callback) {
        if (name && url && url.indexOf(".json") > 0) {
            var result;
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var json = JSON.parse(xhr.responseText);
                        twaver.Util.registerImage(name, json);
                        network && network.invalidateElementUIs();
                        callback && callback();
                    }
                }
            };
            xhr.open("GET", url, true);
            xhr.send();
        } else {
            var image = new Image();
            image.src = url;
            image.onload = function () {
                twaver.Util.registerImage(name, image, image.width, image.height);
                image.onload = null;
                if (network) {
                    network.invalidateElementUIs();
                }
                if (callback) {
                    callback();
                }
            };
        }
    },
    getRegisteredImageNames: function () {
        return _twaver.getRegisteredImageNames();
    },
    unregisterImage: function (name) {
        _twaver.unregisterImage(name);
    },
    getImageAsset: function (name) {
        return _twaver.getImageAsset(name);
    },
    validateLicense: function (license) {
        _twaver.validateLicense(license);
    },

    getLicense: function () {
        return $license;
    },

    isPermissionGIS: function () {
        return __isPermissionGIS();
    },

    moveElements: function (elements, xoffset, yoffset, animate, finishFunction, network) {
        if (xoffset === 0 && yoffset === 0) {
            return;
        }
        if (!elements || elements.isEmpty()) {
            return;
        }
        var a = twaver.animate.AnimateManager,
            nodes, locations;
        a.endAnimate();
        elements = $element.filterMovingElements(elements);
        if (animate) {
            nodes = new $List();
            locations = new $List();
        }
        elements.forEach(function (element) {
            if (element instanceof $Node) {
                if (animate) {
                    nodes.add(element);
                    locations.add({
                        x: element.getX() + xoffset,
                        y: element.getY() + yoffset
                    });
                } else {
                    element.translate(xoffset, yoffset);
                }
            }
        });
        if (animate) {
            a.start(new twaver.animate.AnimateLocation(nodes, locations, finishFunction));
        } else {
            if (finishFunction) {
                finishFunction();
            }
        }
    },
    isTypeOf: function (type, base) {
        if (type === base) {
            return true;
        }
        var superClass = type.superClass;
        while (superClass) {
            if (superClass === base.prototype) {
                return true;
            }
            superClass = superClass.constructor.superClass;
        }
        return false;
    },
    setFocus: function (e) {
        if (document.activeElement === e) {
            return;
        }
        var left, top;
        var doc = document.documentElement;
        var body = document.body;
        var target;
        if (doc && ($ua.isIE || $ua.isOpera || doc.scrollLeft || doc.scrollTop)) {
            left = doc.scrollLeft;
            top = doc.scrollTop;
            target = doc;
        } else if (body) {
            left = body.scrollLeft;
            top = body.scrollTop;
            target = body;
        }
        e.focus();
        if (target) {
            target.scrollLeft = left;
            target.scrollTop = top;
        }
    },
    isOpera: $ua.isOpera,
    isIE: $ua.isIE,
    isFirefox: $ua.isFirefox,
    isChrome: $ua.isChrome,
    isSafari: $ua.isSafari,
    isIPhone: $ua.isIPhone,
    isIPod: $ua.isIPod,
    isIPad: $ua.isIPad,
    isAndroid: $ua.isAndroid,
    isWebOS: $ua.isWebOS,
    isTouchable: $ua.isTouchable,
    ext: function (subClass, superClass, o) {
        _twaver.ext(subClass, superClass, o);
    },
    getValue: function (instance, property, type) {
        return _twaver.getValue(instance, property, type);
    },
    setValue: function (instance, property, value) {
        _twaver.setValue(instance, property, value);
    },
    grow: function (rect, width, height) {
        $math.grow(rect, width, height);
    },
    containsPoint: function (rect, x, y) {
        return $math.containsPoint.apply(null, arguments);
    },
    intersects: function (srcRect, dstRect) {
        return $math.intersects(srcRect, dstRect);
    },
    getRect: function (points) {
        return $math.getRect(points);
    },
    unionRect: function (srcRect, dstRect) {
        return $math.unionRect(srcRect, dstRect);
    },
    createDiv: function () {
        return $html.createDiv();
    },
    createCanvas: function () {
        return $html.createCanvas();
    },
    setCanvas: function (c, x, y, w, h) {
        return $html.setCanvas.apply(null, arguments);
    },
    drawVector: function (g, shape, pattern, x, y, w, h) {
        $g.drawVector.apply(null, arguments);
    },
    fill: function (g, fillColor, gradient, gradientColor, x, y, w, h) {
        $g.fill.apply(null, arguments);
    },
    getClass: function (className) {
        return _twaver.getClass(className);
    },
    getAllClassNames: function () {
        var result = [],
            key;
        for (key in _twaver.classCache) {
            result.push(key);
        }
        return result;
    },
    newInstance: function (className) {
        return _twaver.newInstance.apply(null, arguments);
    },
    isDeserializing: function () {
        return _twaver.isDeserializing;
    },
    addEventListener: function (type, handler, view, scope) {
        $html.addEventListener(type, handler, view, scope);
    },
    removeEventListener: function (type, view, scope) {
        $html.removeEventListener(type, view, scope);
    },
    drawArrow: function (g, arrowWidth, arrowHeight, linePaths, isSrouce,
        arrowStyle, drawBody, arrowColor, arrowXOffset, arrowYOffset, lineWidth, arrowOutlineColor, ui) {
        $arrow.drawArrow.apply(null, arguments);
    },
    calculatePointAngleAlongLine: function (points, segments, isSource, xOffset, yOffset) {
        return $math.calculatePointInfoAlongLineBySegments(points, segments, isSource, xOffset, yOffset);
    },
    getSubNetwork: function (element) {
        return $element.getSubNetwork(element);
    },
    transformPoint: function (point, angle, xOffset, yOffset) {
        return $math.transformPoint(point, angle, xOffset, yOffset);
    },
    getToolTipDiv: function () {
        return $popup.getToolTipDiv();
    },
    showToolTip: function (eorp, innerHTML) {
        $popup.showToolTip(eorp, innerHTML);
    },
    hideToolTip: function () {
        $popup.hideToolTip();
    },
    resetToolTip: function () {
        $popup.resetToolTip();
    },
    setCSSStyle: function (domObject, styleName, styleValue) {
        $html.setCSSStyle(domObject, styleName, styleValue);
    },
    removeCSSStyle: function (domObject, styleName) {
        $html.removeCSSStyle(domObject, styleName);
    },
    getCSSStyle: function (domObject, styleName) {
        return $html.getCSSStyle(domObject, styleName);
    },
    toDegrees: function (radian) {
        return $math.toDegrees(radian);
    },
    toRadians: function (degree) {
        return $math.toDegrees(degree);
    },
    getRadiansBetweenLines: function (from, to) {
        return $math.getRadiansBetweenLines(from, to);
    },
    getElementsBounds: function (elements, network) {
        var bounds = null;
        elements.forEach(function (element) {
            if (element.getRect) {
                var rect, ui;
                if (network) {
                    ui = network.getElementUI(element);
                    if (ui) {
                        rect = ui.getViewRect();
                    }
                }
                if (!rect) {
                    rect = element.getRect();
                }
                if (bounds) {
                    bounds = twaver.Util.unionRect(bounds, rect);
                } else {
                    bounds = rect;
                }
            }
        })
        return bounds;
    },
    getPointIndex: function (points, point, tolerance) {
        tolerance || (tolerance = 10);
        if (points) {
            for (var i = points.size(); i--; i >= 0) {
                if ($math.getDistance(points.get(i), point) <= tolerance) {
                    return i;
                }
            }
        }
        return -1;
    },
    registerVectorShape: function (name, func) {
        _twaver.g['_' + name] = func;
    },
    rotateCanvas: function (g, rect, angle) {
        g.translate(rect.x + rect.width / 2, rect.y + rect.height / 2);
        g.rotate(angle * Math.PI / 180);
        g.translate(-(rect.x + rect.width / 2), -(rect.y + rect.height / 2));
    },
    registerShape: function (name, shapeFunc) {
        registerShape(name, shapeFunc);
    },
    registerDraw: function (name, draw) {
        registerDraw(name, draw);
    },
    getFilterColor: function (sourceColor, filterColor) {
        return getFilterColor(sourceColor, filterColor);
    },
    registerGifImage: function (name, url) {
        // var views = arguments;
        // var http = new XMLHttpRequest();
        // http.overrideMimeType('text/plain; charset=x-user-defined');
        // http.onload = function(e) {
        //     var stream = new _stream(http.response);
        //     var gif = new _gif(stream);
        //     gif.doParse();
        //     var myInterval = setInterval(function () {
        //         if(gif.loaded) {
        //             clearInterval(myInterval);
        //             twaver.Util.registerImage(name, gif);
        //             for (var i = 2; i < views.length; i++) {
        //                 var view = views[i];
        //                 if (view.invalidateElementUIs) {
        //                     view.invalidateElementUIs();
        //                 }
        //                 if (view.invalidateDisplay) {
        //                     view.invalidateDisplay();
        //                 }
        //             }
        //         }
        //     }, 10);
        // };
        // http.open('POST', url, true);
        // http.send();
    },
    parseVectorData: function (data) {
        return parsePathOrPoints(data);
    },
    getSharedLinks: function (node1, node2) {
        var links1 = node1.getLinks(),
            links2 = node2.getLinks();
        if (links1 && links1.size() != 0 && links2 && links2.size() != 0) {
            var links = links1.size() > links2.size() ? links1 : links2;
            return links.toList(function (link) {
                return (link.getFromNode() == node1 && link.getToNode() == node2) || (link.getFromNode() == node2 && link.getToNode() == node1);
            });
        }
        return null;
    },
    isSharedLinks: function (node1, node2) {
        var result = false,
            links1 = node1.getLinks(),
            links2 = node2.getLinks();
        if (links1 && links1.size() != 0 && links2 && links2.size() != 0) {
            var links = links1.size() > links2.size() ? links1 : links2;
            links.forEach(function (link) {
                if ((link.getFromNode() == node1 && link.getToNode() == node2) || (link.getFromNode() == node2 && link.getToNode() == node1)) {
                    result = true;
                    return false;
                }
                return true;
            });
        }
        return result;
    },
    playAnimate: function (animate) {
        return playAnimate(animate);
    },
    pauseAnimate: function (animate) {
        animate.pause();
    },
    resumeAnimate: function (animate) {
        animate.resume();
    },
    stopAnimate: function (animate, end) {
        stopAnimate(animate, end);
    },
    pauseAllAnimates: function () {
        pauseAllAnimates();
    },
    resumeAllAnimates: function () {
        resumeAllAnimates();
    },
    stopAllAnimates: function (end) {
        stopAllAnimates(end);
    },
    randomColor: function () {
        return '#' + ('00000' + (this.random() * 0x1000000 << 0).toString(16)).substr(-6);
    },
    random: function () {
        return Math.random();
    },
    getHSVColor: function (h, s, v) {
        var r, g, b, i, f, p, q, t;
        if (h && s === undefined && v === undefined) {
            s = h.s, v = h.v, h = h.h;
        }
        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0:
                r = v, g = t, b = p;
                break;
            case 1:
                r = q, g = v, b = p;
                break;
            case 2:
                r = p, g = v, b = t;
                break;
            case 3:
                r = p, g = q, b = v;
                break;
            case 4:
                r = t, g = p, b = v;
                break;
            case 5:
                r = v, g = p, b = q;
                break;
        }
        var rgb = '#' + toHex(r * 255) + toHex(g * 255) + toHex(b * 255);
        return rgb;
    },
    toHex: function (value) {
        var result = parseInt(value).toString(16);
        if (result.length == 1) {
            result = '0' + result;
        }
        return result;
    },
    makeHighRes: function (c) {
        var ctx = c.getContext('2d');
        // finally query the various pixel ratios
        var devicePixelRatio = window.devicePixelRatio || 1;
        var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
            ctx.mozBackingStorePixelRatio ||
            ctx.msBackingStorePixelRatio ||
            ctx.oBackingStorePixelRatio ||
            ctx.backingStorePixelRatio || 1;
        var ratio = devicePixelRatio / backingStoreRatio;
        // upscale canvas if the two ratios don't match
        if (devicePixelRatio !== backingStoreRatio) {
            var oldWidth = c.width;
            var oldHeight = c.height;
            c.width = Math.round(oldWidth * ratio);
            c.height = Math.round(oldHeight * ratio);
            c.style.width = oldWidth + 'px';
            c.style.height = oldHeight + 'px';
            ctx.scale(ratio, ratio);
        }
    },
    newFunction: function () {
        var args = arguments,
            len = args.length;
        if (len === 1) {
            return _twaver.newInstance('Function', args[0]);
        } else if (len === 2) {
            return _twaver.newInstance('Function', args[0], args[1]);
        } else if (len === 3) {
            return _twaver.newInstance('Function', args[0], args[1], args[2]);
        } else if (len === 4) {
            return _twaver.newInstance('Function', args[0], args[1], args[2], args[3]);
        } else if (len === 5) {
            return _twaver.newInstance('Function', args[0], args[1], args[2], args[3], args[4]);
        } else if (len === 6) {
            return _twaver.newInstance('Function', args[0], args[1], args[2], args[3], args[4], args[5]);
        } else if (len === 7) {
            return _twaver.newInstance('Function', args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        } else if (len === 8) {
            return _twaver.newInstance('Function', args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
        }
        return null;
    },
};
_twaver.ext('twaver.Util', Object, {});
//BigInteger

// Bits per digit
var dbits;

// JavaScript engine analysis
var canary = 0xdeadbeefcafe;
var j_lm = ((canary & 0xffffff) == 0xefcafe);

// (public) Constructor
function BigInteger(a, b, c) {
	if (a != null)
		if ("number" == typeof a)
			this.fromNumber(a, b, c);
		else if (b == null && "string" != typeof a)
			this.fromString(a, 256);
		else
			this.fromString(a, b);
}

// return new, unset BigInteger
function nbi() {
	return new BigInteger(null);
}

// am: Compute w_j += (x*this_i), propagate carries,
// c is initial carry, returns final carry.
// c < 3*dvalue, x < 2*dvalue, this_i < dvalue
// We need to select the fastest one that works in this environment.

// am1: use a single mult and divide to get the high bits,
// max digit bits should be 26 because
// max internal value = 2*dvalue^2-2*dvalue (< 2^53)
function am1(i, x, w, j, c, n) {
	while (--n >= 0) {
		var v = x * this[i++] + w[j] + c;
		c = Math.floor(v / 0x4000000);
		w[j++] = v & 0x3ffffff;
	}
	return c;
}

// am2 avoids a big mult-and-extract completely.
// Max digit bits should be <= 30 because we do bitwise ops
// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
function am2(i, x, w, j, c, n) {
	var xl = x & 0x7fff, xh = x >> 15;
	while (--n >= 0) {
		var l = this[i] & 0x7fff;
		var h = this[i++] >> 15;
		var m = xh * l + h * xl;
		l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);
		c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
		w[j++] = l & 0x3fffffff;
	}
	return c;
}

// Alternately, set max digit bits to 28 since some
// browsers slow down when dealing with 32-bit numbers.
function am3(i, x, w, j, c, n) {
	var xl = x & 0x3fff, xh = x >> 14;
	while (--n >= 0) {
		var l = this[i] & 0x3fff;
		var h = this[i++] >> 14;
		var m = xh * l + h * xl;
		l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;
		c = (l >> 28) + (m >> 14) + xh * h;
		w[j++] = l & 0xfffffff;
	}
	return c;
}

if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
	BigInteger.prototype.am = am2;
	dbits = 30;
} else if (j_lm && (navigator.appName != "Netscape")) {
	BigInteger.prototype.am = am1;
	dbits = 26;
} else {// Mozilla/Netscape seems to prefer am3
	BigInteger.prototype.am = am3;
	dbits = 28;
}

BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = ((1 << dbits) - 1);
BigInteger.prototype.DV = (1 << dbits);

var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;

// Digit conversions
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for ( vv = 0; vv <= 9; ++vv)
	BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for ( vv = 10; vv < 36; ++vv)
	BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for ( vv = 10; vv < 36; ++vv)
	BI_RC[rr++] = vv;

function int2char(n) {
	return BI_RM.charAt(n);
}

function intAt(s, i) {
	var c = BI_RC[s.charCodeAt(i)];
	return (c == null) ? -1 : c;
}

// (protected) copy this to r
function bnpCopyTo(r) {
	for (var i = this.t - 1; i >= 0; --i)
		r[i] = this[i];
	r.t = this.t;
	r.s = this.s;
}

// (protected) set from integer value x, -DV <= x < DV
function bnpFromInt(x) {
	this.t = 1;
	this.s = (x < 0) ? -1 : 0;
	if (x > 0)
		this[0] = x;
	else if (x < -1)
		this[0] = x + DV;
	else
		this.t = 0;
}

// return bigint initialized to value
function nbv(i) {
	var r = nbi();
	r.fromInt(i);
	return r;
}

// (protected) set from string and radix
function bnpFromString(s, b) {
	var k;
	if (b == 16)
		k = 4;
	else if (b == 8)
		k = 3;
	else if (b == 256)
		k = 8;
	// byte array
	else if (b == 2)
		k = 1;
	else if (b == 32)
		k = 5;
	else if (b == 4)
		k = 2;
	else {
		this.fromRadix(s, b);
		return;
	}
	this.t = 0;
	this.s = 0;
	var i = s.length, mi = false, sh = 0;
	while (--i >= 0) {
		var x = (k == 8) ? s[i] & 0xff : intAt(s, i);
		if (x < 0) {
			if (s.charAt(i) == "-")
				mi = true;
			continue;
		}
		mi = false;
		if (sh == 0)
			this[this.t++] = x;
		else if (sh + k > this.DB) {
			this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
			this[this.t++] = (x >> (this.DB - sh));
		} else
			this[this.t - 1] |= x << sh;
		sh += k;
		if (sh >= this.DB)
			sh -= this.DB;
	}
	if (k == 8 && (s[0] & 0x80) != 0) {
		this.s = -1;
		if (sh > 0)
			this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
	}
	this.clamp();
	if (mi)
		BigInteger.ZERO.subTo(this, this);
}

// (protected) clamp off excess high words
function bnpClamp() {
	var c = this.s & this.DM;
	while (this.t > 0 && this[this.t - 1] == c)--this.t;
}

// (public) return string representation in given radix
function bnToString(b) {
	if (this.s < 0)
		return "-" + this.negate().toString(b);
	var k;
	if (b == 16)
		k = 4;
	else if (b == 8)
		k = 3;
	else if (b == 2)
		k = 1;
	else if (b == 32)
		k = 5;
	else if (b == 4)
		k = 2;
	else
		return this.toRadix(b);
	var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
	var p = this.DB - (i * this.DB) % k;
	if (i-- > 0) {
		if (p < this.DB && ( d = this[i] >> p) > 0) {
			m = true;
			r = int2char(d);
		}
		while (i >= 0) {
			if (p < k) {
				d = (this[i] & ((1 << p) - 1)) << (k - p);
				d |= this[--i] >> (p += this.DB - k);
			} else {
				d = (this[i] >> (p -= k)) & km;
				if (p <= 0) {
					p += this.DB;
					--i;
				}
			}
			if (d > 0)
				m = true;
			if (m)
				r += int2char(d);
		}
	}
	return m ? r : "0";
}

// (public) -this
function bnNegate() {
	var r = nbi();
	BigInteger.ZERO.subTo(this, r);
	return r;
}

// (public) |this|
function bnAbs() {
	return (this.s < 0) ? this.negate() : this;
}

// (public) return + if this > a, - if this < a, 0 if equal
function bnCompareTo(a) {
	var r = this.s - a.s;
	if (r != 0)
		return r;
	var i = this.t;
	r = i - a.t;
	if (r != 0)
		return r;
	while (--i >= 0)
	if (( r = this[i] - a[i]) != 0)
		return r;
	return 0;
}

// returns bit length of the integer x
function nbits(x) {
	var r = 1, t;
	if (( t = x >>> 16) != 0) {
		x = t;
		r += 16;
	}
	if (( t = x >> 8) != 0) {
		x = t;
		r += 8;
	}
	if (( t = x >> 4) != 0) {
		x = t;
		r += 4;
	}
	if (( t = x >> 2) != 0) {
		x = t;
		r += 2;
	}
	if (( t = x >> 1) != 0) {
		x = t;
		r += 1;
	}
	return r;
}

// (public) return the number of bits in "this"
function bnBitLength() {
	if (this.t <= 0)
		return 0;
	return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));
}

// (protected) r = this << n*DB
function bnpDLShiftTo(n, r) {
	var i;
	for ( i = this.t - 1; i >= 0; --i)
		r[i + n] = this[i];
	for ( i = n - 1; i >= 0; --i)
		r[i] = 0;
	r.t = this.t + n;
	r.s = this.s;
}

// (protected) r = this >> n*DB
function bnpDRShiftTo(n, r) {
	for (var i = n; i < this.t; ++i)
		r[i - n] = this[i];
	r.t = Math.max(this.t - n, 0);
	r.s = this.s;
}

// (protected) r = this << n
function bnpLShiftTo(n, r) {
	var bs = n % this.DB;
	var cbs = this.DB - bs;
	var bm = (1 << cbs) - 1;
	var ds = Math.floor(n / this.DB), c = (this.s << bs) & this.DM, i;
	for ( i = this.t - 1; i >= 0; --i) {
		r[i + ds + 1] = (this[i] >> cbs) | c;
		c = (this[i] & bm) << bs;
	}
	for ( i = ds - 1; i >= 0; --i)
		r[i] = 0;
	r[ds] = c;
	r.t = this.t + ds + 1;
	r.s = this.s;
	r.clamp();
}

// (protected) r = this >> n
function bnpRShiftTo(n, r) {
	r.s = this.s;
	var ds = Math.floor(n / this.DB);
	if (ds >= this.t) {
		r.t = 0;
		return;
	}
	var bs = n % this.DB;
	var cbs = this.DB - bs;
	var bm = (1 << bs) - 1;
	r[0] = this[ds] >> bs;
	for (var i = ds + 1; i < this.t; ++i) {
		r[i - ds - 1] |= (this[i] & bm) << cbs;
		r[i - ds] = this[i] >> bs;
	}
	if (bs > 0)
		r[this.t - ds - 1] |= (this.s & bm) << cbs;
	r.t = this.t - ds;
	r.clamp();
}

// (protected) r = this - a
function bnpSubTo(a, r) {
	var i = 0, c = 0, m = Math.min(a.t, this.t);
	while (i < m) {
		c += this[i] - a[i];
		r[i++] = c & this.DM;
		c >>= this.DB;
	}
	if (a.t < this.t) {
		c -= a.s;
		while (i < this.t) {
			c += this[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += this.s;
	} else {
		c += this.s;
		while (i < a.t) {
			c -= a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c -= a.s;
	}
	r.s = (c < 0) ? -1 : 0;
	if (c < -1)
		r[i++] = this.DV + c;
	else if (c > 0)
		r[i++] = c;
	r.t = i;
	r.clamp();
}

// (protected) r = this * a, r != this,a (HAC 14.12)
// "this" should be the larger one if appropriate.
function bnpMultiplyTo(a, r) {
	var x = this.abs(), y = a.abs();
	var i = x.t;
	r.t = i + y.t;
	while (--i >= 0)
	r[i] = 0;
	for ( i = 0; i < y.t; ++i)
		r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
	r.s = 0;
	r.clamp();
	if (this.s != a.s)
		BigInteger.ZERO.subTo(r, r);
}

// (protected) r = this^2, r != this (HAC 14.16)
function bnpSquareTo(r) {
	var x = this.abs();
	var i = r.t = 2 * x.t;
	while (--i >= 0)
	r[i] = 0;
	for ( i = 0; i < x.t - 1; ++i) {
		var c = x.am(i, x[i], r, 2 * i, 0, 1);
		if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
			r[i + x.t] -= x.DV;
			r[i + x.t + 1] = 1;
		}
	}
	if (r.t > 0)
		r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
	r.s = 0;
	r.clamp();
}

// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
// r != q, this != m.  q or r may be null.
function bnpDivRemTo(m, q, r) {
	var pm = m.abs();
	if (pm.t <= 0)
		return;
	var pt = this.abs();
	if (pt.t < pm.t) {
		if (q != null)
			q.fromInt(0);
		if (r != null)
			this.copyTo(r);
		return;
	}
	if (r == null)
		r = nbi();
	var y = nbi(), ts = this.s, ms = m.s;
	var nsh = this.DB - nbits(pm[pm.t - 1]);
	// normalize modulus
	if (nsh > 0) {
		pm.lShiftTo(nsh, y);
		pt.lShiftTo(nsh, r);
	} else {
		pm.copyTo(y);
		pt.copyTo(r);
	}
	var ys = y.t;
	var y0 = y[ys - 1];
	if (y0 == 0)
		return;
	var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);
	var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
	var i = r.t, j = i - ys, t = (q == null) ? nbi() : q;
	y.dlShiftTo(j, t);
	if (r.compareTo(t) >= 0) {
		r[r.t++] = 1;
		r.subTo(t, r);
	}
	BigInteger.ONE.dlShiftTo(ys, t);
	t.subTo(y, y);
	// "negative" y so we can replace sub with am later
	while (y.t < ys)
	y[y.t++] = 0;
	while (--j >= 0) {
		// Estimate quotient digit
		var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
		if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {// Try it out
			y.dlShiftTo(j, t);
			r.subTo(t, r);
			while (r[i] < --qd)
			r.subTo(t, r);
		}
	}
	if (q != null) {
		r.drShiftTo(ys, q);
		if (ts != ms)
			BigInteger.ZERO.subTo(q, q);
	}
	r.t = ys;
	r.clamp();
	if (nsh > 0)
		r.rShiftTo(nsh, r);
	// Denormalize remainder
	if (ts < 0)
		BigInteger.ZERO.subTo(r, r);
}

// (public) this mod a
function bnMod(a) {
	var r = nbi();
	this.abs().divRemTo(a, null, r);
	if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
		a.subTo(r, r);
	return r;
}

// Modular reduction using "classic" algorithm
function Classic(m) {
	this.m = m;
}

function cConvert(x) {
	if (x.s < 0 || x.compareTo(this.m) >= 0)
		return x.mod(this.m);
	else
		return x;
}

function cRevert(x) {
	return x;
}

function cReduce(x) {
	x.divRemTo(this.m, null, x);
}

function cMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}

function cSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}

Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;

// (protected) return "-1/this % 2^DB"; useful for Mont. reduction
// justification:
//         xy == 1 (mod m)
//         xy =  1+km
//   xy(2-xy) = (1+km)(1-km)
// x[y(2-xy)] = 1-k^2m^2
// x[y(2-xy)] == 1 (mod m^2)
// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
// JS multiply "overflows" differently from C/C++, so care is needed here.
function bnpInvDigit() {
	if (this.t < 1)
		return 0;
	var x = this[0];
	if ((x & 1) == 0)
		return 0;
	var y = x & 3;
	// y == 1/x mod 2^2
	y = (y * (2 - (x & 0xf) * y)) & 0xf;
	// y == 1/x mod 2^4
	y = (y * (2 - (x & 0xff) * y)) & 0xff;
	// y == 1/x mod 2^8
	y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff;
	// y == 1/x mod 2^16
	// last step - calculate inverse mod DV directly;
	// assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
	y = (y * (2 - x * y % this.DV)) % this.DV;
	// y == 1/x mod 2^dbits
	// we really want the negative inverse, and -DV < y < DV
	return (y > 0) ? this.DV - y : -y;
}

// Montgomery reduction
function Montgomery(m) {
	this.m = m;
	this.mp = m.invDigit();
	this.mpl = this.mp & 0x7fff;
	this.mph = this.mp >> 15;
	this.um = (1 << (m.DB - 15)) - 1;
	this.mt2 = 2 * m.t;
}

// xR mod m
function montConvert(x) {
	var r = nbi();
	x.abs().dlShiftTo(this.m.t, r);
	r.divRemTo(this.m, null, r);
	if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
		this.m.subTo(r, r);
	return r;
}

// x/R mod m
function montRevert(x) {
	var r = nbi();
	x.copyTo(r);
	this.reduce(r);
	return r;
}

// x = x/R mod m (HAC 14.32)
function montReduce(x) {
	while (x.t <= this.mt2)// pad x so am has enough room later
	x[x.t++] = 0;
	for (var i = 0; i < this.m.t; ++i) {
		// faster way of calculating u0 = x[i]*mp mod DV
		var j = x[i] & 0x7fff;
		var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;
		// use am to combine the multiply-shift-add into one call
		j = i + this.m.t;
		x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
		// propagate carry
		while (x[j] >= x.DV) {
			x[j] -= x.DV;
			x[++j]++;
		}
	}
	x.clamp();
	x.drShiftTo(this.m.t, x);
	if (x.compareTo(this.m) >= 0)
		x.subTo(this.m, x);
}

// r = "x^2/R mod m"; x != r
function montSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}

// r = "xy/R mod m"; x,y != r
function montMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}

Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;

// (protected) true iff this is even
function bnpIsEven() {
	return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;
}

// (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
function bnpExp(e, z) {
	if (e > 0xffffffff || e < 1)
		return BigInteger.ONE;
	var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
	g.copyTo(r);
	while (--i >= 0) {
		z.sqrTo(r, r2);
		if ((e & (1 << i)) > 0)
			z.mulTo(r2, g, r);
		else {
			var t = r;
			r = r2;
			r2 = t;
		}
	}
	return z.revert(r);
}

// (public) this^e % m, 0 <= e < 2^32
function bnModPowInt(e, m) {
	var z;
	if (e < 256 || m.isEven())
		z = new Classic(m);
	else
		z = new Montgomery(m);
	return this.exp(e, z);
}

// protected
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;

// public
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;

// "constants"
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);

function bnClone() {
	var r = nbi();
	this.copyTo(r);
	return r;
}

// (public) return value as integer
function bnIntValue() {
	if (this.s < 0) {
		if (this.t == 1)
			return this[0] - this.DV;
		else if (this.t == 0)
			return -1;
	} else if (this.t == 1)
		return this[0];
	else if (this.t == 0)
		return 0;
	// assumes 16 < DB < 32
	return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
}

// (public) return value as byte
function bnByteValue() {
	return (this.t == 0) ? this.s : (this[0] << 24) >> 24;
}

// (public) return value as short (assumes DB>=16)
function bnShortValue() {
	return (this.t == 0) ? this.s : (this[0] << 16) >> 16;
}

// (protected) return x s.t. r^x < DV
function bnpChunkSize(r) {
	return Math.floor(Math.LN2 * this.DB / Math.log(r));
}

// (public) 0 if this == 0, 1 if this > 0
function bnSigNum() {
	if (this.s < 0)
		return -1;
	else if (this.t <= 0 || (this.t == 1 && this[0] <= 0))
		return 0;
	else
		return 1;
}

// (protected) convert to radix string
function bnpToRadix(b) {
	if (b == null)
		b = 10;
	if (this.signum() == 0 || b < 2 || b > 36)
		return "0";
	var cs = this.chunkSize(b);
	var a = Math.pow(b, cs);
	var d = nbv(a), y = nbi(), z = nbi(), r = "";
	this.divRemTo(d, y, z);
	while (y.signum() > 0) {
		r = (a + z.intValue()).toString(b).substr(1) + r;
		y.divRemTo(d, y, z);
	}
	return z.intValue().toString(b) + r;
}

// (protected) convert from radix string
function bnpFromRadix(s, b) {
	this.fromInt(0);
	if (b == null)
		b = 10;
	var cs = this.chunkSize(b);
	var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
	for (var i = 0; i < s.length; ++i) {
		var x = intAt(s, i);
		if (x < 0) {
			if (s.charAt(i) == "-" && this.signum() == 0)
				mi = true;
			continue;
		}
		w = b * w + x;
		if (++j >= cs) {
			this.dMultiply(d);
			this.dAddOffset(w, 0);
			j = 0;
			w = 0;
		}
	}
	if (j > 0) {
		this.dMultiply(Math.pow(b, j));
		this.dAddOffset(w, 0);
	}
	if (mi)
		BigInteger.ZERO.subTo(this, this);
}

// (protected) alternate constructor
function bnpFromNumber(a, b, c) {
	if ("number" == typeof b) {
		// new BigInteger(int,int,RNG)
		if (a < 2)
			this.fromInt(1);
		else {
			this.fromNumber(a, c);
			if (!this.testBit(a - 1))// force MSB set
				this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
			if (this.isEven())
				this.dAddOffset(1, 0);
			// force odd
			while (!this.isProbablePrime(b)) {
				this.dAddOffset(2, 0);
				if (this.bitLength() > a)
					this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
			}
		}
	} else {
		// new BigInteger(int,RNG)
		var x = new Array(), t = a & 7;
		x.length = (a >> 3) + 1;
		b.nextBytes(x);
		if (t > 0)
			x[0] &= ((1 << t) - 1);
		else
			x[0] = 0;
		this.fromString(x, 256);
	}
}

// (public) convert to bigendian byte array
function bnToByteArray() {
	var i = this.t, r = new Array();
	r[0] = this.s;
	var p = this.DB - (i * this.DB) % 8, d, k = 0;
	if (i-- > 0) {
		if (p < this.DB && ( d = this[i] >> p) != (this.s & this.DM) >> p)
			r[k++] = d | (this.s << (this.DB - p));
		while (i >= 0) {
			if (p < 8) {
				d = (this[i] & ((1 << p) - 1)) << (8 - p);
				d |= this[--i] >> (p += this.DB - 8);
			} else {
				d = (this[i] >> (p -= 8)) & 0xff;
				if (p <= 0) {
					p += this.DB;
					--i;
				}
			}
			if ((d & 0x80) != 0)
				d |= -256;
			if (k == 0 && (this.s & 0x80) != (d & 0x80))
				++k;
			if (k > 0 || d != this.s)
				r[k++] = d;
		}
	}
	return r;
}

function bnEquals(a) {
	return (this.compareTo(a) == 0);
}

function bnMin(a) {
	return (this.compareTo(a) < 0) ? this : a;
}

function bnMax(a) {
	return (this.compareTo(a) > 0) ? this : a;
}

// (protected) r = this op a (bitwise)
function bnpBitwiseTo(a, op, r) {
	var i, f, m = Math.min(a.t, this.t);
	for ( i = 0; i < m; ++i)
		r[i] = op(this[i], a[i]);
	if (a.t < this.t) {
		f = a.s & this.DM;
		for ( i = m; i < this.t; ++i)
			r[i] = op(this[i], f);
		r.t = this.t;
	} else {
		f = this.s & this.DM;
		for ( i = m; i < a.t; ++i)
			r[i] = op(f, a[i]);
		r.t = a.t;
	}
	r.s = op(this.s, a.s);
	r.clamp();
}

// (public) this & a
function op_and(x, y) {
	return x & y;
}

function bnAnd(a) {
	var r = nbi();
	this.bitwiseTo(a, op_and, r);
	return r;
}

// (public) this | a
function op_or(x, y) {
	return x | y;
}

function bnOr(a) {
	var r = nbi();
	this.bitwiseTo(a, op_or, r);
	return r;
}

// (public) this ^ a
function op_xor(x, y) {
	return x ^ y;
}

function bnXor(a) {
	var r = nbi();
	this.bitwiseTo(a, op_xor, r);
	return r;
}

// (public) this & ~a
function op_andnot(x, y) {
	return x & ~y;
}

function bnAndNot(a) {
	var r = nbi();
	this.bitwiseTo(a, op_andnot, r);
	return r;
}

// (public) ~this
function bnNot() {
	var r = nbi();
	for (var i = 0; i < this.t; ++i)
		r[i] = this.DM & ~this[i];
	r.t = this.t;
	r.s = ~this.s;
	return r;
}

// (public) this << n
function bnShiftLeft(n) {
	var r = nbi();
	if (n < 0)
		this.rShiftTo(-n, r);
	else
		this.lShiftTo(n, r);
	return r;
}

// (public) this >> n
function bnShiftRight(n) {
	var r = nbi();
	if (n < 0)
		this.lShiftTo(-n, r);
	else
		this.rShiftTo(n, r);
	return r;
}

// return index of lowest 1-bit in x, x < 2^31
function lbit(x) {
	if (x == 0)
		return -1;
	var r = 0;
	if ((x & 0xffff) == 0) {
		x >>= 16;
		r += 16;
	}
	if ((x & 0xff) == 0) {
		x >>= 8;
		r += 8;
	}
	if ((x & 0xf) == 0) {
		x >>= 4;
		r += 4;
	}
	if ((x & 3) == 0) {
		x >>= 2;
		r += 2;
	}
	if ((x & 1) == 0)
		++r;
	return r;
}

// (public) returns index of lowest 1-bit (or -1 if none)
function bnGetLowestSetBit() {
	for (var i = 0; i < this.t; ++i)
		if (this[i] != 0)
			return i * this.DB + lbit(this[i]);
	if (this.s < 0)
		return this.t * this.DB;
	return -1;
}

// return number of 1 bits in x
function cbit(x) {
	var r = 0;
	while (x != 0) {
		x &= x - 1;
		++r;
	}
	return r;
}

// (public) return number of set bits
function bnBitCount() {
	var r = 0, x = this.s & this.DM;
	for (var i = 0; i < this.t; ++i)
		r += cbit(this[i] ^ x);
	return r;
}

// (public) true iff nth bit is set
function bnTestBit(n) {
	var j = Math.floor(n / this.DB);
	if (j >= this.t)
		return (this.s != 0);
	return ((this[j] & (1 << (n % this.DB))) != 0);
}

// (protected) this op (1<<n)
function bnpChangeBit(n, op) {
	var r = BigInteger.ONE.shiftLeft(n);
	this.bitwiseTo(r, op, r);
	return r;
}

// (public) this | (1<<n)
function bnSetBit(n) {
	return this.changeBit(n, op_or);
}

// (public) this & ~(1<<n)
function bnClearBit(n) {
	return this.changeBit(n, op_andnot);
}

// (public) this ^ (1<<n)
function bnFlipBit(n) {
	return this.changeBit(n, op_xor);
}

// (protected) r = this + a
function bnpAddTo(a, r) {
	var i = 0, c = 0, m = Math.min(a.t, this.t);
	while (i < m) {
		c += this[i] + a[i];
		r[i++] = c & this.DM;
		c >>= this.DB;
	}
	if (a.t < this.t) {
		c += a.s;
		while (i < this.t) {
			c += this[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += this.s;
	} else {
		c += this.s;
		while (i < a.t) {
			c += a[i];
			r[i++] = c & this.DM;
			c >>= this.DB;
		}
		c += a.s;
	}
	r.s = (c < 0) ? -1 : 0;
	if (c > 0)
		r[i++] = c;
	else if (c < -1)
		r[i++] = this.DV + c;
	r.t = i;
	r.clamp();
}

// (public) this + a
function bnAdd(a) {
	var r = nbi();
	this.addTo(a, r);
	return r;
}

// (public) this - a
function bnSubtract(a) {
	var r = nbi();
	this.subTo(a, r);
	return r;
}

// (public) this * a
function bnMultiply(a) {
	var r = nbi();
	this.multiplyTo(a, r);
	return r;
}

// (public) this^2
function bnSquare() {
	var r = nbi();
	this.squareTo(r);
	return r;
}

// (public) this / a
function bnDivide(a) {
	var r = nbi();
	this.divRemTo(a, r, null);
	return r;
}

// (public) this % a
function bnRemainder(a) {
	var r = nbi();
	this.divRemTo(a, null, r);
	return r;
}

// (public) [this/a,this%a]
function bnDivideAndRemainder(a) {
	var q = nbi(), r = nbi();
	this.divRemTo(a, q, r);
	return new Array(q, r);
}

// (protected) this *= n, this >= 0, 1 < n < DV
function bnpDMultiply(n) {
	this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
	++this.t;
	this.clamp();
}

// (protected) this += n << w words, this >= 0
function bnpDAddOffset(n, w) {
	if (n == 0)
		return;
	while (this.t <= w)
	this[this.t++] = 0;
	this[w] += n;
	while (this[w] >= this.DV) {
		this[w] -= this.DV;
		if (++w >= this.t)
			this[this.t++] = 0;
		++
		this[w];
	}
}

// A "null" reducer
function NullExp() {
}

function nNop(x) {
	return x;
}

function nMulTo(x, y, r) {
	x.multiplyTo(y, r);
}

function nSqrTo(x, r) {
	x.squareTo(r);
}

NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;

// (public) this^e
function bnPow(e) {
	return this.exp(e, new NullExp());
}

// (protected) r = lower n words of "this * a", a.t <= n
// "this" should be the larger one if appropriate.
function bnpMultiplyLowerTo(a, n, r) {
	var i = Math.min(this.t + a.t, n);
	r.s = 0;
	// assumes a,this >= 0
	r.t = i;
	while (i > 0)
	r[--i] = 0;
	var j;
	for ( j = r.t - this.t; i < j; ++i)
		r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
	for ( j = Math.min(a.t, n); i < j; ++i)
		this.am(0, a[i], r, i, 0, n - i);
	r.clamp();
}

// (protected) r = "this * a" without lower n words, n > 0
// "this" should be the larger one if appropriate.
function bnpMultiplyUpperTo(a, n, r) {--n;
	var i = r.t = this.t + a.t - n;
	r.s = 0;
	// assumes a,this >= 0
	while (--i >= 0)
	r[i] = 0;
	for ( i = Math.max(n - this.t, 0); i < a.t; ++i)
		r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
	r.clamp();
	r.drShiftTo(1, r);
}

// Barrett modular reduction
function Barrett(m) {
	// setup Barrett
	this.r2 = nbi();
	this.q3 = nbi();
	BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
	this.mu = this.r2.divide(m);
	this.m = m;
}

function barrettConvert(x) {
	if (x.s < 0 || x.t > 2 * this.m.t)
		return x.mod(this.m);
	else if (x.compareTo(this.m) < 0)
		return x;
	else {
		var r = nbi();
		x.copyTo(r);
		this.reduce(r);
		return r;
	}
}

function barrettRevert(x) {
	return x;
}

// x = x mod m (HAC 14.42)
function barrettReduce(x) {
	x.drShiftTo(this.m.t - 1, this.r2);
	if (x.t > this.m.t + 1) {
		x.t = this.m.t + 1;
		x.clamp();
	}
	this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
	this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
	while (x.compareTo(this.r2) < 0)
	x.dAddOffset(1, this.m.t + 1);
	x.subTo(this.r2, x);
	while (x.compareTo(this.m) >= 0)
	x.subTo(this.m, x);
}

// r = x^2 mod m; x != r
function barrettSqrTo(x, r) {
	x.squareTo(r);
	this.reduce(r);
}

// r = x*y mod m; x,y != r
function barrettMulTo(x, y, r) {
	x.multiplyTo(y, r);
	this.reduce(r);
}

Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;

// (public) this^e % m (HAC 14.85)
function bnModPow(e, m) {
	var i = e.bitLength(), k, r = nbv(1), z;
	if (i <= 0)
		return r;
	else if (i < 18)
		k = 1;
	else if (i < 48)
		k = 3;
	else if (i < 144)
		k = 4;
	else if (i < 768)
		k = 5;
	else
		k = 6;
	if (i < 8)
		z = new Classic(m);
	else if (m.isEven())
		z = new Barrett(m);
	else
		z = new Montgomery(m);

	// precomputation
	var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
	g[1] = z.convert(this);
	if (k > 1) {
		var g2 = nbi();
		z.sqrTo(g[1], g2);
		while (n <= km) {
			g[n] = nbi();
			z.mulTo(g2, g[n - 2], g[n]);
			n += 2;
		}
	}

	var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
	i = nbits(e[j]) - 1;
	while (j >= 0) {
		if (i >= k1)
			w = (e[j] >> (i - k1)) & km;
		else {
			w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
			if (j > 0)
				w |= e[j - 1] >> (this.DB + i - k1);
		}

		n = k;
		while ((w & 1) == 0) {
			w >>= 1;
			--n;
		}
		if ((i -= n) < 0) {
			i += this.DB;
			--j;
		}
		if (is1) {// ret == 1, don't bother squaring or multiplying it
			g[w].copyTo(r);
			is1 = false;
		} else {
			while (n > 1) {
				z.sqrTo(r, r2);
				z.sqrTo(r2, r);
				n -= 2;
			}
			if (n > 0)
				z.sqrTo(r, r2);
			else {
				t = r;
				r = r2;
				r2 = t;
			}
			z.mulTo(r2, g[w], r);
		}

		while (j >= 0 && (e[j] & (1 << i)) == 0) {
			z.sqrTo(r, r2);
			t = r;
			r = r2;
			r2 = t;
			if (--i < 0) {
				i = this.DB - 1;
				--j;
			}
		}
	}
	return z.revert(r);
}

// (public) gcd(this,a) (HAC 14.54)
function bnGCD(a) {
	var x = (this.s < 0) ? this.negate() : this.clone();
	var y = (a.s < 0) ? a.negate() : a.clone();
	if (x.compareTo(y) < 0) {
		var t = x;
		x = y;
		y = t;
	}
	var i = x.getLowestSetBit(), g = y.getLowestSetBit();
	if (g < 0)
		return x;
	if (i < g)
		g = i;
	if (g > 0) {
		x.rShiftTo(g, x);
		y.rShiftTo(g, y);
	}
	while (x.signum() > 0) {
		if (( i = x.getLowestSetBit()) > 0)
			x.rShiftTo(i, x);
		if (( i = y.getLowestSetBit()) > 0)
			y.rShiftTo(i, y);
		if (x.compareTo(y) >= 0) {
			x.subTo(y, x);
			x.rShiftTo(1, x);
		} else {
			y.subTo(x, y);
			y.rShiftTo(1, y);
		}
	}
	if (g > 0)
		y.lShiftTo(g, y);
	return y;
}

// (protected) this % n, n < 2^26
function bnpModInt(n) {
	if (n <= 0)
		return 0;
	var d = this.DV % n, r = (this.s < 0) ? n - 1 : 0;
	if (this.t > 0)
		if (d == 0)
			r = this[0] % n;
		else
			for (var i = this.t - 1; i >= 0; --i)
				r = (d * r + this[i]) % n;
	return r;
}

// (public) 1/this % m (HAC 14.61)
function bnModInverse(m) {
	var ac = m.isEven();
	if ((this.isEven() && ac) || m.signum() == 0)
		return BigInteger.ZERO;
	var u = m.clone(), v = this.clone();
	var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
	while (u.signum() != 0) {
		while (u.isEven()) {
			u.rShiftTo(1, u);
			if (ac) {
				if (!a.isEven() || !b.isEven()) {
					a.addTo(this, a);
					b.subTo(m, b);
				}
				a.rShiftTo(1, a);
			} else if (!b.isEven())
				b.subTo(m, b);
			b.rShiftTo(1, b);
		}
		while (v.isEven()) {
			v.rShiftTo(1, v);
			if (ac) {
				if (!c.isEven() || !d.isEven()) {
					c.addTo(this, c);
					d.subTo(m, d);
				}
				c.rShiftTo(1, c);
			} else if (!d.isEven())
				d.subTo(m, d);
			d.rShiftTo(1, d);
		}
		if (u.compareTo(v) >= 0) {
			u.subTo(v, u);
			if (ac)
				a.subTo(c, a);
			b.subTo(d, b);
		} else {
			v.subTo(u, v);
			if (ac)
				c.subTo(a, c);
			d.subTo(b, d);
		}
	}
	if (v.compareTo(BigInteger.ONE) != 0)
		return BigInteger.ZERO;
	if (d.compareTo(m) >= 0)
		return d.subtract(m);
	if (d.signum() < 0)
		d.addTo(m, d);
	else
		return d;
	if (d.signum() < 0)
		return d.add(m);
	else
		return d;
}

var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];

// (public) test primality with certainty >= 1-.5^t
function bnIsProbablePrime(t) {
	var i, x = this.abs();
	if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
		for ( i = 0; i < lowprimes.length; ++i)
			if (x[0] == lowprimes[i])
				return true;
		return false;
	}
	if (x.isEven())
		return false;
	i = 1;
	while (i < lowprimes.length) {
		var m = lowprimes[i], j = i + 1;
		while (j < lowprimes.length && m < lplim)
		m *= lowprimes[j++];
		m = x.modInt(m);
		while (i < j)
		if (m % lowprimes[i++] == 0)
			return false;
	}
	return x.millerRabin(t);
}

// (protected) true if probably prime (HAC 4.24, Miller-Rabin)
function bnpMillerRabin(t) {
	var n1 = this.subtract(BigInteger.ONE);
	var k = n1.getLowestSetBit();
	if (k <= 0)
		return false;
	var r = n1.shiftRight(k);
	t = (t + 1) >> 1;
	if (t > lowprimes.length)
		t = lowprimes.length;
	var a = nbi();
	for (var i = 0; i < t; ++i) {
		//Pick bases at random, instead of starting at 2
		a.fromInt(lowprimes[Math.floor(twaver.Util.random() * lowprimes.length)]);
		var y = a.modPow(r, this);
		if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
			var j = 1;
			while (j++ < k && y.compareTo(n1) != 0) {
				y = y.modPowInt(2, this);
				if (y.compareTo(BigInteger.ONE) == 0)
					return false;
			}
			if (y.compareTo(n1) != 0)
				return false;
		}
	}
	return true;
}

// protected
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;

// public
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

// JSBN-specific extension
BigInteger.prototype.square = bnSquare;

// prng4.js - uses Arcfour as a PRNG

function Arcfour() {
	this.i = 0;
	this.j = 0;
	this.S = new Array();
}

// Initialize arcfour context from key, an array of ints, each from [0..255]
function ARC4init(key) {
	var i, j, t;
	for ( i = 0; i < 256; ++i)
		this.S[i] = i;
	j = 0;
	for ( i = 0; i < 256; ++i) {
		j = (j + this.S[i] + key[i % key.length]) & 255;
		t = this.S[i];
		this.S[i] = this.S[j];
		this.S[j] = t;
	}
	this.i = 0;
	this.j = 0;
}

function ARC4next() {
	var t;
	this.i = (this.i + 1) & 255;
	this.j = (this.j + this.S[this.i]) & 255;
	t = this.S[this.i];
	this.S[this.i] = this.S[this.j];
	this.S[this.j] = t;
	return this.S[(t + this.S[this.i]) & 255];
}

Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;

// Plug in your RNG constructor here
function prng_newstate() {
	return new Arcfour();
}

// Pool size must be a multiple of 4 and greater than 32.
// An array of bytes the size of the pool will be passed to init()
var rng_psize = 256;

// Random number generator

var rng_state;
var rng_pool;
var rng_pptr;

// Mix in a 32-bit integer into the pool
function rng_seed_int(x) {
	rng_pool[rng_pptr++] ^=x & 255;
	rng_pool[rng_pptr++] ^=(x >> 8) & 255;
	rng_pool[rng_pptr++] ^=(x >> 16) & 255;
	rng_pool[rng_pptr++] ^=(x >> 24) & 255;
	if (rng_pptr >= rng_psize)
		rng_pptr -= rng_psize;
}

// Mix in the current time (w/milliseconds) into the pool
function rng_seed_time() {
	rng_seed_int(new Date().getTime());
}

// Initialize the pool with junk if needed.
if (rng_pool == null) {
	rng_pool = new Array();
	rng_pptr = 0;
	var t;
	if (navigator.appName == "Netscape" && navigator.appVersion < "5" && window.crypto) {
		// Extract entropy (256 bits) from NS4 RNG if available
		var z = window.crypto.random(32);
		for ( t = 0; t < z.length; ++t)
			rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
	}
	while (rng_pptr < rng_psize) {// extract some randomness from Math.random()
		t = Math.floor(65536 * twaver.Util.random());
		rng_pool[rng_pptr++] = t >>> 8;
		rng_pool[rng_pptr++] = t & 255;
	}
	rng_pptr = 0;
	rng_seed_time();
}

function rng_get_byte() {
	if (rng_state == null) {
		rng_seed_time();
		rng_state = prng_newstate();
		rng_state.init(rng_pool);
		for ( rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
			rng_pool[rng_pptr] = 0;
		rng_pptr = 0;
		//rng_pool = null;
	}
	// TODO: allow reseeding after first request
	return rng_state.next();
}

function rng_get_bytes(ba) {
	var i;
	for ( i = 0; i < ba.length; ++i)
		ba[i] = rng_get_byte();
}

function SecureRandom() {
}

SecureRandom.prototype.nextBytes = rng_get_bytes;

// base64

var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var b64pad = "=";

function hex2b64(h) {
	var i;
	var c;
	var ret = "";
	for ( i = 0; i + 3 <= h.length; i += 3) {
		c = parseInt(h.substring(i, i + 3), 16);
		ret += b64map.charAt(c >> 6) + b64map.charAt(c & 63);
	}
	if (i + 1 == h.length) {
		c = parseInt(h.substring(i, i + 1), 16);
		ret += b64map.charAt(c << 2);
	} else if (i + 2 == h.length) {
		c = parseInt(h.substring(i, i + 2), 16);
		ret += b64map.charAt(c >> 2) + b64map.charAt((c & 3) << 4);
	}
	while ((ret.length & 3) > 0)
	ret += b64pad;
	return ret;
}

// convert a base64 string to hex
function b64tohex(s) {
	var ret = ""
	var i;
	var k = 0;
	// b64 state, 0-3
	var slop;
	for ( i = 0; i < s.length; ++i) {
		if (s.charAt(i) == b64pad)
			break;
		v = b64map.indexOf(s.charAt(i));
		if (v < 0)
			continue;
		if (k == 0) {
			ret += int2char(v >> 2);
			slop = v & 3;
			k = 1;
		} else if (k == 1) {
			ret += int2char((slop << 2) | (v >> 4));
			slop = v & 0xf;
			k = 2;
		} else if (k == 2) {
			ret += int2char(slop);
			ret += int2char(v >> 2);
			slop = v & 3;
			k = 3;
		} else {
			ret += int2char((slop << 2) | (v >> 4));
			ret += int2char(v & 0xf);
			k = 0;
		}
	}
	if (k == 1)
		ret += int2char(slop << 2);
	return ret;
}

// convert a base64 string to a byte/number array
function b64toBA(s) {
	//piggyback on b64tohex for now, optimize later
	var h = b64tohex(s);
	var i;
	var a = new Array();
	for ( i = 0; 2 * i < h.length; ++i) {
		a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);
	}
	return a;
}

// RSA

function parseBigInt(str, r) {
	return new BigInteger(str, r);
}

function byte2Hex(b) {
	if (b < 0x10)
		return "0" + b.toString(16);
	else
		return b.toString(16);
}

// PKCS#1 (type 2, random) pad input string s to n bytes, and return a bigint
function pkcs1pad2(s, n) {
	if (n < s.length + 11) {// TODO: fix for utf-8
		//alert("Message too long for RSA");
		return null;
	}
	var ba = new Array();
	var i = s.length - 1;
	while (i >= 0 && n > 0) {
		var c = s.charCodeAt(i--);
		if (c < 128) {// encode using utf-8
			ba[--n] = c;
		} else if ((c > 127) && (c < 2048)) {
			ba[--n] = (c & 63) | 128;
			ba[--n] = (c >> 6) | 192;
		} else {
			ba[--n] = (c & 63) | 128;
			ba[--n] = ((c >> 6) & 63) | 128;
			ba[--n] = (c >> 12) | 224;
		}
	}
	ba[--n] = 0;
	var rng = new SecureRandom();
	var x = new Array();
	while (n > 2) {// random non-zero pad
		x[0] = 0;
		while (x[0] == 0)
		rng.nextBytes(x);
		ba[--n] = x[0];
	}
	ba[--n] = 2;
	ba[--n] = 0;
	return new BigInteger(ba);
}

// "empty" RSA key constructor
function RSAKey() {
	this.n = null;
	this.e = 0;
	this.d = null;
	this.p = null;
	this.q = null;
	this.dmp1 = null;
	this.dmq1 = null;
	this.coeff = null;
}

// Set the public key fields N and e from hex strings
function RSASetPublic(n, e) {
	this.n = parseBigInt(n, 16);
	this.e = parseInt(e, 16);
}

// Perform raw public operation on "x": return x^e (mod n)
function RSADoPublic(x) {
	return x.modPowInt(this.e, this.n);
}

// Return the PKCS#1 RSA encryption of "text" as an even-length hex string
function RSAEncrypt(text) {
	var m = pkcs1pad2(text, (this.n.bitLength() + 7) >> 3);
	if (m == null)
		return null;
	var c = this.doPrivate(m);
	if (c == null)
		return null;
	var h = c.toString(16);
	if ((h.length & 1) == 0)
		return h;
	else
		return "0" + h;
}

// Return the PKCS#1 RSA encryption of "text" as a Base64-encoded string
//function RSAEncryptB64(text) {
//  var h = this.encrypt(text);
//  if(h) return hex2b64(h); else return null;
//}

// protected
RSAKey.prototype.doPublic = RSADoPublic;

// public
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;

// Undo PKCS#1 (type 2, random) padding and, if valid, return the plaintext
function pkcs1unpad2(d, n) {
	var b = d.toByteArray();
	var i = 0;
	while (i < b.length && b[i] == 0)++i;
	if (b.length - i != n - 1 || b[i] != 2)
		return null;
	++i;
	while (b[i] != 0)
	if (++i >= b.length)
		return null;
	var ret = "";
	while (++i < b.length) {
		var c = b[i] & 255;
		if (c < 128) {// utf-8 decode
			ret += String.fromCharCode(c);
		} else if ((c > 191) && (c < 224)) {
			ret += String.fromCharCode(((c & 31) << 6) | (b[i + 1] & 63));
			++i;
		} else {
			ret += String.fromCharCode(((c & 15) << 12) | ((b[i + 1] & 63) << 6) | (b[i + 2] & 63));
			i += 2;
		}
	}
	return ret;
}

// Set the private key fields N, e, and d from hex strings
function RSASetPrivate(N, E, D) {
	this.n = parseBigInt(N, 16);
	this.e = parseInt(E, 16);
	this.d = parseBigInt(D, 16);
}

// Set the private key fields N, e, d and CRT params from hex strings
function RSASetPrivateEx(N, E, D, P, Q, DP, DQ, C) {
	this.n = parseBigInt(N, 16);
	this.e = parseInt(E, 16);
	this.d = parseBigInt(D, 16);
	this.p = parseBigInt(P, 16);
	this.q = parseBigInt(Q, 16);
	this.dmp1 = parseBigInt(DP, 16);
	this.dmq1 = parseBigInt(DQ, 16);
	this.coeff = parseBigInt(C, 16);
}

// Perform raw private operation on "x": return x^d (mod n)
function RSADoPrivate(x) {
	if (this.p == null || this.q == null)
		return x.modPow(this.d, this.n);

	// TODO: re-calculate any missing CRT params
	var xp = x.mod(this.p).modPow(this.dmp1, this.p);
	var xq = x.mod(this.q).modPow(this.dmq1, this.q);

	while (xp.compareTo(xq) < 0)
	xp = xp.add(this.p);
	return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}

// Return the PKCS#1 RSA decryption of "ctext".
// "ctext" is an even-length hex string and the output is a plain string.
function RSADecrypt(ctext) {
	var c = parseBigInt(ctext, 16);
	var m = this.doPublic(c);
	if (m == null)
		return null;
	return pkcs1unpad2(m, (this.n.bitLength() + 7) >> 3);
}

RSAKey.prototype.doPrivate = RSADoPrivate;

RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.decrypt = RSADecrypt;

var __v = function() {
	__l.v($license);
},
__l = {};
var n = "6a384c1259bdb5e731ec96b3174683f48a2c56a85e52e7a5bb20b58711ce50c1" + "a294bd5e1d1752e766085e9ae94bae6d217c25dbb5fcdb86a8a9a7e180fa0667" + "23d00fcb85fcf7c9d29f8cc8859f53244a49c0bc30dcc45156daf8843ce1d24f" + "e8ebc9a3c186bb26e9d0714041aef160304c1db8cc5728cf4acb39d29755f319", e = "10001", d = "61a921483dfa8f24e26204ace4d990b965d11e5bef5d8a5e768ebc5853a6bdd9" + "4b02369a3165207460fb91001d3fd83fbe69c6e51b8e40c8ae8a4e30a7c539dc" + "a98b44858bdc0b76f25af6803d4d13dacd9fa1a28f66cf561fa36309d4239a2c" + "f50fe20ef0e99e01fc8701090f0685a524f411e00ca91f877d3b49d2d0052f9", p = "b881f568eb43e7a60c256a8a90e08b7c7638fd66ce3cded9005c72e283ca4f2b" + "8601e2edc687d7f898348a05723b515d9edeb626af7b499a56ddaea93b0c2047", q = "9360ab3d6b678727748ea004e85120f1823ec94e6116dc5fcd7b1c9ea231d38e" + "5d7d2d23c00607912e1645835756b71290c6c3cc2bc656e93d9a4f6b0d55619f", dmp1 = "3e61c2259d15b26693c8bac2eac4e0a44e1c6aa0adae2af2578aea54e796293a" + "5fee9759293c98aab65b5d27063e43fe514e9f6b68fd581f54ab52f868bc6ad5", dmq1 = "4dac2913d9c35a6be4f63647dfd8c23006a0e89fb273c5f987e656931490861b" + "0612aef3a48489006ef5b5f51ed6c8edb3f7cdc191609af59a4df5854a25b1a9", coeff = "acd9837a1472711ff2b63ba0de667fa4a4a56a8b0f4cbb0a555f73d1bc529e9e" + "cf865b709fd8235c3db05bcf1539de1e594d3a8275fe0784a9f5241d8895b328";
__l.cross = function(str) {
	if (str) {
		var crossStr = '';
		for (var i = 0; i < str.length; ) {
			if (i + 1 < str.length) {
				crossStr += str[i + 1];
				crossStr += str[i];
			} else {
				crossStr += str[i];
			}
			i += 2;
		}
		return crossStr;
	}
	return null;
};

__l.reverse = function(str) {
	if (str) {
		var reversedString = '';
		for (var i = str.length; i > 0; i--) {
			reversedString = reversedString + str[i - 1];
		}
		return reversedString;
	}
	return null;
};

__l.v = function(license) {
	if (license) {
		var l = __l;
    l.start = null;
    l.beginDate = null;
    l.end = null;
    l.endDate = null;
    l.gis = null;
    l['3D'] = null;
    l['3d'] = null;
    l.l = null;
	  l.__li__ = null;
		if (license.indexOf('signature=') > 0) {
			var array = license.split('signature=');
			var plainLicenseText = array[0];
			var signature = array[1];
			var rsa = new RSAKey();
			rsa.setPublic(n, e);
			var encryptText = signature, length = encryptText.length, maxSize = 256, index = 0, segment = '', result = '';
			while (index < length) {
				segment = encryptText.substr(index, maxSize);
				result += rsa.decrypt(segment);
				index += maxSize;
			}
			if (result === plainLicenseText) {
				l.i(license);
				return true;
			}
		}
	}
	return false;
};

__l.i = function(li) {
	var l = __l;
	l.__li__ = li;
	var array = li.split('\n');
	var i, line, property, value, ll;

	for (i=array.length-1; i>=0; i--) {
		line = array[i];
		ll = line.split('=');
		property = ll[0];
		value = ll[1];
		l[property] = value;
	}

	if (l.start != undefined) {
		l.beginDate = new Date(Date.parse(l.start.replace(/-/g, "/")));
	}

	if (l.end != undefined) {
		l.endDate = new Date(Date.parse(l.end.replace(/-/g, "/")));
	}

	var gis = l.gis;
    if(gis != undefined){
    	gis = parseInt(gis);
    }
	if (gis) {
		l._isPermissionGIS = true;
	}
    var threed = l['3D'] || l['3d'];
    if(threed != undefined){
    	threed = parseInt(threed);
    }
	if (threed) {
		l._isPermission3D = true;
	}

	if (l['3D']) {
		l._isPermission3D = true;
	}

	if (l.l != undefined) {
		l.version = l.l;
	}

};

var __isLi = function(l) {
	return l.__li__ !== undefined && !l._isPermission3D;
};

var __isExpired = function(l) {
	if (!__isLi(l)) {
		return true;
	}
	var now = new Date();
	return (l.beginDate != null && l.beginDate.getTime() - now.getTime() >= 0) || (l.endDate != null && l.endDate.getTime() - now.getTime() <= 0);
};

var __isDeverlopVersion = function(l) {
	if (l.type === 2) {
		return true;
	}
	return false;
};

var __isPermissionGIS = function() {
	if (__isExpired(__l)) {
		return false;
	}
	return __l._isPermissionGIS;
};
__l.$z = function(text) {
	var rsa = new RSAKey();
	rsa.setPublic(n, e);
	var encryptText = text, length = encryptText.length, maxSize = 256, index = 0, segment = '', result = '';
	while (index < length) {
		segment = encryptText.substr(index, maxSize);
		result += rsa.decrypt(segment);
		index += maxSize;
	}
	return result;
};
__l.twm = function(view) {
	var l = __l;
	var evaluation = l.$z('4cd18113d0c7046bfe51f7a3fbd41c2b7cf14dd785d6ea7cec9da17710d3acfb8ce0cb9cf10839f4bd51e88819de19cdc0db09278584396156fcb65abe0353ac49d01326b30efa0ea98a07da9f8ceeb7572fc1b37b5965ba6103ccba4913b62e36e49425c6ff21a2f008830c59cff8f29058769f858c8a9f0bab3eaea7fb8a9e');
	var t = this.type;
	var mark = this.markText;

	var k = l.$z('648be38cd61c870e95ffc1ea0676af40736c1365015abc326e891a4de67b4de3d4b05da70b9aebedc83ec26ecf71eb74c72f42f6d9a4be2d507d2f67d2860b7b66e3ba1d565e15923f2db335ff922eef17c01b59818b583d5656412d6cc9d9ba70001c2c88e3efd492c6b13a07fda5f325b333138a2036f4696542ec137cc341');
	view[k] = l.__li__;
	if (t === '3' && !__isExpired(__l) && mark === undefined) {
		return;
	}
	if (view.__liLabel == undefined) {
		view.__liLabel = document.createElement('div');
	}
	if (l.startDate === undefined) {
		l.startDate = new Date();
	}
	var lt = new Date().getTime() - l.startDate.getTime();
	if (lt < 1000 * 300) {
		return;
	}
	var expired = __isExpired(l) && lt > 1000 * 300;
	var text = mark;
	if (expired) {
		text = l.$z('0dd629dbd0ce341ecdd447e35ddc3135a0b46916f7571a687f38ae665cf0ae095fee885e14329caa75112d8787508da17285b0897845d8ccae73e6a2727dd19f1ca335fe139d0e60d240f9ececc78f81c2c5667f51aeed4135b9c4bb436b8acb7cd418eeeb404bc4f3bcdedb481ac0edff7644435ce2b9f2bda78c892bd56d73');
	} else if (t == '2' && (text === undefined || text == '')) {
		text = l.$z('644d54bf9c59afbd8a742a9e7e2731f23f149ccb7f04c3547548c50ac2d77faea108b55f1f6261e99869f1c06b84e8abdefdf45b5170048531421f3d528123972ba2f03d70f37c33f1341dc12f986e0089e42bab517e2a05b455d12d90991bbba9bc45c715a81943062ea5fa5408c8b1b9270d260cc5a67b38ecc4178ce512fc');
	} else if (t == '1' && !mark) {
		text = evaluation;
	}
	if (text === undefined) {
		return;
	}

	var component = view;
	var ld = component.__liLabel;
	ld.innerHTML = text;

	if (component._rootCanvas) {
		ld.type = t;
		ld.mark = mark;
		ld.expired = expired;
		component._xyz = ld;
	} else {
		var x = 0;
		var y = 0;
		ld.style.position = 'absolute';
		var style = component.getView().style;
		if ((mark != undefined && mark != null && mark != '') || t == '2') {
			x = 10 - component.getView().scrollLeft;
			y = 10 - component.getView().scrollTop;

		} else {
			x = style.width.replace('px', '') / 2 - 50 - component.getView().scrollLeft;
			y = style.height.replace('px', '') / 2 - component.getView().scrollTop;
		}
		ld.style.right = x + 'px';
		ld.style.bottom = y + 'px';
		ld.style.fontSize = '120%';
		if (expired) {
			component.getView().style.opacity = 0.1;
			ld.style.color = 'red';
			ld.style.fontSize = '150%';
		}
		component.getView().appendChild(ld);
	}

};

_twaver.validateLicense($license);


var $DashedLine = function (g, onLength, offLength) {
    this.g = g;
    this.onLength = onLength;
    this.offLength = offLength;

    this.isLine = true;
    this.overflow = 0;
    this.dashLength = onLength + offLength;
    this.pen = {
        x: 0,
        y: 0
    };
};
_twaver.ext($DashedLine, Object, {
    _curveaccuracy: 6,
    moveTo: function (x, y) {
        this.pen = {
            x: x,
            y: y
        };
        this.g.moveTo(x, y);
        if (!this.start) {
            this.start = {
                x: x,
                y: y
            };
        }
    },
    lineTo: function (x, y) {
        var dx = x - this.pen.x,
            dy = y - this.pen.y;
        var a = Math.atan2(dy, dx);
        var ca = Math.cos(a),
            sa = Math.sin(a);
        var segLength = this.lineLength(this.pen.x, this.pen.y, x, y);
        if (this.overflow) {
            if (this.overflow > segLength) {
                if (this.isLine) this._lineTo(x, y);
                else this.moveTo(x, y);
                this.overflow -= segLength;
                return;
            }
            if (this.isLine) this._lineTo(this.pen.x + ca * this.overflow, this.pen.y + sa * this.overflow);
            else this.moveTo(this.pen.x + ca * this.overflow, this.pen.y + sa * this.overflow);
            segLength -= this.overflow;
            this.overflow = 0;
            this.isLine = !this.isLine;
            if (!segLength) return;
        }
        var fullDashCount = Math.floor(segLength / this.dashLength);
        if (fullDashCount) {
            var onx = ca * this.onLength,
                ony = sa * this.onLength;
            var offx = ca * this.offLength,
                offy = sa * this.offLength;
            for (var i = 0; i < fullDashCount; i++) {
                if (this.isLine) {
                    this._lineTo(this.pen.x + onx, this.pen.y + ony);
                    this.moveTo(this.pen.x + offx, this.pen.y + offy);
                } else {
                    this.moveTo(this.pen.x + offx, this.pen.y + offy);
                    this._lineTo(this.pen.x + onx, this.pen.y + ony);
                }
            }
            segLength -= this.dashLength * fullDashCount;
        }
        if (this.isLine) {
            if (segLength > this.onLength) {
                this._lineTo(this.pen.x + ca * this.onLength, this.pen.y + sa * this.onLength);
                this.moveTo(x, y);
                this.overflow = this.offLength - (segLength - this.onLength);
                this.isLine = false;
            } else {
                this._lineTo(x, y);
                if (segLength == this.onLength) {
                    this.overflow = 0;
                    this.isLine = !this.isLine;
                } else {
                    this.overflow = this.onLength - segLength;
                    this.moveTo(x, y);
                }
            }
        } else {
            if (segLength > this.offLength) {
                this.moveTo(this.pen.x + ca * this.offLength, this.pen.y + sa * this.offLength);
                this._lineTo(x, y);
                this.overflow = this.onLength - (segLength - this.offLength);
                this.isLine = true;
            } else {
                this.moveTo(x, y);
                if (segLength == this.offLength) {
                    this.overflow = 0;
                    this.isLine = !this.isLine;
                } else this.overflow = this.offLength - segLength;
            }
        }
    },
    quadraticCurveTo: function (cx, cy, x, y) {
        var sx = this.pen.x;
        var sy = this.pen.y;
        var segLength = this.curveLength(sx, sy, cx, cy, x, y);
        var t = 0;
        var t2 = 0;
        var c;
        if (this.overflow) {
            if (this.overflow > segLength) {
                if (this.isLine) this._curveTo(cx, cy, x, y);
                else this.moveTo(x, y);
                this.overflow -= segLength;
                return;
            }
            t = this.overflow / segLength;
            c = this.curveSliceUpTo(sx, sy, cx, cy, x, y, t);
            if (this.isLine) this._curveTo(c[2], c[3], c[4], c[5]);
            else this.moveTo(c[4], c[5]);
            this.overflow = 0;
            this.isLine = !this.isLine;
            if (!segLength) return;
        }
        var remainLength = segLength - segLength * t;
        var fullDashCount = Math.floor(remainLength / this.dashLength);
        var ont = this.onLength / segLength;
        var offt = this.offLength / segLength;
        if (fullDashCount) {
            for (var i = 0; i < fullDashCount; i++) {
                if (this.isLine) {
                    t2 = t + ont;
                    c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                    this._curveTo(c[2], c[3], c[4], c[5]);
                    t = t2;
                    t2 = t + offt;
                    c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                    this.moveTo(c[4], c[5]);
                } else {
                    t2 = t + offt;
                    c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                    this.moveTo(c[4], c[5]);
                    t = t2;
                    t2 = t + ont;
                    c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                    this._curveTo(c[2], c[3], c[4], c[5]);
                }
                t = t2;
            }
        }
        remainLength = segLength - segLength * t;
        if (this.isLine) {
            if (remainLength > this.onLength) {
                t2 = t + ont;
                c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                this._curveTo(c[2], c[3], c[4], c[5]);
                this.moveTo(x, y);
                this.overflow = this.offLength - (remainLength - this.onLength);
                this.isLine = false;
            } else {
                c = this.curveSliceFrom(sx, sy, cx, cy, x, y, t);
                this._curveTo(c[2], c[3], c[4], c[5]);
                if (segLength == this.onLength) {
                    this.overflow = 0;
                    this.isLine = !this.isLine;
                } else {
                    this.overflow = this.onLength - remainLength;
                    this.moveTo(x, y);
                }
            }
        } else {
            if (remainLength > this.offLength) {
                t2 = t + offt;
                c = this.curveSlice(sx, sy, cx, cy, x, y, t, t2);
                this.moveTo(c[4], c[5]);
                c = this.curveSliceFrom(sx, sy, cx, cy, x, y, t2);
                this._curveTo(c[2], c[3], c[4], c[5]);

                this.overflow = this.onLength - (remainLength - this.offLength);
                this.isLine = true;
            } else {
                this.moveTo(x, y);
                if (remainLength == this.offLength) {
                    this.overflow = 0;
                    this.isLine = !this.isLine;
                } else this.overflow = this.offLength - remainLength;
            }
        }
    },
    bezierCurveTo: function (cx1, cy1, cx2, cy2, x, y) {
        this.pen = {
            x: x,
            y: y
        };
        var lineDash = [this.onLength, this.offLength];
        this.g.setLineDash && this.g.setLineDash(lineDash);
        this.g.lineDash = lineDash;
        this.g.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);
    },
    rect: function (x, y, w, h) {
        this.pen = {
            x: x,
            y: y
        };
        this.moveTo(x, y);
        this.lineTo(x, y + h);
        this.lineTo(x + w, y + h);
        this.lineTo(x + w, y);
        this.lineTo(x, y);
    },
    closePath: function () {
        this.lineTo(this.start.x, this.start.y);
    },
    lineLength: function (sx, sy, ex, ey) {
        var dx = ex - sx;
        var dy = ey - sy;
        return Math.sqrt(dx * dx + dy * dy);
    },
    curveLength: function (sx, sy, cx, cy, ex, ey, accuracy) {
        var total = 0;
        var tx = sx;
        var ty = sy;
        var px, py, t, it, a, b, c;
        var n = (accuracy > 0) ? accuracy : this._curveaccuracy;
        for (var i = 1; i <= n; i++) {
            t = i / n;
            it = 1 - t;
            a = it * it;
            b = 2 * t * it;
            c = t * t;
            px = a * sx + b * cx + c * ex;
            py = a * sy + b * cy + c * ey;
            total += this.lineLength(tx, ty, px, py);
            tx = px;
            ty = py;
        }
        return total;
    },
    curveSlice: function (sx, sy, cx, cy, ex, ey, t1, t2) {
        if (t1 == 0) return this.curveSliceUpTo(sx, sy, cx, cy, ex, ey, t2);
        else if (t2 == 1) return this.curveSliceFrom(sx, sy, cx, cy, ex, ey, t1);
        var c = this.curveSliceUpTo(sx, sy, cx, cy, ex, ey, t2);
        c.push(t1 / t2);
        return this.curveSliceFrom.apply(this, c);
    },
    curveSliceUpTo: function (sx, sy, cx, cy, ex, ey, t) {
        if (t != 1) {
            var midx = cx + (ex - cx) * t;
            var midy = cy + (ey - cy) * t;
            cx = sx + (cx - sx) * t;
            cy = sy + (cy - sy) * t;
            ex = cx + (midx - cx) * t;
            ey = cy + (midy - cy) * t;
        }
        return [sx, sy, cx, cy, ex, ey];
    },
    curveSliceFrom: function (sx, sy, cx, cy, ex, ey, t) {
        if (t != 1) {
            var midx = sx + (cx - sx) * t;
            var midy = sy + (cy - sy) * t;
            cx = cx + (ex - cx) * t;
            cy = cy + (ey - cy) * t;
            sx = midx + (cx - midx) * t;
            sy = midy + (cy - midy) * t;
        }
        return [sx, sy, cx, cy, ex, ey];
    },
    _lineTo: function (x, y) {
        if (x == this.pen.x && y == this.pen.y) return;
        this.pen = {
            x: x,
            y: y
        };
        this.g.lineTo(x, y);
    },
    _curveTo: function (cx, cy, x, y) {
        if (cx == x && cy == y && x == this.pen.x && y == this.pen.y) return;
        this.pen = {
            x: x,
            y: y
        };
        this.g.quadraticCurveTo(cx, cy, x, y);
    }
});
_twaver.DashedLine = $DashedLine;
var $element = {
    DEFAULTS: {
        'default': 1,
        'default.vector': 1,
        'vector.default': 1
    },
    VECTORS: {
        'vector': 1,
        'default.vector': 1,
        'vector.default': 1
    },
    hasDefault: function (node) {
        if (node instanceof $Node) {
            var type = node.getStyle('body.type');
            return $element.DEFAULTS[type] === 1;
        }
        return true;
    },
    hasVector: function (node) {
        if (node instanceof $Node) {
            var type = node.getStyle('body.type');
            return $element.VECTORS[type] === 1;
        }
        return false;
    },
    hasAgentLinks: function (node) {
        var n = node.getChildrenSize();
        for (var i = 0; i < n; i++) {
            var child = node.getChildAt(i);
            if (child instanceof $Node && $element.hasAgentLinks(child)) {
                return true;
            }
        }
        return node.hasAgentLinks();
    },
    getParents: function (data, root, includeRoot) {
        if (!includeRoot) {
            includeRoot = true;
        }
        var list = new $List();
        var parent = data._parent;
        while (parent != null && parent !== root) {
            list.add(parent, 0);
            parent = parent._parent;
        }
        if (includeRoot && parent != null && parent === root) {
            list.add(parent, 0);
        }
        return list;
    },
    getSubNetwork: function (element) {
        if (!element) {
            return null;
        }
        //for link, only if the fromNode and toNode have the same subnetwork,
        //return the subnetwork,otherwise return null.
        if (element instanceof twaver.Link) {
            var fromAgent = element._fromAgent;
            var toAgent = element._toAgent;
            if (!fromAgent || !toAgent) {
                return null;
            }
            //subnetwork.
            var aSubNetwork = $element.getSubNetwork(fromAgent);
            var zSubNetwork = $element.getSubNetwork(toAgent);
            if (aSubNetwork === zSubNetwork) {
                return aSubNetwork;
            }
            return null;
        }

        var parent = element._parent;
        if (!parent) {
            return null;
        }
        while (parent instanceof twaver.Link && !(parent.ISubNetwork)) {
            parent = parent._parent;
        }
        if (parent.ISubNetwork) {
            return parent;
        } else {
            return $element.getSubNetwork(parent);
        }
    },
    figureSameSubNetworkAgent: function (node) {
        if (!node) {
            return null;
        }
        var parent = node._parent;
        while (parent instanceof $Group) {
            if (parent._parent instanceof $Group) {
                if (!parent.isExpanded()) {
                    node = parent;
                }
                parent = parent._parent;
            } else {
                if (parent.isExpanded()) {
                    return node;
                } else {
                    return parent;
                }
            }
        }
        return node;
    },
    figureSpanSubNetworkAgent: function (node, refNode) {
        if (!node || !refNode) {
            return null;
        }
        var nodeSN = $element.getSubNetwork(node);
        var refNodeSN = $element.getSubNetwork(refNode);
        if (nodeSN != refNodeSN) {
            // check refNode's up subnetwork.
            while (refNodeSN != null && nodeSN != refNodeSN) {
                refNodeSN = $element.getSubNetwork(refNodeSN);
            }
            if (nodeSN === refNodeSN) {
                return node;
            }

            // check node's and refNode's same ancestor.
            var list = new $List();
            list.add(node, 0);
            var parent = node._parent;
            while (parent instanceof $Node) {
                if (!refNode.isDescendantOf(parent)) {
                    list.add(parent, 0);
                    parent = parent._parent;
                } else {
                    break;
                }
            }
            var n = list.size();
            for (var i = 0; i < n; i++) {
                var element = list.get(i);
                if (element instanceof $Group && (!element.isExpanded())) {
                    return element;
                }
                if (element.ISubNetwork) {
                    return element;
                }
            }
            return node;
        }
        return node;
    },
    figureFromAgent: function (link) {
        if (link.isLooped()) {
            return link.getFromNode();
        }
        var fromAgent = $element.figureSameSubNetworkAgent(link.getFromNode());
        var toAgent = $element.figureSameSubNetworkAgent(link.getToNode());
        if (fromAgent === toAgent) {
            return link.getFromNode();
        }
        return $element.figureSpanSubNetworkAgent(fromAgent, toAgent);
    },
    figureToAgent: function (link) {
        if (link.isLooped()) {
            return link.getToNode();
        }
        var fromAgent = $element.figureSameSubNetworkAgent(link.getFromNode());
        var toAgent = $element.figureSameSubNetworkAgent(link.getToNode());
        if (fromAgent === toAgent) {
            return link.getToNode();
        }
        return $element.figureSpanSubNetworkAgent(toAgent, fromAgent);
    },
    getBundleLinks: function (node1, node2) {
        if (!node1 || !node2) {
            return null;
        }
        var i;
        var n;
        var link;
        var list;
        if (node1 === node2) {
            list = node1.getLoopedLinks();
            if (list) {
                list = new $List(list);
            } else {
                return null;
            }
        } else {
            var list1 = node1.getAgentLinks();
            var list2 = node2.getAgentLinks();
            if (!list1 || !list2) {
                return null;
            }
            n = list1.size();
            for (i = 0; i < n; i++) {
                link = list1.get(i);
                if (list2.contains(link)) {
                    if (!list) {
                        list = new $List();
                    }
                    list.add(link);
                }
            }
        }
        if (list != null) {
            for (i = 0; i < list.size(); i++) {
                link = list.get(i);
                if (!link.getStyle('link.bundle.enable')) {
                    link._setBundleLinks(null);
                    list.removeAt(i);
                    i--;
                }
            }
        }
        return list;
    },
    resetBundleLinks: function (node1, node2) {
        var links = $element.getBundleLinks(node1, node2);
        if (!links || links.size() === 0) {
            return;
        }

        var link = null;
        if (links.size() === 1) {
            link = links.get(0);
            link._setBundleLinks(null);
            return;
        }

        var i;
        var id;
        var groupIDs = new $List();
        for (i = 0; i < links.size(); i++) {
            link = links.get(i);
            id = link.getStyle('link.bundle.id');
            if (groupIDs.indexOf(id) < 0) {
                groupIDs.add(id);
            }
        }
        groupIDs.sort();
        var bundleLinks;
        var siblings = new $List();
        var k;
        for (k = 0; k < groupIDs.size(); k++) {
            id = groupIDs.get(k);
            var siblingLinks = new $List();
            for (i = 0; i < links.size(); i++) {
                link = links.get(i);
                if (id === link.getStyle('link.bundle.id')) {
                    siblingLinks.add(link);
                }
            }
            bundleLinks = new twaver.BundleLinks(siblingLinks, siblings);
            siblings.add(bundleLinks);
        }

        for (k = 0; k < siblings.size(); k++) {
            bundleLinks = siblings.get(k);
            for (i = 0; i < bundleLinks.getLinks().size(); i++) {
                link = bundleLinks.getLinks().get(i);
                link._setBundleLinks(bundleLinks);
            }
        }
    },
    moveElements: function (elements, dx, dy, filter) {
        var list = $element.filterMovingElements(elements, filter);
        var n = list.size();
        for (var i = 0; i < n; i++) {
            list.get(i).translate(dx, dy);
        }
    },
    filterMovingElements: function (elements, filter) {
        var list = new $List();
        var n = elements.size();
        for (var i = 0; i < n; i++) {
            var element = elements.get(i);
            if (!(element instanceof $Node)) {
                continue;
            }
            if (filter && !filter(element)) {
                continue;
            }
            var needToMove = true;
            var array = list.toArray();
            for (var k = 0; k < array.length; k++) {
                var e = array[k];
                if (needToMove && e instanceof twaver.Follower && element instanceof twaver.Follower && element.isLoopedHostOn(e)) {
                    needToMove = false;
                }
                else if (e instanceof twaver.Follower && e.isHostOn(element)) {
                    list.remove(e);
                }
                else if (needToMove && element instanceof twaver.Follower && e instanceof $Node && element.isHostOn(e)) {
                    needToMove = false;
                }
                else if ($element.isDescendantOfGroup(e, element)) {
                    list.remove(e);
                }
                else if (needToMove && $element.isDescendantOfGroup(element, e)) {
                    needToMove = false;
                }
            }
            if (needToMove) {
                list.add(element);
            }
        }
        return list;
    },
    isDescendantOfGroup: function (element, group) {
        if (!element || !(group instanceof $Group)) {
            return false;
        }
        if (!group.hasChildren()) {
            return false;
        }
        element = element._parent;
        while (element instanceof $Group) {
            if (element === group) {
                return true;
            } else {
                element = element._parent;
            }
        }
        return false;
    }
};
_twaver.element = $element;

var $bus = {
    between: function (v1, v2, v) {
        if (v >= v1 && v <= v2) {
            return true;
        }
        if (v >= v2 && v <= v1) {
            return true;
        }
        return false;
    },
    considerEast: function (toPoint, result, point1) {
        if (!result) {
            return true;
        }
        if ($bus.between(result.x, point1.x, toPoint.x)) {
            return point1.x > result.x;
        } else {
            return Math.abs(result.x - toPoint.x) > Math.abs(point1.x - toPoint.x);
        }
    },
    considerWest: function (toPoint, result, point1) {
        if (!result) {
            return true;
        }
        if ($bus.between(result.x, point1.x, toPoint.x)) {
            return point1.x < result.x;
        } else {
            return Math.abs(result.x - toPoint.x) > Math.abs(point1.x - toPoint.x);
        }
    },
    considerNorth: function (toPoint, result, point1) {
        if (!result) {
            return true;
        }
        if ($bus.between(result.y, point1.y, toPoint.y)) {
            return point1.y < result.y;
        } else {
            return Math.abs(result.y - toPoint.y) > Math.abs(point1.y - toPoint.y);
        }
    },
    considerSouth: function (toPoint, result, point1) {
        if (!result) {
            return true;
        }
        if ($bus.between(result.y, point1.y, toPoint.y)) {
            return point1.y > result.y;
        } else {
            return Math.abs(result.y - toPoint.y) > Math.abs(point1.y - toPoint.y);
        }
    },
    getHorizontalPoint: function (toPoint, point1, point2) {
        if ($bus.between(point1.x, point2.x, toPoint.x)) {
            return { x: toPoint.x, y: point1.y };
        } else {
            if (Math.abs(toPoint.x - point1.x) < Math.abs(toPoint.x - point2.x)) {
                return { x: point1.x, y: point1.y };
            } else {
                return { x: point2.x, y: point2.y };
            }
        }
    },
    getVerticalPoint: function (toPoint, point1, point2) {
        if ($bus.between(point1.y, point2.y, toPoint.y)) {
            return { x: point1.x, y: toPoint.y };
        } else {
            if (Math.abs(toPoint.y - point1.y) < Math.abs(toPoint.y - point2.y)) {
                return { x: point1.x, y: point1.y };
            } else {
                return { x: point2.x, y: point2.y };
            }
        }
    },
    getPoint: function (result, toPoint, point1, point2, style) {
        var isHorizontal = Math.abs(point2.x - point1.x) > Math.abs(point2.y - point1.y);

        if ('south' === style) {
            if (isHorizontal && $bus.considerSouth(toPoint, result, point1)) {
                return $bus.getHorizontalPoint(toPoint, point1, point2);
            }
            return null;
        }
        else if ('north' === style) {
            if (isHorizontal && $bus.considerNorth(toPoint, result, point1)) {
                return $bus.getHorizontalPoint(toPoint, point1, point2);
            }
            return null;
        }
        else if ('west' === style) {
            if (!isHorizontal && $bus.considerWest(toPoint, result, point1)) {
                return $bus.getVerticalPoint(toPoint, point1, point2);
            }
            return null;
        }
        else if ('east' === style) {
            if (!isHorizontal && $bus.considerEast(toPoint, result, point1)) {
                return $bus.getVerticalPoint(toPoint, point1, point2);
            }
            return null;
        }
        else if ('nearby' === style) {
            var point;
            if (isHorizontal) {
                point = $bus.getHorizontalPoint(toPoint, point1, point2);
            } else {
                point = $bus.getVerticalPoint(toPoint, point1, point2);
            }
            if (!result || $math.getDistance(result, toPoint) > $math.getDistance(point, toPoint)) {
                return point;
            }
            return null;
        }
        return null;
    },
    getBusPoint: function (points, toPoint, style) {
        var result;
        var count = points.size();
        if (count > 0) {
            var point1 = points.get(0);
            for (var i = 1; i < count; i++) {
                var point2 = points.get(i);
                var point = $bus.getPoint(result, toPoint, point1, point2, style);
                if (point) {
                    result = point;
                }
                point1 = point2;
            }
            if (!result) {
                result = { x: point1.x, y: point1.y };
            }
        }
        return result;
    }
};
_twaver.bus = $bus;

var $link = {
    createFromPoint: function (ui,zoomManager) {
        var link = ui._element;
        if (!link.getFromAgent()) {
            return { x: 0, y: 0 };
        }
        var fromPosition = link.getStyle('link.from.position');
        var fromXoffset = link.getStyle('link.from.xoffset');
        var fromYoffset = link.getStyle('link.from.yoffset');
        var fromPoint;

        var fromOffset = link.getStyle('link.from.percent');
        
        if(fromOffset && fromOffset instanceof Array && fromOffset.length === 2 
            && fromOffset[0] <=1 && fromOffset[0] >= 0
            && fromOffset[1] <=1 && fromOffset[1] >= 0){
            var fromAgent = link.getFromAgent();
            var size = fromAgent.getSize();
            var x = fromAgent.getRect().x + size.width * fromOffset[0];
            var y = fromAgent.getRect().y + size.height * fromOffset[1];
            return {x:x , y: y};
        }

        if(ui._network._edgeDetect) {
            var fromAgent = link.getFromAgent();
            var toAgent = link.getToAgent();
            var imageName = fromAgent.getImage();
            var imageAsset = _twaver.images[imageName];
            var fCLocation = fromAgent.getCenterLocation();
            var tCLocation = toAgent.getCenterLocation();
            var angle = this._getPointAngleDegree(tCLocation.x, tCLocation.y, fCLocation.x, fCLocation.y);
            var newPoint = {x: 0, y: 0};
            if (imageAsset) {
                var image = imageAsset._image;
                if(image && isImage(image) || image && twaver.Util.getImageAsset(imageName)._cache){
                    if (isImage(image)) {
                       if (!imageAsset._edgeData) {
                            imageAsset._edgeData = imageAsset._createEdgeData(image, fromAgent._width,fromAgent._height);
                        }
                    }else if(typeof image === 'object'){
                        if (!imageAsset._edgeData) {
                          imageAsset._edgeData = imageAsset._createEdgeData(twaver.Util.getImageAsset(imageName)._cache,fromAgent.getWidth(),fromAgent.getHeight());
                        }
                    }
                    newPoint.x = imageAsset._edgeData[angle].x + fromAgent.getRect().x;
                    newPoint.y = imageAsset._edgeData[angle].y + fromAgent.getRect().y;
                    return newPoint;
                }
            }
        }

        if (!_twaver.isCalculatingBus) {
            _twaver.isCalculatingBus = true;
            if (link.getFromAgent() instanceof twaver.Bus) {
                var bus = link.getFromAgent();
                if ($element.hasVector(bus)) {
                    var rect = zoomManager ? zoomManager._getElementZoomRect(ui,bus.getRect()) : bus.getRect();
                    var shape = bus.getStyle('vector.shape');
                    if (shape === 'oval') {
                        fromPoint = $math.getEllipsePoint(rect, $link.createToPoint(ui));
                    }
                    else if (shape === 'circle') {
                        fromPoint = $math.getEllipsePoint($math.getCircleRect(rect), $link.createToPoint(ui));
                    }
                    else if (shape === 'rectangle' || shape === 'roundrect') {
                        var points = new $List();
                        points.add({ x: bus.x, y: bus.y });
                        points.add({ x: bus.x + bus.width, y: bus.y });
                        points.add({ x: bus.x + bus.width, y: bus.y + bus.height });
                        points.add({ x: bus.x, y: bus.y + bus.height });
                        points.add({ x: bus.x, y: bus.y });
                        points = zoomManager ? zoomManager._getShapeNodeZoomPoints(ui,points) : points;
                        fromPoint = $bus.getBusPoint(points, $link.createToPoint(ui), bus.getStyle('bus.style'));
                    }
                }
                else {
                	var points = zoomManager ? zoomManager._getShapeNodeZoomPoints(ui,bus.getPoints()) : bus.getPoints();
                    fromPoint = $bus.getBusPoint(points, $link.createToPoint(ui), bus.getStyle('bus.style'));
                }
            }
            _twaver.isCalculatingBus = false;
        }

        if (!fromPoint) {
            fromPoint = ui._network.getPosition(fromPosition, link.getFromAgent(), null, fromXoffset, fromYoffset,true);
        } else {
            fromPoint.x += fromXoffset;
            fromPoint.y += fromYoffset;
        }
        return fromPoint;
    },
    createToPoint: function (ui,zoomManager) {
        var link = ui._element;
        if (!link.getToAgent()) {
            return { x: 0, y: 0 };
        }
        var toPosition = link.getStyle('link.to.position');
        var toXoffset = link.getStyle('link.to.xoffset');
        var toYoffset = link.getStyle('link.to.yoffset');

        var toPoint;

        var toOffset = link.getStyle('link.to.percent');
        if(toOffset && toOffset instanceof Array && toOffset.length === 2
            && toOffset[0] <=1 && toOffset[0] >= 0
            && toOffset[1] <=1 && toOffset[1] >= 0){
            var toAgent = link.getToAgent();
            var size = toAgent.getSize();
            var x = toAgent.getRect().x + size.width * toOffset[0];
            var y = toAgent.getRect().y + size.height * toOffset[1];
            return {x:x , y: y};
        }

        if(ui._network._edgeDetect) {
            var fromAgent = link.getFromAgent();
            var toAgent = link.getToAgent();
            var imageName = toAgent.getImage();
            var imageAsset = _twaver.images[imageName];
            var fCLocation = fromAgent.getLocation();
            var tCLocation = toAgent.getCenterLocation();
            var angle = this._getPointAngleDegree(fCLocation.x, fCLocation.y, tCLocation.x, tCLocation.y);
            var newPoint = {x: 0, y: 0};

            if (imageAsset) {
                var image = imageAsset._image;
                if(image && isImage(image) || image && twaver.Util.getImageAsset(imageName)._cache){
                    if (isImage(image)) {
                        if (!imageAsset._edgeData) {
                            imageAsset._edgeData = imageAsset._createEdgeData(image, toAgent.getWidth(), toAgent.getHeight());
                        }
                    }else if(typeof image === 'object'){
                        if (!imageAsset._edgeData) {
                            imageAsset._edgeData = imageAsset._createEdgeData(twaver.Util.getImageAsset(imageName)._cache,toAgent.getWidth(), toAgent.getHeight());
                        }
                    }
                    newPoint.x = imageAsset._edgeData[angle].x + toAgent.getRect().x;
                    newPoint.y = imageAsset._edgeData[angle].y + toAgent.getRect().y;
                    return newPoint;
                }
            }
        }


        if (!_twaver.isCalculatingBus) {
            _twaver.isCalculatingBus = true;

            if (link.getToAgent() instanceof twaver.Bus) {
                var bus = link.getToAgent();
                if ($element.hasVector(bus)) {
                	var rect = zoomManager ? zoomManager._getElementZoomRect(ui,bus.getRect()) : bus.getRect();
                    var shape = bus.getStyle('vector.shape');
                    if (shape === 'oval') {
                        toPoint = $math.getEllipsePoint(rect, $link.createFromPoint(ui));
                    }
                    else if (shape === 'circle') {
                        toPoint = $math.getEllipsePoint($math.getCircleRect(rect), $link.createFromPoint(ui));
                    }
                    else if (shape === 'rectangle' || shape === 'roundrect') {
                        var points = new $List();
                        points.add({ x: bus.x, y: bus.y });
                        points.add({ x: bus.x + bus.width, y: bus.y });
                        points.add({ x: bus.x + bus.width, y: bus.y + bus.height });
                        points.add({ x: bus.x, y: bus.y + bus.height });
                        points.add({ x: bus.x, y: bus.y });
                        points = zoomManager ? zoomManager._getShapeNodeZoomPoints(ui,points) : points;
                        toPoint = $bus.getBusPoint(points, $link.createFromPoint(ui), bus.getStyle('bus.style'));
                    }
                }
                else {
                	var points = zoomManager ? zoomManager._getShapeNodeZoomPoints(ui,bus.getPoints()) : bus.getPoints();
                    toPoint = $bus.getBusPoint(points, $link.createFromPoint(ui), bus.getStyle('bus.style'));
                }
            }

            _twaver.isCalculatingBus = false;
        }

        if (!toPoint) {
            toPoint = ui._network.getPosition(toPosition, link.getToAgent(), null, toXoffset, toYoffset,true);
        } else {
            toPoint.x += toXoffset;
            toPoint.y += toYoffset;
        }
        return toPoint;
    },
    fillLoopedPoints: function (ui, rect, points) {
        var cPoint;
        var radius = $link.getBundleGap(ui, true);
        var percentRadius = radius;
        var type = ui.getStyle('link.looped.type');
        var direction = ui.getStyle('link.looped.direction');

        if (direction === 'north') {
            if (type === 'arc') {
                $link.drawArc(rect.x + rect.width / 2, rect.y, 0, Math.PI, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x + rect.width / 2, y: rect.y };
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y });
            }

            return { x: rect.x + rect.width / 2, y: rect.y - radius };
        }
        else if (direction === 'northeast') {
            if (type === 'arc') {
                $link.drawArc(rect.x + rect.width, rect.y, Math.PI * 1.5, Math.PI * 1.5, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x + rect.width, y: rect.y };
                points.add({ x: cPoint.x, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y });
            }
            return { x: rect.x + rect.width + radius * 0.707, y: rect.y - radius * 0.707 };
        }
        else if (direction === 'east') {
            if (type === 'arc') {
                $link.drawArc(rect.x + rect.width, rect.y + rect.height / 2, Math.PI * 1.5, Math.PI, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x + rect.width, y: rect.y + rect.height / 2 };
                points.add({ x: cPoint.x, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x + radius, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x + radius, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x, y: cPoint.y + percentRadius });
            }
            return { x: rect.x + rect.width + radius, y: rect.y + rect.height / 2 };
        }
        else if (direction === 'southeast') {
            if (type === 'arc') {
                $link.drawArc(rect.x + rect.width, rect.y + rect.height, Math.PI, Math.PI * 1.5, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x + rect.width, y: rect.y + rect.height };
                points.add({ x: cPoint.x, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y });
            }
            return { x: rect.x + rect.width + radius * 0.707, y: rect.y + rect.height + radius * 0.707 };
        }
        else if (direction === 'south') {
            if (type === 'arc') {
                $link.drawArc(rect.x + rect.width / 2, rect.y + rect.height, Math.PI, Math.PI, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x + rect.width / 2, y: rect.y + rect.height };
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y });
            }
            return { x: rect.x + rect.width / 2, y: rect.y + rect.height + radius };
        }
        else if (direction === 'southwest') {
            if (type === 'arc') {
                $link.drawArc(rect.x, rect.y + rect.height, Math.PI * 0.5, Math.PI * 1.5, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x, y: rect.y + rect.height };
                points.add({ x: cPoint.x, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y + radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y });
            }
            return { x: rect.x - radius * 0.707, y: rect.y + rect.height + radius * 0.707 };
        }
        else if (direction === 'west') {
            if (type === 'arc') {
                $link.drawArc(rect.x, rect.y + rect.height / 2, Math.PI * 0.5, Math.PI, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x, y: rect.y + rect.height / 2 };
                points.add({ x: cPoint.x, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x - radius, y: cPoint.y - percentRadius });
                points.add({ x: cPoint.x - radius, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x, y: cPoint.y + percentRadius });
            }
            return { x: rect.x - radius, y: rect.y + rect.height / 2 };
        }
        else if (direction === 'northwest') {
            if (type === 'arc') {
                $link.drawArc(rect.x, rect.y, 0, Math.PI * 1.5, radius, radius, false, points);
            }
            else {
                cPoint = { x: rect.x, y: rect.y };
                points.add({ x: cPoint.x, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y + percentRadius });
                points.add({ x: cPoint.x - percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y - radius });
                points.add({ x: cPoint.x + percentRadius, y: cPoint.y });
            }
            return { x: rect.x - radius * 0.707, y: rect.y - radius * 0.707 };
        }
        throw "Can not resolve link looped direction '" + direction + "'";
    },
    drawArc: function (x, y, startAngle, arc, radius, yRadius, continueFlag, points) {
        var segAngle;
        var theta;
        var angle;
        var angleMid;
        var segs;
        var ax;
        var ay;
        var bx;
        var by;
        var cx;
        var cy;

        if (Math.abs(arc) > 2 * Math.PI) {
            arc = 2 * Math.PI;
        }

        segs = Math.ceil(Math.abs(arc) / (Math.PI / 4));
        segAngle = arc / segs;
        theta = -segAngle;
        angle = -startAngle;

        if (segs > 0) {
            ax = x + Math.cos(startAngle) * radius;
            ay = y + Math.sin(-startAngle) * yRadius;

            points.add({ x: ax, y: ay });

            for (var i = 0; i < segs; i++) {
                angle += theta;
                angleMid = angle - theta / 2;

                bx = x + Math.cos(angle) * radius;
                by = y + Math.sin(angle) * yRadius;
                cx = x + Math.cos(angleMid) * (radius / Math.cos(theta / 2));
                cy = y + Math.sin(angleMid) * (yRadius / Math.cos(theta / 2));
                var tempPoint = new $List();
                tempPoint.add({ x: cx, y: cy });
                tempPoint.add({ x: bx, y: by });
                points.add(tempPoint);
            }
        }
    },
    fillBundlePoints: function (ui, type, fromPoint, toPoint, points ,zoomManager) {
        var bundleCount = ui._element.getBundleCount();
        var bundleIndex = ui._element.getBundleIndex();
        var bundleExpanded = ui.getStyle('link.bundle.expanded');

        var yoffset;
//        if (!bundleExpanded || (type !== 'parallel' && (yoffset = $link.getBundleGap(ui, false)) === 0)) {
        if ((type !== 'parallel' && (yoffset = $link.getBundleGap(ui, false)) === 0)) {
            points.add(fromPoint);
            points.add(toPoint);
            return $math.getCenterPoint(fromPoint, toPoint);
        }
        else {
            yoffset === undefined && (yoffset = $link.getBundleGap(ui, false));
            var xoffset = $link.getBundleOffset(ui);
            var dist = $math.getDistance(fromPoint, toPoint);

            if(zoomManager){
                var sizeZoom = zoomManager.getSizeZoom();
                xoffset *= sizeZoom;
                yoffset *= sizeZoom;
            }

            if (type === 'arc' || type === 'triangle') {
                points.add({ x: 0, y: 0 });
            }
            if (type === 'arc') {
                points.add({ x: 0, y: yoffset });
            }
            points.add({ x: xoffset, y: yoffset });
            points.add({ x: dist - xoffset, y: yoffset });
            if (type === 'arc') {
                points.add({ x: dist, y: yoffset });
            }
            if (type === 'arc' || type === 'triangle') {
                points.add({ x: dist, y: 0 });
            }

            var angle = Math.atan2(toPoint.y - fromPoint.y, toPoint.x - fromPoint.x);
            var matrix = $math.createMatrix(angle, 0, 0);
            for (var i = 0, s = points.size(); i < s; i++) {
                var point = points.get(i);
                point = matrix.transform(point);
                point.x += fromPoint.x;
                point.y += fromPoint.y;
                points.set(i, point);
            }
            if (type === 'arc') {
                var hotSpot = $math.getCenterPoint(points.get(2), points.get(3));
                var ps = new $List();
                ps.add(points.get(1));
                ps.add(points.get(2));
                points.set(1, ps);

                ps = new $List();
                ps.add(points.get(4));
                ps.add(points.get(5));
                points.set(4, ps);

                points.removeAt(5);
                points.removeAt(2);
                return hotSpot;
            }
            else {
                return $link.calculateCenterPoint(points);
            }
        }
    },
    calculateCenterPoint: function (points) {
        var s = points.size();
        if (points == null || s < 1) {
            return { x: 0, y: 0 };
        }
        if (s % 2 === 0) {
            var h = s / 2;
            var p1 = points.get(h - 1);
            var p2 = points.get(h);
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }
        else {
            return points.get((s - 1) / 2);
        }
    },
    getBundleOffset: function (ui) {
        var dest = $math.getDistance(ui.getFromPoint(), ui.getToPoint());
        var offset = ui.getStyle('link.bundle.offset');
        return dest > offset * 2 ? offset : dest / 2;
    },
    getBundleGap: function (ui, isLooped) {
        var link = ui._element;
        if (!link.getBundleLinks()) {
            if (isLooped) {
                return link.getStyle('link.looped.gap');
            }
            else {
                return 0;
            }
        }
        var gapStyle = isLooped ? 'link.looped.gap' : 'link.bundle.gap';
        var firstLink = null;
        var thisLinkPosition = 0;
        var sumGap = 0;
        var siblings = link.getBundleLinks().getSiblings();
        var lastGap = 0;
        var isIndependent = link.getStyle('link.bundle.independent');
        var bundleGroupGap = link.getStyle('link.bundle.group.gap');
        for (var i = 0, s = siblings.size(); i < s; i++) {
            var siblingBundleLinks = siblings.get(i);
            if (isIndependent && siblingBundleLinks !== link.getBundleLinks()) {
                continue;
            }
            for (var j = 0, ss = siblingBundleLinks.getLinks().size(); j < ss; j++) {
                var siblingLink = siblingBundleLinks.getLinks().get(j);
                if (isIndependent !== siblingLink.getStyle('link.bundle.independent')) {
                    continue;
                }
                if (ui._network.isVisible(siblingLink)) {
                    if (firstLink == null) {
                        firstLink = siblingLink;
                        lastGap = siblingLink.getStyle(gapStyle);
                    }
                    else {
                        var currentGap = siblingLink.getStyle(gapStyle);
                        sumGap += lastGap / 2 + currentGap / 2;
                        lastGap = currentGap;
                    }
                    if (siblingLink === link) {
                        thisLinkPosition = sumGap+bundleGroupGap/2;
                    }
                }
            }
            sumGap += bundleGroupGap;
        }
        if (isLooped) {
            return sumGap - thisLinkPosition + lastGap;
        }
        var value = thisLinkPosition - sumGap / 2;
        if (firstLink != null && link.getFromAgent() !== firstLink.getFromAgent()) {
            value = -value;
        }
        return value;
    },
    isTargetPriority: function (isHorizontal, sourceBounds, targetBounds) {
        if (isHorizontal) {
            if (sourceBounds.height < targetBounds.height) {
                return sourceBounds.height + targetBounds.height < Math.max(sourceBounds.y + sourceBounds.height, targetBounds.y + targetBounds.height) - Math.min(sourceBounds.y, targetBounds.y) + sourceBounds.height / 2;
            }
        } else {
            if (sourceBounds.width < targetBounds.width) {
                return sourceBounds.width + targetBounds.width < Math.max(sourceBounds.x + sourceBounds.width, targetBounds.x + targetBounds.width) - Math.min(sourceBounds.x, targetBounds.x) + sourceBounds.width / 2;
            }
        }
        return true;
    },
    calculateOrthogonalAndFlexionalLinkPoints: function (linkType, sourceBounds, targetBounds, link) {
        var horizontal = $link.isHorizontal(linkType, sourceBounds, targetBounds, link);
        //layout
        var result = new $List();
        if ($link.isFlexionalTypeLink(linkType)) {
            $link.flexional(horizontal, sourceBounds, targetBounds, result, link.getStyle('link.extend'));
        } else {
            $link.orthogonal(linkType, sourceBounds, targetBounds, result, horizontal, link);
            var splitByPercent = $link.isSplitByPercent(linkType, link);
            var splitLocation = splitByPercent ? $link.calculateSplitValueByPercent(linkType, horizontal, sourceBounds, targetBounds, link.getStyle('link.split.percent')) :
					link.getStyle('link.split.value');
            if (splitLocation === 0) {
                horizontal = !horizontal;
            }
        }

        ///start and end point
        var next;
        if (result.size() === 0) {
            if ($link.isTargetPriority(horizontal, sourceBounds, targetBounds)) {
                next = { x: targetBounds.x + targetBounds.width / 2, y: targetBounds.y + targetBounds.height / 2 };
                result.add($link.rectanglePerimeter(sourceBounds, true, next));
                result.add($link.rectanglePerimeter(targetBounds, false, result.get(result.size() - 1)));
            } else {
                next = { x: sourceBounds.x + sourceBounds.width / 2, y: sourceBounds.y + sourceBounds.height / 2 };
                next = $link.rectanglePerimeter(targetBounds, false, next);
                result.add($link.rectanglePerimeter(sourceBounds, true, next));
                result.add(next);
            }
        } else {
            next = result.get(0);
            result.add($link.rectanglePerimeter(sourceBounds, true, next), 0);
            result.add($link.rectanglePerimeter(targetBounds, false, result.get(result.size() - 1)));
        }

        ///delete duplicate points
        var pointCount = result.size();
        if (pointCount < 2) {
            return result;
        }
        var previousPoint = result.get(0);
        for (var index = 1; index < pointCount - 1; index++) {
            var point = result.get(index);
            if (point.x === previousPoint.x && point.y === previousPoint.y) {
                result.remove(point);
                pointCount--;
                index--;
            }
            previousPoint = point;
        }
        return result;
    },
    isHorizontal: function (linkType, sourceBounds, targetBounds, link) {
        if (linkType) {
            if (linkType === 'flexional.horizontal' ||
					linkType === 'orthogonal.horizontal' ||
					linkType === 'orthogonal.H.V' ||
					linkType === 'extend.left' ||
					linkType === 'extend.right') {
                return true;
            } else if (linkType === 'flexional.vertical' ||
					linkType === 'orthogonal.vertical' ||
					linkType === 'orthogonal.V.H' ||
					linkType === 'extend.top' ||
					linkType === 'extend.bottom') {
                return false;
            }
        }
        var xGap = $link.calculateXGap(sourceBounds, targetBounds);
        var yGap = $link.calculateYGap(sourceBounds, targetBounds);
        return xGap >= yGap;
    },
    flexional: function (isHorizontal, sourceBounds, targetBounds, result, extend) {
        isHorizontal ? $link.flexionalHorizontal(sourceBounds, targetBounds, result, extend) : $link.flexionalVertical(sourceBounds, targetBounds, result, extend);
    },
    isSplitByPercent: function (linkType, link) {
        return link.getStyle('link.split.by.percent');
    },
    isExtendTypeLink: function (linkType) {
        return linkType && (linkType === 'extend.top' ||
				linkType === 'extend.left' ||
				linkType === 'extend.bottom' ||
				linkType === 'extend.right');
    },
    isFlexionalTypeLink: function (linkType) {
        return linkType && (linkType === 'flexional' ||
				linkType === 'flexional.horizontal' ||
			linkType === 'flexional.vertical');
    },
    calculateControlPoint: function (linkType, isHorizontal, sourceBounds, targetBounds, link) {
        if (linkType === 'orthogonal.H.V' || linkType === 'orthogonal.V.H') {
            return { x: targetBounds.x + targetBounds.width / 2, y: targetBounds.y + targetBounds.height / 2 };
        }
        var splitLocation;
        if ($link.isExtendTypeLink(linkType)) {
            var top = Math.min(sourceBounds.y, targetBounds.y);
            var left = Math.min(sourceBounds.x, targetBounds.x);
            var bottom = Math.max(sourceBounds.y + sourceBounds.height, targetBounds.y + targetBounds.height);
            var right = Math.max(sourceBounds.x + sourceBounds.width, targetBounds.x + targetBounds.width);
            splitLocation = link.getStyle('link.extend');
            if (linkType === 'extend.top') {
                return { x: (left + right) / 2, y: top - splitLocation };
            }
            if (linkType === 'extend.left') {
                return { x: left - splitLocation, y: (top + bottom) / 2 };
            }
            if (linkType === 'extend.bottom') {
                return { x: (left + right) / 2, y: bottom + splitLocation };
            }
            if (linkType === 'extend.right') {
                return { x: right + splitLocation, y: (top + bottom) / 2 };
            }
        }
        var splitByPercent = $link.isSplitByPercent(linkType, link);

        splitLocation = splitByPercent ? $link.calculateSplitValueByPercent(linkType, isHorizontal, sourceBounds, targetBounds, link.getStyle('link.split.percent')) :
				(link.getStyle('link.split.value'));
        if (splitLocation === Number.NEGATIVE_INFINITY || splitLocation === Number.POSITIVE_INFINITY) {
            return { x: targetBounds.x + targetBounds.width / 2, y: targetBounds.y + targetBounds.height / 2 };
        }
        if (splitLocation === 0) {
            return { x: sourceBounds.x + sourceBounds.width / 2, y: sourceBounds.y + sourceBounds.height / 2 };
        }
        if (isHorizontal) {
            var isLeft = (sourceBounds.x + sourceBounds.x + sourceBounds.width) < (targetBounds.x + targetBounds.x + targetBounds.width);
            return { x: $link.calculateSplitLocation(isLeft, splitLocation, sourceBounds.x, sourceBounds.width), y: sourceBounds.y + sourceBounds.height / 2 };
        }
        var isTop = (sourceBounds.y + sourceBounds.y + sourceBounds.height) < (targetBounds.y + targetBounds.y + targetBounds.height);
        return { x: sourceBounds.x + sourceBounds.width / 2, y: $link.calculateSplitLocation(isTop, splitLocation, sourceBounds.y, sourceBounds.height) };
    },
    calculateGap: function (sourceLeft, sourceRight, targetLeft, targetRight) {
        var sumWidth = Math.max(sourceRight, targetRight) - Math.min(sourceLeft, targetLeft);
        return sumWidth - (sourceRight - sourceLeft + targetRight - targetLeft);
    },
    calculateXGap: function (sourceBounds, targetBounds) {
        var sumWidth = Math.max(sourceBounds.x + sourceBounds.width, targetBounds.x + targetBounds.width) - Math.min(sourceBounds.x, targetBounds.x);
        return sumWidth - sourceBounds.width - targetBounds.width;
    },
    calculateYGap: function (sourceBounds, targetBounds) {
        var sumHeight = Math.max(sourceBounds.y + sourceBounds.height, targetBounds.y + targetBounds.height) - Math.min(sourceBounds.y, targetBounds.y);
        return sumHeight - sourceBounds.height - targetBounds.height;
    },
    calculateSplitValueByPercent: function (linkType, isHorizontal, sourceBounds, targetBounds, splitPercent) {
        var gap = $link.calculateSplitGapByPercent(splitPercent, isHorizontal, sourceBounds, targetBounds);
        return gap * splitPercent;
    },
    calculateSplitGapByPercent: function (splitPercent, isHorizontal, sourceBounds, targetBounds, point) {
        if (isHorizontal) {
            return $link._calculateSplitGapByPercent(splitPercent, sourceBounds.x, sourceBounds.x + sourceBounds.width, targetBounds.x, targetBounds.x + targetBounds.width);
        } else {
            return $link._calculateSplitGapByPercent(splitPercent, sourceBounds.y, sourceBounds.y + sourceBounds.height, targetBounds.y, targetBounds.y + targetBounds.height);
        }
    },
    _calculateSplitGapByPercent: function (splitPercent, sourceLeft, sourceRight, targetLeft, targetRight) {
        var xGap = $link.calculateGap(sourceLeft, sourceRight, targetLeft, targetRight);
        var isLeft = (sourceLeft + sourceRight) < (targetLeft + targetRight);
        if (xGap > 0) {
            if (splitPercent === 1) {
                return xGap + (targetRight - targetLeft) / 2;
            }
            if (splitPercent >= 0 && splitPercent < 1) {
                return xGap;
            }
            if (splitPercent < 0) {
                if (isLeft) {
                    return targetLeft - sourceLeft;
                }
                return sourceRight - targetRight;
            }
        }
        if ((isLeft && splitPercent > 0) || (!isLeft && splitPercent < 0)) {
            return Math.abs(sourceRight - targetRight);
        }
        return Math.abs(sourceLeft - targetLeft);
    },
    calculateSplitPercentByControlPoint: function (point, isHorizontal, sourceBounds, targetBounds) {
        if (isHorizontal) {
            return $link.calculateSplitPercent(point.x, sourceBounds.x, sourceBounds.x + sourceBounds.width, targetBounds.x, targetBounds.x + targetBounds.width);
        } else {
            return $link.calculateSplitPercent(point.y, sourceBounds.y, sourceBounds.y + sourceBounds.height, targetBounds.y, targetBounds.y + targetBounds.height);
        }
    },
    calculateSplitPercent: function (x, sourceLeft, sourceRight, targetLeft, targetRight) {
        if (x >= sourceLeft && x <= sourceRight) {
            return 0;
        }
        var xGap = $link.calculateGap(sourceLeft, sourceRight, targetLeft, targetRight);
        if (xGap > 0 && x >= targetLeft && x <= targetRight) {
            return 1;
        }
        var isLeft = (sourceLeft + sourceRight) < (targetLeft + targetRight);
        if (xGap > 0) {
            if (x > Math.min(sourceRight, targetRight) && x < Math.max(sourceLeft, targetLeft)) {
                return Math.abs(x - (isLeft ? sourceRight : sourceLeft)) / xGap;
            }
            if (isLeft) {
                if (x < sourceLeft) {
                    return (x - sourceLeft) / (targetLeft - sourceLeft);
                }
            } else {
                if (x > sourceRight) {
                    return (sourceRight - x) / (sourceRight - targetRight);
                }
            }
        }
        if (x > sourceRight) {
            return (isLeft ? x - sourceRight : sourceRight - x) / Math.abs(sourceRight - targetRight);
        }
        return (isLeft ? x - sourceLeft : sourceLeft - x) / (Math.abs(sourceLeft - targetLeft));
    },
    calculateSplitLocation: function (sourceAtLeftOrTop, splitDistance, x, width) {
        if (sourceAtLeftOrTop === (splitDistance > 0)) {
            return x + width + Math.abs(splitDistance);
        } else {
            return x - Math.abs(splitDistance);
        }
    },
    calculateAngle: function (dx, dy) {
        if (dx !== 0 && dy !== 0) {
            return Math.atan2(dx, dy);
        }
        if (dx === 0) {
            if (dy > 0) {
                return 0;
            }
            if (dy < 0) {
                return Math.PI;
            }
        }
        if (dx > 0) {
            return Math.PI / 2;
        }
        return -Math.PI / 2;
    },
    drawCorner: function (points, link) {
        var pointCount = points.size();
        if (pointCount < 3) {
            return;
        }
        var cornerType = link.getStyle('link.corner');
        if (cornerType === 'none') {
            return;
        }
        var cornerRadiusX = link.getStyle('link.xradius');
        var cornerRadiusY = link.getStyle('link.yradius');

        var _cornerX, _cornerY;
        var previousPoint = points.get(0);
        var currentPoint = points.get(1);
        var fromPoint, toPoint;

        for (var index = 2; index < pointCount; index++) {
            var nextPoint = points.get(index);
            var dx1 = currentPoint.x - previousPoint.x;
            var dy1 = currentPoint.y - previousPoint.y;
            var dx2 = nextPoint.x - currentPoint.x;
            var dy2 = nextPoint.y - currentPoint.y;

            var isH1 = dy1 === 0;
            if ((dx1 === 0 && dy2 === 0) || (dy1 === 0 && dx2 === 0)) {
                if (isH1) {
                    _cornerX = Math.min(index === 2 ? Math.abs(dx1) : Math.abs(dx1) / 2, cornerRadiusX);
                    _cornerY = Math.min(index === pointCount - 1 ? Math.abs(dy2) : Math.abs(dy2) / 2, cornerRadiusY);
                    fromPoint = { x: currentPoint.x - (dx1 > 0 ? _cornerX : -_cornerX), y: currentPoint.y };
                    toPoint = { x: currentPoint.x, y: currentPoint.y + (dy2 > 0 ? _cornerY : -_cornerY) };
                } else {
                    _cornerX = Math.min(index === pointCount - 1 ? Math.abs(dx2) : Math.abs(dx2) / 2, cornerRadiusX);
                    _cornerY = Math.min(index === 2 ? Math.abs(dy1) : Math.abs(dy1) / 2, cornerRadiusY);
                    fromPoint = { x: currentPoint.x, y: currentPoint.y - (dy1 > 0 ? _cornerY : -_cornerY) };
                    toPoint = { x: currentPoint.x + (dx2 > 0 ? _cornerX : -_cornerX), y: currentPoint.y }
                }
                points.remove(currentPoint);
                index--;
                pointCount--;
                if (fromPoint.x !== previousPoint.x || fromPoint.y !== previousPoint.y) {
                    points.add(fromPoint, index);
                    index++;
                    pointCount++;
                }
                if (cornerType === 'bevel') {
                    points.add(toPoint, index);
                    index++;
                    pointCount++;
                } else if (cornerType === 'round') {
                    var newPoints = new $List();
                    newPoints.add(currentPoint);
                    newPoints.add(toPoint);
                    points.add(newPoints, index);
                    index++;
                    pointCount++;
                }
            }
            previousPoint = currentPoint;
            currentPoint = nextPoint;
        }
        if (toPoint && toPoint.x === currentPoint.x && toPoint.y === currentPoint.y) {
            points.remove(currentPoint);
        }
    },
    orthogonal: function (linkType, source, target, result, isHorizontal, link) {
        ///control point
        var controlPoint = link.getStyle('link.control.point');
        var centerPriority = controlPoint == null;

        if (controlPoint) {
            var linkBounds = $math.unionRect(source, target);
            if (!$math.containsPoint(linkBounds, controlPoint)) {
                isHorizontal = $link.calculateIsHorizontalByControlPoint(controlPoint.x, controlPoint.y, linkBounds.y, linkBounds.x, linkBounds.y + linkBounds.height, linkBounds.x + linkBounds.width);
            }
        } else {
            controlPoint = $link.calculateControlPoint(linkType, isHorizontal, source, target, link);
        }

        if (isHorizontal) {
            $link.sideToSide(source, target, controlPoint, result, centerPriority);
        } else {
            $link.topToBottom(source, target, controlPoint, result, centerPriority);
        }
    },
    calculateIsHorizontalByControlPoint: function (x, y, top, left, bottom, right) {
        if ((y < top && top - y > left - x && top - y > x - right) || (y > bottom && y - bottom > left - x && y - bottom > x - right)) {
            return false;
        }
        return true;
    },
    contains: function (rect, x, y) {
        return (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height);
    },
    topToBottom: function (source, target, controlPoint, result, centerPriority) {
        var t = Math.max(source.y, target.y);
        var b = Math.min(source.y + source.height, target.y + target.height);
        var y = controlPoint ? controlPoint.y : b + (t - b) / 2;
        var x1 = source.x + source.width / 2;
        var x2 = target.x + target.width / 2;
        if (!centerPriority && controlPoint) {
            if (controlPoint.x >= source.x && controlPoint.x <= source.x + source.width) {
                x1 = controlPoint.x;
            }
            if (controlPoint.x >= target.x && controlPoint.x <= target.x + target.width) {
                x2 = controlPoint.x;
            }
        }
        if (!$link.contains(target, x1, y) && !$link.contains(source, x1, y)) {
            result.add({ x: x1, y: y });
        }
        if (!$link.contains(target, x2, y) && !$link.contains(source, x2, y)) {
            result.add({ x: x2, y: y });
        }
        if (result.size() === 0) {
            if (controlPoint) {
                if (!$link.contains(target, controlPoint.x, y) && !$link.contains(source, controlPoint.x, y)) {
                    result.add({ x: controlPoint.x, y: y });
                }
            } else {
                var l = Math.max(source.x, target.x);
                var r = Math.min(source.x + source.width, target.x + target.width);
                result.add({ x: l + (r - l) / 2, y: y });
            }
        }
    },
    sideToSide: function (source, target, controlPoint, result, centerPriority) {
        var l = Math.max(source.x, target.x);
        var r = Math.min(source.x + source.width, target.x + target.width);
        var x = controlPoint ? controlPoint.x : r + (l - r) / 2;
        var y1 = source.y + source.height / 2;
        var y2 = target.y + target.height / 2;
        if (!centerPriority && controlPoint) {
            if (controlPoint.y >= source.y && controlPoint.y <= source.y + source.height) {
                y1 = controlPoint.y;
            }
            if (controlPoint.y >= target.y && controlPoint.y <= target.y + target.height) {
                y2 = controlPoint.y;
            }
        }
        if (!$link.contains(target, x, y1) && !$link.contains(source, x, y1)) {
            result.add({ x: x, y: y1 });
        }
        if (!$link.contains(target, x, y2) && !$link.contains(source, x, y2)) {
            result.add({ x: x, y: y2 });
        }
        if (result.size() === 0) {
            if (controlPoint) {
                if (!$link.contains(target, x, controlPoint.y) && !$link.contains(source, x, controlPoint.y)) {
                    result.add({ x: x, y: controlPoint.y });
                }
            } else {
                var t = Math.max(source.y, target.y);
                var b = Math.min(source.y + source.height, target.y + target.height);
                result.add({ x: x, y: t + (b - t) / 2 });
            }
        }
    },
    flexionalHorizontal: function (source, target, result, segment) {
        var isSourceLeft = target.x + target.width < source.x;
        var isTargetLeft = source.x + source.width < target.x;

        var x0 = (isSourceLeft) ? source.x : source.x + source.width;
        var y0 = source.y + source.height / 2;
        var xe = (isTargetLeft) ? target.x : target.x + target.width;
        var ye = target.y + target.height / 2;
        var seg = segment;

        var dx = (isSourceLeft) ? -seg : seg;
        var dep = { x: x0 + dx, y: y0 };
        dx = (isTargetLeft) ? -seg : seg;
        var arr = { x: xe + dx, y: ye };
        if (isSourceLeft === isTargetLeft) {
            var x = (isSourceLeft) ? Math.min(x0, xe) - segment : Math.max(x0, xe) + segment;
            result.add({ x: x, y: y0 });
            result.add({ x: x, y: ye });
        } else if ((dep.x < arr.x) === isSourceLeft) {
            var midY = y0 + (ye - y0) / 2;
            result.add(dep);
            result.add({ x: dep.x, y: midY });
            result.add({ x: arr.x, y: midY });
            result.add(arr);
        } else {
            result.add(dep);
            result.add(arr);
        }
    },
    flexionalVertical: function (source, target, result, segment) {
        var isSourceTop = target.y + target.height < source.y;
        var isTargetTop = source.y + source.height < target.y;

        var x0 = source.x + source.width / 2;
        var y0 = (isSourceTop) ? source.y : source.y + source.height;
        var xe = target.x + target.width / 2;
        var ye = (isTargetTop) ? target.y : target.y + target.height;
        var seg = segment;

        var dy = (isSourceTop) ? -seg : seg;
        var dep = { x: x0, y: y0 + dy };
        dy = (isTargetTop) ? -seg : seg;
        var arr = { x: xe, y: ye + dy };
        if (isSourceTop === isTargetTop) {
            var y = (isSourceTop) ? Math.min(y0, ye) - segment : Math.max(y0, ye) + segment;
            result.add({ x: x0, y: y });
            result.add({ x: xe, y: y });
        } else if ((dep.y < arr.y) === isSourceTop) {
            var midX = x0 + (xe - x0) / 2;
            result.add(dep);
            result.add({ x: midX, y: dep.y });
            result.add({ x: midX, y: arr.y });
            result.add(arr);
        } else {
            result.add(dep);
            result.add(arr);
        }
    },
    rectanglePerimeter: function (bounds, isSource, next) {
        var cx = bounds.x + bounds.width / 2;
        var cy = bounds.y + bounds.height / 2;
        var dx = next.x - cx;
        var dy = next.y - cy;
        var alpha = Math.atan2(dy, dx);
        var p = { x: 0, y: 0 };
        var pi = Math.PI;
        var pi2 = Math.PI / 2;
        var beta = pi2 - alpha;
        var t = Math.atan2(bounds.height, bounds.width);
        if (alpha < -pi + t || alpha > pi - t) {
            p.x = bounds.x;
            p.y = cy - bounds.width * Math.tan(alpha) / 2;
        } else if (alpha < -t) {
            p.y = bounds.y;
            p.x = cx - bounds.height * Math.tan(beta) / 2;
        } else if (alpha < t) {
            p.x = bounds.x + bounds.width;
            p.y = cy + bounds.width * Math.tan(alpha) / 2;
        } else {
            p.y = bounds.y + bounds.height;
            p.x = cx + bounds.height * Math.tan(beta) / 2;
        }
        if (next.x >= bounds.x && next.x <= bounds.x + bounds.width) {
            p.x = next.x;
        } else if (next.y >= bounds.y && next.y <= bounds.y + bounds.height) {
            p.y = next.y;
        }
        if (next.x < bounds.x) {
            p.x = bounds.x;
        } else if (next.x > bounds.x + bounds.width) {
            p.x = bounds.x + bounds.width;
        }
        if (next.y < bounds.y) {
            p.y = bounds.y;
        } else if (next.y > bounds.y + bounds.height) {
            p.y = bounds.y + bounds.height;
        }
        return p;
    },
    isSplitTypeLink: function (type) {
        return type && (type === 'orthogonal' ||
				type === 'orthogonal.horizontal' ||
				type === 'orthogonal.vertical');
    },
    isOrthogonalOrFlexionalLink: function (link) {
        if (link instanceof twaver.ShapeLink) {
            return false;
        }
        if (link.isLooped()) {
            return false;
        }
        var type = link.getStyle('link.type');
        return $link.isOrthogonalOrFlexionalType(type);
    },
    isOrthogonalLink: function (link) {
        if (link instanceof twaver.ShapeLink) {
            return false;
        }
        if (link.isLooped()) {
            return false;
        }
        var type = link.getStyle('link.type');
        return $link.isOrthogonalType(type);
    },
    isOrthogonalOrFlexionalType: function (type) {
        return type === 'orthogonal' ||
				type === 'orthogonal.horizontal' ||
				type === 'orthogonal.H.V' ||
				type === 'orthogonal.vertical' ||
				type === 'orthogonal.V.H' ||
				type === 'extend.top' ||
				type === 'extend.left' ||
				type === 'extend.bottom' ||
				type === 'extend.right' ||
				type === 'flexional' ||
				type === 'flexional.horizontal' ||
				type === 'flexional.vertical';
    },
    isOrthogonalType: function (type) {
        return type === 'orthogonal' ||
				type === 'orthogonal.horizontal' ||
				type === 'orthogonal.H.V' ||
				type === 'orthogonal.vertical' ||
				type === 'orthogonal.V.H' ||
				type === 'extend.top' ||
				type === 'extend.left' ||
				type === 'extend.bottom' ||
				type === 'extend.right';
    },
    hasControlPoint: function (linkType) {
        return linkType === 'orthogonal' ||
				linkType === 'orthogonal.horizontal' ||
				linkType === 'orthogonal.vertical' ||
				linkType === 'extend.bottom' ||
				linkType === 'extend.left' ||
				linkType === 'extend.right' ||
				linkType === 'extend.top';
    },
    getControlPoint: function (link, linkUI,zoomManager) {
        if (!link) {
            throw "link can't be null";
        }
        var linkType = link.getStyle('link.type');
        if (!$link.hasControlPoint(linkType)) {
            return null;
        }
        var controlPoint = link.getStyle('link.control.point');
        if (controlPoint) {
            return controlPoint;
        } else {
            var sourceBounds, targetBounds;
            if (linkUI == null) {
                sourceBounds = link.getFromAgent().getRect();
                targetBounds = link.getToAgent().getRect();
            } else {
                sourceBounds = $link.getLinkSourceBounds(linkUI,zoomManager);
                targetBounds = $link.getLinkTargetBounds(linkUI,zoomManager);
            }
            if (sourceBounds == null || targetBounds == null) {
                return null;
            }
            var horizontal = $link.isHorizontal(linkType, sourceBounds, targetBounds, link);
            return $link.calculateControlPoint(link.getStyle('link.type'), horizontal, sourceBounds, targetBounds, link);
        }
    },
    getSplitValueByControlPoint: function (point, linkType, sourceBounds, targetBounds, isHorizontal) {
        if (linkType === 'extend.top') {
            return Math.min(sourceBounds.y, targetBounds.y) - point.y;
        }
        if (linkType === 'extend.left') {
            return Math.min(sourceBounds.x, targetBounds.x) - point.x;
        }
        if (linkType === 'extend.bottom') {
            return point.y - Math.max(sourceBounds.y + sourceBounds.height, targetBounds.y + targetBounds.height);
        }
        if (linkType === 'extend.right') {
            return point.x - Math.max(sourceBounds.x + sourceBounds.width, targetBounds.x + targetBounds.width);
        }
        var splitValue;
        if (isHorizontal) {
            var isLeft = (sourceBounds.x + sourceBounds.x + sourceBounds.width) < (targetBounds.x + targetBounds.x + targetBounds.width);
            splitValue = isLeft ? point.x - sourceBounds.x + sourceBounds.width : sourceBounds.x - point.x;
            if (splitValue > 0) {
                return splitValue;
            }
            if (splitValue > -sourceBounds.width) {
                return 0;
            }
            return splitValue + sourceBounds.width;
        }
        var isTop = (sourceBounds.y + sourceBounds.y + sourceBounds.height) < (targetBounds.y + targetBounds.y + targetBounds.height);
        splitValue = isTop ? point.y - sourceBounds.y - sourceBounds.height : sourceBounds.y - point.y;
        if (splitValue > 0) {
            return splitValue;
        }
        if (splitValue > -sourceBounds.height) {
            return 0;
        }
        return splitValue + sourceBounds.height;
    },
    isHorizontalByControlPoint: function (controlPoint, linkType, sourceBounds, targetBounds, link) {
        var linkBounds = $math.unionRect(sourceBounds, targetBounds);
        if (!$math.containsPoint(linkBounds, controlPoint)) {
            return $link.calculateIsHorizontalByControlPoint(controlPoint.x, controlPoint.y, linkBounds.y, linkBounds.x, linkBounds.y + linkBounds.height, linkBounds.x + linkBounds.width);
        }
        return $link.isHorizontal(linkType, sourceBounds, targetBounds, link);
    },
    setParamsByControlPoint: function (point, sourceBounds, targetBounds, linkType, link) {
        var isHorizontal = $link.isHorizontalByControlPoint(point, linkType, sourceBounds, targetBounds, link);
        var controlPoint = link.getStyle('link.control.point');
        if (controlPoint || linkType === 'orthogonal' ||
				linkType === 'orthogonal.horizontal' ||
				linkType === 'orthogonal.vertical') {
            link.setStyle('link.type', isHorizontal ? 'orthogonal.horizontal' : 'orthogonal.vertical');
        }
        if (controlPoint) {
            link.setStyle('link.control.point', point);
            return;
        }

        var splitValue = $link.getSplitValueByControlPoint(point, linkType, sourceBounds, targetBounds, isHorizontal);
        if ($link.isExtendTypeLink(linkType)) {
            link.setStyle('link.extend', splitValue);
            return;
        }
        var splitByPercent = $link.isSplitByPercent(linkType, link);
        if (!splitByPercent) {
            link.setStyle('link.split.value', splitValue);
            return;
        }
        if (splitValue === 0) {
            link.setStyle('link.split.percent', 0);
            return;
        }
        link.setStyle('link.split.percent', $link.calculateSplitPercentByControlPoint(point, isHorizontal, sourceBounds, targetBounds));
    },
    getLinkNodeBounds: function (elementUI, xOffset, yOffset, atEdge, positionType ,zoomManager) {
        if(zoomManager){
            var locationZoom = zoomManager.getLocationZoom();
            var sizeZoom = zoomManager.getSizeZoom(elementUI);
        }
        if (elementUI == null) {
            return null;
        }
        var bounds;
        if (!atEdge) {
            var position = elementUI.getNetwork().getPosition(positionType, elementUI, null, xOffset, yOffset);
            if(zoomManager){
                bounds = { x: position.x * locationZoom, y: position.y * locationZoom, width: 1, height: 1 };
            }else{
                bounds = { x: position.x, y: position.y, width: 1, height: 1 };
            }
        } else {
            if(zoomManager){
                bounds = elementUI.getZoomBodyRect();
                bounds.x += xOffset;
                bounds.y += yOffset;
            }else {
                bounds = elementUI.getBodyRect();
                bounds.x += xOffset;
                bounds.y += yOffset;
            }
        }
        return bounds;
    },
    getLinkSourceBounds: function (ui ,zoomManager) {
        var link = ui._element;
        var source = ui.getNetwork().getElementUI(link.getFromAgent());
        if (source == null) {
            return null;
        }
        var fromPosition = link.getStyle('link.from.position');
        var fromXoffset = link.getStyle('link.from.xoffset');
        var fromYoffset = link.getStyle('link.from.yoffset');
        var isFromLinkAtEdge = link.getStyle('link.from.at.edge');
        return $link.getLinkNodeBounds(source, fromXoffset, fromYoffset, isFromLinkAtEdge, fromPosition ,zoomManager);
    },
    getLinkTargetBounds: function (ui ,zoomManager) {
        var link = ui._element;
        var target = ui.getNetwork().getElementUI(link.getToAgent());
        if (target == null) {
            return null;
        }
        var toPosition = link.getStyle('link.to.position');
        var toXoffset = link.getStyle('link.to.xoffset');
        var toYoffset = link.getStyle('link.to.yoffset');
        var isToLinkAtEdge = link.getStyle('link.to.at.edge');
        return $link.getLinkNodeBounds(target, toXoffset, toYoffset, isToLinkAtEdge, toPosition ,zoomManager);
    },
    orthogonalAndFlexional: function (ui, linkType,zoomManager) {
        ///offset
        var sourceBounds = $link.getLinkSourceBounds(ui,zoomManager);
        if (sourceBounds == null) {
            return null;
        }
        var targetBounds = $link.getLinkTargetBounds(ui,zoomManager);
        if (targetBounds == null) {
            return null;
        }
        var points = $link.calculateOrthogonalAndFlexionalLinkPoints(linkType, sourceBounds, targetBounds, ui._element);

        ///link offset
        $link.offsetLink(ui, points);

        ///hot point
        ui.setHotSpot($link.calculateCenterPoint(points));

        ///draw corner
        if (linkType !== 'flexional') {
            $link.drawCorner(points, ui._element);
        }
        return points;
    },
    offsetLink: function (ui, points) {
        //when more than one links,need  bundle up or expand
        var link = ui._element;
        var isAgent = link.isBundleAgent();
        if (isAgent) {
            return;
        }
        var bundleOffset = $link.getBundleGap(ui, false);
        if (bundleOffset === 0) {
            return;
        }

        //my gad
        var oldAngle, currentAngle;
        var xAgainstDirection = false, yAgainstDirection = false;
        var previousPoint = points.get(0);
        var originalityPreviousPoint = _twaver.clone(previousPoint);

        for (var index = 1, count = points.size(); index < count; index++) {
            var point = points.get(index);
            var dx = point.x - originalityPreviousPoint.x;
            var dy = point.y - originalityPreviousPoint.y;
            originalityPreviousPoint = _twaver.clone(point);
            currentAngle = $link.calculateAngle(dx, dy);

            if (dx === 0) {
                if ((currentAngle - oldAngle) % Math.PI === 0 && (currentAngle - oldAngle) % (2 * Math.PI) !== 0) {
                    xAgainstDirection = !xAgainstDirection;
                    if (xAgainstDirection) {
                        dy = -dy;
                    }
                }
                if ((currentAngle - oldAngle) % Math.PI !== 0) {
                    previousPoint.x += dy < 0 ? bundleOffset : -bundleOffset;
                }
                point.x += dy < 0 ? bundleOffset : -bundleOffset;
            } else if (dy === 0) {
                if ((currentAngle - oldAngle) % Math.PI === 0 && (currentAngle - oldAngle) % (2 * Math.PI) !== 0) {
                    yAgainstDirection = !yAgainstDirection;
                    if (yAgainstDirection) {
                        dx = -dx;
                    }
                }
                if (!oldAngle || (currentAngle - oldAngle) % Math.PI !== 0) {
                    previousPoint.y -= dx < 0 ? bundleOffset : -bundleOffset;
                }
                point.y -= dx < 0 ? bundleOffset : -bundleOffset;
            }
            oldAngle = currentAngle;
            previousPoint = point;
        }
    },
    _getPointAngleDegree: function (x1, y1, x2, y2) {
        var xOffset = x2 - x1;
        var yOffset = y2 - y1;
        var angle = Math.atan2(yOffset, xOffset);
        angle = angle / Math.PI * 180;
        angle = parseInt(angle) + 180;
        angle = angle % 360;

        return angle;
    }
};
_twaver.link = $link;

var $box = {
    findMoveToBottomDatas: function (sm, datas, children) {
        for (var i = 0; i < children.size(); i++) {
            var data = children.get(i);
            if (sm.contains(data)) {
                datas.add(data);
            }
        }
        for (i = 0; i < children.size(); i++) {
            data = children.get(i);
            $box.findMoveToBottomDatas(sm, datas, data.getChildren());
        }
    },
    findMoveToTopDatas: function (sm, datas, children) {
        for (var i = 0; i < children.size(); i++) {
            var data = children.get(children.size() - 1 - i);
            if (sm.contains(data)) {
                datas.add(data);
            }
        }
        for (i = 0; i < children.size(); i++) {
            data = children.get(i);
            $box.findMoveToTopDatas(sm, datas, data.getChildren());
        }
    },
    findMoveUpDatas: function (sm, datas, children) {
        var startToIterate = false;
        for (var i = 0; i < children.size(); i++) {
            var data = children.get(i);
            if (sm.contains(data)) {
                if (startToIterate) {
                    datas.add(data);
                }
            } else {
                startToIterate = true;
            }
        }
        for (i = 0; i < children.size(); i++) {
            data = children.get(i);
            $box.findMoveUpDatas(sm, datas, data.getChildren());
        }
    },
    findMoveDownDatas: function (sm, datas, children) {
        var startToIterate = false;
        for (var i = 0; i < children.size(); i++) {
            var data = children.get(children.size() - 1 - i);
            if (sm.contains(data)) {
                if (startToIterate) {
                    datas.add(data);
                }
            } else {
                startToIterate = true;
            }
        }
        for (i = 0; i < children.size(); i++) {
            data = children.get(i);
            $box.findMoveDownDatas(sm, datas, data.getChildren());
        }
    },
    doLayout: function (network, options) {
        options = options || {};
        options.type = options.type || 'round';
        options.animate = options.animate || true;
        options.elements = options.elements || new twaver.List();
        options.repulsion = options.repulsion || 1;
        options.expandGroup = options.expandGroup || false;
        //options.explicitXOffset = options.explicitXOffset || 'round';
        //options.explicitYOffset = options.explicitYOffset || 'round';
        var autoLayouter = new twaver.layout.AutoLayouter(network.getElementBox());
        autoLayouter.getElements = function () {
            
        };
    }
};
_twaver.box = $box;

var $touch = {
    scrollLeft: function () {
        return $touch._filterResults(
		    window.pageXOffset ? window.pageXOffset : 0,
		    document.documentElement ? document.documentElement.scrollLeft : 0,
		    document.body ? document.body.scrollLeft : 0
	    );
    },
    scrollTop: function () {
        return $touch._filterResults(
		    window.pageYOffset ? window.pageYOffset : 0,
		    document.documentElement ? document.documentElement.scrollTop : 0,
		    document.body ? document.body.scrollTop : 0
	    );
    },
    _filterResults: function (n_win, n_docel, n_body) {
        var n_result = n_win ? n_win : 0;
        if (n_docel && (!n_result || (n_result > n_docel)))
            n_result = n_docel;
        return n_body && (!n_result || (n_result > n_body)) ? n_body : n_result;
    },
    isSingleTouch: function (e) {
        return e.touches && e.touches.length == 1;
    },
    isMultiTouch: function (e) {
        return e.touches && e.touches.length > 1;
    },
    getDistance: function (e) {
        if (!$touch.isMultiTouch(e)) {
            return 0;
        }
        var t0 = e.touches[0];
        var t1 = e.touches[1];
        return Math.sqrt(
            Math.pow(t0.clientX - t1.clientX, 2) +
            Math.pow(t0.clientY - t1.clientY, 2)
        );
    },
    getCenterLocation: function(e){
        if (!$touch.isMultiTouch(e)) {
            return 0;
        }
        var t0 = e.touches[0];
        var t1 = e.touches[1];
        return {x:(t0.clientX + t1.clientX)/2, y:(t0.clientY + t1.clientY)/2};
    }
};
_twaver.touch = $touch;

var $render = {
    _string: function (value, div, view, innerText) {
        var text = view._stringPool.get();
        text.style.whiteSpace = 'nowrap';
        text.style.verticalAlign = 'middle';
        text.style.padding = '0px 2px';
        _twaver.setText(text, value, innerText);
        text.setAttribute('title', value);
        div.appendChild(text);
    },
    _boolean: function (value, div, view) {
        var checkBox = view._booleanPool.get();
        if (div._editInfo) {
            checkBox._editInfo = div._editInfo;
            delete div._editInfo;
            checkBox.disabled = false;
        } else {
            checkBox.disabled = true;
        }
        checkBox.keepDefault = true;
        checkBox.type = 'checkbox';
        checkBox.style.margin = '0px 2px';
        checkBox.style.verticalAlign = 'middle';
        checkBox.checked = value;
        div.appendChild(checkBox);
        if (div.style.textAlign === '') {
            div.style.textAlign = 'center';
        }
    },
    _color: function (value, div, view) {
        var color = view._colorPool.get();
        color.style.width = '100%';
        color.style.height = '100%';
        color.style.backgroundColor = value;
        color.setAttribute('title', value);
        div.appendChild(color);
    },
    _listPoints: function (value, div, view, innerText) {
        var text = view._stringPool.get();
        text.style.whiteSpace = 'nowrap';
        text.style.verticalAlign = 'middle';
        text.style.padding = '0px 2px';
        var array = value._as || value;
        var result = '';
        array.forEach(function(a,index){
            result += index == (array.length -1)? '[' + a.x + ',' + a.y + ']' : '[' + a.x + ',' + a.y + '],';
        });
        value = result;
        _twaver.setText(text, value, innerText);
        text.setAttribute('title', value);
        div.appendChild(text);
    },
    render: function (type, value, div, view, innerText) {
        if (value == null) {
            return;
        }
        var func = $render['_' + type];
        if (func) {
            func(value, div, view, innerText);
        } else {
            if (typeof value === 'boolean') {
                $render._boolean(value, div, view, innerText);
            }else if(value instanceof twaver.List) {
                $render._listPoints(value, div, view, innerText);
            }else {
                $render._string(value, div, view, innerText);
            }
        }
    }
};
_twaver.render = $render;

var $popup = {

    toolTipDiv: null,

    getToolTipDiv: function () {
        if (!$popup.toolTipDiv) {
            $popup.toolTipDiv = document.createElement('div');

            // init default style
            var D = $Defaults;
            var style = $popup.toolTipDiv.style;
            style.position = 'absolute';
            style.color = D.TOOLTIP_COLOR;
            style.background = D.TOOLTIP_BACKGROUND;
            style.fontSize = D.TOOLTIP_FONT_SIZE;
            style.padding = D.TOOLTIP_PADDING;
            style.border = D.TOOLTIP_BORDER;
            style.borderRadius = D.TOOLTIP_BORDER_RADIUS;
            style.boxShadow = D.TOOLTIP_BOX_SHADOW;
            style.zIndex = D.TOOLTIP_ZINDEX;
            if (style.setProperty) {
                style.setProperty('-webkit-box-shadow', D.TOOLTIP_BOX_SHADOW, null);
            }
        }
        return $popup.toolTipDiv;
    },

    isToolTipVisible: function () {
        return $popup.getToolTipDiv().parentNode ? true : false;
    },

    hideToolTip: function () {
        $popup._clearTimeout();
        $popup._clearDismiss();
        if (!$popup.isToolTipVisible()) {
            return;
        }
        var div = $popup.getToolTipDiv();
        if (div.parentNode) {
            div.parentNode.removeChild(div);
        }
    },

    showToolTip: function (eventOrPoint, innerHTML,callback) {
        if (!eventOrPoint || !innerHTML) {
            $popup.hideToolTip();
            return;
        }

        if ($popup.isToolTipVisible() || $popup._reshow_timeout) {
            $popup._showToolTip(eventOrPoint, innerHTML,callback);
        } else {
            $popup._clearTimeout();
            // $popup._show_timeout = setTimeout($popup._showToolTip, $Defaults.TOOLTIP_INITIAL_DELAY,eventOrPoint, innerHTML);
            $popup._show_timeout = setTimeout(function(){
                $popup._showToolTip(eventOrPoint, innerHTML,callback);
            }, $Defaults.TOOLTIP_INITIAL_DELAY);
        }
    },
    _showToolTip: function (eventOrPoint, innerHTML,callback) {
        var x, y, div;

        if (eventOrPoint.target) {
            x = eventOrPoint.clientX;
            y = eventOrPoint.clientY;
        } else {
            x = eventOrPoint.x;
            y = eventOrPoint.y;
        }
        div = $popup.getToolTipDiv();
        $html.clear(div);
        if (innerHTML instanceof Element) {
            var innerHTMLClone = innerHTML.cloneNode(true);
            div.appendChild(innerHTMLClone);
            // div.appendChild(innerHTML);
        } else {
            div.innerHTML = innerHTML;
        }
        div.style.left = x + $Defaults.TOOLTIP_XOFFSET + 'px';
        div.style.top = y + $Defaults.TOOLTIP_YOFFSET + 'px';
        if (!div.parentNode) {
            document.body.appendChild(div);
        }

        callback && callback(div);
        $popup._clearDismiss();
        $popup._dismiss_timeout = setTimeout($popup.hideToolTip, $Defaults.TOOLTIP_DISMISS_DELAY);
        $popup._clearReshow();
        $popup._reshow_timeout = setTimeout($popup._clearReshow, $Defaults.TOOLTIP_RESHOW_DELAY);
    },
    _clearDismiss: function () {
        if ($popup._dismiss_timeout) {
            clearTimeout($popup._dismiss_timeout);
            $popup._dismiss_timeout = null;
        }
    },
    _clearReshow: function () {
        if ($popup._reshow_timeout) {
            clearTimeout($popup._reshow_timeout);
            $popup._reshow_timeout = null;
        }
    },
    _clearTimeout: function () {
        if ($popup._show_timeout) {
            clearTimeout($popup._show_timeout);
            $popup._show_timeout = null;
        }
    },
    resetToolTip: function () {
        $popup.hideToolTip();
        $popup.toolTipDiv = null;
    }
};
_twaver.popup = $popup;

var $network_interaction = {
        handleClicked: function (network, e, element) {
            if (network.isSelectingElement()) return;
            if (!$ua.isTouchable && e.button !== 0) {
                return;
            }
            if (element) {
                var image = _getElementImage(element);
                image && image.onClick && image.onClick(element, network);
                network.onClickElement(element, e);
                network.fireInteractionEvent({
                    kind: 'clickElement',
                    event: e,
                    element: element
                });
            } else {
                network.onClickBackground(e);
                network.fireInteractionEvent({
                    kind: 'clickBackground',
                    event: e
                });
            }
        },
        handleDoubleClicked: function (network, e, element) {
            if (!$ua.isTouchable && e.button !== 0) {
                return;
            }
            if (network.isEditingElement()) {
                return;
            }
            if (element) {
                var image = _getElementImage(element);
                image && image.onDoubleClick && image.onDoubleClick(element, network);
                network.onDoubleClickElement(element, e);
                network.fireInteractionEvent({
                    kind: 'doubleClickElement',
                    event: e,
                    element: element
                });
            } else {
                network.onDoubleClickBackground(e);
                network.fireInteractionEvent({
                    kind: 'doubleClickBackground',
                    event: e
                });
            }
            if (element) {
                if (element instanceof twaver.Link && network.isDoubleClickToLinkBundle()) {
                    if (element.ISubNetwork && network.isDoubleClickToSubNetwork() && !_twaver.isCtrlDown(e)) {
                        if (network.isDoubleClickToEmptySubNetwork() || element.getChildrenSize() > 0) {
                            network.setCurrentSubNetwork(element, network.isSubNetworkAnimate(), function () {
                                network.fireInteractionEvent({
                                    kind: 'enterSubNetwork',
                                    event: e,
                                    element: element
                                });
                            });
                        }
                    } else {
                        if (element.reverseBundleExpanded()) {
                            network.fireInteractionEvent({
                                kind: 'bundleLink',
                                event: e,
                                element: element
                            });
                        }
                    }
                } else if (element.ISubNetwork && network.isDoubleClickToSubNetwork()) {
                    if (network.isDoubleClickToEmptySubNetwork() || element.getChildrenSize() > 0) {
                        network.setCurrentSubNetwork(element, network.isSubNetworkAnimate(), function () {
                            network.fireInteractionEvent({
                                kind: 'enterSubNetwork',
                                event: e,
                                element: element
                            });
                        });
                    }
                } else if (element instanceof $Group && network.isDoubleClickToGroupExpand()) {
                    element.reverseExpanded();
                    network.fireInteractionEvent({
                        kind: 'expandGroup',
                        event: e,
                        element: element
                    });
                }
            } else {
                if (network.isDoubleClickToUpSubNetwork()) {
                    network.upSubNetwork(network.isSubNetworkAnimate(), function () {
                        network.fireInteractionEvent({
                            kind: 'upSubNetwork',
                            event: e
                        });
                    });
                }
            }
        },
        handleKeyDown: function (network, e) {
            if (_twaver.isCtrlDown(e) && e.keyCode == 65) {
                if (network.isKeyboardSelectEnabled() && network.selectAll().size() > 0) {
                    network.fireInteractionEvent({
                        kind: 'selectAll'
                    });
                }
                $html.preventDefault(e);
            } else if (e.keyCode == 46) {
                if (network.isKeyboardRemoveEnabled() && network.removeSelection()) {
                    network.fireInteractionEvent({
                        kind: 'removeElement'
                    });
                }
                $html.preventDefault(e);
            } else {
                _twaver.showVersion(e);
            }
        },
        handleLongClicked: function (network, e, element) {
            if (!$ua.isTouchable && e.button !== 0) {
                return;
            }

            if (element) {
                var image = _getElementImage(element);
                image && image.onLongClick && image.onLongClick(element, network);
                network.onLongClickElement(element, e);
                network.fireInteractionEvent({
                    kind: 'longClickElement',
                    event: e,
                    element: element
                });
            } else {
                network.onLongClickBackground(e);
                network.fireInteractionEvent({
                    kind: 'longClickBackground',
                    event: e
                });
            }
        }
    },
    _getElementImage = function (element) {
        if (element && element._image) {
            if (typeof element._image !== 'object') {
                var image = _twaver.getImageAsset(element._image);
                if (image) {
                    return image._image;
                }
            } else {
                return element._image;
            }
        }
        return null;
    };
_twaver.interaction = $network_interaction;
var parsePathOrPoints = function (d) {
  if (d.trim()[0].match(/[mlhvcsqta]/i)) {
    return parsePath(d);
  } else {
    return parsePoints(d);
  }
};

var pointsCache = {};

var parsePoints = function (points) {
  var result = pointsCache[points];
  if (result) {
    return result;
  }
  pointsCache[points] = result = [];
  points.trim().split(' ').forEach(function (point) {
    point = point.split(',');
    if (point.length === 2) {
      result.push({
        x: parseFloat(point[0]),
        y: parseFloat(point[1])
      });
    } else {
      result.push(point[0]);
    }
  });
  return result;
};

var pathCache = {};
var pattern_path = /[mlhvcsqtaz][\d.,\-\s]*/gi;
var pattern_path_points = /-?(\d)+(\.(\d)+)?/g;

var parsePath = function (d) {
  var result = pathCache[d],
    match;
  if (result) {
    return result;
  }
  match = d.trim().match(pattern_path);
  pathCache[d] = result = [];
  if (match) {
    match.forEach(function (seg) {
      var c = seg[0],
        points = seg.match(pattern_path_points),
        length = points && points.length,
        i;
      result.push(seg = {
        c: c
      });
      if (length) {
        points.forEach(function (point, index) {
          points[index] = parseFloat(point);
        });
        switch (c) {
          case 'M':
          case 'm':
          case 'L':
          case 'l':
            for (i = 0; i < length; i += 2) {
              if (i !== 0) {
                result.push(seg = {
                  c: (c === 'M' || c === 'L') ? 'L' : 'l'
                });
              }
              seg.x = points[i];
              seg.y = points[i + 1];
            }
            break;
          case 'H':
          case 'h':
            for (i = 0; i < length; i ++) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.x = points[i];
            }
            break;
          case 'V':
          case 'v':
            for (i = 0; i < length; i ++) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.y = points[i];
            }
            break;
          case 'C':
          case 'c':
            for (i = 0; i < length; i += 6) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.x1 = points[i];
              seg.y1 = points[i + 1];
              seg.x2 = points[i + 2];
              seg.y2 = points[i + 3];
              seg.x = points[i + 4];
              seg.y = points[i + 5];
            }
            break;
          case 'S':
          case 's':
            for (i = 0; i < length; i += 4) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.x2 = points[i];
              seg.y2 = points[i + 1];
              seg.x = points[i + 2];
              seg.y = points[i + 3];
            }
            break;
          case 'Q':
          case 'q':
            for (i = 0; i < length; i += 4) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.x1 = points[i];
              seg.y1 = points[i + 1];
              seg.x = points[i + 2];
              seg.y = points[i + 3];
            }
            break;
          case 'T':
          case 't':
            for (i = 0; i < length; i += 2) {
              if (i !== 0) {
                result.push(seg = {
                  c: c
                });
              }
              seg.x = points[i];
              seg.y = points[i + 1];
            }
            break;
        }
      }
    });
  }
  return result;
};

var parseGradient = function (gradient, g) {
    var transform = gradient.transform && parseTransform(gradient.transform),
      matrix, point, result,
      x1, y1, x2, y2,
      fx, fy, cx, cy, r;
    if (transform && transform.length) {
      matrix = $Matrix.identity();
      transform.forEach(function (transform) {
        var type = transform[0];
        if (type === 'matrix') {
          matrix.multiply(new $Matrix(transform[1], transform[2], transform[3], transform[4], transform[5], transform[6]));
        } else if (type === 'translate') {
          matrix.translate(transform[1] || 0, transform[2] || 0);
        } else if (type === 'scale') {
          matrix.scale(transform[1] || 1, transform[2] || transform[1] || 1);
        } else if (type === 'rotate') {
          matrix.rotate(transform[1] || 0, transform[2] || 0, transform[3] || 0);
        } else if (type === 'skewX') {
          matrix.skew(transform[1] || 0, 0);
        } else if (type === 'skewY') {
          matrix.skew(0, transform[1] || 0);
        }
      });
    }
    if (gradient.type === 'linear') {
      x1 = gradient.x1 || 0;
      y1 = gradient.y1 || 0;
      x2 = gradient.x2 || 0;
      y2 = gradient.y2 || 0;
      if (matrix) {
        point = matrix.transform(x1, y1);
        x1 = point.x;
        y1 = point.y;
        point = matrix.transform(x2, y2);
        x2 = point.x;
        y2 = point.y;
      }
      result = g.createLinearGradient(x1, y1, x2, y2);
    } else if (gradient.type === 'radial') {
      fx = gradient.fx || 0;
      fy = gradient.fy || 0;
      cx = gradient.cx || 0;
      cy = gradient.cy || 0;
      r = gradient.r || 0;
      
      gradient.fx == null && (fx = cx);
      gradient.fy == null && (fy = cy);
      if (matrix) {
        point = matrix.transform(fx, fy);
        fx = point.x;
        fy = point.y;
        point = matrix.transform(cx, cy);
        cx = point.x;
        cy = point.y;
        r = Math.max(matrix._m11, matrix._m22) * r;
      }
      result = g.createRadialGradient(fx, fy, 0, cx, cy, r);
    }
    if (result) {
      gradient.stop && gradient.stop.length && gradient.stop.forEach(function (seg) {
        result.addColorStop(parseFloat(seg.offset), getFilterColor(seg.color, g._color));
      });
    }
  return result;
};

var parseTransform = function (text) {
  return text.replace(/[\s\r\t\n]+/gm, ' ').trim().replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/).map(function (data) {
    return data.replace(')', '').trim().split(/\s*\(\s*|\s+,?\s*|,\s*/).map(function (data, i) {
      return i === 0 ? data : parseFloat(data);
    });
  });
};

var drawImage = twaver.Util.drawImage = function (g, image, color, rect, data, view, inPattern) {
  var imageAsset, imageName, sx, sy, zoom = 1;
  if (typeof image !== 'object') {
    imageName = image;
    imageAsset = _twaver.images[image];
    image = imageAsset && imageAsset.getImage();
  }
  if (isImage(image)) {
    g.drawImage(imageAsset ? imageAsset.getImage(color, rect.width, rect.height) : image, rect.x, rect.y, rect.width, rect.height);
  } else if (image && typeof image === 'object') {
    g._data = data;
    g._view = view;
    if (imageName) {
      sx = rect.width / ((image.w && getVectorValue(data, image, image, 'w')) || data.getWidth());
      sy = rect.height / ((image.h && getVectorValue(data, image, image, 'h')) || data.getHeight());
      if (view) {
        if (view.getSizeZoom) {
          zoom = view.getSizeZoom() * view.getGraphicsZoom();
        } else {
          zoom = view.getZoom();
        }
      }
      if (!imageAsset._cache || Math.max(sx * zoom, sy * zoom) > 1) {
        drawVector(g, image, color, rect, data, view, inPattern);
      } else {
        g.drawImage(color ? imageAsset.getImage(color, rect.width, rect.height) : imageAsset._cache, rect.x, rect.y, rect.width, rect.height);
      }
    } else {
      drawVector(g, image, color, rect, data, view, inPattern);
    }
    g._data = null;
    g._view = null;
  }
};

var drawVector = function (g, image, color, rect, data, view, inPattern) {
  var shapeState = data && data.getStyle('image.state'),
    v, vc, i, f, shapeData, vector, sx, sy, oldVector, oldFill, oldPattern, oldLineWidth, oldAlpha, oldScaleX, oldScaleY, oldColor, state, width, height;
  oldVector = g._vector;
  oldColor = g._color;
  oldFill = g._fill;
  oldPattern = g._pattern;
  oldLineWidth = g._lineWidth;
  oldAlpha = g._alpha;
  oldScaleX = g._sx;
  oldScaleY = g._sy;

  vector = image;

  if (getVectorValue(data, vector, vector, 'visible', view) === false) {
    return;
  }

  g._color = color;
  v = getVectorValue(data, vector, vector, 'v', view);
  vc = v && v.length;
  width = (vector.w && getVectorValue(data, vector, vector, 'w')) || data.getWidth();
  height = (vector.h && getVectorValue(data, vector, vector, 'h')) || data.getHeight();
  sx = rect.width / width;
  sy = rect.height / height;
  if (inPattern === true) {
    g._fill = null;
    g._pattern = null;
    g._lineWidth = null;
    g._alpha = null;
  } else {
    g._sx = sx;
    g._sy = sy;
  }

  g.save();
  g.translate(rect.x + rect.width / 2, rect.y + rect.height / 2);
  (sx !== 1 || sy !== 1) && g.scale(sx, sy);
  if (vector.origin) {
    g.translate((vector.origin.x - 0.5) * width, (vector.origin.y - 0.5) * height);
  }
  g._vector = vector;
  if (vector.clip) {
    g.beginPath();
    if (vector.clip === true) {
      g.rect(-(vector.origin ? vector.origin.x : 0.5) * width, -(vector.origin ? vector.origin.y : 0.5) * height, width, height);
    } else {
      if (vector.clip.length) {
        vector.clip.forEach(function (shapeData) {
          g.drawShape(shapeData);
        });
      } else {
        g.drawShape(vector.clip);
      }
    }
    g.clip();
  }
  setCanvasStyle(data, vector, vector, g, view);
  for (i = 0, vc = v.length; i < vc; i++) {
    shapeData = v[i];
    g._shapeData = shapeData;
    if (view) {
      view._shapeDataIndex = i;
      if (shapeData.animate) {
        refreshAnimate(shapeData, vector, data, view);
      }
    }
    state = getVectorValue(data, vector, shapeData, 'state', view);
    if (getVectorValue(data, vector, shapeData, 'visible', view) !== false &&
        (!state || (Array.isArray(state) ? (state.indexOf(shapeState) >= 0) : (state === shapeState)))) {
      f = shapeFunction[shapeData.shape];
      if (f) {
        g.save();
        if (shapeData.shape === 'vector' || shapeData.shape === 'g') {
          f(g, shapeData, data, view);
        } else {
          setCanvasStyle(data, vector, shapeData, g, view, function () {
            f(g, shapeData, data, view);
          });
        }
        g.restore();
      }
    }
    view && (view._shapeDataIndex = null);
    g._shapeData = null;
  }
  g.restore();

  g._vector = oldVector;
  g._shapeData = null;
  g._color = oldColor;
  g._fill = oldFill;
  g._pattern = oldPattern;
  g._lineWidth = oldLineWidth;
  g._alpha = oldAlpha;
  g._sx = oldScaleX;
  g._sy = oldScaleY;
};

var fillPattern = function fillPattern (g, pattern, rect, data, view) {
  var x, y, w, h, hc, vc, i, j, imageAsset,
    vector = g._vector,
    origin = vector.origin,
    vw = (vector.w && getVectorValue(data, vector, vector, 'w')) || data.getWidth(),
    vh = (vector.h && getVectorValue(data, vector, vector, 'h')) || data.getHeight();
  if (typeof pattern === 'string') {
    imageAsset = _twaver.images[pattern];
    if (imageAsset) {
      w = imageAsset.getWidth();
      h = imageAsset.getHeight();
    }
  } else {
    w = pattern.w && getVectorValue(data, pattern, pattern, 'w');
    h = pattern.h && getVectorValue(data, pattern, pattern, 'h');
  }
  if (!w || !h || !rect) {
    return;
  }
  hc = rect.w / w * g._sx;
  vc = rect.h / h * g._sy;
  x = rect.x - vw / 2 * (g._sx - 1);
  y = rect.y - vh / 2 * (g._sy - 1);
  if (origin) {
    x -= (origin.x - 0.5) * vw * (g._sx - 1);
    y -= (origin.y - 0.5) * vh * (g._sy - 1);
  }
  if (g._sx !== 1 || g._sy !== 1) {
    g.scale(1 / g._sx, 1 / g._sy);
    x += ((origin ? origin.x : 0.5) * vw + rect.x) * (g._sx - 1);
    y += ((origin ? origin.x : 0.5) * vh + rect.y) * (g._sy - 1);
  }
  rect = { x: 0, y: 0, width: w, height: h };
  for (i = 0; i < hc; i++) {
    for (j = 0; j < vc; j++) {
      rect.x = i * w + x;
      rect.y = j * h + y;
      drawImage(g, pattern, null, rect, data, view, true);
    }
  }
};

var shapeFunction = {
  line: function (g, shapeData, data, view) {
    var p1 = getVectorValue(data, g._vector, shapeData, 'p1', view),
      p2 = getVectorValue(data, g._vector, shapeData, 'p2', view),
      x1, y1, x2, y2;
    if (p1) {
      x1 = getHStringValue(p1.length ? p1[0] : p1.x, g);
      y1 = getVStringValue(p1.length ? p1[1] : p1.y, g);
    } else {
      x1 = getVectorValue(data, g._vector, shapeData, 'x1', view, true);
      y1 = getVectorValue(data, g._vector, shapeData, 'y1', view, false);
    }
    if (p2) {
      x2 = getHStringValue(p2.length ? p2[0] : p2.x, g);
      y2 = getVStringValue(p2.length ? p2[1] : p2.y, g);
    } else {
      x2 = getVectorValue(data, g._vector, shapeData, 'x2', view, true);
      y2 = getVectorValue(data, g._vector, shapeData, 'y2', view, false);
    }
    g.moveTo(x1, y1);
    g.lineTo(x2, y2);
  },
  rect: function (g, shapeData, data, view) {
    var rect = getVectorValue(data, g._vector, shapeData, 'rect', view),
      r = getVectorValue(data, g._vector, shapeData, 'r', view),
      x, y, w, h;
    if (rect) {
      if (Array.isArray(rect)) {
        x = rect[0];
        y = rect[1];
        w = rect[2];
        h = rect[3];
      } else {
        x = rect.x;
        y = rect.y;
        w = rect.w;
        h = rect.h;
      }
      x = getHStringValue(x, g);
      y = getVStringValue(y, g);
      w = getHStringValue(w, g);
      h = getVStringValue(h, g);
    } else {
      x = getVectorValue(data, g._vector, shapeData, 'x', view, true);
      y = getVectorValue(data, g._vector, shapeData, 'y', view, false);
      w = getVectorValue(data, g._vector, shapeData, 'w', view, true);
      h = getVectorValue(data, g._vector, shapeData, 'h', view, false);
    }
    g.drawRoundRect(x, y, w, h, r);
    if (g._gradientFunc || g._pattern) {
      g._rect = { x: x, y: y, w: w, h: h };
    }
  },
  circle: function (g, shapeData, data, view) {
    var cx = getVectorValue(data, g._vector, shapeData, 'cx', view, true),
      cy = getVectorValue(data, g._vector, shapeData, 'cy', view, false),
      w = (g._vector.w && getVectorValue(data, g._vector, g._vector, 'w')) || data.getWidth(),
      h = (g._vector.h && getVectorValue(data, g._vector, g._vector, 'h')) || data.getHeight(),
      r = getStringValue(getVectorValue(data, g._vector, shapeData, 'r', view), Math.min(w, h), shapeData, g._vector),
      startAngle = getVectorValue(data, g._vector, shapeData, 'startAngle', view),
      endAngle = getVectorValue(data, g._vector, shapeData, 'endAngle', view),
      anticlockwise = getVectorValue(data, g._vector, shapeData, 'anticlockwise', view),
      close = getVectorValue(data, g._vector, shapeData, 'close', view);
    startAngle == null && (startAngle = 0);
    endAngle == null && (endAngle = 360);
    anticlockwise == null && (anticlockwise = false);
    if (close) {
      g.moveTo(cx, cy);
    }
    g.arc(cx, cy, r, startAngle / 180 * Math.PI, endAngle / 180 * Math.PI, anticlockwise);
    if (close) {
      g.closePath();
    }
    if (g._gradientFunc || g._pattern) {
      g._rect = { x: cx - r, y: cy - r, w: r * 2, h:  r * 2 };
    }
  },
  ellipse: function (g, shapeData, data, view) {
    var cx = getVectorValue(data, g._vector, shapeData, 'cx', view, true),
      cy = getVectorValue(data, g._vector, shapeData, 'cy', view, false),
      rx = getVectorValue(data, g._vector, shapeData, 'rx', view, true),
      ry = getVectorValue(data, g._vector, shapeData, 'ry', view, false),
      startAngle = getVectorValue(data, g._vector, shapeData, 'startAngle', view),
      endAngle = getVectorValue(data, g._vector, shapeData, 'endAngle', view),
      anticlockwise = getVectorValue(data, g._vector, shapeData, 'anticlockwise', view),
      close = getVectorValue(data, g._vector, shapeData, 'close', view);
    startAngle == null && (startAngle = 0);
    endAngle == null && (endAngle = 360);
    anticlockwise == null && (anticlockwise = false);
    if (close) {
      g.moveTo(cx, cy);
    }
    g.ellipse(cx, cy, rx, ry, 0, startAngle / 180 * Math.PI, endAngle / 180 * Math.PI, anticlockwise);
    if (close) {
      g.closePath();
    }
    if (g._gradientFunc || g._pattern) {
      g._rect = { x: cx - rx, y: cy - ry, w: rx * 2, h:  ry * 2 };
    }
  },
  path: function (g, shapeData, data, view) {
    var d = getVectorValue(data, g._vector, shapeData, 'data', view);
    g.drawPath(d);
  },
  text: function (g, shapeData, data, view) {
    var text = getVectorValue(data, g._vector, shapeData, 'text', view),
      x = getVectorValue(data, g._vector, shapeData, 'x', view, true),
      y = getVectorValue(data, g._vector, shapeData, 'y', view, false),
      maxWidth = getVectorValue(data, g._vector, shapeData, 'w', view, true);
    if (text == null) {
      return;
    }
    text = String(text);
    var paragraphs = text.split('\n'),
      lineHeight = g.measureText('e').width * 2,
      size = getTextSize(g, text, maxWidth);
    y -= ((size.h / lineHeight) - 1 ) / 2 * lineHeight;
    // TODO _rect
    paragraphs.forEach(function (paragraph) {
      if (maxWidth) {
        var words = paragraph.split(' '),
          length = words.length,
          line = '',
          word, tempLine, i, tempWidth, j;
        for (i = 0; i < length; i++) {
          word = words[i] + (i === length -1 ? '': ' ');
          tempLine = line + word;
          tempWidth = g.measureText(tempLine).width;
          if (tempWidth < maxWidth) {
            line = tempLine;
          } else if (tempWidth == maxWidth) {
            g.fillText(line, x, y);
            line = '';
            y += lineHeight;
          } else {
            for (j = 0; j < word.length; j++) {
              tempLine = line + word.substr(0, j + 1);
              if (g.measureText(tempLine).width > maxWidth) {
                g.fillText(tempLine.substring(0, tempLine.length - 1), x, y);
                line = word.substring(j, word.length);
                y += lineHeight;
                break;
              }
            }
            while (line.length > 0 && g.measureText(line).width > maxWidth) {
              for (j = 0; j < line.length; j++) {
                tempLine = line.substr(0, j + 1);
                if (g.measureText(tempLine).width > maxWidth) {
                  g.fillText(line.substr(0, j), x, y);
                  line = line.substring(j, line.length);
                  y += lineHeight;
                  break;
                }
              }
            }
          }
        }
        g.fillText(line, x, y);
      } else {
        g.fillText(paragraph, x, y);
      }
      y += lineHeight;
    });
  },
  draw: function (g, shapeData, data, view) {
    var draw = shapeData.draw,
      match, source;
    if (typeof draw === 'string') {
      if (match = draw.match(bindingPattern_evaluate)) {
        source = 'with(data) { ' + match[1] + ' }';
        //try {
          // draw = new Function('g', 'data', 'view', source);
          draw = twaver.Util.newFunction('g', 'data', 'view', source);
        //} catch (e) {
          //console.log(e);
        //}
      } else {
        draw = drawFunctionCache[draw];
      }
    }
    (typeof draw === 'function') && draw.call(g._vector, g, data, view);
  },
  vector: function (g, shapeData, data, view) {
    var vector = g._vector,
      vectorName = getVectorValue(data, vector, shapeData, 'name', view),
      x = getVectorValue(data, vector, shapeData, 'x', view, true),
      y = getVectorValue(data, vector, shapeData, 'y', view, false),
      w = getVectorValue(data, vector, shapeData, 'w', view),
      h = getVectorValue(data, vector, shapeData, 'h', view),
      i, childShapeData, f, oldLineWidth, oldFill, oldAlpha, originShapeData, imageAssert, v, c, ow, oh, oldShapeData;
    if (typeof vectorName === 'string') {
      imageAssert = _twaver.images[vectorName];
      originShapeData = imageAssert && imageAssert._image;
    } else {
      originShapeData = vectorName;
    }
    if (originShapeData) {
      if (isImage(originShapeData)) {
        if (w != null && h != null) {
          g.drawImage(originShapeData, x, y, getHStringValue(w, g), getVStringValue(h, g));
        } else {
          g.drawImage(originShapeData, x, y);
        }
      } else {
        v = getVectorValue(data, originShapeData, originShapeData, 'v', view);
        c = v && v.length;
        ow = originShapeData.w && getVectorValue(data, originShapeData, originShapeData, 'w');
        oh = originShapeData.h && getVectorValue(data, originShapeData, originShapeData, 'h');
        if (w != null && h != null) {
          w = getHStringValue(w, g);
          h = getVStringValue(h, g);
        } else {
          w = ow;
          h = oh;
        }
        g.save();
        oldLineWidth = g._lineWidth;
        oldFill = g._fill;
        oldAlpha = g._alpha;
        setCanvasStyle(data, originShapeData, originShapeData, g, view);
        setCanvasStyle(data, vector, shapeData, g, view);
        g.translate(x, y);
        g.scale(w / ow, h / oh);
        if (originShapeData.origin) {
          g.translate((originShapeData.origin.x - 0.5) * ow, (originShapeData.origin.y - 0.5) * oh);
        }
        if (originShapeData.clip) {
          g.beginPath();
          if (originShapeData.clip === true) {
            g.rect(-(originShapeData.origin ? originShapeData.origin.x : 0.5) * ow, -(originShapeData.origin ? originShapeData.origin.y : 0.5) * oh, ow, oh);
          } else {
            if (originShapeData.clip.length) {
              originShapeData.clip.forEach(function (shapeData) {
                g.drawShape(shapeData);
              });
            } else {
              g.drawShape(originShapeData.clip);
            }
          }
          g.clip();
        }
        oldShapeData = g._shapeData;
        g._vector = originShapeData;
        for (i = 0; i < c; i++) {
          childShapeData = v[i];
          g._shapeData = childShapeData;
          if (view) {
            if (view._shapeDataIndex.length) {
              view._shapeDataIndex.push(i);
            } else {
              view._shapeDataIndex = [ view._shapeDataIndex, i ];
            }
            if (childShapeData.animate) {
              refreshAnimate(childShapeData, vector, data, view);
            }
          }
          if (getVectorValue(data, originShapeData, childShapeData, 'visible', view) !== false) {
            f = shapeFunction[childShapeData.shape];
            if (f) {
              g.save();
              if (childShapeData.shape === 'vector' || childShapeData.shape === 'g') {
                f(g, childShapeData, data, view);
              } else {
                setCanvasStyle(data, originShapeData, childShapeData, g, view, function () {
                  f(g, childShapeData, data, view);
                });
              }
              g.restore();
            }
          }
          if (view) {
            view._shapeDataIndex.pop();
          }
        }
        g._vector = vector;
        g._shapeData = oldShapeData;
        g._lineWidth = oldLineWidth;
        g._fill = oldFill;
        g._alpha = oldAlpha;
        g.restore();
      }
    }
  },
  g: function (g, shapeData, data, view) {
    var v = getVectorValue(data, g._vector, shapeData, 'v', view),
      f, oldLineWidth, oldFill, oldAlpha, oldShapeData;
    if (v && v.length) {
      g.save();
      oldLineWidth = g._lineWidth;
      oldFill = g._fill;
      oldAlpha = g._alpha;
      oldShapeData = g._shapeData;
      setCanvasStyle(data, g._vector, shapeData, g, view);
      v.forEach(function (shapeData) {
        if (getVectorValue(data, g._vector, shapeData, 'visible', view) !== false) {
          f = shapeFunction[shapeData.shape];
          if (f) {
            g.save();
            g._shapeData = shapeData;
            if (shapeData.shape === 'vector' || shapeData.shape === 'g') {
              f(g, shapeData, data, view);
            } else {
              setCanvasStyle(data, g._vector, shapeData, g, view, function () {
                f(g, shapeData, data, view);
              });
            }
            g.restore();
          }
        }
      });
      g._lineWidth = oldLineWidth;
      g._fill = oldFill;
      g._alpha = oldAlpha;
      g._shapeData = oldShapeData;
      g.restore();
    }
  }
};

function getTextSize (g, text, maxWidth) {
  var width = 0,
    height = 0,
    paragraphs = text.split('\n'),
    lineHeight = g.measureText('e').width * 2;
  paragraphs.forEach(function (paragraph) {
    if (maxWidth) {
      var words = paragraph.split(' '),
        length = words.length,
        line = '',
        word, tempLine, i, tempWidth, j;
      for (i = 0; i < length; i++) {
        word = words[i] + (i === length -1 ? '': ' ');
        tempLine = line + word;
        tempWidth = g.measureText(tempLine).width;
        if (tempWidth < maxWidth) {
          line = tempLine;
        } else if (tempWidth == maxWidth) {
          line = '';
          height += lineHeight;
        } else {
          for (j = 0; j < word.length; j++) {
            tempLine = line + word.substr(0, j + 1);
            if (g.measureText(tempLine).width > maxWidth) {
              line = word.substring(j, word.length);
              height += lineHeight;
              break;
            }
          }
          while (line.length > 0 && g.measureText(line).width > maxWidth) {
            for (j = 0; j < line.length; j++) {
              tempLine = line.substr(0, j + 1);
              if (g.measureText(tempLine).width > maxWidth) {
                line = line.substring(j, line.length);
                height += lineHeight;
                break;
              }
            }
          }
        }
      }
    } else {
      tempWidth = g.measureText(paragraph).width;
      width = tempWidth > width ? tempWidth : width;
    }
    height += lineHeight;
  });
  width = maxWidth ? maxWidth : width;
  return { w: width, h: height };
}

shapeFunction.image = shapeFunction.vector;
var nativeShapeKeys = Object.keys(shapeFunction);

var pathFunction = {
  M: function (g, seg) {
    g.moveTo(seg.x, seg.y);
    g._path_start = seg;
    g._rect && getMaxRect(g._rect, seg.x, seg.y);
    return seg;
  },
  m: function (g, seg, pre) {
    if (pre) {
      seg = { x: pre.x + seg.x, y: pre.y + seg.y };
    }
    g.moveTo(seg.x, seg.y);
    g._path_start = seg;
    g._rect && getMaxRect(g._rect, seg.x, seg.y);
    return seg;
  },
  Z: function (g) {
    g.closePath();
    return g._path_start;
  },
  z: function (g) {
    g.closePath();
    return g._path_start;
  },
  L: function (g, seg) {
    g.lineTo(seg.x, seg.y);
    g._rect && getMaxRect(g._rect, seg.x, seg.y);
    return seg;
  },
  l: function (g, seg, pre) {
    var point = { x: pre.x + seg.x, y: pre.y + seg.y };
    g.lineTo(point.x, point.y);
    g._rect && getMaxRect(g._rect, point.x, point.y);
    return point;
  },
  H: function (g, seg, pre) {
    var point = { x: seg.x, y: pre.y };
    g.lineTo(point.x, point.y);
    g._rect && getMaxRect(g._rect, point.x, point.y);
    return point;
  },
  h: function (g, seg, pre) {
    var point = { x: pre.x + seg.x, y: pre.y };
    g.lineTo(point.x, point.y);
    g._rect && getMaxRect(g._rect, point.x, point.y);
    return point;
  },
  V: function (g, seg, pre) {
    var point = { x: pre.x, y: seg.y };
    g.lineTo(point.x, point.y);
    g._rect && getMaxRect(g._rect, point.x, point.y);
    return point;
  },
  v: function (g, seg, pre) {
    var point = { x: pre.x, y: pre.y + seg.y };
    g.lineTo(point.x, point.y);
    g._rect && getMaxRect(g._rect, point.x, point.y);
    return point;
  },
  Q: function (g, seg) {
    // quadraticCurveTo(cpx, cpy, x, y)
    g._preQ_x = seg.x1;
    g._preQ_y = seg.y1;
    g.quadraticCurveTo(seg.x1, seg.y1, seg.x, seg.y);
    if (g._rect) {
      getMaxRect(g._rect, seg.x1, seg.y1);
      getMaxRect(g._rect, seg.x, seg.y);
    }
    return seg;
  },
  q: function (g, seg, pre) {
    // quadraticCurveTo(cpx, cpy, x, y)
    var point = { x: pre.x + seg.x, y: pre.y + seg.y },
      p1_x = g._preQ_x = pre.x + seg.x1,
      p1_y = g._preQ_y = pre.y + seg.y1;
    g.quadraticCurveTo(p1_x, p1_y, point.x, point.y);
    if (g._rect) {
      getMaxRect(g._rect, p1_x, p1_y);
      getMaxRect(g._rect, point.x, point.y);
    }
    return point;
  },
  T: function (g, seg, pre) {
    var x1 = g._preQ_x = 2 * pre.x - g._preQ_x,
      y1 = g._preQ_y = 2 * pre.y - g._preQ_y;
    g.quadraticCurveTo(x1, y1, seg.x, seg.y);
    if (g._rect) {
      getMaxRect(g._rect, x1, y1);
      getMaxRect(g._rect, seg.x, seg.y);
    }
    return seg;
  },
  t: function (g, seg, pre) {
    // quadraticCurveTo(cpx, cpy, x, y)
    var point = { x: pre.x + seg.x, y: pre.y + seg.y },
      x1 = g._preQ_x = 2 * pre.x - g._preQ_x,
      y1 = g._preQ_y = 2 * pre.y - g._preQ_y;
    g.quadraticCurveTo(x1, y1, point.x, point.y);
    if (g._rect) {
      getMaxRect(g._rect, x1, y1);
      getMaxRect(g._rect, point.x, point.y);
    }
    return point;
  },
  C: function (g, seg) {
    // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
    g._preC_x = seg.x2;
    g._preC_y = seg.y2;
    g.bezierCurveTo(seg.x1, seg.y1, seg.x2, seg.y2, seg.x, seg.y);
    if (g._rect) {
      getMaxRect(g._rect, seg.x1, seg.y1);
      getMaxRect(g._rect, seg.x2, seg.y2);
      getMaxRect(g._rect, seg.x, seg.y);
    }
    return seg;
  },
  c: function (g, seg, pre) {
    // bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
    var point = { x: pre.x + seg.x, y: pre.y + seg.y },
      p1_x = pre.x + seg.x1,
      p1_y = pre.y + seg.y1,
      p2_x = g._preC_x = pre.x + seg.x2,
      p2_y = g._preC_y = pre.y + seg.y2;
    g.bezierCurveTo(p1_x, p1_y, p2_x, p2_y, point.x, point.y);
    if (g._rect) {
      getMaxRect(g._rect, p1_x, p1_y);
      getMaxRect(g._rect, p2_x, p2_y);
      getMaxRect(g._rect, point.x, point.y);
    }
    return point;
  },
  S: function (g, seg, pre) {
    var x1 = 2 * pre.x - g._preC_x,
      y1 = 2 * pre.y - g._preC_y;
    g._preC_x = seg.x2;
    g._preC_y = seg.y2;
    g.bezierCurveTo(x1, y1, seg.x2, seg.y2, seg.x, seg.y);
    if (g._rect) {
      getMaxRect(g._rect, x1, y1);
      getMaxRect(g._rect, seg.x2, seg.y2);
      getMaxRect(g._rect, seg.x, seg.y);
    }
    return seg;
  },
  s: function (g, seg, pre) {
    var point = { x: pre.x + seg.x, y: pre.y + seg.y },
      x1 = 2 * pre.x - g._preC_x,
      y1 = 2 * pre.y - g._preC_y,
      p2_x = g._preC_x = pre.x + seg.x2,
      p2_y = g._preC_y = pre.y + seg.y2;
    g.bezierCurveTo(x1, y1, p2_x, p2_y, point.x, point.y);
    if (g._rect) {
      getMaxRect(g._rect, x1, y1);
      getMaxRect(g._rect, p2_x, p2_y);
      getMaxRect(g._rect, point.x, point.y);
    }
    return point;
  },
  //TODO A,a
};

var setCanvasStyle = function (data, vector, shapeData, g, view, cb) {
  var line = getVectorValue(data, vector, shapeData, 'line', view),
    fill = getVectorValue(data, vector, shapeData, 'fill', view),
    fillRule = getVectorValue(data, vector, shapeData, 'fillRule', view) || 'nonzero', // 'nonzero', 'evenodd'
    gradient = getVectorValue(data, vector, shapeData, 'gradient', view),
    gradientColor = getVectorValue(data, vector, shapeData, 'gradientColor', view),
    pattern = getVectorValue(data, vector, shapeData, 'pattern', view),
    font = getVectorValue(data, vector, shapeData, 'font', view),
    textAlign = getVectorValue(data, vector, shapeData, 'textAlign', view) || 'center',
    textBaseline = getVectorValue(data, vector, shapeData, 'textBaseline', view) || 'middle',
    translate = getVectorValue(data, vector, shapeData, 'translate', view),
    rotate = getVectorValue(data, vector, shapeData, 'rotate', view),
    rotateOrigin = getVectorValue(data, vector, shapeData, 'rotateOrigin', view),
    scale = getVectorValue(data, vector, shapeData, 'scale', view),
    transform = getVectorValue(data, vector, shapeData, 'transform', view),
    alpha = getVectorValue(data, vector, shapeData, 'alpha', view),
    oldLineWidth = g._lineWidth,
    oldFill = g._fill,
    oldPattern = g._pattern,
    oldAlpha = g._alpha,
    oldGradientFunc = g._gradientFunc,
    lineColor, lineWidth, lineCap, lineJoin, miterLimit, lineDash, lineDashOffset, rect, gradientFunc, scaleX, scaleY, translateX, translateY;
  if (line) {
    lineColor = line.color;
    lineWidth = line.width;
    lineCap = line.cap;
    lineJoin = line.join;
    miterLimit = line.miterLimit;
    lineDash = line.dash;
    lineDashOffset = line.dashOffset;
  } else {
    lineColor = getVectorValue(data, vector, shapeData, 'lineColor', view),
    lineWidth = getVectorValue(data, vector, shapeData, 'lineWidth', view),
    lineCap = getVectorValue(data, vector, shapeData, 'lineCap', view),
    lineJoin = getVectorValue(data, vector, shapeData, 'lineJoin', view),
    miterLimit = getVectorValue(data, vector, shapeData, 'miterLimit', view),
    lineDash = getVectorValue(data, vector, shapeData, 'lineDash', view),
    lineDashOffset = getVectorValue(data, vector, shapeData, 'lineDashOffset', view);
  }
  lineColor != null && (g.strokeStyle = getFilterColor(lineColor, g._color));
  lineWidth != null && (g.lineWidth = g._lineWidth = (view && view.getSizeZoom && !view.zoomManager.sizeChange ? lineWidth / view.getSizeZoom() : lineWidth));
  lineCap != null && (g.lineCap = lineCap);
  lineJoin != null && (g.lineJoin = lineJoin);
  miterLimit != null && (g.miterLimit = miterLimit);
  if (lineDash != null) {
    g.lineDash = lineDash;
    g.setLineDash(lineDash);
  }
  lineDashOffset != null && (g.lineDashOffset = lineDashOffset);
  if (pattern) {
    g._pattern = pattern;
  } else {
    fill && (g.fillStyle = g._fill = getFilterColor(fill, g._color));

    if (gradient) {
      if (typeof gradient === 'string') {
        gradientFunc = gradient_types[gradient];
      } else {
        gradientFunc = gradient_types[gradient.type];
        gradient.color && (gradientColor = gradient.color);
        if (!gradientFunc) {
          gradient = parseGradient(gradient, g);
        }
      }
      g._gradientFunc = gradientFunc;
    }
  }

  font != null && (g.font = font);
  textAlign != null && (g.textAlign = textAlign);
  textBaseline != null && (g.textBaseline = textBaseline);
  setCanvasShadowStyle(data, vector, shapeData, g, view);

  if (transform != null) {
    if (typeof transform === 'string') {
      transform = parseTransform(transform);
    }
    if (transform.length) {
      transform.forEach(function (transform) {
        var type = transform[0];
        if (type === 'matrix') {
          g.transform(transform[1], transform[2], transform[3], transform[4], transform[5], transform[6]);
        } else if (type === 'translate') {
          g.translate(transform[1] || 0, transform[2] || 0);
        } else if (type === 'scale') {
          g.scale(transform[1] || 1, transform[2] || transform[1] || 1);
        } else if (type === 'rotate') {
          if (transform.length > 2) {
            g.translate(transform[2], transform[3]);
            g.rotate(transform[1]);
            g.translate(-transform[2], -transform[3]);
          } else {
            g.rotate(transform[1]);
          }
        } else if (type === 'skewX') {
          g.transform(1, 0, Math.tan(transform[1] * Math.PI / 180), 1, 0, 0);
        } else if (type === 'skewY') {
          g.transform(1, Math.tan(transform[1] * Math.PI / 180), 0, 1, 0, 0);
        }
      });
    }
  } else {
    if (translate != null) {
      if (Array.isArray(translate)) {
        translateX = translate[0];
        translateY = translate[1];
      } else if (typeof translate === 'object') {
        translateX = translate.x;
        translateY = translate.y;
      } else {
        translateX = translate;
        translateY = 0;
      }
      translateX = getHStringValue(translateX, g);
      translateY = getVStringValue(translateY, g);
      if (translateX !== 0 || translateY !== 0) {
        g.translate(translateX, translateY);
      }
    }
    if (rotate != null && (rotate % 360) !== 0) {
      var rotateOriginX, rotateOriginY;
      if (rotateOrigin) {
        if (Array.isArray(rotateOrigin)) {
          rotateOriginX = rotateOrigin[0];
          rotateOriginY = rotateOrigin[1];
        } else if (typeof rotateOrigin === 'object') {
          rotateOriginX = rotateOrigin.x;
          rotateOriginY = rotateOrigin.y;
        } else {
          rotateOriginX = rotateOriginY = rotateOrigin;
        }
        rotateOriginX = getHStringValue(rotateOriginX, g);
        rotateOriginY = getVStringValue(rotateOriginY, g);
        if (rotateOriginX !== 0 || rotateOriginY !== 0) {
          g.translate(rotateOriginX, rotateOriginY);
        }
      }
      g.rotate(rotate * Math.PI / 180);
      if (rotateOrigin) {
        if (rotateOriginX !== 0 || rotateOriginY !== 0) {
          g.translate(-rotateOriginX, -rotateOriginY);
        }
      }
    }
    if (scale != null) {
      if (Array.isArray(scale)) {
        scaleX = scale[0];
        scaleY = scale[1];
      } else if (typeof scale === 'object') {
        scaleX = scale.x;
        scaleY = scale.y;
      } else {
        scaleX = scaleY = scale;
      }
      if (scaleX !== 1 || scaleY !== 1) {
        g.scale(scaleX, scaleY);
      }
    }
  }

  if (alpha != null) {
    g.globalAlpha = g._alpha = oldAlpha != null ? oldAlpha * alpha : alpha;
  }

  if (cb) {
    g.beginPath();
    cb();
    rect = g._rect || shapeData.rect;
    if (g._pattern) {
      g._lineWidth > 0 && g.stroke();
      g.clip();
      fillPattern(g, g._pattern, rect, data, view);
    } else {
      if (gradientFunc && rect) {
        gradient = gradientFunc(g, getFilterColor(fill || '#000000', g._color),
                                getFilterColor(gradientColor || '#FFFFFF', g._color), rect.x, rect.y, rect.w, rect.h);
      }
      gradient && (g.fillStyle = g._fill = gradient);
      g._fill && g.fill(fillRule);
      g._lineWidth > 0 && g.stroke();
    }

    g._lineWidth = oldLineWidth;
    g._fill = oldFill;
    g._pattern = oldPattern;
    g._alpha = oldAlpha;
    g._gradientFunc = oldGradientFunc;
    g._rect = null;
  }
};

var setCanvasShadowStyle = function (data, vector, shapeData, g, view) {
  var shadow = getVectorValue(data, vector, shapeData, 'shadow', view),
    shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor;
  if (shadow) {
    shadowOffsetX = shadow.offsetX;
    shadowOffsetY = shadow.offsetY;
    shadowBlur = shadow.blur;
    shadowColor = shadow.color;
  } else {
    shadowOffsetX = getVectorValue(data, vector, shapeData, 'shadowOffsetX', view);
    shadowOffsetY = getVectorValue(data, vector, shapeData, 'shadowOffsetY', view);
    shadowBlur = getVectorValue(data, vector, shapeData, 'shadowBlur', view);
    shadowColor = getVectorValue(data, vector, shapeData, 'shadowColor', view);
  }
  shadowOffsetX != null && (g.shadowOffsetX = shadowOffsetX);
  shadowOffsetY != null && (g.shadowOffsetY = shadowOffsetY);
  shadowBlur != null && (g.shadowBlur = shadowBlur);
  shadowColor != null && (g.shadowColor = shadowColor);
};

var bindingPattern_interpolate = /<%=([\s\S]+?)%>/;
var bindingPattern_evaluate = /<%([\s\S]+?)%>/;
var bindingPattern = new RegExp([bindingPattern_interpolate.source, bindingPattern_evaluate.source].join('|'));
var getVectorValue = function (data, vector, shapeData, prop, view, h, withAnimate) {
  var value = shapeData[prop],
    type = typeof value,
    match, source, f, vw, vh;
  if (type === 'string' && (match = value.match(bindingPattern))) {
    // TODO replace a@attr,s@attr,c@attr to attr(),s('attr'),c('attr')
    source = 'with(data) { ' + (match[1] ? 'return ' + match[1] : match[2]) + ' }';
    //try {
      // f = new Function('data', 'view', source);
         f = twaver.Util.newFunction('data', 'view', source);
         value = f.call(vector, data, view);
    //} catch (e) {
      //console.log(e);
    //}
  } else if (type === 'function') {
    value = value.call(vector, data, view);
  }
  if (h === true) {
    vw = (vector.w && getVectorValue(data, vector, vector, 'w')) || data.getWidth();
    if ((shapeData.rel === true || (shapeData.rel === undefined && vector.rel)) && value <= 1 && value >= -1) {
      value = value * vw;
    } else if (typeof value === 'string') {
      value = parseInt(value) / 100 * vw;
    }
    value = value || 0;
  } else if (h === false) {
    vh = (vector.h && getVectorValue(data, vector, vector, 'h')) || data.getHeight();
    if ((shapeData.rel === true || (shapeData.rel === undefined && vector.rel)) && value <= 1 && value >= -1) {
      value = value * vh;
    } else if (typeof value === 'string') {
      value = parseInt(value) / 100 * vh;
    }
    value = value || 0;
  }
  if (withAnimate !== false && view && data && shapeData.animate && data._animates) {
    var animates = data._animates,
      shapeDataIndex = view._shapeDataIndex,
      index;
    if (shapeDataIndex.length) {
      for (var i=0; i<shapeDataIndex.length; i++) {
        index = shapeDataIndex[i];
        animates = animates[index];
      }
    } else {
      index = shapeDataIndex;
    }
    var animate = animates[index],
      animateItem = animate[prop];
    if (animateItem) {
      if (Array.isArray(animateItem)) {
        for (var i = animateItem.length - 1; i >= 0; i--) {
          var item = animateItem[i];
          if (item.stopped || item.time > 0) {
            if (item.started) {
              return getAnimateValue(item, value);
            }
          }
        }
      } else {
        if (animateItem.started) {
          return getAnimateValue(animateItem, value);
        }
      }
    }
  }
  return value;
};

var getHStringValue = function (value, g) {
  if (!value) {
    return 0;
  }
  var w = (g._vector.w && getVectorValue(g._data, g._vector, g._vector, 'w')) || g._data.getWidth();
  if (((g._shapeData && g._shapeData.rel === true) || ((!g._shapeData || g._shapeData.rel === undefined) && g._vector.rel)) && value <= 1 && value >= -1) {
    return value * w;
  }
  if (typeof value === 'string') {
    return parseInt(value) / 100 * w;
  }
  return value;
};

var getVStringValue = function (value, g) {
  if (!value) {
    return 0;
  }
  var h = (g._vector.h && getVectorValue(g._data, g._vector, g._vector, 'h')) || g._data.getHeight();
  if (((g._shapeData && g._shapeData.rel === true) || ((!g._shapeData || g._shapeData.rel === undefined) && g._vector.rel)) && value <= 1 && value >= -1) {
    return value * h;
  }
  if (typeof value === 'string') {
    return parseInt(value) / 100 * h;
  }
  return value;
};

var getStringValue = function (value, scale, shapeData, vector) {
  if (!value) {
    return 0;
  }
  if ((shapeData.rel === true || (shapeData.rel === undefined && vector.rel)) && value <= 1 && value >= -1) {
    return value * scale;
  }
  if (typeof value === 'string') {
    return parseInt(value) / 100 * scale;
  }
  return value;
};

var context_proto = (window.CanvasRenderingContext2D || Canvas.Context2d).prototype;
context_proto.drawShape = function (shapeData) {
  var g = this,
    vector = g._vector,
    oldShapeData = g._shapeData,
    data = g._data,
    view = g._view,
    f = shapeFunction[shapeData.shape];
  if (f) {
    g.save();
    g._shapeData = shapeData;
    if (shapeData.shape === 'vector' || shapeData.shape === 'g') {
      f(g, shapeData, data, view);
    } else {
      setCanvasStyle(data, vector, shapeData, g, view, function () {
        f(g, shapeData, data, view);
      });
    }
    g._shapeData = oldShapeData;
    g.restore();
  }
};
context_proto.drawPath = function (d) {
  var g = this,
    path, p, close, i, pre, seg, f, point, c, rect, x, y;
  if (typeof d === 'string') {
    d = parsePathOrPoints(d);
  }
  c = d ? d.length : 0;
  if (c <= 1) {
    return;
  }
  if (g._gradientFunc || g._pattern) {
    g._rect = rect = { x: 0, y: 0, w: 0, h: 0 };
  }
  path = d && d[0] && d[0].c;
  if (!path) {
    p = d && d[0] && d[0].x != null;
    close = d[c - 1] === 'z' || d[c - 1] === 'Z';
    if (close) {
      c--;
    }
  }
  if (path) {
    for (i = 0; i < c; i++) {
      seg = d[i];
      f = pathFunction[seg.c];
      f && (pre = f(g, seg, pre));
    }
    g._path_start = null;
    g._preC_x = null;
    g._preC_y = null;
    g._preQ_x = null;
    g._preQ_y = null;
  } else if (p) {
    point = d[0];
    x = getHStringValue(point.x, g);
    y = getVStringValue(point.y, g);
    g.moveTo(x, y);
    rect && getMaxRect(rect, x, y);
    for (i = 1; i < c; i++) {
      point = d[i];
      x = getHStringValue(point.x, g);
      y = getVStringValue(point.y, g);
      g.lineTo(x, y);
      rect && getMaxRect(rect, x, y);
    }
    close && g.closePath();
  } else {
    x = getHStringValue(d[0], g);
    y = getVStringValue(d[1], g);
    g.moveTo(x, y);
    rect && getMaxRect(rect, x, y);
    for (i = 2; i < c; i += 2) {
      x = getHStringValue(d[i], g);
      y = getVStringValue(d[i + 1], g);
      g.lineTo(x, y);
      rect && getMaxRect(rect, x, y);
    }
    close && g.closePath();
  }
  return d;
};

var getMaxRect = function (rect, x, y) {
  var x1 = Math.min(rect.x, x);
  var x2 = Math.max(rect.x + rect.w, x);
  var y1 = Math.min(rect.y, y);
  var y2 = Math.max(rect.y + rect.h, y);
  rect.x = x1;
  rect.y = y1;
  rect.w = x2 - x1;
  rect.h = y2 - y1;
};

context_proto._fillPath = function (color, d) {
  var g = this;
  g.beginPath();
  g.fillStyle = color;
  g.drawPath(d);
  g.fill();
};
context_proto._fillRect = function (color, x, y, w, h) {
  var g = this;
  g.beginPath();
  g.fillStyle = color;
  g.rect(x, y, w, h);
  g.fill();
};
if (!context_proto.ellipse) {
  // http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas
  context_proto.ellipse = function (cx, cy, rx, ry) {
    var g = this,
      kappa = .5522848,
      ox = rx * kappa, // control point offset horizontal
      oy = ry * kappa, // control point offset vertical
      xe = cx + rx,    // x-end
      ye = cy + ry,    // y-end
      x = cx - rx,
      y = cy - ry;
    g.moveTo(x, cy);
    g.bezierCurveTo(x, cy - oy, cx - ox, y, cx, y);
    g.bezierCurveTo(cx + ox, y, xe, cy - oy, xe, cy);
    g.bezierCurveTo(xe, cy + oy, cx + ox, ye, cx, ye);
    g.bezierCurveTo(cx - ox, ye, x, cy + oy, x, cy);
  };
}

context_proto.drawRoundRect = function (x, y, width, height, r) {
  var g = this;
  if (!r) {
    g.rect(x, y, width, height);
    return;
  }

  var topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius;
  if (Array.isArray(r)) {
    if (r.length === 1) {
      topLeftRadius = topRightRadius = bottomLeftRadius = bottomRightRadius = r[0];
    } else if (r.length === 2) {
      topLeftRadius = topRightRadius = r[0];
      bottomLeftRadius = bottomRightRadius = r[1];
    } else if (r.length === 4) {
      topLeftRadius = r[0];
      topRightRadius = r[1];
      bottomLeftRadius = r[2];
      bottomRightRadius = r[3];
    } else {
      g.rect(x, y, width, height);
      return;
    }
  } else {
    topLeftRadius = topRightRadius = bottomLeftRadius = bottomRightRadius = r;
  }
  var xw = x + width;
  var yh = y + height;

  // Make sure none of the radius values are greater than w/h.
  // These are all inlined to avoid function calling overhead
  var minSize = width < height ? width * 2 : height * 2;
  topLeftRadius = topLeftRadius < minSize ? topLeftRadius : minSize;
  topRightRadius = topRightRadius < minSize ? topRightRadius : minSize;
  bottomLeftRadius = bottomLeftRadius < minSize ? bottomLeftRadius : minSize;
  bottomRightRadius = bottomRightRadius < minSize ? bottomRightRadius : minSize;

  // Math.sin and Math,tan values for optimal performance.
  // Math.rad = Math.PI / 180 = 0.0174532925199433
  // r * Math.sin(45 * Math.rad) =  (r * 0.707106781186547);
  // r * Math.tan(22.5 * Math.rad) = (r * 0.414213562373095);
  //
  // We can save further cycles by precalculating
  // 1.0 - 0.707106781186547 = 0.292893218813453 and
  // 1.0 - 0.414213562373095 = 0.585786437626905

  // bottom-right corner
  var a = bottomRightRadius * 0.292893218813453;   // radius - anchor pt;
  var s = bottomRightRadius * 0.585786437626905;   // radius - control pt;
  g.moveTo(xw, yh - bottomRightRadius);
  g.quadraticCurveTo(xw, yh - s, xw - a, yh - a);
  g.quadraticCurveTo(xw - s, yh, xw - bottomRightRadius, yh);

  // bottom-left corner
  a = bottomLeftRadius * 0.292893218813453;
  s = bottomLeftRadius * 0.585786437626905;
  g.lineTo(x + bottomLeftRadius, yh);
  g.quadraticCurveTo(x + s, yh, x + a, yh - a);
  g.quadraticCurveTo(x, yh - s, x, yh - bottomLeftRadius);

  // top-left corner
  a = topLeftRadius * 0.292893218813453;
  s = topLeftRadius * 0.585786437626905;
  g.lineTo(x, y + topLeftRadius);
  g.quadraticCurveTo(x, y + s, x + a, y + a);
  g.quadraticCurveTo(x + s, y, x + topLeftRadius, y);

  // top-right corner
  a = topRightRadius * 0.292893218813453;
  s = topRightRadius * 0.585786437626905;
  g.lineTo(xw - topRightRadius, y);
  g.quadraticCurveTo(xw - s, y, xw - a, y + a);
  g.quadraticCurveTo(xw, y + s, xw, y + topRightRadius);
  g.lineTo(xw, yh - bottomRightRadius);
};

var isImage = function (image) {
  return Canvas ? (image instanceof Canvas || image instanceof Image) : (image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement);
};
var drawFunctionCache = {};

var getDraw = function (name) {
  return drawFunctionCache[name];
};

var registerDraw = function (name, draw) {
  if (typeof draw === 'function') {
    drawFunctionCache[name] = draw;
  }
};

var getShape = function (name) {
  return shapeFunction[name];
};

var registerShape = function (name, shapeFunc) {
  if (typeof shapeFunc === 'function' && nativeShapeKeys.indexOf(name) < 0) {
    shapeFunction[name] = shapeFunc;
  }
};

function refreshAnimate (shapeData, vector, data, view) {
  var animate = shapeData.animate,
    now = view._now,
    shapeDataIndex = view._shapeDataIndex,
    index;
  var animates = data._animates;
  if (!animates) {
    animates = data._animates = {};
  }
  if (shapeDataIndex.length) {
    for (var i=0; i<shapeDataIndex.length; i++) {
      index = shapeDataIndex[i];
      var baseAnimates = animates[index];
      if (!baseAnimates) {
        baseAnimates = animates[index] = {};
      }
      animates = baseAnimates;
    }
  } else {
    index = shapeDataIndex;
  }
  var newAnimate = animates[index];
  if (!newAnimate) {
    newAnimate = animates[index] = {};
    animate.forEach(function (animateItem) {
      var prop = animateItem.attr,
        oldItem = newAnimate[prop],
        from;
      animateItem = {
        attr: prop,
        to: animateItem.to,
        type: animateItem.type || 'number',
        delay: animateItem.delay || 0,
        dur: animateItem.dur || 1000,
        interval: animateItem.interval || 0,
        finish: animateItem.finish,
        repeat: animateItem.repeat || 1,
        reverse: animateItem.reverse == null ? true : animateItem.reverse,
        onDone: animateItem.onDone,
        easing: animateItem.easing,
        trigger: animateItem.to == null,
        
        start: now,
        time: 0,
        total: 0,
        count: 0,
        started: false,
        stopped: false,
        current: null
      };
      if (Array.isArray(animateItem.dur)) {
        animateItem.groupDur = animateItem.dur.slice(0, animateItem.dur.length - 1);
        animateItem.dur = animateItem.dur[animateItem.dur.length - 1];
        animateItem.groupDurTotal = animateItem.groupDur.reduce(function (pre, item, index) {
          return animateItem.groupDur[index] = pre + item;
        }, 0);
        animateItem.groupIndex = 0;
        animateItem.groupTime = 0;
        animateItem.groupStart = now;
      }
      (animateItem.finish == null) && (animateItem.finish = animateItem.delay + animateItem.dur + animateItem.interval);
      if (!oldItem) {
        from = getVectorValue(data, vector, shapeData, prop, view);
        newAnimate[prop] = animateItem;
      } else if (Array.isArray(oldItem)) {
        oldItem.push(animateItem);
        oldItem = oldItem[oldItem.length - 2];
      } else {
        newAnimate[prop] = [ oldItem, animateItem ];
      }
      if (oldItem) {
        from = oldItem.to;
        if (oldItem.type === 'group_set') {
          from = from[from.length - 1];
        }
      }
      animateItem.from = from;
      if (!animateItem.trigger) {
        animateItem.started = true;
        setDefaultValue(animateItem);
        refreshDelta(animateItem);
      }
    });
  }

  animate = newAnimate;
  Object.keys(animate).forEach(function (attr) {
    var animateItem = animate[attr];
    if (Array.isArray(animateItem)) {
      var lastAnimateItem = animateItem[animateItem.length - 1];
      if (lastAnimateItem.count + 1 === lastAnimateItem.repeat) {
        animateItem.forEach(function (animateItem) {
          refreshAnimateItem(animateItem, shapeData, vector, data, view, true);
        });
      } else if (lastAnimateItem.count + 1 < lastAnimateItem.repeat) {
        if (lastAnimateItem.total >= lastAnimateItem.finish) {
          animateItem.forEach(function (animateItem) {
            if (!animateItem.trigger) {
              animateItem.started = true;
            }
            animateItem.stopped = false;
            animateItem.time = 0;
            animateItem.start = now;
            animateItem.total = 0;
            if (animateItem.type === 'group_set') {
              animateItem.groupIndex = 0;
              animateItem.groupTime = 0;
              animateItem.groupStart = now;
            }
          });
        }
        animateItem.forEach(function (animateItem) {
          refreshAnimateItem(animateItem, shapeData, vector, data, view, false);
        });
      }
    } else {
      refreshAnimateItem(animateItem, shapeData, vector, data, view, true);
    }
  });
}

function refreshAnimateItem (animateItem, shapeData, vector, data, view, end) {
  if (animateItem.trigger) {
    var to = getVectorValue(data, vector, shapeData, animateItem.attr, view, null, false);
    if (!animateItem.started) {
      if (to === animateItem.from) {
        return;
      } else {
        animateItem.started = true;
        animateItem.start = view._now;
        animateItem.to = to;
        setDefaultValue(animateItem);
        refreshDelta(animateItem);
      }
    }
    if (animateItem.started && to !== animateItem.to) {
        animateItem.start = view._now;
        animateItem.from = animateItem.current;
        animateItem.to = to;
        animateItem.time = 0;
        animateItem.total = 0;
        animateItem.count = 0;
        setDefaultValue(animateItem);
        refreshDelta(animateItem);
    }
  }
  if (animateItem.started && !animateItem.stopped) {
    var now = view._now;
    var time = now - animateItem.start;
    if (time >= animateItem.delay) {
      animateItem.total = time;
      time = time - animateItem.delay;
      animateItem.time = time > animateItem.dur ? animateItem.dur : time;
      if (animateItem.type === 'group_set') {
        animateItem.groupTime = now - animateItem.groupStart;
        if (animateItem.groupStart === animateItem.start) {
          animateItem.groupTime -= animateItem.delay;
        }
        if (animateItem.groupTime >= animateItem.groupDur[animateItem.groupIndex]) {
          animateItem.groupIndex++;
          //console.log(time, animateItem.groupTime, animateItem.groupIndex);
        }
        if (animateItem.groupTime >= animateItem.groupDurTotal) {
          animateItem.groupIndex = 0;
          animateItem.groupTime = animateItem.groupTime - animateItem.groupDurTotal;
          animateItem.groupStart = now;
        }
        //console.log(time, animateItem.groupTime, animateItem.groupStart, animateItem.start, animateItem.groupIndex);
      }
      if (animateItem.total >= animateItem.finish) {
        animateItem.count++;
        if (animateItem.type === 'group_set') {
          /*animateItem.groupIndex = 0;
          animateItem.groupTime = 0;
          animateItem.groupStart = now;*/
        }
        if (animateItem.count >= animateItem.repeat) {
          animateItem.time = animateItem.dur;
          animateItem.stopped = true;
          if (animateItem.trigger) {
            animateItem.from = animateItem.to;
            animateItem.to = null;
            animateItem.start = null;
            animateItem.time = 0;
            animateItem.total = 0;
            animateItem.count = 0;
            animateItem.started = false;
            animateItem.stopped = false;
          }
          animateItem.onDone && animateItem.onDone.call(vector, data, view);
        } else if (end) {
          animateItem.time = 0;
          animateItem.start = now;
          animateItem.total = 0;
          if (animateItem.reverse) {
            var from = animateItem.from;
            animateItem.from = animateItem.to;
            animateItem.to = from;
            refreshDelta(animateItem);
          }
        }
      }
    }
    view && !view._invalidate && (view._invalidate = true);
  }
}

(function () {
  var vendors = ['webkit', 'moz'];
  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];
    window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);
  }
  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy
      || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function(callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function() { callback(lastTime = nextTime); }, nextTime - now);
    };
    window.cancelAnimationFrame = clearTimeout;
  }
}());

var Animate = twaver.Animate = function (animate) {
  var self = this;
  self.type = animate.type == null ? 'number' : animate.type;
  self.delay = animate.delay == null ? 0 : animate.delay;
  self.dur = animate.dur == null ? 1000 : animate.dur;
  self.interval = animate.interval == null ? 0 : animate.interval;
  self.finish = animate.finish == null ? self.delay + self.dur + self.interval : animate.finish;
  if (animate.finish == null) {
    self.finish = self.delay + self.dur + self.interval;
  } else {
    self.finish = animate.finish;
    self.interval = self.finish - self.delay - self.dur;
  }
  self.repeat = animate.repeat == null ? 1 : animate.repeat;
  self.reverse = animate.reverse == null ? true : animate.reverse;
  self.easing = animate.easing == null ? 'easeNone' : animate.easing;

  self.onUpdate = animate.onUpdate;
  self.onDone = animate.onDone;
  self.onStop = animate.onStop;
  self.onPlay = animate.onPlay;
  self.attr = animate.attr;
  self.source = animate.source;
  self.filter = animate.filter;
  self.from = animate.from;
  self.to = animate.to;

  self.start = null;
  self.time = 0;
  self.total = 0;
  self.count = 0;
  self.started = false;
  self.stopped = false;
  self.paused = false;
  self.pausedTime = null;
  self.pausedTotal = 0;
  self._speed = 1;
  self._oldSpeed = null;
  self._speedTotal = 0;
  self._speedTime = null;
  self._percent = 0;
  self._percentSet = null;
  self._percentDiff = 0;

  self.id = next_animate_id++;
};
_twaver.ext('twaver.Animate', Object, {
  play: function () {
    return playAnimate(this);
  },
  stop: function (end) {
    return stopAnimate(this, end);
  },
  pause: function () {
    if (!this.stopped) {
      this.paused = true;
    }
  },
  resume: function () {
    if (this.paused) {
      this.paused = false;
      need_animate = true;
    }
  },
  isPaused: function () {
    return this.paused;
  },
  percent: function (percent) {
    if (percent == null) {
      return this._percentSet || this._percent;
    }
    this._percentSet = percent < 0 ? 0 : (percent > 100 ? 100 : percent);
    if (this.paused) {
      need_animate = true;
    }
    if (!this.started) {
      this.play();
      this.pause();
    }
    return this;
  },
  speed: function (speed) {
    if (speed == null) {
      return this._speed;
    }
    speed = speed < 0 ? 1 : speed;
    if (speed !== this.speed) {
      if (!this.stopped) {
        this._oldSpeed = this._speed;
      }
      this._speed = speed;
    }
    return this;
  },
  clone: function () {
    return new Animate(this);
  },
  chain: function (animate) {
    var self = this,
      oldOnDone;
    self.next = animate;
    animate.pre = self;
    if (self.onDone) {
      oldOnDone = self.onDone;
      self.onDone = function () {
        oldOnDone.call(self);
        animate.play();
      };
    } else {
      self.onDone = function () {
        animate.play();
      };
    }
    return self;
  }
});

function playAnimate (animate) {
  if (!animates[animate.id]) {
    need_animate = true;
    animates[animate.id] = animate;

    if (animate.from == null && animate.attr && animate.source) {
      var match;
      if (match = animate.attr.match(/^S[:@](.*)/i)) {
        animate.from = animate.source.getStyle(match[1]);
      } else if (match = animate.attr.match(/^C[:@](.*)/i)) {
        animate.from = animate.source.getClient(match[1]);
      } else {
        animate.from = twaver.Util.getValue(animate.source, animate.attr);
      }
    }
    setDefaultValue(animate);
    refreshDelta(animate);
  }
  animate.resume();
  return animate;
}

function stopAnimate (animate, end) {
  if (animates[animate.id]) {
    (end == null) && (end = true);
    if (end) {
      updateAnimateValue(animate, animate.to);
    }
    if (animate.onStop) {
      animate.onStop();
    }
    animate.time = 0;
    animate.total = 0;
    animate.start = null;
    animate.count = 0;
    animate.started = false;
    animate.stopped = false;
    animate.paused = false;
    animate.pausedTime = null;
    animate.pausedTotal = 0;
    animate._oldSpeed = null;
    animate._speedTotal = 0;
    animate._speedTime = null;
    animate._percent = 0;
    animate._percentSet = null;
    animate._percentDiff = 0;
    delete animates[animate.id];
  }
  return animate;
}

function stopAllAnimates (end) {
  (end == null) && (end = true);
  Object.keys(animates).forEach(function (animateId) {
    var animate = animates[animateId];
    if (!animate) {
      return;
    }
    if (end) {
      updateAnimateValue(animate, animate.to);
    }
    if (animate.onStop) {
      animate.onStop();
    }
  });
  animates = {};
}

function pauseAllAnimates () {
  Object.keys(animates).forEach(function (animateId) {
    var animate = animates[animateId];
    if (!animate) {
      return;
    }
    animate.pause();
  });
}

function resumeAllAnimates () {
  Object.keys(animates).forEach(function (animateId) {
    var animate = animates[animateId];
    if (!animate) {
      return;
    }
    animate.resume();
  });
}

function doAnimate (time) {
  Object.keys(animates).forEach(function (animateId) {
    var animate = animates[animateId];
    if (!animate) {
      return;
    }
    (animate.start == null) && (animate._speedTime = animate.start = time);
    if (animate._percentSet != null) {
      animate._percentDiff += (animate._percentSet - animate._percent) * animate.finish;
    }
    if (animate.paused) {
      if (!animate.pausedTime) {
        animate.pausedTime = time;
      }
      if (animate._percentSet == null) {
        return;
      }
    }
    if (animate._percentSet == null && animate.pausedTime) {
      animate.pausedTotal += (time - animate.pausedTime) * (animate._oldSpeed || animate._speed);
      animate.pausedTime = null;
    }
    if (animate._oldSpeed && !animate.pausedTime) {
      animate._speedTotal = (time - animate._speedTime) * animate._oldSpeed - animate.pausedTotal + animate._percentDiff + animate._speedTotal;
      animate._percentDiff = 0;
      animate.pausedTotal = 0;
      animate._speedTime = time;
      animate._oldSpeed = null;
    }
    animate.total = (time - animate._speedTime) * animate._speed - animate.pausedTotal + animate._percentDiff + animate._speedTotal;
    if (animate._percentSet != null && animate.pausedTime) {
      animate.total -= (time - animate.pausedTime) * (animate._oldSpeed || animate._speed);
    }
    animate._percent = animate.total >= animate.finish ? 1 : animate.total / animate.finish;
    if (animate.total > animate.delay) {
      animate.time = animate.total - animate.delay;
      var stopped = false;
      if (animate.time >= animate.dur) {
        animate.time = animate.dur;
        if (animate.total >= animate.finish) {
          stopped = true;
        }
      }
      !animate.stopped && updateAnimateValue(animate, getAnimateValue(animate));
      animate.stopped = stopped;
      if (animate.total >= animate.finish) {
        animate.count++;
        if (animate.count >= animate.repeat) {
          stopAnimate(animate, false);
          animate.onDone && animate.onDone();
        } else {
          animate.time = 0;
          animate.total = 0;
          animate.start = null;
          animate.stopped = false;
          if (animate.reverse) {
            var from = animate.from;
            animate.from = animate.to;
            animate.to = from;
            refreshDelta(animate);
          }
        }
      }
    }
    if (!animate.paused) {
      !need_animate && (need_animate = true);
    }
    if (animate._percentSet != null) {
      animate._percentSet = null;
    }
  });
}

function updateAnimateValue (animate, value) {
  if (!animate.started) {
    animate.started = true;
    animate.onPlay && animate.onPlay();
  }
  animate.filter && (value = animate.filter(value));
  if (animate.attr && animate.source) {
    var match;
    if (match = animate.attr.match(/^S[:@](.*)/i)) {
      animate.source.setStyle(match[1], value);
    } else if (match = animate.attr.match(/^C[:@](.*)/i)) {
      animate.source.setClient(match[1], value);
    } else {
      twaver.Util.setValue(animate.source, animate.attr, value);
    }
  }
  if (animate.onUpdate) {
    animate.onUpdate(value);
  }
}

function setDefaultValue (animateItem) {
  var type = animateItem.type,
    from = animateItem.from,
    to = animateItem.to;
  if (type === 'number') {
    animateItem.from = from || 0;
    animateItem.to = to || 0;
  } else if (type === 'point') {
    if (from) {
      from.length && (animateItem.from = { x: from[0], y: from[1] });
    } else {
      animateItem.from = animateItem.attr === 'scale' ? { x: 1, y: 1 } : { x: 0, y: 0 };
    }
    if (to) {
      to.length && (animateItem.to = { x: to[0], y: to[1] });
    } else {
      animateItem.to = animateItem.attr === 'scale' ? { x: 1, y: 1 } : { x: 0, y: 0 };
    }
  } else if (type === 'rect') {
    if (from) {
      from.length && (animateItem.from = { x: from[0], y: from[1], w: from[2], h: from[3] });
    } else {
      animateItem.from = { x: 0, y: 0, w: 0, h: 0 };
    }
    if (to) {
      to.length && (animateItem.to = { x: to[0], y: to[1], w: to[2], h: to[3] });
    } else {
      animateItem.to = { x: 0, y: 0, w: 0, h: 0 };
    }
  } else if (type === 'color') {
    animateItem.from = getColorValue(from);
    animateItem.to = getColorValue(to);
  } else if (type === 'set') {
    // do nothing
  } else if (type === 'group_set') {
    // do nothing
  }
  animateItem.current = animateItem.from;
}

function refreshDelta (animateItem) {
  var type = animateItem.type,
    from = animateItem.from,
    to = animateItem.to;
  if (type === 'number') {
    animateItem.delta = to - from;
  } else if (type === 'point') {
    animateItem.delta = {
      x: to.x - from.x,
      y: to.y - from.y
    };
  } else if (type === 'rect') {
    animateItem.delta = {
      x: to.x - from.x,
      y: to.y - from.y,
      w: to.w - from.w,
      h: to.h - from.h
    };
  } else if (type === 'color') {
    animateItem.delta = { r: to.r - from.r, g: to.g - from.g, b: to.b - from.b, a: to.a - from.a };
  } else if (type === 'set') {
    // do nothing
  } else if (type === 'group_set') {
    // do nothing
  }
}

function getAnimateValue (animateItem, value) {
  var type = animateItem.type,
    delta = animateItem.delta,
    from = animateItem.from,
    time = animateItem.time,
    dur = animateItem.dur,
    easing = Easing[animateItem.easing || 'easeNone'];
  if (!easing) {
    easing = Easing.easeNone;
  }
  if (type === 'number') {
    value = easing(time, from, delta, dur);
  } else if (type === 'point') {
    value = {
      x: easing(time, from.x, delta.x, dur),
      y: easing(time, from.y, delta.y, dur)
    };
  } else if (type === 'rect') {
    value = {
      x: easing(time, from.x, delta.x, dur),
      y: easing(time, from.y, delta.y, dur),
      w: easing(time, from.w, delta.w, dur),
      h: easing(time, from.h, delta.h, dur)
    };
  } else if (type === 'color') {
    value = 'rgba(' +
      Math.floor(easing(time, from.r, delta.r, dur)) + ',' +
      Math.floor(easing(time, from.g, delta.g, dur)) + ',' +
      Math.floor(easing(time, from.b, delta.b, dur)) + ',' +
      Math.floor(easing(time, from.a, delta.a, dur)) + ')';
  } else if (type === 'set') {
    if (animateItem.time) {
      value = animateItem.to;
    }
  } else if (type === 'group_set') {
    value = animateItem.to[animateItem.groupIndex];
  }
  animateItem.current = value;
  return value;
}

var animates = {},
  next_animate_id = 1,
  need_animate = false;

(function animateLoop (time) {
  twaver.animateLoopId = requestAnimationFrame(animateLoop);
  if (need_animate) {
    need_animate = false;
    doAnimate(time);
  }
})(0);

var Easing = {

    /**
     * Uniform speed between points.
     * @for Easing
     * @method easeNone
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeNone: function (t, b, c, d) {
        return c*t/d + b;
    },

    /**
     * Begins slowly and accelerates towards end. (quadratic)
     * @method easeIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeIn: function (t, b, c, d) {
        return c*(t/=d)*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.  (quadratic)
     * @method easeOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOut: function (t, b, c, d) {
        return -c *(t/=d)*(t-2) + b;
    },

    /**
     * Begins slowly and decelerates towards end. (quadratic)
     * @method easeBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBoth: function (t, b, c, d) {
        if ((t /= d/2) < 1) {
            return c/2*t*t + b;
        }

        return -c/2 * ((--t)*(t-2) - 1) + b;
    },

    /**
     * Begins slowly and accelerates towards end. (quartic)
     * @method easeInStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeInStrong: function (t, b, c, d) {
        return c*(t/=d)*t*t*t + b;
    },

    /**
     * Begins quickly and decelerates towards end.  (quartic)
     * @method easeOutStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeOutStrong: function (t, b, c, d) {
        return -c * ((t=t/d-1)*t*t*t - 1) + b;
    },

    /**
     * Begins slowly and decelerates towards end. (quartic)
     * @method easeBothStrong
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    easeBothStrong: function (t, b, c, d) {
        if ((t /= d/2) < 1) {
            return c/2*t*t*t*t + b;
        }

        return -c/2 * ((t-=2)*t*t*t - 2) + b;
    },

    /**
     * Snap in elastic effect.
     * @method elasticIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */

    elasticIn: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }
        if ( (t /= d) === 1 ) {
            return b+c;
        }
        if (!p) {
            p = d* 0.3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            s = p/4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
    },

    /**
     * Snap out elastic effect.
     * @method elasticOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticOut: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }
        if ( (t /= d) === 1 ) {
            return b+c;
        }
        if (!p) {
            p=d * 0.3;
        }

        if (!a || a < Math.abs(c)) {
            a = c;
            s = p / 4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
    },

    /**
     * Snap both elastic effect.
     * @method elasticBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} a Amplitude (optional)
     * @param {Number} p Period (optional)
     * @return {Number} The computed value for the current animation frame
     */
    elasticBoth: function (t, b, c, d, a, p) {
        var s;
        if (t === 0) {
            return b;
        }

        if ( (t /= d/2) === 2 ) {
            return b+c;
        }

        if (!p) {
            p = d*(0.3*1.5);
        }

        if ( !a || a < Math.abs(c) ) {
            a = c;
            s = p/4;
        }
        else {
            s = p/(2*Math.PI) * Math.asin (c/a);
        }

        if (t < 1) {
            return -0.5*(a*Math.pow(2,10*(t-=1)) *
                    Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
        }
        return a*Math.pow(2,-10*(t-=1)) *
                Math.sin( (t*d-s)*(2*Math.PI)/p )*0.5 + c + b;
    },


    /**
     * Backtracks slightly, then reverses direction and moves to end.
     * @method backIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backIn: function (t, b, c, d, s) {
        if (s === undefined) {
            s = 1.70158;
        }
        if (t === d) {
            t -= 0.001;
        }
        return c*(t/=d)*t*((s+1)*t - s) + b;
    },

    /**
     * Overshoots end, then reverses and comes back to end.
     * @method backOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backOut: function (t, b, c, d, s) {
        if (typeof s === 'undefined') {
            s = 1.70158;
        }
        return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
    },

    /**
     * Backtracks slightly, then reverses direction, overshoots end,
     * then reverses and comes back to end.
     * @method backBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @param {Number} s Overshoot (optional)
     * @return {Number} The computed value for the current animation frame
     */
    backBoth: function (t, b, c, d, s) {
        if (typeof s === 'undefined') {
            s = 5.70158;
        }

        if ((t /= d/2 ) < 1) {
            return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
        }
        return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
    },

    /**
     * Bounce off of start.
     * @method bounceIn
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceIn: function (t, b, c, d) {
        return c - Easing.bounceOut(d-t, 0, c, d) + b;
    },

    /**
     * Bounces off end.
     * @method bounceOut
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceOut: function (t, b, c, d) {
        if ((t/=d) < (1/2.75)) {
                return c*(7.5625*t*t) + b;
        } else if (t < (2/2.75)) {
                return c*(7.5625*(t-=(1.5/2.75))*t + 0.75) + b;
        } else if (t < (2.5/2.75)) {
                return c*(7.5625*(t-=(2.25/2.75))*t + 0.9375) + b;
        }
        return c*(7.5625*(t-=(2.625/2.75))*t + 0.984375) + b;
    },

    /**
     * Bounces off start and end.
     * @method bounceBoth
     * @param {Number} t Time value used to compute current value
     * @param {Number} b Starting value
     * @param {Number} c Delta between start and end values
     * @param {Number} d Total length of animation
     * @return {Number} The computed value for the current animation frame
     */
    bounceBoth: function (t, b, c, d) {
        if (t < d/2) {
            return Easing.bounceIn(t * 2, 0, c, d) * 0.5 + b;
        }
        return Easing.bounceOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
    }
};
var $backgroundUI = {
    draw: function(ctx, network) {
        var target = network.getCurrentSubNetwork() == null ? network.getElementBox() : network.getCurrentSubNetwork();
        var type = target.getStyle("background.type");
        if(type == "none") {
            //do nothing
        }
        if(type == "image") {
            this.drawImage(ctx, target,network);

        } else if(type == "vector") {
           this.drawVector(ctx, target,network);
        } else if(type == "image.vector") {
            this.drawImage(ctx, target,network);
            this.drawVector(ctx, target,network);

        } else if(type == "vector.image") {
            this.drawVector(ctx, target,network);
            this.drawImage(ctx, target,network);
        }
    },
    drawImage: function(ctx,target,network) {
        var image = target.getStyle("background.image");
        var imageAsset = _twaver.getImageAsset(image);
        var zoom = network.getGraphicsZoom ? network.getGraphicsZoom() : network.getZoom();
        if(imageAsset == null){
            return;
        }
        var scope = target.getStyle("background.image.scope");
        var rect = network.getScopeRect(scope);
        var vx = network._dragToPan ? 0 : -rect.x/zoom;
        var vy = network._dragToPan ? 0 : -rect.y/zoom;
        if(scope == "rootcanvas" || scope == 'viewport'){
            rect.x = vx;
            rect.y = vy;
        }
        if(scope == 'rootcanvas'){
            rect.width = Math.max(imageAsset.getWidth(), rect.width/zoom);
            rect.height = Math.max(imageAsset.getHeight(), rect.height/zoom);
        }
        if(target.getStyle("background.image.stretch") == "none") {
            rect.width = imageAsset.getWidth();
            rect.height = imageAsset.getHeight();
        }
        var padding = target.getStyle("background.image.padding");
        if(padding) {
            $math.grow(rect, padding, padding);
        }
        if(target.getStyle("background.image.stretch") == "tile") {
            if(isImage(imageAsset.getImage())) {
                for (var w = 0; w < rect.width; w += imageAsset.getWidth()) {
                    for (var h = 0; h < rect.height; h  += imageAsset.getHeight()) {
                        ctx.drawImage(imageAsset.getImage(), w, h);
                    }
                }
            }
        } else if(target.getStyle("background.image.stretch") == "fill" || target.getStyle("background.image.stretch") == "none") {
            drawImage(ctx,imageAsset.getImage(),null,rect,target,network);
        }
    },
    drawVector: function(ctx,target,network) {
        var scope = target.getStyle("background.vector.scope");
        var rect = network.getScopeRect(scope);
        var zoom = network.getGraphicsZoom ? network.getGraphicsZoom() : network.getZoom();
        var vx = network._dragToPan ? 0 : -rect.x/zoom;
        var vy = network._dragToPan ? 0 : -rect.y/zoom;
        if(scope == "rootcanvas" || scope == 'viewport'){
            rect.x = vx;
            rect.y = vy;
        }
        if(scope == 'rootcanvas'){
            rect.width = rect.width/zoom;
            rect.height = rect.height/zoom;
        }
        // var rect = {x:0,y:0,width:ctx.canvas.width,height:ctx.canvas.height};
        var outlineWidth = target.getStyle("background.outline.width");
        var outlineColor = target.getStyle("background.outline.color");
        var fill = target.getStyle("background.vector.fill");
        var fillColor = target.getStyle('background.vector.fill.color');
        var padding = target.getStyle("background.vector.padding");
        var shape = target.getStyle("background.vector.shape");
        var pattern = target.getStyle("background.vector.pattern");
        if(padding) {
            $math.grow(rect, padding, padding);
        }
        var gradient = target.getStyle('background.vector.gradient');
        if (fill) {
            if (gradient) {
                $g.fill(ctx, fillColor, gradient, target.getStyle("background.vector.gradient.color"), rect);
            } else {
                ctx.fillStyle = fillColor;
            }
            $g.drawVector(ctx, shape, pattern, rect);
            ctx.fill();
        }
        if(outlineWidth > 0) {
            ctx.lineWidth = outlineWidth;
            ctx.strokeStyle = target.getStyle('background.outline.color');
            $g.drawVector(ctx, shape, pattern, rect);
            ctx.stroke();
        }
    }
};
var UndoManager = twaver.UndoManager = function (box) {
  var self = this;
  self._list = [];
  self._cursor = -1;
  self._suspended = false;
  self._dispatcher = new twaver.EventDispatcher();
  self._box = box;
  self._enabled = false;
  self._limit = 100;
};

UndoManager._IGNORE_PROPERTIES = {
  alarmState: 1,
  propagateSeverity: 1,
  enablePropagation: 1,
  children: 1,
  fromAgent: 1,
  toAgent: 1,
  bundleLinks: 1
};

_twaver.ext('twaver.UndoManager', Object, {
  setEnabled: function (enabled) {
    var self = this,
      box = self._box;
    if (self._enabled != enabled) {
      if (enabled) {
        box.addDataBoxChangeListener(self._handleDataBoxChange, self, true);
        box.addDataPropertyChangeListener(self._handleDataPropertyChange, self, true);
      } else {
        box.removeDataBoxChangeListener(self._handleDataBoxChange, self);
        box.removeDataPropertyChangeListener(self._handleDataPropertyChange, self);
      }
    }
    self._enabled = enabled;
  },
  isEnabled: function () {
    return this._enabled;
  },
  undo: function () {
    var self = this,
      list = self._list,
      action, i, c;
    if (!self.canUndo()) {
      return;
    }
    action = list[self._cursor--];
    self._suspended = true;
    if (action.length) {
      for (c = action.length, i = c - 1; i >= 0; i--) {
        action[i].undo();
      }
    } else {
      action.undo();
    }
    self._suspended = false;
    self._fire({
      kind: 'undo',
      action: action
    });
  },
  redo: function () {
    var self = this,
      list = self._list,
      action;
    if (!self.canRedo()) {
      return;
    }
    action = list[++self._cursor];
    self._suspended = true;
    if (action.length) {
      action.forEach(function (item) {
        item.redo();
      });
    } else {
      action.redo();
    }
    self._suspended = false;
    self._fire({
      kind: 'redo',
      action: action
    });
  },
  canUndo: function () {
    return this._cursor >= 0;
  },
  canRedo: function () {
    return this._cursor < this._list.length - 1;
  },
  _add: function (action) {
    var self = this,
      batch = self._batch,
      list = self._list;
    if (batch) {
      batch.push(action);
    } else {
      if (self._cursor !== list.length - 1) {
        list.splice(self._cursor + 1, list.length);
      }
      if (self._limit !== 0 && list.length === self._limit) {
        list.splice(0, 1);
      }
      list.push(action);
      self._cursor = list.length - 1;
      self._fire({
        kind: 'add',
        action: action
      });
    }
  },
  _handleDataBoxChange: function (e) {
    if (this._suspended) {
      return;
    }
    var self = this,
      box = self._box,
      kind = e.kind,
      data = e.data;
    if (kind === 'add') {
      self._add({
        undo: function () {
          var self = this;
          self.parent = data.getParent();
          self.host = data.getHost && data.getHost();
          if (data.getFromNode) {
            self.fromNode = data.getFromNode();
            self.toNode = data.getToNode();
          }
          box.remove(data);
        },
        redo: function () {
          var self = this;
          self.parent && data.setParent(self.parent);
          data.getHost && self.host && data.setHost(self.host);
          if (data.getFromNode) {
            self.fromNode && data.setFromNode(self.fromNode);
            self.toNode && data.setToNode(self.toNode);
          }
          box.add(data);
        }
      });
    } else if (kind === 'remove') {
      self._add({
        undo: function () {
          box.add(data);
        },
        redo: function () {
          box.remove(data);
        }
      });
    }
  },
  _handleDataPropertyChange: function (e) {
    if (this._suspended) {
      return;
    }
    var self = this,
      property = e.property,
      prefix = property.substr(0, 2),
      data = e.source,
      oldValue = e.oldValue,
      newValue = e.newValue;
    if (prefix === 'C:') {
      property = property.substr(2);
      self._add({
        undo: function () {
          data.setClient(property, oldValue);
        },
        redo: function () {
          data.setClient(property, newValue);
        }
      });
    } else if (prefix === 'S:') {
      property = property.substr(2);
      self._add({
        undo: function () {
          data.setStyle(property, oldValue);
        },
        redo: function () {
          data.setStyle(property, newValue);
        }
      });
    } else {
      if (UndoManager._IGNORE_PROPERTIES[property]) {
        ;
      } else {
        self._add({
          undo: function () {
            data[_twaver.setter(property)](oldValue);
          },
          redo: function () {
            data[_twaver.setter(property)](newValue);
          }
        });
      }
    }
  },
  size: function () {
    return this._list.length;
  },
  getCursor: function () {
    return this._cursor;
  },
  _fire: function (e) {
    this._dispatcher.fire(e);
  },
  on: function (listener, scope, ahead) {
    this._dispatcher.add(listener, scope, ahead);
  },
  off: function (listener, scope) {
    this._dispatcher.remove(listener, scope);
  },
  isSuspended: function () {
    return this._suspended;
  },
  setSuspended: function (suspended) {
    this._suspended = suspended;
  },
  getLimit: function () {
    return this._limit;
  },
  setLimit: function (limit) {
    var self = this,
      list = self._list,
      trimCount, leftTrimCount;
    limit < 0 && (limit = 0);
    if (limit !== self._limit) {
      trimCount = list.length - limit;
      if (limit > 0 && trimCount > 0) {
        leftTrimCount = self._cursor + 1;
        self._cursor -= trimCount;
        self._cursor < -1 && (self._cursor = -1);
        if (leftTrimCount > 0) {
          list.splice(0, leftTrimCount);
        }
        trimCount -= leftTrimCount;
        if (trimCount > 0) {
          list.splice(list.length - trimCount, trimCount);
        }
      }
      self._limit = limit;
      self._fire({
        kind: 'change'
      });
    }
    return self;
  },
  clear: function () {
    var self = this;
    self._list = [];
    self._cursor = -1;
    self._fire({
      kind: 'clear'
    });
    return self;
  },
  batch: function (callback, scope) {
    var self = this;
    self.startBatch();
    callback.call(scope);
    self.endBatch();
    return self;
  },
  startBatch: function () {
    var self = this;
    if (!self._batch) {
      self._batch = [];
    }
    return self;
  },
  endBatch: function () {
    var self = this,
      batch;
    if (self._batch) {
      batch = self._batch;
      self._batch = null;
      batch.length && self._add(batch);
    }
    return self;
  }
});

twaver.Pool = function (tagName, redundancy) {
    if (typeof tagName === 'string') {
        this.func = function () {
            return document.createElement(tagName);
        }
    } else {
        this.func = tagName;
    }
    this.tagName = tagName;
    if (redundancy != null) {
        this.redundancy = redundancy;
    }
};
_twaver.ext('twaver.Pool', Object, {
    redundancy: 2,
    currentIndex: -1,
    get: function () {
        this.currentIndex++;
        if (this.currentIndex === this.size()) {
            var html = this.func();
            html._pool = this;
            html.style.margin = '0px';
            html.style.padding = '0px';
            if (!this.list) {
                this.list = new $List();
            }
            this.list.add(html);
            return html;
        }
        return this.list.get(this.currentIndex);
    },
    release: function (html) {
        if (this.list && this.list.remove(html) >= 0) {
            delete html._selectData;
            delete html._expandData;
            delete html._checkData;
            delete html._editInfo;
            delete html.keepDefault;
            html.style.margin = '0px';
            html.style.padding = '0px';
            html.style.backgroundColor = '';
            html.removeAttribute('title');
            if (this.tagName === 'img' && html.removeAttribute) {
                html.removeAttribute('width');
                html.removeAttribute('height');
                html.removeAttribute('src');
            }
            this.list.add(html);
            this.currentIndex--;
        }
    },
    reset: function () {
        this.currentIndex = -1;
    },
    clear: function () {
        if (this.list) {
            while (this.redundancy + this.currentIndex < this.list.size() - 1) {
                delete this.list.removeAt(this.list.size() - 1)._pool;
            }
        }
    },
    size: function () {
        return this.list ? this.list.size() : 0;
    }
});

var $List = function () {
    this._as = [];
    if (arguments.length === 1) {
        var v = arguments[0];
        if (v instanceof $List) {
            v = v._as;
        }
        if (v instanceof Array) {
            var n = v.length;
            for (var i = 0; i < n; i++) {
                this._as.push(v[i]);
            }
        } else if (v === false) {
            this._duplicatable = false;
            this._map = {};
        } else if (v != null) {
            this._as.push(v);
        }
    } else if (arguments.length > 1) {
        n = arguments.length;
        for (i = 0; i < n; i++) {
            this._as.push(arguments[i]);
        }
    }
};
twaver.List = $List;
_twaver.ext('twaver.List', Object, {
    _duplicatable: true,
    size: function () {
        return this._as.length;
    },
    isEmpty: function () {
        return this._as.length === 0;
    },
    add: function (item, index) {
        if (!this._duplicatable) {
            if (this._map[item._id]) {
                return;
            } else {
                this._map[item._id] = true;
            }
        }
        if (index === undefined) {
            return this._as.push(item);
        } else {
            return this._as.splice(index, 0, item);
        }
    },
    addAll: function (array) {
        if (array instanceof $List) {
            array = array._as;
        }
        if (array instanceof Array) {
            var n = array.length;
            for (var i = 0; i < n; i++) {
                this.add(array[i]);
            }
        } else {
            this.add(array);
        }
    },
    get: function (index) {
        return this._as[index];
    },
    remove: function (item) {
        if (!this._duplicatable && !this._map[item && item._id]) {
            return -1;
        }
        var index = this._as.indexOf(item);
        if (index >= 0 && index < this._as.length) {
            this.removeAt(index);
        }
        return index;
    },
    removeAt: function (index) {
        var item = this._as.splice(index, 1)[0];
        if (!this._duplicatable && item) {
            delete this._map[item._id];
        }
        return item;
    },
    set: function (index, item) {
        var oldItem = this._as[index];
        if (oldItem === item) {
            return item;
        }
        if (!this._duplicatable) {
            if (this._map[item._id]) {
                throw 'duplicate item:' + item;
            }
            delete this._map[oldItem._id];
            this._map[item._id] = true;
        }
        this._as[index] = item;
        return oldItem;
    },
    clear: function () {
        if (!this._duplicatable) {
            this._map = {};
        }
        return this._as.splice(0, this._as.length);
    },
    contains: function (item) {
        if (this._duplicatable) {
            return this.indexOf(item) >= 0;
        } else {
            return !!this._map[item && item._id];
        }
    },
    indexOf: function (item) {
        return this._as.indexOf(item);
    },
    forEach: function (f, scope) {
        var n = this._as.length;
        for (var i = 0; i < n; i++) {
            var e = this._as[i];
            if (scope) {
                f.call(scope, e)
            } else {
                f(e);
            }
        }
    },
    forEachReverse: function (f, scope) {
        var n = this._as.length;
        for (var i = n - 1; i >= 0; i--) {
            var e = this._as[i];
            if (scope) {
                f.call(scope, e)
            } else {
                f(e);
            }
        }
    },
    toArray: function (matchFunction, scope) {
        if (matchFunction) {
            var list = [];
            var n = this._as.length;
            for (var i = 0; i < n; i++) {
                var e = this._as[i];
                if (scope) {
                    if (matchFunction.call(scope, e)) {
                        list.push(e);
                    }
                } else {
                    if (matchFunction(e)) {
                        list.push(e);
                    }
                }
            }
            return list;
        } else {
            return this._as.concat();
        }
    },
    toList: function (matchFunction, scope) {
        if (matchFunction) {
            var list = new $List();
            var n = this._as.length;
            for (var i = 0; i < n; i++) {
                var e = this._as[i];
                if (scope) {
                    if (matchFunction.call(scope, e)) {
                        list.add(e);
                    }
                } else {
                    if (matchFunction(e)) {
                        list.add(e);
                    }
                }
            }
            return list;
        } else {
            return new $List(this);
        }
    },
    sort: function (sortFunction) {
        if (sortFunction) {
            this._as.sort(sortFunction);
        } else {
            this._as.sort();
        }
        return this;
    },
    toString: function () {
        return this._as.toString();
    }
});

var $arrow = {
    shapeMap: {},
    init: function () {
        $arrow.register('arrow.standard', $arrow.createStandardArrow());
        $arrow.register('arrow.delta', $arrow.createDeltaArrow());
        $arrow.register('arrow.diamond', $arrow.createDiamondArrow());
        $arrow.register('arrow.short', $arrow.createShortArrow());
        $arrow.register('arrow.slant', $arrow.createSlantArrow());
        $arrow.register('arrow.doubledelta', $arrow.createDoubleDeltaArrow());
        $arrow.register('arrow.tee', $arrow.createTeeArrow());
        $arrow.register('arrow.box', $arrow.createBoxArrow());
        $arrow.register('arrow.dot', $arrow.createDotArrow());
        $arrow.register('arrow.tail', $arrow.createTailArrow());
    },
    createStandardArrow: function () {
        var pointArray = new $List();
        pointArray.add({
            x: -1,
            y: -5 / 9
        });
        pointArray.add({
            x: -9 / 12,
            y: 0
        });
        pointArray.add({
            x: -1,
            y: 5 / 9
        });
        pointArray.add({
            x: 0,
            y: 0
        });
        pointArray.add({
            x: -1,
            y: -5 / 9
        });
        return {points:pointArray};
    },
    createDeltaArrow: function () {
        var pointArray = new $List();
        pointArray.add({ x: -1, y: -5 / 9 });
        pointArray.add({ x: -1, y: 5 / 9 });
        pointArray.add({ x: 0, y: 0 });
        pointArray.add({ x: -1, y: -5 / 9 });
        return {points:pointArray};
    },
    createDoubleDeltaArrow: function () {
        var pointArray = new $List();
        pointArray.add({ x: -1, y: -5 / 9 });
        pointArray.add({ x: -1, y: 5 / 9 });
        pointArray.add({ x: -1/2, y: 0 });
        pointArray.add({ x: -1/2, y: -5/9 });
        pointArray.add({ x: 0, y: 0 });
        pointArray.add({ x: -1/2, y: 5/9 });
        pointArray.add({ x: -1/2, y: 0 });
        pointArray.add({ x: -1, y: -5 / 9 });
        return {points:pointArray};
    },
    createTeeArrow: function() {
       var pointArray = new $List();
       pointArray.add({ x: -1/9, y: -5 / 9 });
       pointArray.add({ x: -1/9, y: 5 / 9 });
       pointArray.add({ x: 0, y: 5 / 9 });
       pointArray.add({ x: 0, y: -5 / 9 });
       pointArray.add({ x: -1/9, y: -5 / 9 });
       return {points:pointArray};  
    },
    createBoxArrow: function() {
        var pointArray = new $List();
        pointArray.add({ x: -10/9, y: -5 / 9 });
        pointArray.add({ x: -10/9, y: 5 / 9 });
        pointArray.add({ x: 0, y: 5 / 9 });
        pointArray.add({ x: 0, y: -5 / 9 });
        pointArray.add({ x: -10/9, y: -5 / 9 });
        return {points:pointArray};  
    },
    createDotArrow: function() {
        var arrow = {};
        var pointArray = new twaver.List();
        pointArray.add({x:-1/2,y:0});
        arrow.points = pointArray;
        arrow.draw = function(ctx,arrow) {
            if(!ctx || !arrow || !arrow.points || arrow.points.size() <= 0) {
                return;
            }
            var points = arrow.points._as;
            var center = points[0];
            var radius = Math.min(arrow.width,arrow.height)/2;
            ctx.save();
            ctx.beginPath();
            ctx.arc(center.x,center.y,radius,0,Math.PI * 2,false);
            ctx.closePath();
            ctx.restore();
        }
        return arrow;
    },
    createTailArrow: function() {
        var arrow = {};
        var pointArray = new twaver.List();
        var tail = 30;
        for(var i =-tail/2;i<tail/2;i++){
            pointArray.add({x:-i/9,y:0});
        }
        arrow.points = pointArray;
       
        arrow.draw = function(ctx,arrow) {
            if(!ctx || !arrow || !arrow.points || arrow.points.size() <= 0) {
                return;
            }
            var points = arrow.points._as;
            var shadow = arrow.shadow;
            var shadowColor = arrow.shadowColor;
            var shadowOffsetX = arrow.shadowXOffset;
            var shadowOffsetY = arrow.shadowYOffset;
            var shadowBlur = arrow.shadowBlur;  
            var shadowColor = arrow.shadowColor;
            var count = points.length - 4;
            var maxRadius = Math.min(arrow.width,arrow.height)/2;
            for(var i = 0; i <count; i++) {
                var v = i / count;
                var center = points[i];
                var radius = maxRadius *0.4;
                ctx.save();
                ctx.restore();
                ctx.beginPath();
                ctx.globalAlpha = v * v;
                if(shadow){
                    ctx.shadowOffsetX = shadowOffsetX;
                    ctx.shadowOffsetY = shadowOffsetY;
                    ctx.shadowBlur = shadowBlur;  
                    ctx.shadowColor = shadowColor;
                }
                ctx.arc(center.x,center.y,radius,0,Math.PI * 2,false);
                ctx.closePath();
                ctx.fill();
            }
            return;
        }
        return arrow;
    },
    createDiamondArrow: function () {
        var pointArray = new $List();
        pointArray.add({ x: -7 / 12, y: 5 / 9 });
        pointArray.add({ x: -14 / 12, y: 0 });
        pointArray.add({ x: -7 / 12, y: -5 / 9 });
        pointArray.add({ x: 0, y: 0 });
        pointArray.add({ x: -7 / 12, y: 5 / 9 });
        return {points:pointArray};
    },
    createShortArrow: function () {
        var pointArray = new $List();
        pointArray.add({ x: -8 / 12, y: 6 / 9 });
        pointArray.add({ x: -5 / 12, y: 0 });
        pointArray.add({ x: -8 / 12, y: -6 / 9 });
        pointArray.add({ x: 0, y: 0 });
        pointArray.add({ x: -8 / 12, y: 6 / 9 });
        return {points:pointArray};
    },
    createSlantArrow: function () {
        var pointArray = new $List();
        pointArray.add({ x: -1, y: -5 / 9 });
        pointArray.add({ x: -6.5 / 12, y: 0 });
        pointArray.add({ x: -9 / 12, y: 4 / 9 });
        pointArray.add({ x: 0, y: 0 });
        pointArray.add({ x: -1, y: -5 / 9 });
        return {points:pointArray};
    },
    register: function (shapeType, arrow) {
        $arrow.shapeMap[shapeType] = arrow;
    },
    getShape: function (shapeType) {
        if (shapeType) {
            return $arrow.shapeMap[shapeType];
        }
        throw "shape type can't be null";
    },
    getArrowRect: function (ui, linePaths, isSrouce, arrowStyle, arrowWidth, arrowHeight, arrowXOffset, arrowYOffset, zoomManager) {
        var arrow = $arrow.getShape(arrowStyle);
        if (!arrow || !arrow.points || (arrow.points && arrow.points.size() <= 0)) {
            return;
        }
        if (arrowXOffset > 0 && arrowXOffset < 1) {
            var lineLength;
            if (ui.getLineLength) {
                lineLength = ui.getLineLength();
            } else {
                lineLength = ui._element.getLineLength();
            }
            arrowXOffset *= lineLength;
        } else if (ui.getLineLength) {
            arrowXOffset += $arrow.calculateArrowXOffsetAtEdge(linePaths, ui, isSrouce, zoomManager);
        }

        // if(zoomManager){
        //     arrowXOffset *= zoomManager.getLocationZoom();
        //     arrowYOffset *= zoomManager.getLocationZoom();
        // }
        var pointInfo = $math.calculatePointInfoAlongLine(linePaths, isSrouce, arrowXOffset, arrowYOffset);
        var translatePoint = pointInfo.point;
        var rotateAngle = pointInfo.angle;
        var points = arrow.points._as;
        var i, c = points.length, newPoints = new $List(), value, matrix;
        matrix = new $Matrix(arrowWidth, 0, 0, arrowHeight, translatePoint.x, translatePoint.y);
        for (i = 0; i < c; i++) {
            newPoints.add(matrix.transform(points[i]));
        }
        matrix = $math.createMatrix(rotateAngle + Math.PI, translatePoint.x, translatePoint.y);
        for (i = 0; i < c; i++) {
            value = newPoints.get(i);
            if (value instanceof $List) {
                value = value._as;
            }
            if (value instanceof Array) {
                value[0] = matrix.transform(value[0]);
                value[1] = matrix.transform(value[1]);
            } else {
                newPoints.set(i, matrix.transform(value));
            }
        }
        return $math.getLineRect(newPoints);
    },
    drawArrow: function (g, arrowWidth, arrowHeight, linePaths, isSrouce, arrowStyle, drawBody, arrowColor, arrowXOffset, arrowYOffset, lineWidth, arrowOutlineColor,ui) {
        arrowXOffset = arrowXOffset || 0;
        arrowYOffset = arrowYOffset || 0;
        lineWidth = lineWidth || 0;

        var shadow = ui._element.getStyle('arrow.from.shadow');
        var shadowColor = ui._element.getStyle('arrow.from.shadow.color');
        var shadowXOffset = ui._element.getStyle('arrow.from.shadow.xoffset');
        var shadowYOffset = ui._element.getStyle('arrow.from.shadow.yoffset');
        var shadowBlur = ui._element.getStyle('arrow.from.shadow.blur');

        var drawOutline = lineWidth >= 0 && arrowOutlineColor;
        if (!drawBody && !drawOutline) {
            return;
        }
        var arrow = $arrow.getShape(arrowStyle);
        if (!arrow ||!arrow.points || (arrow.points && arrow.points.size() <= 0)) {
            return;
        }
        var pointInfo = $math.calculatePointInfoAlongLine(linePaths, isSrouce, arrowXOffset, arrowYOffset);
        var point = pointInfo.point;
        var angle = pointInfo.angle;
        // if(ui && ui._network._debug && ui._element instanceof twaver.Link){
        //     if(isSrouce){
        //         var rect = {x: ui._arrowFromRect.x, y:ui._arrowFromRect.y, width: ui._arrowFromRect.width, height:ui._arrowFromRect.height}
        //     }else{
        //         var rect = {x: ui._arrowToRect.x, y:ui._arrowToRect.y, width: ui._arrowToRect.width, height:ui._arrowToRect.height}
        //     }
        //     $g.strokeRect(g, rect, '#CD5B45');
        // }
        if (drawBody) {
            g.fillStyle = arrowColor;
        }
        g.beginPath();
        if (drawOutline) {
            g.lineWidth = lineWidth;
            g.strokeStyle = arrowOutlineColor;
        }
        $arrow._drawArrow(g, arrow, angle, point, arrowWidth, arrowHeight, arrowOutlineColor,shadowColor,shadow,shadowXOffset,shadowYOffset,shadowBlur);
        if(shadow) {
            g.shadowOffsetX = shadowXOffset;
            g.shadowOffsetY = shadowYOffset;
            g.shadowBlur = shadowBlur;  
            g.shadowColor = shadowColor;
        }
        if (drawBody) {
            g.fill();
        }
        if (drawOutline) {
            g.stroke();
        }
    },
    _drawArrow: function (g, arrow, rotateAngle, translatePoint, sx, sy, arrowOutlineColor,shadowColor,shadow,shadowXOffset,shadowYOffset,shadowBlur) {
        if(!arrow.draw) {
            var points = arrow.points._as;
            var i, c = points.length, newPoints = new $List(), value, matrix;
            matrix = new $Matrix(sx, 0, 0, sy, translatePoint.x, translatePoint.y);
            for (i = 0; i < c; i++) {
                newPoints.add(matrix.transform(points[i]));
            }
            newPoints = newPoints._as;
            matrix = $math.createMatrix(rotateAngle + Math.PI, translatePoint.x, translatePoint.y);
            var point = newPoints[0];
            point = matrix.transform(point);
            g.moveTo(point.x, point.y);
            for (i = 1; i < c; i++) {
                value = newPoints[i];
                if (value instanceof $List) {
                    value = value._as;
                }
                if (value instanceof Array) {
                    value[0] = matrix.transform(value[0]);
                    value[1] = matrix.transform(value[1]);
                    g.quadraticCurveTo(value[0].x, value[0].y, value[1].x, value[1].y);
                } else {
                    value = matrix.transform(value);
                    g.lineTo(value.x, value.y);
                }
            }
        }else{
            var points = new twaver.List();
            for(var i = 0; i < arrow.points._as.length; i++){
                points.add(arrow.points.get(i));
            }
            points.add({x:-1,y:-1/2});
            points.add({x:-1,y:1/2});
            points.add({x:0,y:1/2});
            points.add({x:0,y:-1/2});
            points = points._as;

            var i, c = points.length, newPoints = new $List(), value, matrix;
            matrix = new $Matrix(sx, 0, 0, sy, translatePoint.x, translatePoint.y);
            for (var i = 0; i < c; i++) {
                newPoints.add(matrix.transform(points[i]));
            }
            newPoints = newPoints._as;
            matrix = $math.createMatrix(rotateAngle + Math.PI, translatePoint.x, translatePoint.y);
            var nps = new $List();
            for (var i = 0; i < c; i++) {
                nps.add(matrix.transform(newPoints[i]));
            }
            arrow.draw && arrow.draw(g,{points:nps,width:sx,height:sy, shadowColor:shadowColor,shadow:shadow,shadowXOffset:shadowXOffset,shadowYOffset:shadowYOffset,shadowBlur:shadowBlur});
        }
    },
    drawLinkArrow: function (ui, g, points, zoomManager) {
        if (points.size() < 2) {
            return;
        }
        var isBundleAgent = ui._element.isBundleAgent ? ui._element.isBundleAgent() : false;
        if (ui._element.getStyle(isBundleAgent ? 'arrow.agent.from' : 'arrow.from')) {
            $arrow._drawFromArrow(ui, g, points, zoomManager);
        }
        if (ui._element.getStyle(isBundleAgent ? 'arrow.agent.to' : 'arrow.to')) {
            $arrow._drawToArrow(ui, g, points, zoomManager);
        }
    },
    _drawFromArrow: function (ui, g, points, zoomManager) {
        var link = ui._element;
        var isBundleAgent = link.isBundleAgent ? link.isBundleAgent() : false;
        var arrowBodyFill = link.getStyle(isBundleAgent ? 'arrow.agent.from.fill' : 'arrow.from.fill');
        var arrowOutlineWidth = link.getStyle(isBundleAgent ? 'arrow.agent.from.outline.width' : 'arrow.from.outline.width');
        var arrowShadowColor = link.getStyle(isBundleAgent ? 'arrow.agent.from.shadow.color' : 'arrow.from.shadow.color');
        if (arrowBodyFill || arrowOutlineWidth >= 0) {
            var arrowWidth = link.getStyle(isBundleAgent ? 'arrow.agent.from.width' : 'arrow.from.width');
            var arrowHeight = link.getStyle(isBundleAgent? 'arrow.agent.from.height' : 'arrow.from.height');
            var arrowXOffset = link.getStyle(isBundleAgent? 'arrow.agent.from.xoffset' : 'arrow.from.xoffset');

            if (arrowXOffset > 0 && arrowXOffset < 1) {
                var lineLength;
                if (ui.getLineLength) {
                    lineLength = ui.getLineLength();
                } else {
                    lineLength = ui._element.getLineLength();
                }
                arrowXOffset *= lineLength;
            } else if (ui.getLineLength) {
                arrowXOffset += $arrow.calculateArrowXOffsetAtEdge(points, ui, true, zoomManager);
            }

            var arrowYOffset = link.getStyle(isBundleAgent ? 'arrow.agent.from.yoffset' : 'arrow.from.yoffset');
            var arrowStyle = link.getStyle(isBundleAgent? 'arrow.agent.from.shape' : 'arrow.from.shape');

            // arrowXOffset = ui._network._edgeDetect? 0:arrowXOffset;
            // arrowYOffset = ui._network._edgeDetect? 0:arrowYOffset;
            // if(zoomManager){
            //     arrowXOffset *= zoomManager.getLocationZoom();
            //     arrowYOffset *= zoomManager.getLocationZoom();
            // }
            $arrow.drawArrow(g, arrowWidth, arrowHeight, points, true, arrowStyle, arrowBodyFill,
                link.getStyle(isBundleAgent ? 'arrow.agent.from.color' : 'arrow.from.color'), arrowXOffset, arrowYOffset, arrowOutlineWidth, link.getStyle(isBundleAgent ? 'arrow.agent.from.outline.color':'arrow.from.outline.color'), ui);
        }
    },
    _drawToArrow: function (ui, g, points, zoomManager) {
        var link = ui._element;
        var isBundleAgent = link.isBundleAgent ? link.isBundleAgent() : false;
        var arrowBodyFill = link.getStyle(isBundleAgent ? 'arrow.agent.to.fill' : 'arrow.to.fill');
        var arrowOutlineWidth = link.getStyle(isBundleAgent ? 'arrow.agent.to.outline.width' : 'arrow.to.outline.width');
        if (arrowBodyFill || arrowOutlineWidth >= 0) {
            var arrowWidth = link.getStyle(isBundleAgent ? 'arrow.agent.to.width' : 'arrow.to.width');
            var arrowHeight = link.getStyle(isBundleAgent ? 'arrow.agent.to.height' : 'arrow.to.height');
            var arrowXOffset = link.getStyle(isBundleAgent ? 'arrow.agent.to.xoffset' : 'arrow.to.xoffset');

            if (arrowXOffset > 0 && arrowXOffset < 1) {
                var lineLength;
                if (ui.getLineLength) {
                    lineLength = ui.getLineLength();
                } else {
                    lineLength = ui._element.getLineLength();
                }
                arrowXOffset *= lineLength;
            } else if (ui.getLineLength) {
                arrowXOffset += $arrow.calculateArrowXOffsetAtEdge(points, ui, false, zoomManager);
            }
           
            var arrowYOffset = link.getStyle(isBundleAgent ? 'arrow.agent.to.yoffset' : 'arrow.to.yoffset');
            var arrowStyle = link.getStyle(isBundleAgent ? 'arrow.agent.to.shape' : 'arrow.to.shape');
            
            // if(zoomManager){
            //     arrowXOffset *= zoomManager.getLocationZoom();
            //     arrowYOffset *= zoomManager.getLocationZoom();
            // }
            // arrowXOffset = ui._network._edgeDetect? 0:arrowXOffset;
            // arrowYOffset = ui._network._edgeDetect? 0:arrowYOffset;

            $arrow.drawArrow(g, arrowWidth, arrowHeight, points, false, arrowStyle, arrowBodyFill,
                link.getStyle(isBundleAgent ? 'arrow.agent.to.color' : 'arrow.to.color'), arrowXOffset, arrowYOffset, arrowOutlineWidth, link.getStyle(isBundleAgent ? 'arrow.agent.to.outline.color' : 'arrow.to.outline.color'), ui);
        }
    },
    calculateArrowXOffsetAtEdge: function (result, linkUI, isSource, zoomManager) {
        if (result == null || result.size() < 2) {
            return 0;
        }
        var link = linkUI._element;
        var arrowAtEdge = (isSource ? link.getStyle('arrow.from.at.edge') : link.getStyle('arrow.to.at.edge'));
        if (!arrowAtEdge) {
            return 0;
        }
        var agentNodeUI = isSource ? linkUI._network.getElementUI(link.getFromAgent()) : linkUI._network.getElementUI(link.getToAgent());
        if (!agentNodeUI) {
            return 0;
        }
        if(zoomManager){
            var sourceBounds = agentNodeUI.getZoomBodyRect();
        }else{
            var sourceBounds = agentNodeUI._bodyRect;
        }
        
        if (sourceBounds == null) {
            return 0;
        }
        var temp = $math._getPoint(result.get(isSource ? 0 : result.size() - 1));
        var xOffset = 0, lineLength = linkUI.getLineLength();
        while ($arrow._containsByInt(sourceBounds, Math.floor(temp.x), Math.floor(temp.y), false) && xOffset < lineLength) {
            temp = $math.calculatePointInfoAlongLine(result, isSource, xOffset++).point;
        }
        return xOffset;
    },
    _containsByInt: function (rect, x, y, includeOutline) {
        includeOutline = includeOutline === undefined ? true : includeOutline;
        if (includeOutline) {
            return (x >= Math.floor(rect.x) && x <= Math.floor(rect.x + rect.width) && y >= Math.floor(rect.y) && y <= Math.floor(rect.y + rect.height));
        }
        return (x > Math.floor(rect.x) && x < Math.floor(rect.x + rect.width) && y > Math.floor(rect.y) && y < Math.floor(rect.y + rect.height));
    }
};
$arrow.init();
_twaver.arrow = $arrow;

twaver.EventDispatcher = function () {
    this._f = 0;
};
_twaver.ext('twaver.EventDispatcher', null, {
    contains: function (l, s) {
        if (this._ls) {
            for (var i = 0, n = this._ls.size(), o; i < n; i++) {
                o = this._ls.get(i);
                if (l === o.l && s === o.s) {
                    return true;
                }
            }
        }
        return false;
    },
    add: function (l, s, a) {
        var o = { l: l, s: s, a: a };
        if (!this._ls) {
            this._ls = new $List();
        }
        if (this._f) {
            if (!this._addPendings) {
                this._addPendings = new $List();
            }
            this._addPendings.add(o);
        } else {
            if (o.a) {
                this._ls.add(o, 0);
            } else {
                this._ls.add(o);
            }
        }
    },
    remove: function (l, s) {
        if (this._ls) {
            if (this._f) {
                if (!this._removePendings) {
                    this._removePendings = new $List();
                }
                this._removePendings.add({ l: l, s: s });
            } else {
                this._remove(l, s);
            }
        }
    },
    _remove: function (l, s) {
        for (var i = 0, n = this._ls.size(), o; i < n; i++) {
            o = this._ls.get(i);
            if (o.l === l && o.s === s) {
                this._ls.removeAt(i);
                return;
            }
        }
    },
    fire: function (e) {
        if (this._ls) {
            var i, n = this._ls.size(), o;
            this._f++;
            for (i = 0; i < n; i++) {
                o = this._ls.get(i);
                if (o.s) {
                    o.l.call(o.s, e);
                } else {
                    o.l(e);
                }
            }
            this._f--;

            if (!this._f) {
                if (this._removePendings) {
                    n = this._removePendings.size();
                    for (i = 0; i < n; i++) {
                        o = this._removePendings.get(i);
                        this._remove(o.l, o.s);
                    }
                    delete this._removePendings;
                }
                if (this._addPendings) {
                    n = this._addPendings.size();
                    for (i = 0; i < n; i++) {
                        o = this._addPendings.get(i);
                        if (o.a) {
                            this._ls.add(o, 0);
                        } else {
                            this._ls.add(o);
                        }
                    }
                    delete this._addPendings;
                }
            }
        }
    }
});

twaver.ImageAsset = function (name, source, width, height, svg) {
    this._name = name;
    this._width = width;
    this._height = height;
    this._svg = svg;
    this._edgeData;

    if (typeof source === "string") {
        this._src = source;
    } else if (typeof source === "function") {
        this._func = source;
    } else if (isImage(source)) {
        this._image = source;
    } else if (typeof source === 'object') {
        this._image = source;
        this._width = source.w || source.width;
        this._height = source.h || source.height;
        if (source.cache !== false && isVectorCacheable(source)) {
            getPatternImages(name, source);
            this._cache = createVectorCanvas(source);
        }
    }
};
_twaver.ext('twaver.ImageAsset', Object, {
    getName: function () {
        return this._name;
    },
    getSrc: function () {
        return this._src;
    },
    isSvg: function () {
        return this._svg;
    },
    getImage: function (color, width, height) {
        if (!color || !this._image) {
            return this._image;
        }
        if (!this._map) {
            this._map = {};
        }
        var key;
        if (this._svg && arguments.length === 3) {
            key = color + ',' + width + ',' + height;
        } else {
            key = color;
        }
        var c = this._map[key];
        if (c) {
            return c;
        }
        c = _getImage(this._cache || this._image, getColorValue(color), this._svg ? (width || this.getWidth()) : this.getWidth(), this._svg ? (height || this.getHeight()) : this.getHeight());
        this._map[key] = c;
        return c;
    },
    getWidth: function () {
        return this._width;
    },
    getHeight: function () {
        return this._height;
    },
    getFunction: function () {
        return this._func;
    },
    _createEdgeData: function (image,width,height) {
        var samplingLimit = 300;
        var samplingScaleRate = samplingLimit / width;
        if (height < width) {
            samplingScaleRate = samplingLimit / height;
        }
        var samplingWidth = Math.floor(width * samplingScaleRate);
        var samplingHeight = Math.floor(height * samplingScaleRate);

        if (!this.tempCanvas) {
            this.tempCanvas = document.createElement("canvas");
            this.ctx = this.tempCanvas.getContext("2d");
        }
        this.tempCanvas.width = samplingWidth;
        this.tempCanvas.height = samplingHeight;
        this.ctx.clearRect(0, 0, samplingWidth, samplingHeight);
        this.ctx.drawImage(image, 0, 0, samplingWidth, samplingHeight);//paint with sampling size.
        var imgData = this.ctx.getImageData(0,0,samplingWidth,samplingHeight);

        var lastTransparent=true;
        var points=[];

        //horizontal edge scan
        for (var y=0, width=samplingWidth, height=samplingHeight; y<height;y++) {
            for (var x=0;x<width;x++) {
                var index=(y*width+x)*4;
                var transparent=this._isTransparentPoint(imgData.data, index);
                var edge=(lastTransparent!=transparent) || (!transparent && (x==0 || x==width-1));
                if(edge){
                    var offset=transparent ? 1 : 0;
                    points.push({"x":x-offset, "y":y});
                }
                lastTransparent=transparent;
            }
        }

        //vertical edge scan
        lastTransparent=true;
        for (var x=0, width=samplingWidth, height=samplingHeight;x<width;x++) {
            for (var y=0;y<height;y++) {
                var index=(y*width+x)*4;
                var transparent=this._isTransparentPoint(imgData.data, index);
                var edge=(lastTransparent!=transparent) || (!transparent && (y==0 || y==height-1));
                if(edge){
                    var offset=transparent ? 1 : 0;
                    points.push({"x":x, "y":y-offset});
                }
                lastTransparent=transparent;
            }
        }

        //filter points by angle.
        var centerX=width/2, centerY=height/2;
        var edgeData=[];
        for(var i=0;i<360;i++){
            edgeData.push({"x":centerX, "y":centerY, "dist":0});//init all edges to center.
        }
        //replace each edge by outsider edge.
        for(var i=0, total=points.length; i<total; i++){
            var point=points[i];
            var angle=this._getPointAngleDegree(point.x, point.y, centerX, centerY);
            var dist=this._getPointDist(point.x, point.y, centerX, centerY);
            if(edgeData[angle].dist<dist){
                edgeData[angle]={"x":point.x, "y":point.y, "dist":dist};
            }
        }
        //reset by sampling scale rate.
        for(var i=0, total=edgeData.length; i<total; i++){
            var edge=edgeData[i];
            edge.x=edge.x/samplingScaleRate;
            edge.y=edge.y/samplingScaleRate;
            delete edge.dist;//clear this distance var.
        }
        return edgeData;
    },
    _isTransparentPoint: function (data, index) {
        return (data[index] + data[index + 1] + data[index + 2] + data[index + 3]) == 0;
    },

    _getPointAngleDegree: function (x1, y1, x2, y2) {
        var xOffset = x2 - x1;
        var yOffset = y2 - y1;
        var angle = Math.atan2(yOffset, xOffset);
        angle = angle / Math.PI * 180;
        angle = parseInt(angle) + 180;
        angle = angle % 360;

        return angle;
    },

    _getPointDist: function (x1, y1, x2, y2) {
        var xOffset = x2 - x1;
        var yOffset = y2 - y1;
        return Math.sqrt(xOffset * xOffset + yOffset * yOffset);
    }
});
var color_cache = {};
var color_canvas = $html.createCanvas();
color_canvas.width = 1;
color_canvas.height = 1;
var color_g = color_canvas.getContext('2d');

var getColorValue = function (color) {
  color = color || 'black';
  var value = color_cache[color],
    data;
  if (!value) {
    color_g.clearRect(0, 0, 1, 1);
    color_g.fillStyle = color;
    color_g.fillRect(0, 0, 1, 1);
    data = color_g.getImageData(0, 0, 1, 1).data;
    value = color_cache[color] = { r: data[0], g: data[1], b: data[2], a: data[3] };
  }
  return value;
};

var getFilterColor = function (sourceColor, filterColor) {
    if (!filterColor) {
        return sourceColor;
    }
    filterColor = getColorValue(filterColor);
    sourceColor = getColorValue(sourceColor);
    if($Defaults.PIXEL_FILTER_FUNCTION) {
        var rgb = $Defaults.PIXEL_FILTER_FUNCTION(sourceColor, filterColor);
        return 'rgba(' +
          rgb.r + ',' +
          rgb.g + ',' +
          rgb.b + ',' + sourceColor.a + ')';
    }
    return null;
};

var _getImage = function (image, color, width, height) {
    var c = $html.createCanvas(width, height);
    var g2 = c.getContext('2d');
    g2.drawImage(image, 0, 0, width, height);
    try {
        var imageData = g2.getImageData(0, 0, width, height);
        var pix = imageData.data;
        for (var i = 0, n = pix.length; i < n; i += 4) {
            var sourceColor = {r: pix[i + 0], g: pix[i + 1], b: pix[i + 2]};
            var result = $Defaults.PIXEL_FILTER_FUNCTION(sourceColor, color);
            pix[i + 0] = result.r;
            pix[i + 1] = result.g;
            pix[i + 2] = result.b;
        }
        g2.putImageData(imageData, 0, 0);
    } catch (e) {
        return image;
    }
    return c;
};

var vector_pattern = {};
var add_vector_pattern = function (pattern, imageName) {
  if (pattern) {
    var type = typeof pattern;
    if (type === 'string') {
      if (!pattern.match(bindingPattern)) {
        if (!_twaver.images[pattern]) {
          (vector_pattern[pattern] || (vector_pattern[pattern] = [])).push(imageName);
        }
      }
    }
  }
};
var getPatternImages = function (imageName, image) {
  image.pattern && add_vector_pattern(image.pattern, imageName);
  image.v && image.v.forEach(function (shape) {
    shape.pattern && add_vector_pattern(shape.pattern, imageName);
  });
};
var refresh_pattern_cache = function (name) {
    var patterns = vector_pattern[name];
    if (patterns) {
        patterns.forEach(function (name) {
            var pattern = _twaver.images[name];
            pattern._cache = createVectorCanvas(pattern._image);
        });
        delete vector_pattern[name];
    }
};

var isVectorCacheable = function (image) {
  if (!image.w || !image.h) {
    return false;
  }
  return isVectorGCacheable(image);
};

var isVectorGCacheable = function (g) {
  return !Object.keys(g).some(function (name) {
    if (/^on/.test(name)) {
      return false;
    }
    var value = g[name],
      result = isBidingValue(value);
    if (!result && name === 'v') {
      result = value.some(function (shapeData) {
        // if shapeData is vector and child vector is registered and not cacheable, then vector is not cacheable
        if (shapeData.shape === 'draw') {
            return true;
        }
        if (shapeData.shape === 'vector') {
          var childVector = _twaver.images[shapeData.name];
          if (childVector && !childVector._cache) {
            return true;
          }
        }
        var innerResult = Object.keys(shapeData).some(function (shapeName) {
          if (shapeName === 'state' || shapeName === 'animate') {
            return true;
          }
          return isBidingValue(shapeData[shapeName]);
        });
        if (innerResult) {
          return true;
        } else {
          if (shapeData.shape === 'g' && shapeData.v && shapeData.v.length) {
            return !isVectorGCacheable(shapeData);
          } else {
            return false;
          }
        }
      });
    }
    return result;
  });
};

var isBidingValue = function (value) {
  var type = typeof value;
  return (type === 'string' && value.match(bindingPattern)) || type === 'function';
};

var createVectorCanvas = function (vector) {
  var canvas = $html.createCanvas(vector.w, vector.h),
    g = canvas.getContext('2d');
  twaver.Util.makeHighRes(canvas);
  drawVector(g, vector, null, { x: 0, y: 0, width: vector.w, height: vector.h });
  return canvas;
};

var _imageUtil = twaver.imageUtil = {

	IMAGE_LOAD_COMPLETED:'IMAGE_LOAD_COMPLETED',
	_dispatcher : new twaver.EventDispatcher(),
	addEventListener:function  (listener, scope, ahead) {
		_imageUtil._dispatcher.add(listener, scope, ahead);
	},
	removeEventListener:function  (listener, scope) {
		_imageUtil._dispatcher.remove(listener, scope)
	},
    
    images:{},
    registerImageByUrl: function (url, svg, name) {

    	svg = svg || _imageUtil.getImageType(url);
    	name = name || _imageUtil.getImageName(url);
        if(_imageUtil.images[name]){
            return;
        }
        _imageUtil.images[name] = url;
        var image = new Image();
        image.src = url;
        image.onload = function () {
            _twaver.registerImage(name, image, image.width, image.height, svg === true);
             image.onload = null;
            delete _imageUtil.images[name];
            //TODO dispatchEvent
            var e = {
            	type:_imageUtil.IMAGE_LOAD_COMPLETED,
            	url:url,
            	svg:svg,
            	name:name
            }
            _imageUtil._dispatcher.fire(e);
        };
    },
    getImageName: function (url) {
        if (typeof url !== 'string') {
            // console && console.error && console.error('method twaver.imageUtil.getImageName(url) first argument url is invalid');
            return null;
        }
        var index = url.lastIndexOf('/');
        var name = url;
        if (index >= 0) {
            name = url.substring(index + 1);
        }
        index = name.lastIndexOf('.');
        if (index >= 0) {
            name = name.substring(0, index);
        }
        return name;
    },
    getImageType: function (url) {
        if (typeof url !== 'string') {
            // console && console.error && console.error('method twaver.imageUtil.getImageType(url) first argument url is invalid');
            return null;
        }
        var index = url.lastIndexOf('/');
        var name = url;
        if (index >= 0) {
            name = url.substring(index + 1);
        }
        index = name.lastIndexOf('.');
        if (index >= 0) {
            name = name.substring(index + 1);
        }
        return name;
    },
}

var $Defaults = {

    COLORS: ['#6495ED', '#FFFF00', '#00FFFF', '#FF0000', '#7FFF00', '#E0A580', '#5FC0CB', '#FA00F0', '#A1BC50',
    '#FFD700', '#4169E1', '#E5A5F5', '#1E90FF', '#696969', '#FF6347', '#00BFEF', '#FFD700', '#80E090',
    '#5F9EA0', '#A000FF', '#7FAF00', '#228BA2', '#FF00FF', '#7FFFD4', '#800000', '#0000CD', '#20B2AA',
    '#D2691E', '#6495BD', '#DC143C', '#F0A8AF', '#008B8B', '#800080', '#B8860B', '#4B0082', '#00FF00',
    '#FFA500', '#FF4500', '#FFFF00', '#9ACD32', '#00008B', '#FF1493', '#ADFF2F', '#4682B4', '#00C0B1'],

    CALL_LATER_DELAY: 17,
    SCROLL_BAR_WIDTH: 17,
    SELECT_COLOR: '#C2CFF1',
    FOCUS_ON_CLICK: true,

    VIEW_POSITION: 'absolute',
    VIEW_FONT_SIZE: '12px',
    VIEW_FONT_FAMILY: 'arial, tahoma, helvetica, sans-serif',

    TOOLTIP_BACKGROUND: 'lightyellow',
    TOOLTIP_FONT_SIZE: '12px',
    TOOLTIP_COLOR: 'black',
    TOOLTIP_PADDING: '4px 8px',
    TOOLTIP_BORDER: '1px solid gray',
    TOOLTIP_BORDER_RADIUS: '6px',
    TOOLTIP_XOFFSET: 12,
    TOOLTIP_YOFFSET: 12,
    TOOLTIP_BOX_SHADOW: '0px 0px 3px #AAA',
    TOOLTIP_ZINDEX: 100000,
    TOOLTIP_INITIAL_DELAY: 750,
    TOOLTIP_RESHOW_DELAY: 500,
    TOOLTIP_DISMISS_DELAY: 4000,

    ZOOM_MAX: 5,
    ZOOM_MIN: 0.1,
    ZOOM_INCREMENT: 1.3,
    ZOOM_ANIMATE: true,

    COLUMN_INNER_TEXT: true,
    COLUMN_WIDTH: 80,
    COLUMN_HORIZONTAL_ALIGN: '',
    COLUMN_PROPERTY_TYPE: 'accessor', // 'field', 'accessor', 'style', 'client'
    COLUMN_VALUE_TYPE: 'string', // 'string', 'boolean', 'color', 'int', 'number'
    COLUMN_EDITABLE: false,
    COLUMN_SORTABLE: true,
    COLUMN_VISIBLE: true,
    COLUMN_RESIZABLE: true,
    COLUMN_MOVABLE: true,
    COLUMN_RENDER_CELL: null,
    COLUMN_RENDER_HEADER: null,
    COLUMN_RENDER_EDITOR: null,

    PROPERTY_INNER_TEXT: true,
    PROPERTY_HORIZONTAL_ALIGN: '',
    PROPERTY_PROPERTY_TYPE: 'accessor', // 'field', 'accessor', 'style', 'client'
    PROPERTY_VALUE_TYPE: 'string', // 'string', 'boolean', 'color', 'int', 'number'
    PROPERTY_EDITABLE: false,
    PROPERTY_CATEGORY_NAME: null,
    PROPERTY_RENDER_NAME: null,
    PROPERTY_RENDER_VALUE: null,
    PROPERTY_RENDER_EDITOR: null,

    TAB_WIDTH: 100,
    TAB_CLOSABLE: false,
    TAB_RESIZABLE: true,
    TAB_MOVABLE: true,
    TAB_DISABLED: false,
    TAB_VISIBLE: true,

    ACCORDION_EXPAND_ICON: 'expand_icon',
    ACCORDION_COLLAPSE_ICON: 'collapse_icon',
    ACCORDION_TITLE_HEIGHT: 20,
    ACCORDION_TITLE_BACKGROUND: '#EBEBEB',
    ACCORDION_BORDER_BOTTOM_COLOR: 'lightgray',
    ACCORDION_ICON_POSITION: 'left',

    TITLEPANE_TITLE_HEIGHT: 20,
    TITLEPANE_TITLE_BACKGROUND: '#DDD',
    TITLEPANE_TITLE_HORIZONTAL_ALIGN: 'left',

    BORDERPANE_HGAP: 0,
    BORDERPANE_VGAP: 0,

    CHARTPANE_TITLE_HEIGHT: 20,
    CHARTPANE_TITLE_HORIZONTAL_ALIGN: 'center',
    CHARTPANE_LEGEND_ORIENTATION: 'bottom', // top right bottom left
    CHARTPANE_LEGEND_WIDTH: 80,

    LEGENDPANE_ICON_WIDTH: 10,
    LEGENDPANE_ICON_HEIGHT: 10,
    LEGENDPANE_ICON_RADIUS: 0,
    LEGENDPANE_ROW_HEIGHT: 20,
    LEGENDPANE_ORIENTATION: 'horizontal', // 'horizontal' 'vertical'
    LEGENDPANE_HIDDEN_COLOR: '#BABBBC',
    LEGENDPANE_SELECT_BACKGROUND_COLOR: '#00007D',
    LEGENDPANE_SELECT_FOREGROUND_COLOR: '#FFFFFF',

    CHART_TOOLTIP_ENABLED: true,
    CHART_SELECT_TOLERANCE: 0,
    CHART_XGAP: 6,
    CHART_YGAP: 6,
    CHART_XZOOM_ENABLED: true,
    CHART_YZOOM_ENABLED: true,
    CHART_XTRANSLATE_ENABLED: true,
    CHART_YTRANSLATE_ENABLED: true,
    CHART_DOUBLE_CLICK_TO_RESET: true,
    CHART_VALUE_VISIBLE: true,
    CHART_VALUE_FONT: null,
    CHART_BACKGROUND_VISIBLE: false,
    CHART_BACKGROUND_FILL: true,
    CHART_BACKGROUND_FILL_COLOR: 'rgba(50,50,50,0.11)',
    CHART_BACKGROUND_OUTLINE_WIDTH: 1,
    CHART_BACKGROUND_OUTLINE_COLOR: 'rgba(50,50,50,0.11)',
    CHART_BACKGROUND_GRADIENT: 'linear.north',
    CHART_BACKGROUND_GRADIENT_COLOR: '#FFFFFF',

    PIECHART_TYPE: 'oval', // 'oval' 'circle' 'line' 'donut' 'ovalDonut'
    PIECHART_START_ANGLE: 0,
    PIECHART_SELECT_OFFSET: 5,
    PIECHART_SHADOW_OFFSET: 1,
    PIECHART_SHADOW_COLOR: '#C2CFF1',
    PIECHART_LINE_RATE: 0.5,
    PIECHART_DONUT_RATE: 0.5,
    PIECHART_VALUE_POSITION: 0.5,

    BARCHART_TYPE: 'default', // 'default' 'group' 'stack' 'layer' 'percent' 
    BARCHART_UPPER_LIMIT: null,
    BARCHART_LOWER_LIMIT: 0,
    BARCHART_XAXIS_LINE_COLOR: '#808080',
    BARCHART_XAXIS_LINE_WIDTH: 1,
    BARCHART_XAXIS_TEXT_COLOR: '#000000',
    BARCHART_XAXIS_TEXT_FONT: null,
    BARCHART_YAXIS_LINE_COLOR: '#808080',
    BARCHART_YAXIS_LINE_WIDTH: 1,
    BARCHART_YAXIS_TEXT_COLOR: '#000000',
    BARCHART_YAXIS_TEXT_FONT: null,
    BARCHART_XSCALE_TEXT_FONT: null,
    BARCHART_XSCALE_TEXT_COLOR: '#000000',
    BARCHART_XSCALE_TEXT_ORIENTATION: 'horizontal', // 'horizontal' 'vertical'
    BARCHART_YSCALE_TEXT_VISIBLE: true,
    BARCHART_YSCALE_TEXT_COLOR: '#000000',
    BARCHART_YSCALE_TEXT_FONT: null,
    BARCHART_YSCALE_LINE_COLOR: '#808080',
    BARCHART_YSCALE_LINE_WIDTH: 0.3,
    BARCHART_YSCALE_VALUE_GAP: 0,
    BARCHART_YSCALE_PIXEL_GAP: 20,
    BARCHART_YSCALE_MIN_TEXT_VISIBLE: false,

    LINECHART_INTERRUPTABLE: true,
    LINECHART_UPPER_LIMIT: null,
    LINECHART_LOWER_LIMIT: null,
    LINECHART_XAXIS_LINE_COLOR: '#808080',
    LINECHART_XAXIS_LINE_WIDTH: 1,
    LINECHART_XAXIS_TEXT_COLOR: '#000000',
    LINECHART_XAXIS_TEXT_FONT: null,
    LINECHART_YAXIS_LINE_COLOR: '#808080',
    LINECHART_YAXIS_LINE_WIDTH: 1,
    LINECHART_YAXIS_TEXT_COLOR: '#000000',
    LINECHART_YAXIS_TEXT_FONT: null,
    LINECHART_XSCALE_TEXT_FONT: null,
    LINECHART_XSCALE_TEXT_COLOR: '#000000',
    LINECHART_XSCALE_TEXT_ORIENTATION: 'horizontal', // 'horizontal' 'vertical'
    LINECHART_XSCALE_LINE_COLOR: '#808080',
    LINECHART_XSCALE_LINE_WIDTH: 0.3,
    LINECHART_YSCALE_TEXT_VISIBLE: true,
    LINECHART_YSCALE_TEXT_COLOR: '#000000',
    LINECHART_YSCALE_TEXT_FONT: null,
    LINECHART_YSCALE_LINE_COLOR: '#808080',
    LINECHART_YSCALE_LINE_WIDTH: 0.3,
    LINECHART_YSCALE_VALUE_GAP: 0,
    LINECHART_YSCALE_PIXEL_GAP: 20,
    LINECHART_YSCALE_MIN_TEXT_VISIBLE: false,
    LINECHART_VALUESPANCOUNT:1,

    BUBBLECHART_UPPER_LIMIT: null,
    BUBBLECHART_LOWER_LIMIT: null,
    BUBBLECHART_XAXIS_UPPER_LIMIT: null,
    BUBBLECHART_XAXIS_LOWER_LIMIT: null,
    BUBBLECHART_XAXIS_LINE_COLOR: '#808080',
    BUBBLECHART_XAXIS_LINE_WIDTH: 1,
    BUBBLECHART_XAXIS_TEXT_COLOR: '#000000',
    BUBBLECHART_XAXIS_TEXT_FONT: null,
    BUBBLECHART_YAXIS_LINE_COLOR: '#808080',
    BUBBLECHART_YAXIS_LINE_WIDTH: 1,
    BUBBLECHART_YAXIS_TEXT_COLOR: '#000000',
    BUBBLECHART_YAXIS_TEXT_FONT: null,
    BUBBLECHART_XSCALE_TEXT_FONT: null,
    BUBBLECHART_XSCALE_TEXT_COLOR: '#000000',
    BUBBLECHART_XSCALE_TEXT_ORIENTATION: 'horizontal', // 'horizontal' 'vertical'
    BUBBLECHART_XSCALE_LINE_COLOR: '#808080',
    BUBBLECHART_XSCALE_LINE_WIDTH: 0.3,
    BUBBLECHART_YSCALE_TEXT_VISIBLE: true,
    BUBBLECHART_YSCALE_TEXT_COLOR: '#000000',
    BUBBLECHART_YSCALE_TEXT_FONT: null,
    BUBBLECHART_YSCALE_LINE_COLOR: '#808080',
    BUBBLECHART_YSCALE_LINE_WIDTH: 0.3,
    BUBBLECHART_YSCALE_VALUE_GAP: 0,
    BUBBLECHART_YSCALE_PIXEL_GAP: 20,
    BUBBLECHART_YSCALE_MIN_TEXT_VISIBLE: false,
    BUBBLECHART_SELECT_SHADOW_COLOR: '#000000',
    BUBBLECHART_SELECT_SHADOW_OFFSET: 3,

    RADARCHART_AXIS_TEXT_FONT: null,
    RADARCHART_AXIS_TEXT_COLOR: '#000000',
    RADARCHART_AXIS_TEXT_VISIBLE: true,
    RADARCHART_SCALE_TEXT_FONT: null,
    RADARCHART_SCALE_TEXT_COLOR: '#000000',
    RADARCHART_SCALE_TEXT_VISIBLE: true,
    RADARCHART_AXIS_VISIBLE: true,
    RADARCHART_AXIS_LINE_COLOR: '#808080',
    RADARCHART_AXIS_LINE_WIDTH: 3,
    RADARCHART_AXIS_START_ANGLE: 0,
    RADARCHART_RING_VISIBLE: true,
    RADARCHART_RING_TYPE: 'line', // 'line', 'arc'
    RADARCHART_RING_LINE_COLOR: '#808080',
    RADARCHART_RING_LINE_WIDTH: 1,
    RADARCHART_SCALE_COUNT: 5,
    RADARCHART_SCALE_MAXVALUE: 1,
    RADARCHART_SCALE_MINVALUE: 0,
    RADARCHART_ANCHOR_VISIBLE: true,
    RADARCHART_AREA_FILL: true,
    RADARCHART_AREA_FILL_ALPHA: 0.2,
    RADARCHART_AREA_SELECT_FILL_ALPHA: 0.5,

    DIALCHART_UPPER_LIMIT: 100,
    DIALCHART_LOWER_LIMIT: 0,
    DIALCHART_START_ANGLE: 0,
    DIALCHART_END_ANGLE: 360,
    DIALCHART_INNER_RADIUS: 0.8,
    DIALCHART_COLOR_RANGE_FILL_COLOR: '#808080',
    DIALCHART_OUTLINE_WIDTH: 0,
    DIALCHART_OUTLINE_COLOR: '#808080',

    DIALCHART_SCALE_INSIDE: true,
    DIALCHART_MAJOR_SCALE_COUNT: 11,
    DIALCHART_MAJOR_SCALE_LINE_WIDTH: 2,
    DIALCHART_MAJOR_SCALE_LINE_LENGTH: 8,
    DIALCHART_MAJOR_SCALE_LINE_COLOR: '#000000',
    DIALCHART_MINOR_SCALE_COUNT: 4,
    DIALCHART_MINOR_SCALE_LINE_WIDTH: 1,
    DIALCHART_MINOR_SCALE_LINE_LENGTH: 4,
    DIALCHART_MINOR_SCALE_LINE_COLOR: '#000000',
    DIALCHART_SCALE_TEXT_VISIBLE: true,
    DIALCHART_SCALE_UPPER_LIMIT_TEXT_VISIBLE: true,
    DIALCHART_SCALE_LOWER_LIMIT_TEXT_VISIBLE: true,
    DIALCHART_SCALE_TEXT_FONT: null,
    DIALCHART_SCALE_TEXT_COLOR: '#000000',
    DIALCHART_PIVOT_RADIUS: 10,
    DIALCHART_PIVOT_FILL: true,
    DIALCHART_PIVOT_FILL_COLOR: '#808080',
    DIALCHART_PIVOT_OUTLINE_WIDTH: 0,
    DIALCHART_PIVOT_OUTLINE_COLOR: '#808080',
    DIALCHART_VALUE_POSITION: 0.5,
    DIALCHART_INNER_DARKER_RADIUS: 10,
    DIALCHART_OUTER_BRIGHTER_RADIUS: 10,
    DIALCHART_SELECT_SHADOW_COLOR: '#000000',
    DIALCHART_SELECT_SHADOW_OFFSET: 3,

    TABPANE_TAB_GAP: 1,
    TABPANE_TAB_RADIUS: 0,
    TABPANE_TAB_HEIGHT: 24,
    TABPANE_TAB_ORIENTATION: 'top',
    TABPANE_RESIZE_TOLERANCE: 3,
    TABPANE_TAB_BACKGROUND: '#EBEBEB',
    TABPANE_DISABLED_COLOR: '#BABBBC',
    TABPANE_SELECT_BACKGROUND: 'white',
    TABPANE_MOVE_BACKGROUND: 'rgba(184,211,240,0.7)',
    TABPANE_INSERT_BACKGROUND: 'orange',
    TABPANE_HORIZONTAL_ALIGN: 'center',
    TABPANE_CLOSE_ICON: 'close_icon',
    TABPANE_SELECT_NEXT_ON_CLOSE: true,
    TABPANE_SELECT_NEXT_ON_INVISIBLE: true,

    LISTBASE_INNER_TEXT: true,
    LIST_ROW_HEIGHT: 19,
    LIST_INDENT: 2,
    LIST_ROW_LINE_WIDTH: 0,
    LIST_ROW_LINE_COLOR: '#DDD',
    LIST_MAKE_VISIBLE_ON_SELECTED: true,
    LIST_KEYBOARD_REMOVE_ENABLED: true,
    LIST_KEYBOARD_SELECT_ENABLED: true,

    TREE_ROW_HEIGHT: 19,
    TREE_INDENT: 16,
    TREE_ROW_LINE_WIDTH: 0,
    TREE_ROW_LINE_COLOR: '#DDD',
    TREE_MAKE_VISIBLE_ON_SELECTED: true,
    TREE_KEYBOARD_REMOVE_ENABLED: true,
    TREE_KEYBOARD_SELECT_ENABLED: true,
    TREE_EXPAND_ICON: 'expand_icon',
    TREE_COLLAPSE_ICON: 'collapse_icon',
    TREE_LINE_TYPE:'none',//'dotted','solid'
    TREE_LINE_THICKNESS:2,
    TREE_LINE_COLOR:'#000000',
    TREE_LINE_ALPHA:1,
    TREE_LINE_DASH:[4,2],

    TABLE_ROW_HEIGHT: 19,
    TABLE_ROW_LINE_WIDTH: 1,
    TABLE_ROW_LINE_COLOR: '#DDD',
    TABLE_COLUMN_LINE_WIDTH: 1,
    TABLE_COLUMN_LINE_COLOR: '#DDD',
    TABLE_MAKE_VISIBLE_ON_SELECTED: true,
    TABLE_KEYBOARD_REMOVE_ENABLED: true,
    TABLE_KEYBOARD_SELECT_ENABLED: true,
    TABLE_EDITABLE: false,

    TABLEHEADER_HEIGHT: 24,
    TABLEHEADER_RESIZE_TOLERANCE: 3,
    TABLEHEADER_BACKGROUND: '#EBEBEB',
    TABLEHEADER_MOVE_BACKGROUND: 'rgba(184,211,240,0.7)',
    TABLEHEADER_INSERT_BACKGROUND: 'orange',
    TABLEHEADER_COLUMN_LINE_COLOR: '#DDD',
    TABLEHEADER_SORT_DESC_ICON: 'sort_desc',
    TABLEHEADER_SORT_ASC_ICON: 'sort_asc',
    TABLEHEADER_SORT_ICON_POSITION: '98% 50%',

    TREETABLE_ROW_HEIGHT: 19,
    TREETABLE_INDENT: 16,
    TREETABLE_ROW_LINE_WIDTH: 1,
    TREETABLE_ROW_LINE_COLOR: '#DDD',
    TREETABLE_COLUMN_LINE_WIDTH: 1,
    TREETABLE_COLUMN_LINE_COLOR: '#DDD',
    TREETABLE_MAKE_VISIBLE_ON_SELECTED: true,
    TREETABLE_KEYBOARD_REMOVE_ENABLED: true,
    TREETABLE_KEYBOARD_SELECT_ENABLED: true,
    TREETABLE_EXPAND_ICON: 'expand_icon',
    TREETABLE_COLLAPSE_ICON: 'collapse_icon',
    TREETABLE_EDITABLE: false,

    PROPERTYSHEET_AUTO_ADJUSTABLE: true,
    PROPERTYSHEET_INDENT: 16,
    PROPERTYSHEET_ROW_HEIGHT: 19,
    PROPERTYSHEET_ROW_LINE_WIDTH: 1,
    PROPERTYSHEET_COLUMN_LINE_WIDTH: 1,
    PROPERTYSHEET_BORDER_COLOR: '#EBEBEB',
    PROPERTYSHEET_EXPAND_ICON: 'expand_icon',
    PROPERTYSHEET_COLLAPSE_ICON: 'collapse_icon',
    PROPERTYSHEET_PROPERTY_NAME_WIDTH: 100,
    PROPERTYSHEET_PROPERTY_NAME_HORIZONTAL_ALIGN: '',
    PROPERTYSHEET_SUM_WIDTH: 200,
    PROPERTYSHEET_RESIZE_TOLERANCE: 3,
    PROPERTYSHEET_EDITABLE: false,
    PROPERTYSHEET_CATEGORIZABLE: true,
    PROPERTYSHEET_EXPAND_CATEGORY: true,
    
    POPUPMENU_SUBNENU_ENABLE_ICON: 'submenu_enable_icon',
    POPUPMENU_SUBNENU_DISABLE_ICON: 'submenu_disable_icon',
    POPUPMENU_CHECKBOX_SELECTED_ICON: 'checkbox_selected_icon',
    POPUPMENU_CHECKBOX_UNSELECTED_ICON: 'checkbox_unselected_icon',
    POPUPMENU_RADIOBUTTON_SELECTED_ICON: 'radiobutton_selected_icon',
    POPUPMENU_RADIOBUTTON_UNSELECTED_ICON: 'radiobutton_unselected_icon',

    SPLITPANE_ORIENTATION: 'horizontal',
    SPLITPANE_POSITION: 0.5,
    SPLITPANE_DIVIDER_WIDTH: 6,
    SPLITPANE_DIVIDER_BACKGROUND: '#CCCCFF',
    SPLITPANE_DIVIDER_OPACITY: 0.5,
    SPLITPANE_MASK_BACKGROUND: '',
    SPLITPANE_UP_EXPAND_ICON:"up_expand_icon",
    SPLITPANE_DOWN_EXPAND_ICON:"down_expand_icon",
    SPLITPANE_LEFT_EXPAND_ICON:"left_expand_icon",
    SPLITPANE_RIGHT_EXPAND_ICON:"right_expand_icon",

    NODE_WIDTH: 50,
    NODE_HEIGHT: 50,
    IMAGE_NODE: 'node_image',
    IMAGE_GROUP: 'group_image',
    IMAGE_SUBNETWORK: 'subnetwork_image',
    ICON_DATABOX: 'databox_icon',
    ICON_DATA: 'data_icon',
    ICON_NODE: 'node_icon',
    ICON_LINK: 'link_icon',
    ICON_GROUP: 'group_icon',
    ICON_SUBNETWORK: 'subnetwork_icon',
    ICON_GRID: 'grid_icon',
    ICON_BUS: 'bus_icon',
    ICON_SHAPENODE: 'shapenode_icon',
    ICON_SHAPELINK: 'shapelink_icon',
    ICON_LINKSUBNETWORK: 'linksubnetwork_icon',
    ICON_SHAPESUBNETWORK: 'shapesubnetwork_icon',
    LAYER_DEFAULT_ID: 'default',
    LAYER_DEFAULT_NAME: 'default',

    ATTACHMENT_POINTER_LENGTH: 10,
    ATTACHMENT_POINTER_WIDTH: 8,
    ATTACHMENT_CORNER_RADIUS: 5,
    ATTACHMENT_CONTENT_WIDTH: 30,
    ATTACHMENT_CONTENT_HEIGHT: 20,
    ATTACHMENT_POSITION: 'topright.topright',
    ATTACHMENT_XOFFSET: 0,
    ATTACHMENT_YOFFSET: 0,
    ATTACHMENT_PADDING: 0,
    ATTACHMENT_PADDING_LEFT: 0,
    ATTACHMENT_PADDING_RIGHT: 0,
    ATTACHMENT_PADDING_TOP: 0,
    ATTACHMENT_PADDING_BOTTOM: 0,
    ATTACHMENT_DIRECTION: 'right',
    ATTACHMENT_FILL: false,
    ATTACHMENT_FILL_COLOR: '#000000',
    ATTACHMENT_GRADIENT: null,
    ATTACHMENT_GRADIENT_COLOR: '#FFFFFF',
    ATTACHMENT_OUTLINE_WIDTH: -1,
    ATTACHMENT_OUTLINE_COLOR: '#000000',
    ATTACHMENT_CAP: 'butt',
    ATTACHMENT_JOIN: 'miter',
    ATTACHMENT_SHADOWABLE: true,

    NETWORK_TOOLTIP_ENABLED: true,
    NETWORK_SELECT_MODE: 'mix',
    NETWORK_MAKE_VISIBLE_ON_SELECTED: true,
    NETWORK_NO_AGENT_LINK_VISIBLE: false,
    NETWORK_REMOVE_ELEMENTUI_ON_INVISIBLE: false,
    NETWORK_SUBNETWORK_ANIMATE: true,
    NETWORK_SENDTOTOP_ON_SELECTED: true,
    NETWORK_KEYBOARD_REMOVE_ENABLED: true,
    NETWORK_KEYBOARD_SELECT_ENABLED: true,
    NETWORK_RECT_SELECT_ENABLED: true,
    NETWORK_DOUBLECLICK_TO_SUBNETWORK: true,
    NETWORK_DOUBLECLICK_TO_UPSUBNETWORK: true,
    NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK: true,
    NETWORK_DOUBLECLICK_TO_LINKBUNDLE: true,
    NETWORK_DOUBLECLICK_TO_GROUPEXPAND: true,
    NETWORK_SELECT_OUTLINE_COLOR: '#2877A8',
    NETWORK_SELECT_OUTLINE_WIDTH: 1,
    NETWORK_SELECT_FILL_COLOR: 'rgba(184,211,240,0.4)',
    NETWORK_LAZYMOVE_OUTLINE_COLOR: '#2877A8',
    NETWORK_LAZYMOVE_OUTLINE_WIDTH: 1,
    NETWORK_LAZYMOVE_FILL_COLOR: 'rgba(184,211,240,0.4)',
    NETWORK_LAZYMOVE_FILL: true,
    NETWORK_LAZYMOVE_ANIMATE: true,
    NETWORK_RESIZE_POINT_SIZE: 3,
    NETWORK_RESIZE_POINT_FILL_COLOR: '#FFFFFF',
    NETWORK_RESIZE_POINT_OUTLINE_COLOR: '#000000',
    NETWORK_RESIZE_POINT_OUTLINE_WIDTH: 1,
    NETWORK_RESIZE_LINE_COLOR: '#000000',
    NETWORK_RESIZE_LINE_WIDTH: 1,
    NETWORK_RESIZE_ANIMATE: true,
    NETWORK_EDIT_POINT_SIZE: 3,
    NETWORK_EDIT_POINT_FILL_COLOR: '#FFFF00',
    NETWORK_EDIT_POINT_OUTLINE_COLOR: '#000000',
    NETWORK_EDIT_POINT_OUTLINE_WIDTH: 1,
    NETWORK_EDIT_LINE_COLOR: 'rgba(184,211,240,0.7)',
    NETWORK_EDIT_LINE_WIDTH: 2,
    NETWORK_ROTATE_POINT_SIZE: 5,
    NETWORK_ROTATE_POINT_FILL_COLOR: '#FFFF00',
    NETWORK_ROTATE_POINT_OFFSET: 15,
    NETWORK_ROTATE_POINT_OUTLINE_WIDTH: 1,
    NETWORK_ROTATE_POINT_OUTLINE_COLOR: 'rgba(0,0,0,1)',
    NETWORK_ROTATE_SCALE_FILL_COLOR: 'rgb(227,166,103)',
    NETWORK_ROTATE_SCALE_FONT_COLOR: '#FFFFFF',
    NETWORK_ROTATE_SCALE_WIDTH: 30,
    NETWORK_ROTATE_SCALE_HEIGHT: 20,
    NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION: true,
    NETWORK_LINK_FLOW_STEPPING: 3,
    NETWORK_LINK_FLOW_COLOR: "#FF0000",
    NETWORK_LINK_FLOW_INTERVAL: 600,
    NETWORK_SELECTION_TOLERANCE: 2,
    NETWORK_TRANSPARENT_SELECTION_ENABLE:false,

    SHOW_ALARM_IN_ATTACHMENT_DIV: true,
    SHOW_LABEL_IN_ATTACHMENT_DIV: false,
    SHOW_LABEL2_IN_ATTACHMENT_DIV: false,
    SHOW_ICON_IN_ATTACHMENT_DIV: false,
    SHOW_EDIT_IN_ATTACHMENT_DIV: false,

    OVERVIEW_FILL_COLOR: 'rgba(184,211,240,0.4)',
    OVERVIEW_OUTLINE_COLOR: '#B8D3F0',
    OVERVIEW_OUTLINE_WIDTH: 1,
    OVERVIEW_SELECT_COLOR: '#0000FF',
    OVERVIEW_SELECT_WIDTH: 1,
    OVERVIEW_PADDING: 1,
    OVERVIEW_ANIMATE: true,
    OVERVIEW_MAX_PACKING_WIDTH: -1,
    OVERVIEW_MAX_PACKING_HEIGHT: -1,

    TOUCH_MOVE_THRESHOLD:5,
    TOUCH_RECT_SELECT_THRESHOLD:20,
    TOUCH_ZOOM_THRESHOLD:30,

    LINK_BUNDLE_AGENT_FUNCTION: null,
    IS_LINK_ADJUSTED_TO_BOTTOM: false,
    GROUP_EXPAND_ALIGN:'center',//lefttop,center

    ELEMENTUI_FUNCTION: function (network, element) {
        var clazz = element.getElementUIClass();
        if (clazz) {
            return new clazz(network, element);
        }
        return null;
    },

    CANVASUI_FUNCTION: function (network, element) {
        var clazz = element.getCanvasUIClass();
        if (clazz) {
            return new clazz(network, element);
        }
        return null;
    },
    VECTORUI_FUNCTION : function(network,element){
    	var clazz = element.getVectorUIClass();
    	if(clazz){
    		return new clazz(network,element);
    	}
    	return null;
    },
    KEEP_DEFAULT_FUNCTION: function (e) {
        if (e.target.keepDefault || e.target.getAttribute("keepDefault")) {
            return true;
        }
        if (e.target.parentNode && (e.target.parentNode.keepDefault || e.target.parentNode.getAttribute("keepDefault"))) {
            return true;
        }
        if (e.shiftKey) {
            return true;
        }
        return false;
    },
    SORT_FUNCTION: function (v1, v2) {
        if (v1 === v2) {
            return 0;
        }
        if (v1 == null && v2 != null) {
            return 1;
        }
        if (v1 != null && v2 == null) {
            return -1;
        }
        if (v1 == null && v2 == null) {
            return 0;
        }
        var t1 = typeof v1;
        var t2 = typeof v2;
        var value;
        if (t1 === 'string' && t2 === 'string') {
            value = v1.localeCompare(v2);
        }
        if (t1 === 'number' && t2 === 'number') {
            value = v1 - v2;
        }
        if (value === undefined) {
            value = ('' + v1).localeCompare('' + v2);
        }
        if (value > 0) {
            return 1;
        }
        else if (value < 0) {
            return -1;
        }
        return 0;
    },
    CENTER_LOCATION: false,
    PIXEL_FILTER_FUNCTION: function(sourceColor, filterColor) {
        if (!filterColor) {
            return sourceColor;
        }
        var brightness = sourceColor.r * 0.30 + sourceColor.g * 0.59 + sourceColor.b * 0.11;
        return {
            r: Math.floor(filterColor.r * brightness / 255),
            g:Math.floor(filterColor.g * brightness / 255),
            b:Math.floor(filterColor.b * brightness / 255),
        }
    }
};

(function () {
    var D = $Defaults;

    // override twaver defaults
    if (window.OverrideTWaverDefaults) {
        for (var name in OverrideTWaverDefaults) {
            D[name] = OverrideTWaverDefaults[name];
        }
    }

    // italic bold 12px Geneva,Helvetica,Arial,sans-serif
    if (D.VIEW_FONT_SIZE && D.VIEW_FONT_FAMILY) {
        D.FONT = D.VIEW_FONT_SIZE + ' ' + D.VIEW_FONT_FAMILY;
    } else {
        D.FONT = document.createElement('canvas').getContext('2d').font;
    }

    if (!D.CHART_VALUE_FONT) D.CHART_VALUE_FONT = '10px ' + D.VIEW_FONT_FAMILY;

    if (!D.BARCHART_XSCALE_TEXT_FONT) D.BARCHART_XSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
    if (!D.BARCHART_YSCALE_TEXT_FONT) D.BARCHART_YSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
    if (!D.BARCHART_XAXIS_TEXT_FONT) D.BARCHART_XAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;
    if (!D.BARCHART_YAXIS_TEXT_FONT) D.BARCHART_YAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;

    if (!D.LINECHART_XSCALE_TEXT_FONT) D.LINECHART_XSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
    if (!D.LINECHART_YSCALE_TEXT_FONT) D.LINECHART_YSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
    if (!D.LINECHART_XAXIS_TEXT_FONT) D.LINECHART_XAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;
    if (!D.LINECHART_YAXIS_TEXT_FONT) D.LINECHART_YAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;

    if (!D.BUBBLECHART_XAXIS_TEXT_FONT) D.BUBBLECHART_XAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;
    if (!D.BUBBLECHART_YAXIS_TEXT_FONT) D.BUBBLECHART_YAXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;
    if (!D.BUBBLECHART_XSCALE_TEXT_FONT) D.BUBBLECHART_XSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
    if (!D.BUBBLECHART_YSCALE_TEXT_FONT) D.BUBBLECHART_YSCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;

    if (!D.RADARCHART_AXIS_TEXT_FONT) D.RADARCHART_AXIS_TEXT_FONT = '12px ' + D.VIEW_FONT_FAMILY;
    if (!D.RADARCHART_SCALE_TEXT_FONT) D.RADARCHART_SCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;

    if (!D.DIALCHART_SCALE_TEXT_FONT) D.DIALCHART_SCALE_TEXT_FONT = '10px ' + D.VIEW_FONT_FAMILY;
})();
twaver.Defaults = $Defaults;
_twaver.ext('twaver.Defaults', Object, {});

twaver.Colors = {
  orange: '#EC6C00',
  orange_light: '#EF8200',
  orange_dark: '#EA5404',
  gray_light: '#666666',
  gray_dark: '#242424',
  green_light: '#57AB9A',
  green_dark: '#238475',
  blue_light: '#61B6D8',
  blue_dark: '#0089C1'
};
twaver.SerializationSettings = function () {
    var s = twaver.SerializationSettings;

    this.isDataBoxSerializable = s.isDataBoxSerializable;
    this.isLayerBoxSerializable = s.isLayerBoxSerializable;
    this.isStyleSerializable = s.isStyleSerializable;
    this.isClientSerializable = s.isClientSerializable;
    this.isImageSerializable = s.isImageSerializable;

    this._pm = _twaver.clone(s._pm);
    this._sm = _twaver.clone(s._sm);
    this._cm = _twaver.clone(s._cm);
};
(function () {
    var s = twaver.SerializationSettings;
    s.isDataBoxSerializable = true;
    s.isLayerBoxSerializable = true;
    s.isStyleSerializable = true;
    s.isClientSerializable = true;
    s.isImageSerializable = true;

    s._pm = {};
    s._sm = {};
    s._cm = {};

    s.setPropertyType = function (property, type) {
        s._pm[property] = type;
    };
    s.getPropertyType = function (property) {
        return s._pm[property];
    }
    s.setStyleType = function (style, type) {
        s._sm[style] = type;
    };
    s.getStyleType = function (style) {
        return s._sm[style];
    };
    s.setClientType = function (client, type) {
        s._cm[client] = type;
    };
    s.getClientType = function (client) {
        return s._cm[client];
    };
})();

_twaver.ext('twaver.SerializationSettings', Object, {
    setPropertyType: function (property, type) {
        this._pm[property] = type;
    },
    getPropertyType: function (property) {
        return this._pm[property];
    },
    setStyleType: function (style, type) {
        this._sm[style] = type;
    },
    getStyleType: function (style) {
        return this._sm[style];
    },
    setClientType: function (client, type) {
        this._cm[client] = type;
    },
    getClientType: function (client) {
        return this._cm[client];
    }
});


var $Styles = twaver.Styles = {
    _m: {},
    setStyle: function (styleProp, newValue) {
        if (newValue == null) {
            delete $Styles._m[styleProp];
        } else {
            $Styles._m[styleProp] = newValue;
        }
    },
    getStyle: function (styleProp) {
        return $Styles._m[styleProp];
    },
    getStyleProperties: function () {
        return _twaver.keys(twaver.Styles._m);
    }
};

(function () {
    var r = function (name, type) {
        twaver.SerializationSettings.setPropertyType(name, type);
    };

    //r('id', 'string');
    r('name', 'cdata');
    r('name2', 'cdata');
    r('icon', 'string');
    r('toolTip', 'cdata');
    r('parent', 'data');
    r('layerId', 'string');
    r('alarmState', 'alarmstate');
    r('image', 'string');
    r('imageUrl', 'string');
    r('location', 'point');
    r('width', 'number');
    r('height', 'number');
    r('expanded', 'boolean');
    r('host', 'data');
    r('fromNode', 'data');
    r('toNode', 'data');
    r('points', 'list.point');
    r('segments', 'list.string');
    r('angle', 'number');
    r('visible', 'boolean');

    r = function (name, value, type) {
        if (type == null) {
            if (value != null) {
                type = typeof value;
            } else {
                type = 'string';
            }
        }
        twaver.Styles.setStyle(name, value);
        twaver.SerializationSettings.setStyleType(name, type);
    };

    // for chart style
    r('chart.color', null);
    r('chart.value', 0);
    r('chart.values', null, 'list.number');
    r('chart.value.color', '#000000');
    r('chart.value.font', null);
    r('chart.line.width', 2);
    r('chart.marker.size', 6);
    r('chart.marker.shape', 'circle'); // 'rectangle', 'oval', 'roundrect', 'star', 'triangle', 'circle', 'hexagon', 'pentagon', 'diamond'

    r('chart.bubble.shape', 'circle');
    r('chart.names', null, 'list.string');
    r('chart.xaxis.values', null, 'list.number');
    r('chart.yaxis.values', null, 'list.number');

    r('dialchart.rear.extension', 0);
    r('dialchart.base.width', 5);
    r('dialchart.top.width', 0);
    r('dialchart.radius', 0.8);

    // for network style
    r('inner.color', null);

    r('outer.shape', 'rectangle');
    r('outer.color', null);
    r('outer.width', 2);
    r('outer.padding', 1);
    r('outer.padding.left', 0);
    r('outer.padding.right', 0);
    r('outer.padding.top', 0);
    r('outer.padding.bottom', 0);
    r('outer.cap', 'butt');
    r('outer.join', 'miter');
    r('outer.style', 'border');//null, border, glow

    r('shadow.color', null);
    r('shadow.xoffset', 3);
    r('shadow.yoffset', 3);
    r('shadow.blur', 6);

    r('select.style', 'shadow');  // null,shadow,border
    r('select.color', 'rgba(0, 0, 0, 0.7)');
    r('select.shape', 'rectangle');
    r('select.width', 2);
    r('select.padding', 2);
    r('select.padding.left', 0);
    r('select.padding.right', 0);
    r('select.padding.top', 0);
    r('select.padding.bottom', 0);
    r('select.cap', 'butt');
    r('select.join', 'miter');

    r('whole.alpha', 1);
    r('body.type', 'default'); // 'none', 'default', 'vector', 'default.vector', 'vector.default'
    r('network.label', null, 'cdata');

    r('image.padding', 0);
    r('image.padding.left', 0);
    r('image.padding.right', 0);
    r('image.padding.top', 0);
    r('image.padding.bottom', 0);
    r('image.state', null);

    r('vector.shape', 'rectangle');
    r('vector.fill', true);
    r('vector.fill.color', '#CCCCFF');
    r('vector.outline.width', -1);
    r('vector.outline.pattern', null, 'array.number');
    r('vector.outline.color', '#5B5B5B');
    r('vector.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('vector.gradient.color', '#FFFFFF');
    r('vector.padding', 0);
    r('vector.padding.left', 0);
    r('vector.padding.right', 0);
    r('vector.padding.top', 0);
    r('vector.padding.bottom', 0);
    r('vector.cap', 'butt');
    r('vector.join', 'miter');
    r('vector.deep', 0);

    r('group.shape', 'rectangle');
    r('group.fill', true);
    r('group.fill.color', '#CCCCFF');
    r('group.outline.width', -1);
    r('group.outline.color', '#5B5B5B');
    r('group.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('group.gradient.color', '#FFFFFF');
    r('group.padding', 5);
    r('group.padding.left', 0);
    r('group.padding.right', 0);
    r('group.padding.top', 0);
    r('group.padding.bottom', 0);
    r('group.cap', 'butt');
    r('group.join', 'miter');
    r('group.deep', 1);
    r('group.shape.roundrect.radius', -1);
    r('group.expend.image',null);
    r('group.expend.image.vector',false);

    r('label.alpha', 1);
    r('label.color', '#000000');
    r('label.font', null);
    r('label.position', 'bottom.bottom'); // 'topleft.topleft', 'top.top', 'topright.topright', 'right.right', 'left.left', 'bottom.bottom', 'bottomleft.bottomleft', 'bottomright.bottomright'
    r('label.direction', 'below');
    r('label.corner.radius', 0);
    r('label.pointer.length', 0);
    r('label.pointer.width', 8);
    r('label.xoffset', 0);
    r('label.yoffset', 2);
    r('label.padding', 0);
    r('label.padding.left', 0);
    r('label.padding.right', 0);
    r('label.padding.top', 0);
    r('label.padding.bottom', 0);
    r('label.fill', false);
    r('label.fill.color', '#C0C0C0');
    r('label.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('label.gradient.color', '#FFFFFF');
    r('label.outline.width', -1);
    r('label.outline.color', '#000000');
    r('label.cap', 'butt');
    r('label.join', 'miter');
    r('label.shadowable', true);
    r('label.align', 'center');//'left','right','center'
    r('label.rotate.angle',0);
    r('label.maxlength',0);
    r('link.label.rotatable', false);
    r('label.linespacing',15);

    r('label2.alpha', 1);
    r('label2.color', '#000000');
    r('label2.font', null);
    r('label2.position', 'top.top'); // 'topleft.topleft', 'top.top', 'topright.topright', 'right.right', 'left.left', 'bottom.bottom', 'bottomleft.bottomleft', 'bottomright.bottomright'
    r('label2.direction', 'below');
    r('label2.corner.radius', 0);
    r('label2.pointer.length', 0);
    r('label2.pointer.width', 8);
    r('label2.xoffset', 0);
    r('label2.yoffset', -2);
    r('label2.padding', 0);
    r('label2.padding.left', 0);
    r('label2.padding.right', 0);
    r('label2.padding.top', 0);
    r('label2.padding.bottom', 0);
    r('label2.fill', false);
    r('label2.fill.color', '#C0C0C0');
    r('label2.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('label2.gradient.color', '#FFFFFF');
    r('label2.outline.width', -1);
    r('label2.outline.color', '#000000');
    r('label2.cap', 'butt');
    r('label2.join', 'miter');
    r('label2.shadowable', true);
    r('label2.align', 'center');
    r('label2.rotate.angle',0);
    r('label2.maxlength',0);
    r('label2.linespacing',15);
    r('link.label2.rotatable', false);

    r('icons.names', null, 'array.string');
    r('icons.colors', null, 'array.string');
    r('icons.position', null,'array.string');
    r('icons.orientation',null, 'array.string');
    r('icons.xoffset', [0],'array.number');
    r('icons.yoffset', [0],'array.number');
    r('icons.xgap', [1],'array.number');
    r('icons.ygap', [1],'array.number');

    r('alarm.alpha', 1);
    r('alarm.color', '#000000');
    r('alarm.font', null);
    r('alarm.position', 'hotspot');
    r('alarm.direction', 'aboveright');
    r('alarm.corner.radius', 5);
    r('alarm.pointer.length', 10);
    r('alarm.pointer.width', 8);
    r('alarm.xoffset', 0);
    r('alarm.yoffset', 0);
    r('alarm.padding', 0);
    r('alarm.padding.left', 0);
    r('alarm.padding.right', 0);
    r('alarm.padding.top', 0);
    r('alarm.padding.bottom', 0);
    r('alarm.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('alarm.gradient.color', '#FFFFFF');
    r('alarm.outline.width', -1);
    r('alarm.outline.color', '#000000');
    r('alarm.cap', 'butt');
    r('alarm.join', 'miter');
    r('alarm.shadowable', true);

    r('link.color', '#658DC1');
    r('link.width', 3);
    r('link.cap', 'butt');
    r('link.join', 'miter');
    r('link.type', 'arc'); // 'arc', 'triangle', 'parallel', 'flexional', 'flexional.horizontal', 'flexional.vertical',
    // 'orthogonal', 'orthogonal.horizontal', 'orthogonal.vertical', 'orthogonal.H.V', 'orthogonal.V.H'
    // 'extend.top', 'extend.left', 'extend.bottom', 'extend.right'
    r('link.pattern', null, 'array.number');
    r('link.extend', 20);
    r('link.control.point', null, 'point');
    r('link.bundle.id', 0);
    r('link.bundle.enable', true);
    r('link.bundle.expanded', true);
    r('link.bundle.independent', false);
    r('link.bundle.offset', 20);
    r('link.bundle.gap', 12);
    r('link.bundle.group.gap', 0);

    r('link.looped.gap', 6);
    r('link.looped.direction', 'northwest'); // 'northwest', 'north', 'northeast', 'east', 'west', 'south', 'southwest', 'southeast'
    r('link.looped.type', 'arc'); // 'arc', 'rectangle'
    r('link.from.position', 'center');
    r('link.from.xoffset', 0);
    r('link.from.yoffset', 0);
    r('link.from.percent', null);
    r('link.from.at.edge', true);
    r('link.to.position', 'center');
    r('link.to.xoffset', 0);
    r('link.to.yoffset', 0);
    r('link.to.percent', null);
    r('link.to.at.edge', true);
    r('link.split.by.percent', true);
    r('link.split.percent', 0.5);
    r('link.split.value', 20);
    r('link.corner', 'round'); // 'none', 'round', 'bevel'
    r('link.xradius', 8);
    r('link.yradius', 8);
    r('link.flow', false);
    r('link.flow.converse', false);
    r('link.flow.offset',0);

    r('link.handler.alpha', 1);
    r('link.handler.color', '#000000');
    r('link.handler.font', null);
    r('link.handler.position', 'topleft.topleft');
    r('link.handler.direction', 'below');
    r('link.handler.corner.radius', 0);
    r('link.handler.pointer.length', 0);
    r('link.handler.pointer.width', 8);
    r('link.handler.xoffset', 0);
    r('link.handler.yoffset', 0);
    r('link.handler.padding', 0);
    r('link.handler.padding.left', 0);
    r('link.handler.padding.right', 0);
    r('link.handler.padding.top', 0);
    r('link.handler.padding.bottom', 0);
    r('link.handler.fill', false);
    r('link.handler.fill.color', '#C0C0C0');
    r('link.handler.gradient', 'none'); // 'linear.east', 'linear.north', 'linear.northeast', 'linear.northwest', 'linear.south', 'linear.southeast', 'linear.southwest', 'linear.west', 'none', 'radial.center', 'radial.east', 'radial.north', 'radial.northeast', 'radial.northwest', 'radial.south', 'radial.southeast', 'radial.southwest', 'radial.west', 'spread.antidiagonal', 'spread.diagonal', 'spread.east', 'spread.horizontal', 'spread.north', 'spread.south', 'spread.vertical', 'spread.west'
    r('link.handler.gradient.color', '#FFFFFF');
    r('link.handler.outline.width', -1);
    r('link.handler.outline.color', '#000000');
    r('link.handler.cap', 'butt'); // 'butt', 'round', 'square'
    r('link.handler.join', 'miter'); // 'miter', 'round', 'bevel'
    r('link.handler.shadowable', true);

    r('link.agent', false);
    r('link.agent.color', '#658DC1');
    r('link.agent.width', 3);
    r('link.agent.cap', 'butt');
    r('link.agent.join', 'miter');
    r('link.agent.type', 'arc'); // 'arc', 'triangle', 'parallel', 'flexional', 'flexional.horizontal', 'flexional.vertical',
    // 'orthogonal', 'orthogonal.horizontal', 'orthogonal.vertical', 'orthogonal.H.V', 'orthogonal.V.H'
    // 'extend.top', 'extend.left', 'extend.bottom', 'extend.right'
    r('link.agent.pattern', null, 'array.number');
    r('link.agent.extend', 20);
    r('link.agent.control.point', null, 'point');

    r('link.agent.from.position', 'center');
    r('link.agent.from.xoffset', 0);
    r('link.agent.from.yoffset', 0);
    r('link.agent.from.percent', null);
    r('link.agent.from.at.edge', true);
    r('link.agent.to.position', 'center');
    r('link.agent.to.xoffset', 0);
    r('link.agent.to.yoffset', 0);
    r('link.agent.to.percent', null);
    r('link.agent.to.at.edge', true);
    r('link.agent.split.by.percent', true);
    r('link.agent.split.percent', 0.5);
    r('link.agent.split.value', 20);
    r('link.agent.corner', 'round'); // 'none', 'round', 'bevel'
    r('link.agent.xradius', 8);
    r('link.agent.yradius', 8);
    r('link.agent.flow', false);
    r('link.agent.flow.converse', false);
    r('link.agent.flow.offset',0);

    r('follower.row.index', 0);
    r('follower.column.index', 0);
    r('follower.row.span', 1);
    r('follower.column.span', 1);
    r('follower.padding', 0);
    r('follower.padding.left', 0);
    r('follower.padding.right', 0);
    r('follower.padding.top', 0);
    r('follower.padding.bottom', 0);
    r('follower.fill.cell', true);
    r('follower.cell.position', 'center');

    r('glow.blur', 20);

    r('grid.row.count', 1);
    r('grid.column.count', 1);
    r('grid.row.percents', null, 'array.number');
    r('grid.column.percents', null, 'array.number');
    r('grid.border', 1);
    r('grid.border.left', 0);
    r('grid.border.right', 0);
    r('grid.border.top', 0);
    r('grid.border.bottom', 0);
    r('grid.padding', 1);
    r('grid.padding.left', 0);
    r('grid.padding.right', 0);
    r('grid.padding.top', 0);
    r('grid.padding.bottom', 0);
    r('grid.fill', true);
    r('grid.fill.color', '#C0C0C0');
    r('grid.deep', 1);
    r('grid.cell.deep', -1);

    r('shapelink.type', 'lineto'); // 'lineto', 'quadto', 'cubicto'

    r('shapenode.closed', false);
    r('shapenode.pattern', null, 'array.number');

    r('bus.style', 'nearby'); // 'nearby', 'north', 'south', 'west', 'east'

    // Arrow
    r('arrow.from', false);
    r('arrow.from.fill', true);
    r('arrow.from.shape', 'arrow.standard'); // 'arrow.standard', 'arrow.delta', 'arrow.diamond', 'arrow.short', 'arrow.slant'
    r('arrow.from.color', '#000000');
    r('arrow.from.xoffset', 0);
    r('arrow.from.yoffset', 0);
    r('arrow.from.width', 12);
    r('arrow.from.height', 9);
    r('arrow.from.outline.color', '#000000');
    r('arrow.from.outline.width', -1);
    r('arrow.from.at.edge', true);
    r('arrow.from.shadow', false);
    r('arrow.from.shadow.color', '#000000');
    r('arrow.from.shadow.xoffset', 0);
    r('arrow.from.shadow.yoffset', 0);
    r('arrow.from.shadow.blur', 16);

    r('arrow.to', false);
    r('arrow.to.fill', true);
    r('arrow.to.shape', 'arrow.standard'); // 'arrow.standard', 'arrow.delta', 'arrow.diamond', 'arrow.short', 'arrow.slant'
    r('arrow.to.color', '#000000');
    r('arrow.to.xoffset', 0);
    r('arrow.to.yoffset', 0);
    r('arrow.to.width', 12);
    r('arrow.to.height', 9);
    r('arrow.to.outline.color', '#000000');
    r('arrow.to.outline.width', -1);
    r('arrow.to.at.edge', true);

    r('arrow.agent.from', false);
    r('arrow.agent.from.fill', true);
    r('arrow.agent.from.shape', 'arrow.standard'); // 'arrow.standard', 'arrow.delta', 'arrow.diamond', 'arrow.short', 'arrow.slant'
    r('arrow.agent.from.color', '#000000');
    r('arrow.agent.from.xoffset', 0);
    r('arrow.agent.from.yoffset', 0);
    r('arrow.agent.from.width', 12);
    r('arrow.agent.from.height', 9);
    r('arrow.agent.from.outline.color', '#000000');
    r('arrow.agent.from.outline.width', -1);
    r('arrow.agent.from.at.edge', true);
    r('arrow.agent.from.shadow', false);
    r('arrow.agent.from.shadow.color', '#000000');
    r('arrow.agent.from.shadow.xoffset', 0);
    r('arrow.agent.from.shadow.yoffset', 0);
    r('arrow.agent.from.shadow.blur', 16);

    r('arrow.agent.to', false);
    r('arrow.agent.to.fill', true);
    r('arrow.agent.to.shape', 'arrow.standard'); // 'arrow.standard', 'arrow.delta', 'arrow.diamond', 'arrow.short', 'arrow.slant'
    r('arrow.agent.to.color', '#000000');
    r('arrow.agent.to.xoffset', 0);
    r('arrow.agent.to.yoffset', 0);
    r('arrow.agent.to.width', 12);
    r('arrow.agent.to.height', 9);
    r('arrow.agent.to.outline.color', '#000000');
    r('arrow.agent.to.outline.width', -1);
    r('arrow.agent.to.at.edge', true);

    r("background.image",null);
    r("background.image.scope",'viewport');//'viewsize','viewport','rootcanvas'
    r("background.type","none"); //'none','image','vector','image.vector','vector.image'
    r("background.outline.width",-1);
    r("background.outline.color",null);
    r("background.vector.padding",0);
    r("background.image.padding",0);
    r("background.image.stretch","fill");//"fill","tile","none"
    r("background.vector.scope",'viewport');//'viewsize','viewport','rootcanvas',
    // r("background.vector.stretch",'fill');
    r("background.vector.fill",null);
    r("background.vector.fill.color",null);
    r("background.vector.gradient",false);
    r("background.vector.gradient.color",null);
    r("background.vector.shape","rectangle");
    r('background.outline.pattern', null, 'array.number');

    r('attachment.label.style','html');//'none', 'html'
    r('attachment.label2.style','html');//'none', 'html'
    r('attachment.alarm.style','html');

    r('attachment.htmllabel.hyperlink',false);
    r('attachment.htmllabel2.hyperlink',false);

    r('attachment.zIndex',1000);
    r('attachment.pointer.events','auto');


})();
_twaver.ext('twaver.Styles', Object, {});

twaver.PropertyChangeDispatcher = function () {
    this._dispatcher = new twaver.EventDispatcher();
};
_twaver.ext('twaver.PropertyChangeDispatcher', Object, {
    addPropertyChangeListener: function (listener, scope, ahead) {
        this._dispatcher.add(listener, scope, ahead);
    },
    removePropertyChangeListener: function (listener, scope) {
        this._dispatcher.remove(listener, scope);
    },
    firePropertyChange: function (property, oldValue, newValue) {
        if (oldValue == newValue) {
            return false;
        }
        var e = {
            property: property,
            oldValue: oldValue,
            newValue: newValue,
            source: this
        };
        this._dispatcher.fire(e);
        this.onPropertyChanged(e);
        return true;
    },
    onPropertyChanged: function (e) {
    }
});


twaver.animate.Animate = function () {

};
_twaver.ext('twaver.animate.Animate', Object, {
    current: 0,
    step: 8,
    delay: 4,
    finishFunction: null,
    shouldBeFinished: false,

    getCurrentDelay: function () {
        return this.delay * this.current + 1;
    },
    action: function (rate) {

    }
});

twaver.animate.AnimateProperty = function (objects, newValues, finishFunction) {
    this.objects = objects;
    this.newValues = newValues;
    this.finishFunction = finishFunction;
    this.oldValues = new $List();
    var size = this.objects.size();
    for (var i = 0; i < size; i++) {
        var obj = this.objects.get(i);
        this.oldValues.add(this.getPropertyValue(obj));
    }
};
_twaver.ext('twaver.animate.AnimateProperty', twaver.animate.Animate, {
    action: function (rate) {
        var size = this.objects.size();
        for (var i = 0; i < size; i++) {
            var obj = this.objects.get(i);
            var oldValue = this.oldValues.get(i);
            var newValue = this.newValues.get(i);
            this.currentAction(obj, oldValue, newValue, rate);
        }
    },
    getPropertyValue: function (obj) {
    },
    currentAction: function (obj, oldValue, newValue, rate) {
    }
});

twaver.animate.AnimateBounds = function (node, newBounds, finishFunction) {
    this.node = node;
    this.newBounds = newBounds;
    this.oldBounds = node.getRect();
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateBounds', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        var o = this.oldBounds;
        var n = this.newBounds;
        this.node.setLocation(
					o.x + (n.x - o.x) * rate,
					o.y + (n.y - o.y) * rate);
        this.node.setSize(
					o.width + (n.width - o.width) * rate,
					o.height + (n.height - o.height) * rate);
    }
});

twaver.animate.AnimateCenterLocation = function (objects, newValues, finishFunction) {
    twaver.animate.AnimateCenterLocation.superClass.constructor.call(this, objects, newValues, finishFunction);
};
_twaver.ext('twaver.animate.AnimateCenterLocation', twaver.animate.AnimateProperty, {
    getPropertyValue: function (obj) {
        return obj.getCenterLocation();
    },
    currentAction: function (obj, oldValue, newValue, rate) {
        var x = oldValue.x + (newValue.x - oldValue.x) * rate;
        var y = oldValue.y + (newValue.y - oldValue.y) * rate;
        obj.setCenterLocation(x, y);
    }
});

twaver.animate.AnimateLocation = function (objects, newValues, finishFunction) {
    twaver.animate.AnimateLocation.superClass.constructor.call(this, objects, newValues, finishFunction);
};
_twaver.ext('twaver.animate.AnimateLocation', twaver.animate.AnimateProperty, {
    getPropertyValue: function (obj) {
        return obj.getLocation();
    },
    currentAction: function (obj, oldValue, newValue, rate) {
        var x = oldValue.x + (newValue.x - oldValue.x) * rate;
        var y = oldValue.y + (newValue.y - oldValue.y) * rate;
        obj.setLocation(x, y);
    }
});

twaver.animate.AnimateScrollPosition = function (view, newHorizontalOffset, newVerticalOffset) {
    this.view = view;
    this.oldHorizontalOffset = view.scrollLeft;
    this.oldVerticalOffset = view.scrollTop;
    this.newHorizontalOffset = newHorizontalOffset;
    this.newVerticalOffset = newVerticalOffset;
};
_twaver.ext('twaver.animate.AnimateScrollPosition', twaver.animate.Animate, {
    action: function (rate) {
        this.view.scrollLeft = this.oldHorizontalOffset + (this.newHorizontalOffset - this.oldHorizontalOffset) * rate;
        this.view.scrollTop = this.oldVerticalOffset + (this.newVerticalOffset - this.oldVerticalOffset) * rate;
    }
});

twaver.animate.AnimateZoom = function (view, newZoom, finishFunction) {
    this.view = view;
    this.oldZoom = view.getZoom();
    this.newZoom = newZoom;
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateZoom', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        this.view.setZoom(this.oldZoom + (this.newZoom - this.oldZoom) * rate, false);
    }
});

twaver.animate.AnimateXZoom = function (view, newXZoom, finishFunction) {
    this.view = view;
    this.oldXZoom = view.getXZoom();
    this.newXZoom = newXZoom;
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateXZoom', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        this.view.setXZoom(this.oldXZoom + (this.newXZoom - this.oldXZoom) * rate, false);
    }
});

twaver.animate.AnimateYZoom = function (view, newYZoom, finishFunction) {
    this.view = view;
    this.oldYZoom = view.getYZoom();
    this.newYZoom = newYZoom;
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateYZoom', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        this.view.setYZoom(this.oldYZoom + (this.newYZoom - this.oldYZoom) * rate, false);
    }
});

twaver.animate.AnimateXYZoom = function (view, newXZoom, newYZoom, finishFunction) {
    this.view = view;
    this.oldXZoom = view.getXZoom();
    this.newXZoom = newXZoom;
    this.oldYZoom = view.getYZoom();
    this.newYZoom = newYZoom;
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateXYZoom', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        this.view.setXZoom(this.oldXZoom + (this.newXZoom - this.oldXZoom) * rate, false);
        this.view.setYZoom(this.oldYZoom + (this.newYZoom - this.oldYZoom) * rate, false);
    }
});

twaver.animate.AnimateSubNetwork = function (network, subNetwork, finishFunction) {
    this.network = network;
    this.subNetwork = subNetwork;
    this.finishFunction = finishFunction;
};
_twaver.ext('twaver.animate.AnimateSubNetwork', twaver.animate.Animate, {
    shouldBeFinished: true,
    action: function (rate) {
        if (rate > 0.5) {
            this.network.getView().style.opacity = rate * 2 - 1;
            this.network._setCurrentSubNetwork(this.subNetwork);
        } else {
            this.network.getView().style.opacity = 1 - rate * 2;
        }
    }
});

twaver.animate.AnimateManager = {
    timer: null,
    animate: null,
    start: function (newAnimate, delay) {
        var a = twaver.animate.AnimateManager;
        if (newAnimate.current < 0) {
            newAnimate.current = 0;
        }
        if (delay) {
            _twaver.callLater(a.startImpl, null, [newAnimate], delay);
        } else {
            a.startImpl(newAnimate);
        }
    },
    startImpl: function (newAnimate) {
        var a = twaver.animate.AnimateManager;
        if (a.animate) {
            a.endAnimate();
        }
        a.animate = newAnimate;
        a.timer = setTimeout(a.tick, newAnimate.getCurrentDelay());
    },
    tick: function () {
        var a = twaver.animate.AnimateManager;
        var animate = a.animate;
        if (!animate) {
            return;
        }
        if (animate.current < 0) {
            animate.current++;
            return;
        }
        if (animate.current < animate.step) {
            animate.current++;
            animate.action(animate.current / animate.step);
            a.timer = setTimeout(a.tick, animate.getCurrentDelay());
        }
        if (animate.current >= animate.step) {
            a.endAnimate();
        }
    },
    endAnimate: function () {
        var a = twaver.animate.AnimateManager;
        if (a.animate) {
            if (a.animate.shouldBeFinished && a.animate.current < a.animate.step) {
                a.animate.current = a.animate.step;
                a.animate.action(a.animate.current / a.animate.step);
            }
            var f = a.animate.finishFunction;
            a.animate = null;
            if (a.timer) {
                clearTimeout(a.timer);
                a.timer = null;
            }
            if (f) {
                f();
            }
        } else {
            if (a.timer) {
                clearTimeout(a.timer);
                a.timer = null;
            }
        }
    }
};


twaver.DataBox = function (name) {
    twaver.DataBox.superClass.constructor.apply(this, arguments);
    if (arguments.length === 1) {
        this._name = name;
    }
    this._dataList = new $List();
    this._dataMap = {};
    this._rootList = new $List();
    this._rootMap = {};
    this._clientMap = {};

    this._dataBoxChangeDispatcher = new twaver.EventDispatcher();
    this._dataPropertyChangeDispatcher = new twaver.EventDispatcher();
    this._hierarchyChangeDispatcher = new twaver.EventDispatcher();

    this._selectionModel = new twaver.SelectionModel(this);

};
_twaver.ext('twaver.DataBox', twaver.PropertyChangeDispatcher, {
    IClient: true,
    __client: 1,
    __new: 1,
    _limit: -1,
    _name: 'DataBox',
    _icon: $Defaults.ICON_DATABOX,
    __accessor: ['name', 'icon', 'toolTip'],
    getSelectionModel: function () {
        return this._selectionModel;
    },
    size: function () {
        return this._dataList.size();
    },
    isEmpty: function () {
        return this._dataList.isEmpty();
    },
    getLimit: function () {
        return this._limit;
    },
    setLimit: function (limit) {
        var oldValue = this._limit;
        this._limit = limit;
        this.firePropertyChange('limit', oldValue, limit);
        this._checkLimit();
    },
    _checkLimit: function () {
        if (this._limit >= 0 && this.size() > this._limit) {
            this.removeFirst(this.size() - this._limit);
        }
    },
    removeFirst: function (count) {
        if (arguments.length === 0) {
            count = 1;
        }
        while (count > 0 && this._dataList.size() > 0) {
            var data = this._dataList.get(0);
            this.remove(data);
            count--;
        }
    },
    getSiblings: function (data) {
        if (!this.contains(data)) {
            throw data + " dosen't belong to this dataBox";
        }
        var parent = data.getParent();
        if (parent) {
            return parent.getChildren();
        } else {
            return this._rootList;
        }
    },
    getRoots: function () {
        return this._rootList;
    },
    getSiblingIndex: function (data) {
        if (data.getParent()) {
            return data.getParent().getChildren().indexOf(data);
        } else {
            return this._rootList.indexOf(data);
        }
    },
    getDatas: function () {
        return this._dataList;
    },
    getDataAt: function (index) {
        return this._dataList.get(index);
    },
    toDatas: function (matchFunction, scope) {
        return this._dataList.toList(matchFunction, scope);
    },
    forEach: function (f, scope) {
        this._dataList.forEach(f, scope);
    },
    forEachReverse: function (f, scope) {
        this._dataList.forEachReverse(f, scope);
    },
    forEachByDepthFirst: function (callbackFunction, data, scope) {
        if (data) {
            this._depthFirst(callbackFunction, data, scope);
        } else {
            var n = this._rootList.size();
            for (var i = 0; i < n; i++) {
                var root = this._rootList.get(i);
                if (this._depthFirst(callbackFunction, root, scope) === false) {
                    return;
                }
            }
        }
    },
    _depthFirst: function (callbackFunction, data, scope) {
        var n = data.getChildrenSize()
        for (var i = 0; i < n; i++) {
            var child = data.getChildAt(i);
            if (this._depthFirst(callbackFunction, child, scope) === false) {
                return false;
            }
        }
        if (scope) {
            if (callbackFunction.call(scope, data) === false) {
                return false;
            }
        } else {
            if (callbackFunction(data) === false) {
                return false;
            }
        }
    },
    forEachByBreadthFirst: function (callbackFunction, data, scope) {
        var list = new $List();
        if (data) {
            list.add(data);
        } else {
            this._rootList.forEach(list.add, list);
        }
        while (list.size() > 0) {
            data = list.removeAt(0);
            data.getChildren().forEach(list.add, list);
            if (scope) {
                if (callbackFunction.call(scope, data) === false) {
                    return;
                }
            } else {
                if (callbackFunction(data) === false) {
                    return;
                }
            }
        }
    },
    add: function (data, index) {
        if (!data) {
            return;
        }
        if (arguments.length === 1) {
            index = -1;
        }
        var id = data.getId();
        if (this._dataMap.hasOwnProperty(id)) {
            throw "Data with ID '" + id + "' already exists";
        }
        this._dataBoxChangeDispatcher.fire({ kind: 'preAdd', data: data });
        this._dataMap[id] = data;
        this._dataList.add(data);

        if (!data.getParent()) {
            this._rootMap[id] = data;
            if (index >= 0) {
                this._rootList.add(data, index);
            } else {
                this._rootList.add(data);
            }
        }

        data.addPropertyChangeListener(this.handleDataPropertyChange, this, true);
        this._dataBoxChangeDispatcher.fire({ kind: 'add', data: data });

        this._checkLimit();
    },
    addByDescendant : function(data) {
        this.add(data);
        if (data.getChildren().size() > 0) {
            data.getChildren().forEach(function(child) {
                this.addByDescendant(child);
            }, this);
        }
    },
    remove: function (data) {
        this.removeById(data.getId());
    },
    removeSelection: function () {
        this._selectionModel.toSelection().forEach(function (data) {
            this.remove(data);
        }, this);
    },
    removeById: function (id) {
        var data = this.getDataById(id);
        if (!data) {
            return;
        }

        this._dataBoxChangeDispatcher.fire({ kind: 'preRemove', data: data });

        // if link, remove from and to node
        if (data instanceof twaver.Link) {
            data.setFromNode(null);
            data.setToNode(null);
        }

        // if have link, remove link first.
        if (data instanceof $Node && data.getLinks()) {
            data.getLinks().toList().forEach(function (link) {
                this.remove(link);
            }, this);
        }

        // if have followers, remove relation
        if (data instanceof $Node && data.getFollowers()) {
            data.getFollowers().toList().forEach(function (follower) {
                follower.setHost(null);
            });
        }

        // if have host, remove relation
        if (data instanceof twaver.Follower && data.getHost()) {
            data.setHost(null);
        }

        // if have children, remove children first.
        data.toChildren().forEach(function (child) {
            this.remove(child);
        }, this);

        // if parent not null, remove from parent.			
        if (data.getParent()) {
            data.getParent().removeChild(data);
        }

        this._dataList.remove(data);
        delete this._dataMap[id];

        if (this._rootMap[id]) {
            delete this._rootMap[id];
            this._rootList.remove(data);
        }

        this._dataBoxChangeDispatcher.fire({ kind: 'remove', data: data });
        data.removePropertyChangeListener(this.handleDataPropertyChange, this);
    },
    clear: function () {
        if (this._dataList.size() > 0) {
            this._dataList.forEach(function (data) {
                data.removePropertyChangeListener(this.handleDataPropertyChange, this);
            }, this);
            var datas = this._dataList.toList();
            this._dataList.clear();
            this._dataMap = {};
            this._rootList.clear();
            this._rootMap = {};
            this._dataBoxChangeDispatcher.fire({ kind: 'clear', datas: datas });
        }
    },
    getDataById: function (id) {
        return this._dataMap[id];
    },
    containsById: function (id) {
        return this._dataMap.hasOwnProperty(id);
    },
    contains: function (data) {
        if (data) {
            return this._dataMap[data._id] === data;
        }
        return false;
    },
    moveTo: function (data, newIndex) {
        if (!this.contains(data)) {
            throw data + " dosen't belong to this dataBox";
        }
        var list = this.getSiblings(data);
        var oldIndex = list.indexOf(data);
        if (oldIndex === newIndex || oldIndex < 0) {
            return;
        }
        if (newIndex >= 0 && newIndex <= list.size()) {
            list.remove(data);
            if (newIndex > list.size()) {
                newIndex--;
            }
            list.add(data, newIndex);
            this._hierarchyChangeDispatcher.fire({
                data: data,
                oldIndex: oldIndex,
                newIndex: newIndex
            });
        }
    },
    moveUp: function (data) {
        var list = this.getSiblings(data);
        this.moveTo(data, list.indexOf(data) - 1);
    },
    moveDown: function (data) {
        var list = this.getSiblings(data);
        this.moveTo(data, list.indexOf(data) + 1);
    },
    moveToTop: function (data) {
        this.moveTo(data, 0);
    },
    moveToBottom: function (data) {
        var list = this.getSiblings(data);
        this.moveTo(data, list.size());
    },
    moveSelectionUp: function (sm) {
        if (!sm) {
            sm = this._selectionModel;
        }
        var datas = new $List();
        $box.findMoveUpDatas(sm, datas, this._rootList);
        datas.forEach(this.moveUp, this);
    },
    moveSelectionDown: function (sm) {
        if (!sm) {
            sm = this._selectionModel;
        }
        var datas = new $List();
        $box.findMoveDownDatas(sm, datas, this._rootList);
        datas.forEach(this.moveDown, this);
    },
    moveSelectionToTop: function (sm) {
        if (!sm) {
            sm = this._selectionModel;
        }
        var datas = new $List();
        $box.findMoveToTopDatas(sm, datas, this._rootList);
        datas.forEach(this.moveToTop, this);
    },
    moveSelectionToBottom: function (sm) {
        if (!sm) {
            sm = this._selectionModel;
        }
        var datas = new $List();
        $box.findMoveToBottomDatas(sm, datas, this._rootList);
        datas.forEach(this.moveToBottom, this);
    },
    handleDataPropertyChange: function (e) {
        var data = e.source;
        if (e.property === "parent") {
            var id = data.getId();
            if (data.getParent()) {
                if (this._rootMap[id]) {
                    delete this._rootMap[id];
                    this._rootList.remove(data);
                }
            } else {
                if (!this._rootMap[id]) {
                    this._rootMap[id] = data;
                    this._rootList.add(data);
                }
            }
        }
        this.onDataPropertyChanged(data, e);
        this._dataPropertyChangeDispatcher.fire(e);
    },
    onDataPropertyChanged: function (data, e) {

    },
    addDataBoxChangeListener: function (listener, scope, ahead) {
        this._dataBoxChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataBoxChangeListener: function (listener, scope) {
        this._dataBoxChangeDispatcher.remove(listener, scope);
    },
    addDataPropertyChangeListener: function (listener, scope, ahead) {
        this._dataPropertyChangeDispatcher.add(listener, scope, ahead);
    },
    removeDataPropertyChangeListener: function (listener, scope) {
        this._dataPropertyChangeDispatcher.remove(listener, scope);
    },
    addHierarchyChangeListener: function (listener, scope, ahead) {
        this._hierarchyChangeDispatcher.add(listener, scope, ahead);
    },
    removeHierarchyChangeListener: function (listener, scope) {
        this._hierarchyChangeDispatcher.remove(listener, scope);
    },
    getRandomData: function (type) {
        if (type) {
            var typeLists = new twaver.List();
            for(var i=0;i<this._dataList.size()-1;i++){
                var e = this._dataList.get(i);
                if( e instanceof type){
                    typeLists.add(e);
                }
            }
            if(typeLists.size() == 0){
                return null;
            }
        }

        var element = type? typeLists.get(parseInt(twaver.Util.random()*typeLists.size())):
            this._dataList.get(parseInt(twaver.Util.random()*this._dataList.size()));
        return element;
    }
});

twaver.ElementBox = function (name) {
    twaver.ElementBox.superClass.constructor.apply(this, arguments);
    this._styleMap = {};
    this._alarmBox = new twaver.AlarmBox(this);
    this._layerBox = new twaver.LayerBox(this);
    this._alarmStatePropagator = new twaver.AlarmStatePropagator(this);
    this._alarmStatePropagator.setEnable(true);
    this._indexChangeDispatcher = new twaver.EventDispatcher();
    this._undoManager = new twaver.UndoManager(this);
};
twaver.ElementBox.IS_INTERESTED_ADJUSTELEMENTINDEX_PROPERTY = {
    "fromAgent": 1,
    "toAgent": 1,
    "expanded": 1,
    "parent": 1,
    "host": 1
};
_twaver.ext('twaver.ElementBox', twaver.DataBox, {
    IStyle: true,
    __style: 1,

    _name: 'ElementBox',

    add: function (data, index) {
        if (!data) {
            return;
        }
        if (!data.IElement) {
            throw "Only IElement can be added into ElementBox";
        }
        twaver.ElementBox.superClass.add.apply(this, arguments);
        this.adjustElementIndex(data);
    },
    onDataPropertyChanged: function (data, e) {
        if (twaver.ElementBox.IS_INTERESTED_ADJUSTELEMENTINDEX_PROPERTY[e.property]) {
            this.adjustElementIndex(data);
        }
        twaver.ElementBox.superClass.onDataPropertyChanged.apply(this, arguments);
    },
    addIndexChangeListener: function (listener, scope, ahead) {
        this._indexChangeDispatcher.add(listener, scope, ahead);
    },
    removeIndexChangeListener: function (listener, scope) {
        this._indexChangeDispatcher.remove(listener, scope);
    },
    sendToTop: function (element) {
        if (!this.contains(element)) {
            return;
        }
        if (element !== this.getDatas().get(this.size() - 1)) {
            var oldIndex = this.getDatas().indexOf(element);
            this.getDatas().removeAt(oldIndex);
            this.getDatas().add(element);
            this._indexChangeDispatcher.fire({ element: element, oldIndex: oldIndex, newIndex: this.size() - 1 });
        }
        if (element instanceof twaver.Link) {
            if (element.getFromAgent() && !element.getFromAgent().isAdjustedToBottom()) {
                this.sendToTop(element.getFromAgent());
            }
            if (element.getToAgent() && !element.getToAgent().isAdjustedToBottom()) {
                this.sendToTop(element.getToAgent());
            }
        }
        if (element instanceof $Node) {
            if (element.getFollowers()) {
                element.getFollowers().forEach(function (f) {
                    if (f.isRelatedTo(element)) {
                        return;
                    }
                    if (element instanceof twaver.Follower && f.isLoopedHostOn(element)) {
                        return;
                    }
                    this.sendToTop(f);
                }, this);
            }
        }
        if (element.ISubNetwork) {
            return;
        }
        if (element instanceof $Group && !element.isExpanded()) {
            return;
        }
        element.getChildren().forEach(function (child) {
            if (!(child instanceof twaver.Link)) {
                this.sendToTop(child);
            }
        }, this);
    },
    sendToBottom: function (element, refElement) {
        if (element === refElement) {
            return;
        }
        if (!this.contains(element)) {
            return;
        }
        if (refElement && !this.contains(refElement)) {
            return;
        }
        var oldIndex = this.getDatas().remove(element);
        var newIndex = 0;
        if (refElement) {
            newIndex = this.getDatas().indexOf(refElement);
        }
        this.getDatas().add(element, newIndex);
        if (oldIndex != newIndex) {
            this._indexChangeDispatcher.fire({ element: element, oldIndex: oldIndex, newIndex: newIndex });
            if (element.getParent() &&
			        	!element.getParent().ISubNetwork &&
			        	!(element.getParent() instanceof twaver.Link)) {
                this.sendToBottom(element.getParent(), element);
            }
        }
    },
    fireIndexChange: function (element, oldIndex, newIndex) {
        this._indexChangeDispatcher.fire({ element: element, oldIndex: oldIndex, newIndex: newIndex });
    },
    adjustElementIndex: function (element) {
        if (!this.contains(element)) {
            return;
        }
        if (element.isAdjustedToBottom()) {
            this.sendToBottom(element);
            element.getChildren().forEach(this.adjustElementIndex, this);
        }
        else {
            this.sendToTop(element);
        }
    },
    forEachByLayer: function (callbackFunction, layer, scope) {
        var n = this.size();
        var ds = this.getDatas();
        if (!layer) {
            this._layerBox.forEachByDepthFirst(function (currentLayer) {
                for (var j = 0; j < n; j++) {
                    var element = ds.get(j);
                    if (this._layerBox.getLayerByElement(element) === currentLayer) {
                        if (scope) {
                            if (callbackFunction.call(scope, element) === false) {
                                return;
                            }
                        } else {
                            if (callbackFunction(element) === false) {
                                return;
                            }
                        }
                    }
                }
            }, null, this);
        } else {
            for (var j = 0; j < n; j++) {
                var element = ds.get(j);
                if (this._layerBox.getLayerByElement(element) === layer) {
                    if (scope) {
                        if (callbackFunction.call(scope, element) === false) {
                            return;
                        }
                    } else {
                        if (callbackFunction(element) === false) {
                            return;
                        }
                    }
                }
            }
        }
    },
    forEachByLayerReverse: function (callbackFunction, layer, scope) {
        var list = new $List();
        this.forEachByLayer(function (element) { list.add(element, 0); }, layer);
        list.forEach(callbackFunction, scope);
    },
    getLayerBox: function () {
        return this._layerBox;
    },
    getAlarmBox: function () {
        return this._alarmBox;
    },
    getAlarmStatePropagator: function () {
        return this._alarmStatePropagator;
    },
    startBatch : function(callback,scope){
    	twaver._isInitializing = true;
    	twaver._bundleLinks = {};
		twaver._links = {};
		callback.call(scope);
		var link,pair;
		for(var index in twaver._links){ 
			link = twaver._links[index];
			link._checkAgentNodeImpl();
		}
		for(var index in twaver._bundleLinks){
			pair = twaver._bundleLinks[index];
			$element.resetBundleLinks(pair[0], pair[1]);
		}
		twaver._bundleLinks = null;
		twaver._links = null;
		twaver._isInitializing = false;
    },
    getUndoManager: function () {
        return this._undoManager;
    }
});

twaver.SelectionModel = function (dataBox) {
    twaver.SelectionModel.superClass.constructor.apply(this, arguments);
    this._selectionMode = 'multipleSelection';
    this._selectionList = new $List();
    this._selectionChangeDispatcher = new twaver.EventDispatcher();
    this._selectionMap = {};
    this._setDataBox(dataBox);
};
_twaver.ext('twaver.SelectionModel', twaver.PropertyChangeDispatcher, {
    getSelectionMode: function () {
        return this._selectionMode;
    },
    setSelectionMode: function (selectionMode) {
        if (this._selectionMode === selectionMode) {
            return;
        }
        if (selectionMode !== 'noneSelection'
		&& selectionMode !== 'singleSelection'
		&& selectionMode !== 'multipleSelection') {
            return;
        }
        this.clearSelection();
        var oldValue = this._selectionMode;
        this._selectionMode = selectionMode;
        this.firePropertyChange("selectionMode", oldValue, this._selectionMode);
    },
    getDataBox: function () {
        return this._dataBox;
    },
    _setDataBox: function (dataBox) {
        if (!dataBox) {
            throw "dataBox can not be null";
        }
        if (this._dataBox === dataBox) {
            return;
        }
        if (this._dataBox) {
            this.clearSelection();
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this);
        }
        var oldValue = this._dataBox;
        this._dataBox = dataBox;
        this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, true);
        this.firePropertyChange('dataBox', oldValue, this._dataBox);
    },
    dispose: function () {
        this.clearSelection();
        this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this);
    },
    handleDataBoxChange: function (e) {
        if (e.kind === 'remove') {
            var data = e.data;
            if (this.contains(data)) {
                this._selectionList.remove(data);
                delete this._selectionMap[data.getId()];
                this.fireSelectionChange('remove', new $List(data));
            }
        }
        else if (e.kind === 'clear') {
            this.clearSelection();
        }
    },
    getFilterFunction: function () {
        return this._filterFunction;
    },
    setFilterFunction: function (filterFunction) {
        if (this._filterFunction === filterFunction) {
            return;
        }
        this.clearSelection();
        var oldValue = this._filterFunction;
        this._filterFunction = filterFunction;
        this.firePropertyChange("filterFunction", oldValue, this._filterFunction);
    },
    fireSelectionChange: function (kind, datas, oldSelection) {
        if (oldSelection) {
            this._selectionList.forEach(function (data) {
                if (oldSelection.contains(data)) {
                    oldSelection.remove(data);
                } else {
                    oldSelection.add(data);
                }
            });
            datas = oldSelection.toList();
        }
        this._selectionChangeDispatcher.fire({ kind: kind, datas: new $List(datas) });
    },
    addSelectionChangeListener: function (listener, scope, ahead) {
        this._selectionChangeDispatcher.add(listener, scope, ahead);
    },
    removeSelectionChangeListener: function (listener, scope) {
        this._selectionChangeDispatcher.remove(listener, scope);
    },
    _filterList: function (datas, isAdding) {
        var array = new $List(datas);
        for (var i = 0; i < array.size(); i++) {
            var data = array.get(i);
            if ((this._filterFunction && !this._filterFunction(data)) ||
				  		(isAdding && this.contains(data)) ||
				  		(!isAdding && !this.contains(data)) ||
				  		!this._dataBox.contains(data)) {
                array.removeAt(i);
                i--;
            }
        }
        return array;
    },
    appendSelection: function (datas) {
        if (this._selectionMode === 'noneSelection') {
            return;
        }
        var array = this._filterList(datas, true);
        if (array.isEmpty()) {
            return;
        }
        var oldSelection = null;
        if (this._selectionMode === 'singleSelection') {
            oldSelection = new $List(this._selectionList);
            this._selectionList.clear();
            this._selectionMap = {};
            array = new $List(array.get(array.size() - 1));
        }
        for (var i = 0; i < array.size(); i++) {
            var data = array.get(i);
            this._selectionList.add(data);
            this._selectionMap[data.getId()] = data;
        }
        this.fireSelectionChange('append', array, oldSelection);
    },
    removeSelection: function (datas) {
        var array = this._filterList(datas);
        if (array.size() === 0) {
            return;
        }
        for (var i = 0; i < array.size(); i++) {
            var data = array.get(i);
            this._selectionList.remove(data);
            delete this._selectionMap[data.getId()];
        }
        this.fireSelectionChange('remove', array);
    },
    toSelection: function (matchFunction, scope) {
        return this._selectionList.toList(matchFunction, scope);
    },
    getSelection: function () {
        return this._selectionList;
    },
    setSelection: function (datas) {
        if (this._selectionMode === 'noneSelection') {
            return;
        }
        if (this._selectionList.size() === 0 && datas == null) {
            return;
        }
        var oldSelection = new $List(this._selectionList);
        this._selectionList.clear();
        this._selectionMap = {};
        var array = this._filterList(datas, true);
        if (this._selectionMode === 'singleSelection' && array.size() > 1) {
            array = new $List(array.get(array.size() - 1));
        }
        for (var i = 0; i < array.size(); i++) {
            var data = array.get(i);
            this._selectionList.add(data);
            this._selectionMap[data.getId()] = data;
        }
        this.fireSelectionChange('set', null, oldSelection);
    },
    clearSelection: function () {
        if (this._selectionList.size() > 0) {
            var array = this._selectionList.toList();
            this._selectionList.clear();
            this._selectionMap = {};
            this.fireSelectionChange('clear', array);
        }
    },
    selectAll: function () {
        if (this._selectionMode === 'noneSelection') {
            return;
        }
        var array = this._dataBox.toDatas();
        var i = 0;
        var data = null;
        if (this._filterFunction) {
            for (i = 0; i < array.size(); i++) {
                data = array.get(i);
                if (!this._filterFunction(data)) {
                    array.removeAt(i);
                    i--;
                }
            }
        }
        var oldSelection = new $List(this._selectionList);
        this._selectionList.clear();
        this._selectionMap = {};
        if (this._selectionMode === 'singleSelection' && array.size() > 1) {
            array = new $List(array.get(array.size() - 1));
        }
        for (i = 0; i < array.size(); i++) {
            data = array.get(i);
            this._selectionList.add(data);
            this._selectionMap[data.getId()] = data;
        }
        this.fireSelectionChange('all', null, oldSelection);
    },
    size: function () {
        return this._selectionList.size();
    },
    contains: function (data) {
        if (!data) {
            return false;
        }
        return this._selectionMap[data.getId()] != null;
    },
    getLastData: function () {
        if (this._selectionList.size() > 0) {
            return this._selectionList.get(this._selectionList.size() - 1);
        }
        return null;
    },
    getFirstData: function () {
        if (this._selectionList.size() > 0) {
            return this._selectionList.get(0);
        }
        return null;
    },
    isSelectable: function (data) {
        if (!data) {
            return false;
        }
        if (this._selectionMode === 'noneSelection') {
            return false;
        }
        if (this._filterFunction && !this._filterFunction(data)) {
            return false;
        }
        return true;
    }

});

twaver.QuickFinder = function (dataBox, propertyName, propertyType, valueFunction, filterFunction) {
    this._map = {};
    if (!dataBox) {
        throw "dataBox can not be null";
    }
    if (!propertyName) {
        throw "propertyName can not be null";
    }
    this._dataBox = dataBox;
    this._propertyName = propertyName;
    this._propertyType = propertyType || 'accessor';
    if (this._propertyType === 'accessor') {
        this._getter = _twaver.getter(propertyName);
    }
    this._valueFunction = valueFunction || this.getValue;
    this._filterFunction = filterFunction || this.isInterested;
    this._dataBox.forEach(this._addData, this);
    this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this, true);
    this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this, true);
};
_twaver.ext('twaver.QuickFinder', Object, {
    _NULL_: 'twaver-null-key',
    getValueFunction: function () {
        return this._valueFunction;
    },
    getFilterFunction: function () {
        return this._filterFunction;
    },
    handleDataBoxChange: function (e) {
        if (e.kind === 'add') {
            this._addData(e.data);
        }
        else if (e.kind === 'remove') {
            this._removeData(e.data);
        }
        else if (e.kind === 'clear') {
            this._map = {};
        }
    },
    handleDataPropertyChange: function (e) {
        if (!this._filterFunction.call(this, e.source)) {
            return;
        }
        if (this._propertyType === 'accessor' && this._propertyName === e.property) {
            // property change
        }
        else if (this._propertyType === 'style' && e.source.IStyle && 'S:' + this._propertyName === e.property) {
            // style change
        }
        else if (this._propertyType === 'client' && 'C:' + this._propertyName === e.property) {
            // client change
        }
        else {
            return; // do nothing
        }
        var list = this._getMap(e.oldValue);
        if (list) {
            list.remove(e.source);
        }
        this._addData(e.source);
    },
    _getMap: function (key) {
        key = key == null ? this._NULL_ : key;
        return this._map[key];
    },
    find: function (value) {
        var list = this._getMap(value);
        return list ? list.toList() : new $List();
    },
    findFirst: function (value) {
        var list = this._getMap(value);
        return (!list || list.isEmpty()) ? null : list.get(0);
    },
    _addData: function (data) {
        if (!this._filterFunction.call(this, data)) {
            return;
        }
        var value = this._valueFunction.call(this, data);
        var list = this._getMap(value);
        if (!list) {
            list = new $List();
            value = value == null ? this._NULL_ : value;
            this._map[value] = list;
        }
        list.add(data);
    },
    _removeData: function (data) {
        if (!this._filterFunction.call(this, data)) {
            return;
        }
        var value = this._valueFunction.call(this, data);
        var list = this._getMap(value);
        if (list) {
            list.remove(data);
            if (list.isEmpty()) {
                value = value == null ? this._NULL_ : value;
                delete this._map[value];
            }
        }
    },
    dispose: function () {
        this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this);
        this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this);
        delete this._dataBox;
    },
    getDataBox: function () {
        return this._dataBox;
    },
    getPropertyType: function () {
        return this._propertyType;
    },
    getPropertyName: function () {
        return this._propertyName;
    },
    isInterested: function (data) {
        if (this._propertyType === 'style' && !data.IStyle) {
            return false;
        }
        if (this._propertyType === 'accessor' && this._valueFunction === this.getValue && !data[this._getter]) {
            return false;
        }
        return true;
    },
    getValue: function (data) {
        if (this._propertyType === 'accessor') {
            return data[this._getter]();
        }
        else if (this._propertyType === 'style' && data.getStyle) {
            return data.getStyle(this._propertyName);
        }
        else if (this._propertyType === 'client' && data.getClient) {
            return data.getClient(this._propertyName);
        }
        return null;
    }
});

twaver.PropertyPropagator = function (dataBox, propertyName, propertyType) {
    if (!dataBox) {
        throw "dataBox can not be null";
    }
    if (!propertyName) {
        throw "propertyName can not be null";
    }
    this._dataBox = dataBox;
    this._propertyName = propertyName;
    this._propertyType = propertyType || 'accessor';
    if (this._propertyType === 'accessor') {
        this._getter = _twaver.getter(propertyName);
        this._setter = _twaver.setter(propertyName);
    }
    this._enable = false;
    this._isPropagating = false;
};
_twaver.ext('twaver.PropertyPropagator', Object, {
    getDataBox: function () {
        return this._dataBox;
    },
    getPropertyType: function () {
        return this._propertyType;
    },
    getPropertyName: function () {
        return this._propertyName;
    },
    isEnable: function () {
        return this._enable
    },
    setEnable: function (enable) {
        if (this._enable === enable) {
            return;
        }
        this._enable = enable;
        if (this._enable) {
            this._dataBox.addDataBoxChangeListener(this.handleDataBoxChange, this);
            this._dataBox.addDataPropertyChangeListener(this.handleDataPropertyChange, this);
            this._dataBox.forEach(function (data) {
                this.propagate(data);
            }, this);
        } else {
            this._dataBox.removeDataBoxChangeListener(this.handleDataBoxChange, this);
            this._dataBox.removeDataPropertyChangeListener(this.handleDataPropertyChange, this);
        }
    },
    handleDataBoxChange: function (e) {
        if (e.data) {
            this.propagate(e.data);
        }
    },
    handleDataPropertyChange: function (e) {
        if (this.isInterestedProperty(e)) {
            this.propagate(e.source);
        }
        else if (e.property === "parent") {
            var oldParent = e.oldValue;
            if (oldParent) {
                this.propagate(oldParent);
            }
            this.propagate(e.source);
        }
    },
    isInterestedProperty: function (e) {
        if (this._propertyType === 'accessor' && this._propertyName === e.property) {
            return true;
        }
        else if (this._propertyType === 'style' && e.IElement && 'S:' + this._propertyName === e.property) {
            return true;
        }
        else if (this._propertyType === 'client' && 'C:' + this._propertyName === e.property) {
            return true;
        }
        return false;
    },
    propagate: function (data) {
        if (!data || this._isPropagating) {
            return;
        }
        this._isPropagating = true;
        this.propagateToTop(data);
        this._isPropagating = false;
    },
    propagateToTop: function (data) {
        this.propagateToParent(null, data);
        while (data && data.getParent()) {
            this.propagateToParent(data, data.getParent());
            data = data.getParent();
        }
    },
    propagateToParent: function (child, parent) {

    }
});

twaver.AlarmStatePropagator = function (elementBox) {
    twaver.AlarmStatePropagator.superClass.constructor.call(this, elementBox, 'alarmState');
};
_twaver.ext('twaver.AlarmStatePropagator', twaver.PropertyPropagator, {
    handleDataPropertyChange: function (e) {
        if (e.property === "enablePropagation") {
            this.propagate(e.source);
        } else {
            twaver.AlarmStatePropagator.superClass.handleDataPropertyChange.call(this, e);
        }
    },
    propagateToParent: function (child, parent) {
        var result = null;
        parent.getChildren().forEach(function (child) {
            var severity = child.getAlarmState().getHighestOverallAlarmSeverity();
            if (twaver.AlarmSeverity.compare(severity, result) > 0) {
                result = severity;
            }
        });
        parent.getAlarmState().setPropagateSeverity(result);
    }

});

twaver.AlarmSeverity = function (value, name, nickName, color, displayName) {
    this.value = value;
    this.name = name;
    this.nickName = nickName;
    this.color = color;
    this.displayName = displayName;
};
_twaver.ext('twaver.AlarmSeverity', Object, {
    toString: function () {
        if (this.displayName) {
            return this.displayName;
        }
        return this.name;
    }
});
(function () {
    var s = twaver.AlarmSeverity;
    s.severities = new $List();
    s._vm = {};
    s._nm = {};
    s._cp = function (s1, s2) {
        if (s1 && s2) {
            var v = s1.value - s2.value;
            if (v > 0) return 1;
            if (v < 0) return -1;
            return 0;
        }
        if (s1 && !s2) return 1;
        if (!s1 && s2) return -1;
        return 0;
    };
    s.forEach = function (callbackFunction, scope) {
        s.severities.forEach(callbackFunction, scope)
    };
    s.getSortFunction = function () {
        return s._cp;
    };
    s.setSortFunction = function (sortFunction) {
        s._cp = sortFunction;
        s.severities.sort(sortFunction);
    }
    s.add = function (value, name, nickName, color, displayName) {
        var severity = new s(value, name, nickName, color, displayName);
        s._vm[value] = severity;
        s._nm[name] = severity;
        s.severities.add(severity);
        s.severities.sort(s._cp);
        return severity;
    };
    s.remove = function (name) {
        var severity = s._nm[name];
        if (severity) {
            delete s._nm[name];
            delete s._vm[severity.value];
            s.severities.remove(severity);
        }
        return severity;
    };
    s.CRITICAL = s.add(500, "Critical", "C", '#FF0000');
    s.MAJOR = s.add(400, "Major", "M", '#FFA000');
    s.MINOR = s.add(300, "Minor", "m", '#FFFF00');
    s.WARNING = s.add(200, "Warning", "W", '#00FFFF');
    s.INDETERMINATE = s.add(100, "Indeterminate", "N", '#C800FF');
    s.CLEARED = s.add(0, "Cleared", "R", '#00FF00');
    s.isClearedAlarmSeverity = function (severity) {
        return severity ? severity.value === 0 : false;
    };
    s.getByName = function (name) {
        return s._nm[name];
    };
    s.getByValue = function (value) {
        return s._vm[value];
    };
    s.clear = function () {
        s.severities.clear();
        s._vm = {};
        s._nm = {};
    };
    s.compare = function (severity1, severity2) {
        return s._cp(severity1, severity2);
    }
})();


twaver.AlarmState = function (element) {
    this._e = element;
    this._nm = {};
    this._am = {};
    this._ps = null;
    this._haa = null;
    this._hna = null;
    this._hoa = null;
    this._hta = null;
    this._hls = false;
    this._aac = 0;
    this._nac = 0;
};
_twaver.ext('twaver.AlarmState', Object, {
    _ep: true,
    _f: function () {
        this._c1();
        this._c2();
        this._c3();
        this._c4();
        this._c5();
        this._c6();
        this._c7();
        this._e.firePropertyChange("alarmState", null, this);
    },
    getHighestAcknowledgedAlarmSeverity: function () {
        return this._haa;
    },
    getHighestNewAlarmSeverity: function () {
        return this._hna;
    },
    getHighestOverallAlarmSeverity: function () {
        return this._hoa;
    },
    getHighestNativeAlarmSeverity: function () {
        return this._hta;
    },
    hasLessSevereNewAlarms: function () {
        return this._hls;
    },

    _c1: function () {
        var result = null;
        for (var severity in this._am) {
            severity = twaver.AlarmSeverity.getByName(severity);
            if (twaver.AlarmSeverity.isClearedAlarmSeverity(severity)) {
                continue;
            }
            if (this.getAcknowledgedAlarmCount(severity) === 0) {
                continue;
            }
            if (result) {
                result = twaver.AlarmSeverity.compare(result, severity) > 0 ? result : severity;
            } else {
                result = severity;
            }
        }
        this._haa = result;
    },
    _c2: function () {
        var result = null;
        for (var severity in this._nm) {
            severity = twaver.AlarmSeverity.getByName(severity);
            if (twaver.AlarmSeverity.isClearedAlarmSeverity(severity)) {
                continue;
            }
            if (this.getNewAlarmCount(severity) === 0) {
                continue;
            }
            if (result) {
                result = twaver.AlarmSeverity.compare(result, severity) > 0 ? result : severity;
            } else {
                result = severity;
            }
        }
        this._hna = result;
    },
    _c3: function () {
        if (!this._hna) {
            this._hls = false;
            return;
        }
        for (var severity in this._nm) {
            severity = twaver.AlarmSeverity.getByName(severity);
            if (twaver.AlarmSeverity.isClearedAlarmSeverity(severity)) {
                continue;
            }
            if (this.getNewAlarmCount(severity) === 0) {
                continue;
            }
            if (twaver.AlarmSeverity.compare(this._hna, severity) > 0) {
                this._hls = true;
                return;
            }
        }
        this._hls = false;
    },
    _c4: function () {
        var ackResult = this._haa;
        var newResult = this._hna;
        var propagatedResult = this._ps;

        this._hoa = ackResult;
        if (twaver.AlarmSeverity.compare(newResult, this._hoa) > 0) {
            this._hoa = newResult;
        }
        if (twaver.AlarmSeverity.compare(propagatedResult, this._hoa) > 0) {
            this._hoa = propagatedResult;
        }
    },
    _c5: function () {
        var ackResult = this._haa;
        var newResult = this._hna;

        this._hta = ackResult;
        if (twaver.AlarmSeverity.compare(newResult, this._hta) > 0) {
            this._hta = newResult;
        }
    },
    increaseAcknowledgedAlarm: function (severity, increment) {
        if (increment == null) {
            increment = 1;
        }
        if (increment === 0) {
            return;
        }
        var count = this._am[severity.name];
        if (count == null) {
            count = 0;
        }
        count += increment;
        this._am[severity.name] = count;
        this._f();
    },
    increaseNewAlarm: function (severity, increment) {
        if (increment == null) {
            increment = 1;
        }
        if (increment === 0) {
            return;
        }
        var count = this._nm[severity.name];
        if (count == null) {
            count = 0;
        }
        count += increment;
        this._nm[severity.name] = count;
        this._f();
    },
    decreaseAcknowledgedAlarm: function (severity, decrement) {
        if (decrement == null) {
            decrement = 1;
        }
        if (decrement === 0) {
            return;
        }
        var count = this._am[severity.name];
        if (count == null) {
            count = 0;
        }
        count -= decrement;
        if (count < 0) {
            throw "Alarm count can not be negative";
        }
        this._am[severity.name] = count;
        this._f();
    },
    decreaseNewAlarm: function (severity, decrement) {
        if (decrement == null) {
            decrement = 1;
        }
        if (decrement === 0) {
            return;
        }
        var count = this._nm[severity.name];
        if (count == null) {
            count = 0;
        }
        count -= decrement;
        if (count < 0) {
            throw "Alarm count can not be negative";
        }
        this._nm[severity.name] = count;
        this._f();
    },
    acknowledgeAlarm: function (severity) {
        this.decreaseNewAlarm(severity, 1);
        this.increaseAcknowledgedAlarm(severity, 1);
    },
    acknowledgeAllAlarms: function (severity) {
        if (severity) {
            var count = this.getNewAlarmCount(severity);
            this.decreaseNewAlarm(severity, count);
            this.increaseAcknowledgedAlarm(severity, count);
        } else {
            for (var name in this._nm) {
                this.acknowledgeAllAlarms(twaver.AlarmSeverity.getByName(name));
            }
        }
    },
    _c6: function () {
        this._aac = 0;
        for (var severity in this._am) {
            severity = twaver.AlarmSeverity.getByName(severity);
            this._aac += this.getAcknowledgedAlarmCount(severity);
        }
    },
    getAcknowledgedAlarmCount: function (severity) {
        if (severity) {
            var count = this._am[severity.name];
            return count == null ? 0 : count;
        } else {
            return this._aac;
        }
    },
    getAlarmCount: function (severity) {
        return this.getAcknowledgedAlarmCount(severity) + this.getNewAlarmCount(severity);
    },
    _c7: function () {
        this._nac = 0;
        for (var severity in this._nm) {
            severity = twaver.AlarmSeverity.getByName(severity);
            this._nac += this.getNewAlarmCount(severity);
        }
    },
    getNewAlarmCount: function (severity) {
        if (severity) {
            var count = this._nm[severity.name];
            return count == null ? 0 : count;
        } else {
            return this._nac;
        }
    },
    setNewAlarmCount: function (severity, count) {
        this._nm[severity.name] = count;
        this._f();
    },
    removeAllNewAlarms: function (severity) {
        if (severity) {
            delete this._nm[severity];
        } else {
            this._nm = {};
        }
        this._f();
    },
    setAcknowledgedAlarmCount: function (severity, count) {
        this._am[severity.name] = count;
        this._f();
    },
    removeAllAcknowledgedAlarms: function (severity) {
        if (severity) {
            delete this._am[severity.name];
        } else {
            this._am = {};
        }
        this._f();
    },
    isEmpty: function () {
        return this._hoa == null;
    },
    clear: function () {
        this._am = {};
        this._nm = {};
        this._f();
    },
    getPropagateSeverity: function () {
        return this._ps;
    },
    setPropagateSeverity: function (propagateSeverity) {
        if (!this._ep) {
            propagateSeverity = null;
        }
        if (this._ps === propagateSeverity) {
            return;
        }
        var oldValue = this._ps;
        this._ps = propagateSeverity;
        this._f();
        this._e.firePropertyChange('propagateSeverity', oldValue, propagateSeverity);
    },
    isEnablePropagation: function () {
        return this._ep;
    },
    setEnablePropagation: function (enablePropagation) {
        var oldValue = this._ep;
        this._ep = enablePropagation;
        if (this._e.firePropertyChange('enablePropagation', oldValue, enablePropagation)) {
            if (!enablePropagation) {
                this.setPropagateSeverity(null);
            }
        }
    }
});

twaver.AlarmBox = function (elementBox) {
    if (!elementBox) {
        throw "elementBox can not be null.";
    }
    twaver.AlarmBox.superClass.constructor.call(this);
    this._elementBox = elementBox;
    this._alarmElementMapping = new twaver.AlarmElementMapping(this, elementBox);
    this._elementBox.addDataBoxChangeListener(this.handleElementBoxChange, this, true);
    this.addDataBoxChangeListener(this.handleAlarmBoxChange, this, true);
    this.addDataPropertyChangeListener(this.handleAlarmPropertyChange, this, true);
};
_twaver.ext('twaver.AlarmBox', twaver.DataBox, {
    __accessor: ['removeAlarmWhenElementIsRemoved'],

    _name: 'AlarmBox',
    _removeAlarmWhenAlarmIsCleared: false,
    _removeAlarmWhenElementIsRemoved: true,

    getElementBox: function () {
        return this._elementBox;
    },
    isRemoveAlarmWhenAlarmIsCleared: function () {
        return this._removeAlarmWhenAlarmIsCleared;
    },
    setRemoveAlarmWhenAlarmIsCleared: function (removeAlarmWhenAlarmIsCleared) {
        var oldValue = this._removeAlarmWhenAlarmIsCleared;
        this._removeAlarmWhenAlarmIsCleared = removeAlarmWhenAlarmIsCleared;
        this.firePropertyChange("removeAlarmWhenAlarmIsCleared", oldValue, removeAlarmWhenAlarmIsCleared);
        if (removeAlarmWhenAlarmIsCleared) {
            this.toDatas(function (alarm) {
                return alarm.isCleared();
            }).forEach(this.remove, this);
        }
    },
    getAlarmElementMapping: function () {
        return this._alarmElementMapping;
    },
    setAlarmElementMapping: function (alarmElementMapping) {
        if (!alarmElementMapping) {
            throw "alarmElementMapping can not be null";
        }
        if (this._alarmElementMapping === alarmElementMapping) {
            return;
        }
        var oldValue = this._alarmElementMapping;

        this.getDatas().forEach(this._decreaseAlarmState, this);
        this._alarmElementMapping = alarmElementMapping;
        this.getDatas().forEach(this._increaseAlarmState, this);

        this.firePropertyChange("alarmElementMapping", oldValue, alarmElementMapping);
    },
    handleElementBoxChange: function (e) {
        if (e.kind === 'add') {
            this.handleElementAdded(e.data);
        }
        else if (e.kind === 'remove') {
            this.handleElementRemoved(e.data);
            if (this._removeAlarmWhenElementIsRemoved) {
                this.removeAlarmsByElement(e.data);
            }
        }
        else if (e.kind === 'clear') {
            e.datas.forEach(this.handleElementRemoved, this);
            if (this._removeAlarmWhenElementIsRemoved) {
                this.clear();
            }
        }
    },
    handleAlarmBoxChange: function (e) {
        if (e.kind === 'add') {
            this._increaseAlarmState(e.data);
        }
        else if (e.kind === 'remove') {
            this._decreaseAlarmState(e.data);
        }
        else if (e.kind === 'clear') {
            e.datas.forEach(this._decreaseAlarmState, this);
        }
    },
    handleAlarmPropertyChange: function (e) {
        var alarm = e.source;
        if (!alarm.isCleared()) {
            if (e.property === "alarmSeverity") {
                this.handleAlarmSeverityChange(alarm, e);
            } else if (e.property === "acked") {
                this.handleAckedChange(alarm, e);
            }
        }
        if (e.property === "cleared") {
            if (alarm.isCleared()) {
                this._decreaseAlarmState(alarm, true);
                if (this._removeAlarmWhenAlarmIsCleared) {
                    this.remove(alarm);
                }
            } else {
                this._increaseAlarmState(alarm, true);
            }
        }
    },
    handleAckedChange: function (alarm, e) {
        if (!alarm.getAlarmSeverity()) {
            return;
        }
        var elements = this.getCorrespondingElements(alarm);
        if (elements) {
            for (var i = 0; i < elements.size(); i++) {
                var element = elements.get(i);
                if (e.oldValue) {
                    element.getAlarmState().decreaseAcknowledgedAlarm(alarm.getAlarmSeverity());
                } else {
                    element.getAlarmState().decreaseNewAlarm(alarm.getAlarmSeverity());
                }
                if (e.newValue) {
                    element.getAlarmState().increaseAcknowledgedAlarm(alarm.getAlarmSeverity());
                } else {
                    element.getAlarmState().increaseNewAlarm(alarm.getAlarmSeverity());
                }
            }
        }
    },
    handleAlarmSeverityChange: function (alarm, e) {
        var oldValue = e.oldValue;
        var newValue = e.newValue;
        var elements = this.getCorrespondingElements(alarm);
        if (elements) {
            for (var i = 0; i < elements.size(); i++) {
                var element = elements.get(i);
                if (oldValue) {
                    if (alarm.isAcked()) {
                        element.getAlarmState().decreaseAcknowledgedAlarm(oldValue);
                    } else {
                        element.getAlarmState().decreaseNewAlarm(oldValue);
                    }
                }
                if (newValue) {
                    if (alarm.isAcked()) {
                        element.getAlarmState().increaseAcknowledgedAlarm(newValue);
                    } else {
                        element.getAlarmState().increaseNewAlarm(newValue);
                    }
                }
            }
        }
    },
    getCorrespondingAlarms: function (element) {
        return this._alarmElementMapping.getCorrespondingAlarms(element);
    },
    getCorrespondingElements: function (alarm) {
        return this._alarmElementMapping.getCorrespondingElements(alarm);
    },
    handleElementAdded: function (element) {
        var alarms = this.getCorrespondingAlarms(element);
        if (alarms) {
            for (var i = 0; i < alarms.size(); i++) {
                var alarm = alarms.get(i);
                if (alarm.isCleared()) {
                    continue;
                }
                var severity = alarm.getAlarmSeverity();
                if (severity) {
                    if (alarm.isAcked()) {
                        element.getAlarmState().increaseAcknowledgedAlarm(severity);
                    } else {
                        element.getAlarmState().increaseNewAlarm(severity);
                    }
                }
            }
        }
    },
    _increaseAlarmState: function (alarm, forced) {
        if (alarm.isCleared() && !forced) {
            return;
        }
        var severity = alarm.getAlarmSeverity();
        if (severity) {
            var elements = this.getCorrespondingElements(alarm);
            if (elements) {
                for (var i = 0; i < elements.size(); i++) {
                    var element = elements.get(i);
                    if (alarm.isAcked()) {
                        element.getAlarmState().increaseAcknowledgedAlarm(severity);
                    } else {
                        element.getAlarmState().increaseNewAlarm(severity);
                    }
                }
            }
        }
    },
    _decreaseAlarmState: function (alarm, forced) {
        if (alarm.isCleared() && !forced) {
            return;
        }
        var severity = alarm.getAlarmSeverity();
        if (!severity) {
            return;
        }
        var elements = this.getCorrespondingElements(alarm);
        if (elements) {
            for (var i = 0; i < elements.size(); i++) {
                var element = elements.get(i);
                if (alarm.isAcked()) {
                    element.getAlarmState().decreaseAcknowledgedAlarm(severity);
                } else {
                    element.getAlarmState().decreaseNewAlarm(severity);
                }
            }
        }
    },
    handleElementRemoved: function (element) {
        var alarms = this.getCorrespondingAlarms(element);
        if (alarms) {
            alarms.forEach(function (alarm) {
                if (!alarm.isCleared() && alarm.getAlarmSeverity()) {
                    if (alarm.isAcked()) {
                        element.getAlarmState().decreaseAcknowledgedAlarm(alarm.getAlarmSeverity());
                    } else {
                        element.getAlarmState().decreaseNewAlarm(alarm.getAlarmSeverity());
                    }
                }
            });
        }
    },
    removeAlarmsByElement: function (element) {
        var alarms = this.getCorrespondingAlarms(element);
        if (alarms) {
            alarms.forEach(this.remove, this);
        }
    },
    add: function (data, index) {
        if (!data.IAlarm) {
            throw "Only IAlarm can be added into AlarmBox";
        }
        if (this._removeAlarmWhenAlarmIsCleared && data.isCleared()) {
            return;
        }
        twaver.AlarmBox.superClass.add.apply(this, arguments);
    }
});

twaver.AlarmElementMapping = function (alarmBox, elementBox) {
    if (!elementBox) {
        throw "ElementBox can not be null";
    }
    if (!alarmBox) {
        throw "AlarmBox can not be null";
    }
    this._elementBox = elementBox;
    this._alarmBox = alarmBox;
    this._alarmsFinder = new twaver.QuickFinder(alarmBox, "elementId");
};
_twaver.ext('twaver.AlarmElementMapping', Object, {
    getCorrespondingAlarms: function (element) {
        return this._alarmsFinder.find(element.getId());
    },
    getCorrespondingElements: function (alarm) {
        var element = this._elementBox.getDataById(alarm.getElementId());
        return new $List(element);
    },
    dispose: function () {
        this._alarmsFinder.dispose();
        delete this._elementBox;
        delete this._alarmBox;
        delete this._alarmsFinder;
    }
});

twaver.AlarmStateStatistics = function (elementBox) {
    twaver.AlarmStateStatistics.superClass.constructor.apply(this, arguments);
    this.sumNew = 0;
    this.sumAcked = 0;
    this.sumTotal = 0;
    this.severtiyMap = {};
    this.elementMap = {};
    this.setElementBox(elementBox);
};
_twaver.ext('twaver.AlarmStateStatistics', twaver.PropertyChangeDispatcher, {
    getElementBox: function () {
        return this._elementBox;
    },
    setElementBox: function (box) {
        if (!box) {
            throw "ElementBox can not be null";
        }
        if (this._elementBox === box) {
            return;
        }
        var oldValue = this._elementBox;
        if (oldValue) {
            oldValue.removeDataPropertyChangeListener(this.handleElementPropertyChange, this);
            oldValue.removeDataBoxChangeListener(this.handleElementBoxChange, this);
            this.severtiyMap = {};
            this.elementMap = {};
        }
        this._elementBox = box;
        this.reset();
        box.addDataPropertyChangeListener(this.handleElementPropertyChange, this);
        box.addDataBoxChangeListener(this.handleElementBoxChange, this);
        this.firePropertyChange("elementBox", oldValue, box);
    },
    dispose: function () {
        this._elementBox.removeDataPropertyChangeListener(this.handleElementPropertyChange, this);
        this._elementBox.removeDataBoxChangeListener(this.handleElementBoxChange, this);
        delete this._elementBox;
    },
    handleElementPropertyChange: function (e) {
        if (e.property === "alarmState") {
            this.increase(e.source);
            this.fireAlarmStateChange();
        }
    },
    handleElementBoxChange: function (e) {
        if (e.kind === 'add') {
            this.increase(e.data);
            this.fireAlarmStateChange();
        }
        else if (e.kind === 'remove') {
            this.decrease(e.data);
            this.fireAlarmStateChange();
        }
        else if (e.kind === 'clear') {
            this.severtiyMap = {};
            this.elementMap = {};
            this.fireAlarmStateChange();
        }
    },
    fireAlarmStateChange: function () {
        this.sumAcked = 0;
        this.sumNew = 0;
        this.sumTotal = 0;

        twaver.AlarmSeverity.forEach(function (severity) {
            var sumInfo = this.getSumInfo(severity);
            this.sumAcked += sumInfo["ackedCount"];
            this.sumNew += sumInfo["newCount"];
            this.sumTotal += sumInfo["totalCount"];
        }, this);

        this.firePropertyChange("alarmState", false, true);
    },
    getNewAlarmCount: function (severity) {
        if (!severity) {
            return this.sumNew;
        }
        var sumInfo = this.getSumInfo(severity);
        return sumInfo["newCount"];
    },
    getAcknowledgedAlarmCount: function (severity) {
        if (!severity) {
            return this.sumAcked;
        }
        var sumInfo = this.getSumInfo(severity);
        return sumInfo["ackedCount"];
    },
    getTotalAlarmCount: function (severity) {
        if (!severity) {
            return this.sumTotal;
        }
        var sumInfo = this.getSumInfo(severity);
        return sumInfo["totalCount"];
    },
    getSumInfo: function (severity) {
        var sumInfo = this.severtiyMap[severity.name];
        if (!sumInfo) {
            sumInfo = {};
            sumInfo["newCount"] = 0;
            sumInfo["ackedCount"] = 0;
            sumInfo["totalCount"] = 0;
            this.severtiyMap[severity.name] = sumInfo;
        }
        return sumInfo;
    },
    decrease: function (element) {
        var dic = this.elementMap[element.getId()];
        if (dic) {
            delete this.elementMap[element.getId()];
            twaver.AlarmSeverity.forEach(function (severity) {
                var info = dic[severity.name];
                var sumInfo = this.getSumInfo(severity);
                sumInfo["newCount"] = sumInfo["newCount"] - info["newCount"];
                sumInfo["ackedCount"] = sumInfo["ackedCount"] - info["ackedCount"];
                sumInfo["totalCount"] = sumInfo["totalCount"] - info["totalCount"];
            }, this);
        }
    },
    increase: function (element) {
        this.decrease(element);
        if (this._filterFunction && !this._filterFunction(element)) {
            return;
        }
        var dic = {};
        this.elementMap[element.getId()] = dic;
        twaver.AlarmSeverity.forEach(function (severity) {
            var info = {};
            info["newCount"] = element.getAlarmState().getNewAlarmCount(severity);
            info["ackedCount"] = element.getAlarmState().getAcknowledgedAlarmCount(severity);
            info["totalCount"] = element.getAlarmState().getAlarmCount(severity);
            dic[severity.name] = info;

            var sumInfo = this.getSumInfo(severity);
            sumInfo["newCount"] = sumInfo["newCount"] + info["newCount"];
            sumInfo["ackedCount"] = sumInfo["ackedCount"] + info["ackedCount"];
            sumInfo["totalCount"] = sumInfo["totalCount"] + info["totalCount"];
        }, this);
    },
    reset: function () {
        this.severtiyMap = {};
        this.elementMap = {};
        this._elementBox.forEach(this.increase, this);
        this.fireAlarmStateChange();
    },
    setFilterFunction: function (f) {
        var oldValue = this._filterFunction;
        this._filterFunction = f;
        this.reset();
        this.firePropertyChange("filterFunction", oldValue, f);
    },
    getFilterFunction: function () {
        return _filterFunction;
    }
});

twaver.LayerBox = function (elementBox) {
    twaver.LayerBox.superClass.constructor.call(this);
    this._elementBox = elementBox;
    this._defaultLayer = new twaver.Layer($Defaults.LAYER_DEFAULT_ID, $Defaults.LAYER_DEFAULT_NAME);
    this.add(this._defaultLayer);
};
_twaver.ext('twaver.LayerBox', twaver.DataBox, {
    _name: 'LayerBox',

    getElementBox: function () {
        return this._elementBox;
    },
    getDefaultLayer: function () {
        return this._defaultLayer;
    },
    add: function (data, index) {
        if (!data.ILayer) {
            throw "Only ILayer can be added into LayerBox";
        }
        twaver.LayerBox.superClass.add.apply(this, arguments);
    },
    removeById: function (id) {
        if (id === this._defaultLayer.getId()) {
            throw "Cannot remove default layer";
        }
        twaver.LayerBox.superClass.removeById.call(this, id);
    },
    getLayerByElement: function (element) {
        if (!element) {
            return null;
        }
        if (element._layerId === $Defaults.LAYER_DEFAULT_ID) {
            return this._defaultLayer;
        }
        var layer = this.getDataById(element.getLayerId());
        return layer ? layer : this._defaultLayer;
    },
    clear: function () {
        this.toDatas().forEach(function (layer) {
            if (layer != this._defaultLayer) {
                this.removeById(layer.getId());
            }
        }, this);
    }

});

twaver.BundleLinks = function (links, siblings) {
    this._links = links;
    this._siblings = siblings;

    var i;
    var link;

    var expanded = $Styles._m['link.bundle.expanded'];
    for (i = 0; i < links.size(); i++) {
        link = links.get(i);
        var b = link.getStyle('link.bundle.expanded');
        if (b != null) {
            expanded = b;
            break;
        }
    }
    if (expanded == null) {
        expanded = true;
    }

    if ($Defaults.LINK_BUNDLE_AGENT_FUNCTION) {
        var agent = $Defaults.LINK_BUNDLE_AGENT_FUNCTION(links);
        if (agent == null) {
            agent = links.get(0);
        } else {
            if (agent != links.get(0)) {
                links.remove(agent);
                links.add(agent, 0);
            }
        }
    }

    for (i = 0; i < links.size(); i++) {
        links.get(i).setStyle('link.bundle.expanded', expanded);
    }
};
_twaver.ext('twaver.BundleLinks', Object, {
    getLinks: function () {
        return this._links;
    },
    getSiblings: function () {
        return this._siblings;
    },
    forEachSiblingLink: function (f, scope) {
        this._siblings.forEach(function (bundleLinks) {
            bundleLinks.getLinks().forEach(f, scope);
        });
    }
});

var gifUtil = {
    bitsToNum: function (ba) {
        return ba.reduce(function (s, n) {
            return s * 2 + n;
        }, 0);
    },
    byteToBitArr: function (bite) {
        var a = [];
        for (var i = 7; i >= 0; i--) {
            a.push( !! (bite & (1 << i)));
        }
        return a;
    },
    lzwDecode: function (minCodeSize, data) {
        var pos = 0;
        var readCode = function (size) {
            var code = 0;
            for (var i = 0; i < size; i++) {
                if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                    code |= 1 << i;
                }
                pos++;
            }
            return code;
        };

        var output = [];

        var clearCode = 1 << minCodeSize;
        var eoiCode = clearCode + 1;

        var codeSize = minCodeSize + 1;

        var dict = [];

        var clear = function () {
            dict = [];
            codeSize = minCodeSize + 1;
            for (var i = 0; i < clearCode; i++) {
                dict[i] = [i];
            }
            dict[clearCode] = [];
            dict[eoiCode] = null;

        };

        var code;
        var last;

        while (true) {
            last = code;
            code = readCode(codeSize);

            if (code === clearCode) {
                clear();
                continue;
            }
            if (code === eoiCode) break;

            if (code < dict.length) {
                if (last !== clearCode) {
                    dict.push(dict[last].concat(dict[code][0]));
                }
            }
            else {
                if (code !== dict.length) throw new Error('Invalid LZW code.');
                dict.push(dict[last].concat(dict[last][0]));
            }
            output.push.apply(output, dict[code]);

            if (dict.length === (1 << codeSize) && codeSize < 12) {
                codeSize++;
            }
        }
        return output;
    }
};
var _stream = function (data) {
    this.data = data;
    this.len = this.data.length;
    this.pos = 0;
};
_twaver.ext(_stream, Object, {
    readByte: function(){
        if (this.pos >= this.data.length) {
            throw new Error('Attempted to read past end of stream.');
        }
        return this.data.charCodeAt(this.pos++) & 0xFF;
    },
    readBytes: function (n) {
        var bytes = [];
        for (var i = 0; i < n; i++) {
            bytes.push(this.readByte());
        }
        return bytes;
    },
    read: function (n) {
        var s = '';
        for (var i = 0; i < n; i++) {
            s += String.fromCharCode(this.readByte());
        }
        return s;
    },
    readUnsigned: function () {
        var a = this.readBytes(2);
        return (a[1] << 8) + a[0];
    }
});
var _gif = function (_stream) {
    var hdr;
    var stream = _stream;
    var transparency = null;
    var delay = null;
    var disposalMethod = null;
    var disposalRestoreFromIdx = 0;
    var lastDisposalMethod = null;
    var frame = null;
    var lastImg = null;
    var playing = true;
    var forward = true;

    this.frames = [];
    this.size = {};
    var self = this;
    var rect = null;
    var tmpCanvas = document.createElement('canvas');
    this.loaded = false;
    var clear = function () {
        transparency = null;
        delay = null;
        lastDisposalMethod = disposalMethod;
        disposalMethod = null;
        frame = null;
    };
    this.doParse = function () {
        parseGIF(stream, handler);
    };

    var doHdr = function (_hdr) {
        hdr = _hdr;
        self.size.width = hdr.width;
        self.size.height = hdr.height;
    };

    var doGCE = function (gce) {
        pushFrame();
        clear();
        transparency = gce.transparencyGiven ? gce.transparencyIndex : null;
        delay = gce.delayTime;
        disposalMethod = gce.disposalMethod;
    };

    var pushFrame = function () {
        if (!frame) return;
        self.frames.push({
            data: frame.getImageData(0, 0, hdr.width, hdr.height),
            delay: delay
        });
    };

    var doImg = function (img) {
        if (!frame) frame = tmpCanvas.getContext('2d');

        var currIdx = self.frames.length;

        var ct = img.lctFlag ? img.lct : hdr.gct;

        if (currIdx > 0) {
            if (lastDisposalMethod === 3) {
                frame.putImageData(self.frames[disposalRestoreFromIdx].data, 0, 0);
            } else {
                disposalRestoreFromIdx = currIdx - 1;
            }

            if (lastDisposalMethod === 2) {
                if(!lastImg) {
                    frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
                }
            }
        }
        var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);

        img.pixels.forEach(function (pixel, i) {
            if (pixel !== transparency) {
                imgData.data[i * 4 + 0] = ct[pixel][0];
                imgData.data[i * 4 + 1] = ct[pixel][1];
                imgData.data[i * 4 + 2] = ct[pixel][2];
                imgData.data[i * 4 + 3] = 255; // Opaque.
            }
        });
        frame.putImageData(imgData, img.leftPos, img.topPos);
        lastImg = img;
    };

    var doNothing = function () {};
    var withProgress = function (fn) {
        return function (block) {
            fn(block);
        };
    };


    var handler = {
        hdr: withProgress(doHdr),
        gce: withProgress(doGCE),
        com: withProgress(doNothing),
        app: {
            NETSCAPE: withProgress(doNothing)
        },
        img: withProgress(doImg),
        eof: function (block) {
            pushFrame();
            self.loaded = true;
        }
    };

};


var parseGIF = function (st, handler) {
    handler || (handler = {});

    var parseCT = function (entries) {
        var ct = [];
        for (var i = 0; i < entries; i++) {
            ct.push(st.readBytes(3));
        }
        return ct;
    };

    var readSubBlocks = function () {
        var size, data;
        data = '';
        do {
            size = st.readByte();
            data += st.read(size);
        } while (size !== 0);
        return data;
    };

    var parseHeader = function () {
        var hdr = {};
        hdr.sig = st.read(3);
        hdr.ver = st.read(3);
        if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
        hdr.width = st.readUnsigned();
        hdr.height = st.readUnsigned();

        var bits = gifUtil.byteToBitArr(st.readByte());
        hdr.gctFlag = bits.shift();
        hdr.colorRes = gifUtil.bitsToNum(bits.splice(0, 3));
        hdr.sorted = bits.shift();
        hdr.gctSize = gifUtil.bitsToNum(bits.splice(0, 3));

        hdr.bgColor = st.readByte();
        hdr.pixelAspectRatio = st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
        if (hdr.gctFlag) {
            hdr.gct = parseCT(1 << (hdr.gctSize + 1));
        }
        handler.hdr && handler.hdr(hdr);
    };

    var parseExt = function (block) {
        var parseGCExt = function (block) {
            var blockSize = st.readByte(); // Always 4
            var bits = gifUtil.byteToBitArr(st.readByte());
            block.reserved = bits.splice(0, 3); // Reserved; should be 000.
            block.disposalMethod = gifUtil.bitsToNum(bits.splice(0, 3));
            block.userInput = bits.shift();
            block.transparencyGiven = bits.shift();

            block.delayTime = st.readUnsigned();

            block.transparencyIndex = st.readByte();

            block.terminator = st.readByte();

            handler.gce && handler.gce(block);
        };

        var parseComExt = function (block) {
            block.comment = readSubBlocks();
            handler.com && handler.com(block);
        };

        var parsePTExt = function (block) {
            var blockSize = st.readByte(); // Always 12
            block.ptHeader = st.readBytes(12);
            block.ptData = readSubBlocks();
            handler.pte && handler.pte(block);
        };

        var parseAppExt = function (block) {
            var parseNetscapeExt = function (block) {
                var blockSize = st.readByte();
                block.unknown = st.readByte();
                block.iterations = st.readUnsigned();
                block.terminator = st.readByte();
                handler.app && handler.app.NETSCAPE && handler.app.NETSCAPE(block);
            };

            var parseUnknownAppExt = function (block) {
                block.appData = readSubBlocks();
                // FIXME: This won't work if a handler wants to match on any identifier.
                handler.app && handler.app[block.identifier] && handler.app[block.identifier](block);
            };

            var blockSize = st.readByte();
            block.identifier = st.read(8);
            block.authCode = st.read(3);
            switch (block.identifier) {
                case 'NETSCAPE':
                    parseNetscapeExt(block);
                    break;
                default:
                    parseUnknownAppExt(block);
                    break;
            }
        };

        var parseUnknownExt = function (block) {
            block.data = readSubBlocks();
            handler.unknown && handler.unknown(block);
        };

        block.label = st.readByte();
        switch (block.label) {
            case 0xF9:
                block.extType = 'gce';
                parseGCExt(block);
                break;
            case 0xFE:
                block.extType = 'com';
                parseComExt(block);
                break;
            case 0x01:
                block.extType = 'pte';
                parsePTExt(block);
                break;
            case 0xFF:
                block.extType = 'app';
                parseAppExt(block);
                break;
            default:
                block.extType = 'unknown';
                parseUnknownExt(block);
                break;
        }
    };

    var parseImg = function (img) {
        var deinterlace = function (pixels, width) {
            var newPixels = new Array(pixels.length);
            var rows = pixels.length / width;
            var cpRow = function (toRow, fromRow) {
                var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
            };

            var offsets = [0, 4, 2, 1];
            var steps = [8, 8, 4, 2];

            var fromRow = 0;
            for (var pass = 0; pass < 4; pass++) {
                for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                    cpRow(toRow, fromRow)
                    fromRow++;
                }
            }

            return newPixels;
        };

        img.leftPos = st.readUnsigned();
        img.topPos = st.readUnsigned();
        img.width = st.readUnsigned();
        img.height = st.readUnsigned();

        var bits = gifUtil.byteToBitArr(st.readByte());
        img.lctFlag = bits.shift();
        img.interlaced = bits.shift();
        img.sorted = bits.shift();
        img.reserved = bits.splice(0, 2);
        img.lctSize = gifUtil.bitsToNum(bits.splice(0, 3));

        if (img.lctFlag) {
            img.lct = parseCT(1 << (img.lctSize + 1));
        }

        img.lzwMinCodeSize = st.readByte();

        var lzwData = readSubBlocks();

        img.pixels = gifUtil.lzwDecode(img.lzwMinCodeSize, lzwData);

        if (img.interlaced) { // Move
            img.pixels = deinterlace(img.pixels, img.width);
        }

        handler.img && handler.img(img);
    };

    var parseBlock = function () {
        var block = {};
        block.sentinel = st.readByte();

        switch (String.fromCharCode(block.sentinel)) { // For ease of matching
            case '!':
                block.type = 'ext';
                parseExt(block);
                break;
            case ',':
                block.type = 'img';
                parseImg(block);
                break;
            case ';':
                block.type = 'eof';
                handler.eof && handler.eof(block);
                break;
            default:
                throw new Error('Unknown block: 0x' + block.sentinel.toString(16)); // TODO: Pad this with a 0.
        }

        if (block.type !== 'eof') setTimeout(parseBlock, 0);
    };

    var parse = function () {
        parseHeader();
        setTimeout(parseBlock, 0);
    };

    parse();
};
var getGifFrame =  function(frames,size,i) {
    var tmpCanvas = document.createElement('canvas');
    setGifSize(tmpCanvas, size.width, size.height);
    tmpCanvas.getContext("2d").clearRect(0,0,size.width,size.height);
    tmpCanvas.getContext("2d").putImageData(frames[i].data, 0, 0);
    return tmpCanvas;
}
var setGifSize =  function(tpc, w, h) {
    tpc.width = w;
    tpc.height = h;
    tpc.style.width = w + 'px';
    tpc.style.height = h + 'px';
}





twaver.Data = function (id) {
    twaver.Data.superClass.constructor.apply(this, arguments);
    this._childList = new $List();
    this._childMap = {};
    this._clientMap = {};
    if (id === undefined || id === null) {
        this._id = _twaver.id();
    } else if (typeof id === 'string' || typeof id === 'number' || typeof id === 'boolean') {
        this._id = id;
    } else {
        for (var property in id) {
            if (property === 'clients') {
                for (var client in id.clients) {
                    this._clientMap[client] = id.clients[client];
                }
            } else if (property === 'styles') {
                for (var style in id.styles) {
                    this._styleMap[style] = id.styles[style];
                }
            } else {
                 if (id[property] != null) property === 'id' ? (this._id = id[property]) : (this[_twaver.setter(property)] && this[_twaver.setter(property)](id[property]));
            }
        }
        if (this._id == null) this._id = _twaver.id();
    }
};
_twaver.ext('twaver.Data', twaver.PropertyChangeDispatcher, {
    IData: true,
    IClient: true,
    __client: 1,
    __new: 1,
    _parent: null,
    __accessor: ['name','name2','icon', 'toolTip'],
    _icon: $Defaults.ICON_DATA,
    _dragBoundsFunc: null,
    getId: function () {
        return this._id;
    },
    getChildren: function () {
        return this._childList;
    },
    getChildrenSize: function () {
        return this._childList.size();
    },
    toChildren: function (matchFunction, scope) {
        return this._childList.toList(matchFunction, scope);
    },
    addChild: function (child, index) {
        if (index === undefined) {
            index = this._childList.size();
        }
        if (!child || child === this) {
            return false;
        }
        if (this._childMap[child.getId()]) {
            return false;
        }
        if (this.isDescendantOf(child)) {
            return false;
        }
        if (child.getParent()) {
            child.getParent().removeChild(child);
        }
        if (index < 0 || index > this._childList.size()) {
            index = this._childList.size();
        }
        this._childList.add(child, index);
        this._childMap[child._id] = child;
        child.setParent(this);

        this.firePropertyChange('children', null, child);
        this.onChildAdded(child, index);
        return true;
    },
    onChildAdded: function (child, index) {

    },
    removeChild: function (child) {
        if (!child) {
            return false;
        }
        if (!this._childMap[child._id]) {
            return false;
        }
        var index = this._childList.remove(child);
        delete this._childMap[child._id];

        this.firePropertyChange('children', child, null);
        child.setParent(null);

        this.onChildRemoved(child, index);
        return true;
    },
    onChildRemoved: function (child, index) {

    },
    getChildAt: function (index) {
        return this._childList.get(index);
    },
    clearChildren: function () {
        if (this._childList.size() === 0) {
            return false;
        }
        var children = this._childList.toArray();
        var n = children.length;
        for (var i = 0; i < n; i++) {
            this.removeChild(children[i]);
        }
        this.onChildrenCleared(children);
        return true;
    },
    onChildrenCleared: function (children) {

    },
    getParent: function () {
        return this._parent;
    },
    setParent: function (parent) {
        if (this._isUpdatingParent || this._parent === parent || this === parent) {
            return;
        }
        // if parent is descendant of me, return
        if (parent && parent.isDescendantOf(this)) {
            return;
        }

        var oldValue = this._parent;
        this._parent = parent;

        this._isUpdatingParent = true;

        //remove from old parent.
        if (oldValue) {
            oldValue.removeChild(this);
        }
        if (parent) {
            parent.addChild(this);
        }

        delete this._isUpdatingParent;

        //fire event.
        this.firePropertyChange("parent", oldValue, parent);

        this.onParentChanged(oldValue, parent);
    },
    onParentChanged: function (oldParent, parent) {
    },
    hasChildren: function () {
        return this._childList.size() > 0;
    },
    isRelatedTo: function (data) {
        if (!data) {
            return false;
        }
        return this.isDescendantOf(data) || data.isDescendantOf(this);
    },
    isParentOf: function (data) {
        if (!data) {
            return false;
        }
        return this._childMap[data._id] != null;
    },
    isDescendantOf: function (data) {
        if (!data) {
            return false;
        }
        if (!data.hasChildren()) {
            return false;
        }
        var tempParent = this._parent;
        while (tempParent) {
            if (data === tempParent) {
                return true;
            } else {
                tempParent = tempParent.getParent();
            }
        }
        return false;
    },
    getDragBoundsFunc: function(){
        return this._dragBoundsFunc;
    },
    setDragBoundsFunc: function(dbf) {
        this._dragBoundsFunc = dbf;
    },
    toString: function () {
        if (this.getName()) {
            return this.getName();
        }
        return this._id;
    }
});

twaver.Alarm = function (id, elementId, alarmSeverity, isAcked, isCleared) {
    twaver.Alarm.superClass.constructor.call(this, id);
    this._elementId = elementId;
    this._alarmSeverity = alarmSeverity;
    this._acked = isAcked || false;
    this._cleared = isCleared || false;
};
_twaver.ext('twaver.Alarm', twaver.Data, {
    IAlarm: true,
    getElementId: function () {
        return this._elementId;
    },
    __accessor: ['acked', 'cleared', 'alarmSeverity']
});

twaver.Layer = function (id) {
    twaver.Layer.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Layer', twaver.Data, {
    ILayer: true,
    __accessor: ['visible', 'movable', 'editable', 'rotatable'],
    _visible: true,
    _movable: true,
    _editable: true,
    _rotatable: true,
    _name: 'Default'
});

twaver.Element = function (id) {
    this._styleMap = this._styleMap || {};
    this._alarmState = new twaver.AlarmState(this);
    twaver.Element.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Element', twaver.Data, {
    IElement: true,
    IStyle: true,
    __accessor: ['layerId'],
    __bool: ['visible','movable'],
    __style: 1,
    _layerId: $Defaults.LAYER_DEFAULT_ID,
    _visible: true,
    _movable: true,
    getAlarmState: function () {
        return this._alarmState;
    },
    isAdjustedToBottom: function () {
        return false;
    },
    getElementUIClass: function () {
        return null;
    },
    getCanvasUIClass: function () {
        return null;
    },
    getVectorUIClass : function(){
    	return null;
    },
    s: function(style, value){
        if(value === undefined){
            if (typeof style === 'string') {
                return this.getStyle(style);
            } else {
                var self = this;
                Object.keys(style).forEach(function (key) {
                    self.setStyle(key, style[key]);
                });
            }
        }else{
            this.setStyle(style,value);
            return this;
        }
    },
    c : function(key,value){
        if(value === undefined){
            return this.getClient(key);
        }else{
            this.setClient(key,value);
            return this;
        }
    },
});

twaver.Dummy = function (id) {
    twaver.Dummy.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Dummy', twaver.Element, {
    IDummy: true
});

var $Node = function(id) {
	this._location = {
		x : 0,
		y : 0
	};
	$Node.superClass.constructor.call(this, id);
};
twaver.Node = $Node;
$Node.IS_INTERESTED_NODE_PROPERTY = {
	'location' : 1,
	'width' : 1,
	'height' : 1,
	'expanded' : 1
};
_twaver.ext('twaver.Node', twaver.Element, {
	_icon : $Defaults.ICON_NODE,
	_image : $Defaults.IMAGE_NODE,
	_imageUrl:null,
	_angle : 0,
	getLoopedLinks : function() {
		return this._loopedLinks;
	},
	getLinks : function() {
		return this._links;
	},
	getAgentLinks : function() {
		return this._agentLinks;
	},
	getFollowers : function() {
		return this._followers;
	},
	_addFollower : function(follower) {
		if (!this._followers) {
			this._followers = new $List();
		}
		this._followers.add(follower);
	},
	_removeFollower : function(follower) {
		this._followers.remove(follower);
		if (this._followers.isEmpty()) {
			delete this._followers;
		}
	},
	getFromLinks : function() {
		return this._fromLinks;
	},
	getToLinks : function() {
		return this._toLinks;
	},
	_addFromLink : function(link) {
		if (!this._links) {
			this._links = new $List(false);
		}
		if (!this._fromLinks) {
			this._fromLinks = new $List(false);
		}
		this._links.add(link);
		if (this._toLinks && this._toLinks.contains(link)) {
			if (!this._loopedLinks) {
				this._loopedLinks = new $List(false);
			}
			this._loopedLinks.add(link);
		}
		this._fromLinks.add(link);
	},
	_addToLink : function(link) {
		if (!this._links) {
			this._links = new $List(false);
		}
		if (!this._toLinks) {
			this._toLinks = new $List(false);
		}
		this._links.add(link);
		if (this._fromLinks && this._fromLinks.contains(link)) {
			if (!this._loopedLinks) {
				this._loopedLinks = new $List(false);
			}
			this._loopedLinks.add(link);
		}
		this._toLinks.add(link);
	},
	_removeFromLink : function(link) {
		this._links && this._links.remove(link);
		this._fromLinks && this._fromLinks.remove(link);
		this._loopedLinks && this._loopedLinks.remove(link);
	},
	_removeToLink : function(link) {
		this._links && this._links.remove(link);
		this._toLinks && this._toLinks.remove(link);
		this._loopedLinks && this._loopedLinks.remove(link);
	},
	hasAgentLinks : function() {
		return this._agentLinks != null && !this._agentLinks.isEmpty();
	},
	getFromAgentLinks : function() {
		return this._fromAgentLinks;
	},
	getToAgentLinks : function() {
		return this._toAgentLinks;
	},
	_addFromAgentLink : function(link) {
		if (!this._fromAgentLinks) {
			this._fromAgentLinks = new $List(false);
		}
		if (!this._agentLinks) {
			this._agentLinks = new $List(false);
		}
		this._fromAgentLinks.add(link);
		this._agentLinks.add(link);
	},
	_addToAgentLink : function(link) {
		if (!this._toAgentLinks) {
			this._toAgentLinks = new $List(false);
		}
		if (!this._agentLinks) {
			this._agentLinks = new $List(false);
		}
		this._toAgentLinks.add(link);
		this._agentLinks.add(link);
	},
	_removeFromAgentLink : function(link) {
		this._fromAgentLinks && this._fromAgentLinks.remove(link);
		this._agentLinks && this._agentLinks.remove(link);
	},
	_removeToAgentLink : function(link) {
		this._toAgentLinks && this._toAgentLinks.remove(link);
		this._agentLinks && this._agentLinks.remove(link);
	},
	getImage : function() {
		return this._image;
	},
	setImage : function(image) {
		var oldImage = this._image;
		var oldWidth = this.getWidth();
		var oldHeight = this.getHeight();
		this._image = image;
		this.firePropertyChange("image", oldImage, image);
		this.firePropertyChange("width", oldWidth, this.getWidth());
		this.firePropertyChange("height", oldHeight, this.getHeight());
	},
	getImageUrl : function() {
		return this._imageUrl;
	},
	setImageUrl : function(imageUrl) {
		if(this._imageUrl != imageUrl){
			var oldImageUrl = this._imageUrl;
			this._imageUrl = imageUrl;
			if(!_imageUtil.images[imageUrl]){
				twaver.imageUtil.registerImageByUrl(imageUrl, twaver.imageUtil.getImageType(imageUrl) ==='svg', imageUrl);
	        }

			this.setImage(imageUrl);
			this.firePropertyChange("imageUrl", oldImageUrl, imageUrl);
		}
	},
	getX : function() {
		return this._location.x;
	},
	getY : function() {
		return this._location.y;
	},
	setX : function(x) {
		this.setLocation(x, this._location.y);
	},
	setY : function(y) {
		this.setLocation(this._location.x, y);
	},
	getLocation : function() {
		return this._location;
	},
	setLocation : function(x, y) {
		var location;
		if (arguments.length === 2) {
			location = {
				x : arguments[0],
				y : arguments[1]
			};
		} else {
			location = arguments[0];
		}
		if (!_twaver.num(location.x) || !_twaver.num(location.y)) {
			return;
		}
		if (location.x === this._location.x && location.y === this._location.y) {
			return;
		}
		if(this._dragBoundsFunc){
			location = this._dragBoundsFunc(location);
		}
		var oldValue = this._location;
		this._location = location;
		this.firePropertyChange('location', oldValue, location);
	},
	getCenterLocation : function() {
		if ($Defaults.CENTER_LOCATION) {
			return this._location;
		} else {
			return {
				x : (this.getX() + this.getWidth() / 2),
				y : (this.getY() + this.getHeight() / 2)
			};
		}
	},
	setCenterLocation : function(x, y) {
		var location;
		if (arguments.length === 2) {
			location = {
				x : arguments[0],
				y : arguments[1]
			};
		} else {
			location = _twaver.clone(arguments[0]);
		}
		if (!_twaver.num(location.x) || !_twaver.num(location.y)) {
			return;
		}
		if (!$Defaults.CENTER_LOCATION) {
			location.x -= this.getWidth() / 2;
			location.y -= this.getHeight() / 2;
		}
		this.setLocation(location);
	},
	translate : function(x, y) {
		this.setLocation(this.getX() + x, this.getY() + y);
	},
	getWidth : function() {
		if (_twaver.num(this._width) && this._width >= 0) {
			return this._width;
		}
		if (typeof this._image !== 'object') {
			var image = _twaver.getImageAsset(this._image);
			if (image) {
				var w = image.getWidth();
				if (_twaver.num(w) && w >= 0) {
					return w;
				}
				image = image._image;
				return getVectorValue(this, image, image, 'w');
			}
		} else if (this._image) {
			return this._image.w;
		}
		return $Defaults.NODE_WIDTH;
	},
	setWidth : function(width) {
		var oldValue = this._width;
		this._width = width;
		this.firePropertyChange("width", oldValue, width);
	},
	getHeight : function() {
		if (_twaver.num(this._height) && this._height >= 0) {
			return this._height;
		}
		if (typeof this._image !== 'object') {
			var image = _twaver.getImageAsset(this._image);
			if (image) {
				var h = image.getHeight();
				if (_twaver.num(h) && h >= 0) {
					return h;
				}
				image = image._image;
				return getVectorValue(this, image, image, 'h');
			}
		} else if (this._image) {
			return this._image.h;
		}
		return $Defaults.NODE_HEIGHT;
	},
	setHeight : function(height) {
		var oldValue = this._height;
		this._height = height;
		this.firePropertyChange("height", oldValue, height);
	},
	setSize : function() {
		if (arguments.length === 2) {
			this.setWidth(arguments[0]);
			this.setHeight(arguments[1]);
		} else {
			this.setWidth(arguments[0].width);
			this.setHeight(arguments[0].height);
		}
	},
	getSize : function() {
		return {
			width : this.getWidth(),
			height : this.getHeight()
		};
	},
	getRect : function() {
		var orgRect = this.getOriginalRect();
		if (this._angle === 0) {
			return orgRect;
		}
		var matrix = $math.createMatrix(this._angle * Math.PI / 180, orgRect.x + orgRect.width / 2, orgRect.y + orgRect.height / 2);
		var points = [{
			x : orgRect.x,
			y : orgRect.y
		}, {
			x : orgRect.x + orgRect.width,
			y : orgRect.y
		}, {
			x : orgRect.x + orgRect.width,
			y : orgRect.y + orgRect.height
		}, {
			x : orgRect.x,
			y : orgRect.y + orgRect.height
		}];
		for (var i = 0, n = points.length; i < n; i++) {
			points[i] = matrix.transform(points[i]);
		}
		var rect = $math.getRect(points);
		return rect;
	},
	getOriginalRect : function() {
		var self = this,
			width = self.getWidth(),
			height = self.getHeight();
		if ($Defaults.CENTER_LOCATION) {
			return { x: self._location.x - width / 2, y: self._location.y - height / 2, width: width, height: height };
		} else {
			return {
				x : self.getX(),
				y : self.getY(),
				width : width,
				height : height
			};
		}
	},
	getAngle : function() {
		return this._angle;
	},
	setAngle : function(angle) {
		var oldValue = this._angle;
		this._angle = angle % 360;
		this.firePropertyChange("angle", oldValue, this._angle);
	},
	onParentChanged : function(oldParent, parent) {
		$Node.superClass.onParentChanged.call(this, oldParent, parent);
		this._checkLinkAgent();
	},
	_checkLinkAgent : function() {
		if(twaver._isInitializing){
			if (this._links) {
				var n = this._links.size();
				for (var i = 0; i < n; i++) {
					this._links.get(i)._checkAgentNode();
				}
			}
		}else{
			twaver.ElementBox.prototype.startBatch(function() {
			if (this._links) {
				var n = this._links.size();
				for (var i = 0; i < n; i++) {
					this._links.get(i)._checkAgentNode();
				}
			}
		}, this);
		}
		

	},
	onPropertyChanged : function(e) {
		$Node.superClass.onPropertyChanged.call(this, e);
		if (this._followers) {
			var list = this._followers.toList();
			var n = list.size();
			for (var i = 0; i < n; i++) {
				list.get(i).handleHostPropertyChange(e);//handleHostPropertyChange may be change the _followers
			}
		}
		if (this.getParent() instanceof $Group) {
			if ($Node.IS_INTERESTED_NODE_PROPERTY[e.property]) {
				this.getParent().updateLocationFromChildren();
			}
		}
	},
	getElementUIClass : function() {
		return twaver.network.NodeUI;
	},
	getCanvasUIClass : function() {
		return twaver.canvas.NodeUI;
	},
	getVectorUIClass : function() {
		return twaver.vector.NodeUI;
	},
});


var $HTMLNode = function(id) {
	$HTMLNode.superClass.constructor.call(this, id);
};

twaver.HTMLNode = $HTMLNode;

_twaver.ext('twaver.HTMLNode', twaver.Node, {
	getElementUIClass : function() {
		return twaver.network.HTMLNodeUI;
	},
	getCanvasUIClass : function() {
		return twaver.canvas.HTMLNodeUI;
	},
	getVectorUIClass : function() {
		return twaver.vector.HTMLNodeUI;
	},
});


twaver.Link = function(id, fromNode, toNode) {
	twaver.Link.superClass.constructor.call(this, (( id instanceof $Node) ? null : id));
	if (id instanceof $Node) {
		toNode = fromNode;
		fromNode = id;
	}
	fromNode && this.setFromNode(fromNode);
	toNode && this.setToNode(toNode);
};
twaver.Link.IS_INTERESTED_BUNDLE_STYLE = {
	'link.bundle.enable' : 1,
	'link.bundle.id' : 1,
	'link.bundle.independent' : 1
};
_twaver.ext('twaver.Link', twaver.Element, {
	_fromNode : null,
	_toNode : null,
	_fromAgent : null,
	_toAgent : null,
	_icon : $Defaults.ICON_LINK,
	getFromNode : function() {
		return this._fromNode;
	},
	getToNode : function() {
		return this._toNode;
	},
	getFromAgent : function() {
		return this._fromAgent;
	},
	getToAgent : function() {
		return this._toAgent;
	},
	setFromNode : function(fromNode) {
		if (this._fromNode === fromNode) {
			return;
		}
		var oldValue = this._fromNode;
		this._fromNode = fromNode;
		if (oldValue) {
			oldValue._removeFromLink(this);
		}
		if (this._fromNode) {
			this._fromNode._addFromLink(this);
		}
		this._checkAgentNode();
		this.firePropertyChange('fromNode', oldValue, fromNode);
	},
	setToNode : function(toNode) {
		if (this._toNode === toNode) {
			return;
		}
		var oldValue = this._toNode;
		this._toNode = toNode;
		if (oldValue) {
			oldValue._removeToLink(this);
		}
		if (this._toNode) {
			this._toNode._addToLink(this);
		}
		this._checkAgentNode();
		this.firePropertyChange('toNode', oldValue, toNode);
	},
	isLooped : function() {
		return this._fromNode === this._toNode && this._fromNode != null && this._toNode != null;
	},
	_checkAgentNode : function() {
		if (twaver._isInitializing) {
			if (!twaver._links[this._id]) {
				twaver._links[this._id] = this;
			}
		} else {
			this._checkAgentNodeImpl();
		}
	},
	_checkAgentNodeImpl : function() {
		var newFromAgent = $element.figureFromAgent(this);
		var oldValue, scope = this,id;
		if (this._fromAgent != newFromAgent) {
			oldValue = this._fromAgent;
			if (this._fromAgent) {
				this._fromAgent._removeFromAgentLink(this);
			}
			this._fromAgent = newFromAgent;
			if (this._fromAgent) {
				this._fromAgent._addFromAgentLink(this);
			}
			this.firePropertyChange("fromAgent", oldValue, this._fromAgent);

			if (twaver._isInitializing) {
				if (oldValue && this._toAgent) {
					id = oldValue._id + ':' + this._toAgent._id;
					if (!twaver._bundleLinks[id]) {
						twaver._bundleLinks[id] = [oldValue, this._toAgent];
					}
				}
				if (this._fromAgent && this._toAgent) {
					id = this._fromAgent._id + ':' + this._toAgent._id;
					if (!twaver._bundleLinks[id]) {
						twaver._bundleLinks[id] = [this._fromAgent, this._toAgent];
					}
				}
			} else {
				$element.resetBundleLinks(oldValue, scope._toAgent);
				$element.resetBundleLinks(scope._fromAgent, scope._toAgent);
			}

		}

		var newToAgent = $element.figureToAgent(this);
		if (this._toAgent != newToAgent) {
			oldValue = this._toAgent;
			if (this._toAgent) {
				this._toAgent._removeToAgentLink(this);
			}
			this._toAgent = newToAgent;
			if (this._toAgent) {
				this._toAgent._addToAgentLink(this);
			}
			this.firePropertyChange("toAgent", oldValue, this._toAgent);
			if (twaver._isInitializing) {
				if (oldValue && this._fromAgent) {
					id = oldValue._id + ':' + this._fromAgent._id;
					if (!twaver._bundleLinks[id]) {
						twaver._bundleLinks[id] = [oldValue, this._fromAgent];
					}
				}
				if (this._toAgent && this._fromAgent) {
					id = this._toAgent._id + ':' + this._fromAgent._id;
					if (!twaver._bundleLinks[id]) {
						twaver._bundleLinks[id] = [this._toAgent, this._fromAgent];
					}
				}
			} else {
				$element.resetBundleLinks(oldValue, scope._fromAgent);
				$element.resetBundleLinks(scope._toAgent, scope._fromAgent);
			}

		}

	},
	_setBundleLinks : function(bundleLinks) {
		this._bundleLinks = bundleLinks;
		this.firePropertyChange("bundleLinks", true, false);
	},
	getBundleLinks : function() {
		return this._bundleLinks;
	},
	getBundleCount : function() {
		if (this._bundleLinks) {
			return this._bundleLinks.getLinks().size();
		} else {
			return 1;
		}
	},
	getBundleIndex : function() {
		if (this._bundleLinks) {
			return this._bundleLinks.getLinks().indexOf(this);
		} else {
			return 0;
		}
	},
	reverseBundleExpanded : function() {
		if (this._bundleLinks && this._bundleLinks.getLinks().size() > 0) {
			var i;
			var link;
			var links = this._bundleLinks.getLinks();
			var expanded = !this.getStyle("link.bundle.expanded");
			for ( i = 0; i < links.size(); i++) {
				link = links.get(i);
				link.setStyle("link.bundle.expanded", expanded);
			}

			var siblings = this._bundleLinks.getSiblings();
			for ( i = 0; i < siblings.size(); i++) {
				var sibling = siblings.get(i);
				if (sibling != this._bundleLinks) {
					links = sibling.getLinks();
					for (var j = 0; j < links.size(); j++) {
						link = links.get(j);
						link.firePropertyChange("bundleLinks", null, sibling);
					}
				}
			}

			return true;
		}
		return false;
	},
	isBundleAgent : function() {
		return this._bundleLinks != null && this._bundleLinks.getLinks().size() > 1 && this === this._bundleLinks.getLinks().get(0) && !this.getStyle("link.bundle.expanded");
	},
	onStyleChanged : function(styleProp, oldValue, newValue) {
		twaver.Link.superClass.onStyleChanged.call(this, styleProp, oldValue, newValue);
		if (twaver.Link.IS_INTERESTED_BUNDLE_STYLE[styleProp]) {
			$element.resetBundleLinks(this._toAgent, this._fromAgent);
		}
	},
	getElementUIClass : function() {
		return twaver.network.LinkUI;
	},
	getCanvasUIClass : function() {
		return twaver.canvas.LinkUI;
	},
	getVectorUIClass : function() {
		return twaver.vector.LinkUI;
	},
	isAdjustedToBottom : function() {
		return $Defaults.IS_LINK_ADJUSTED_TO_BOTTOM;
	}
});

twaver.HTMLLink = function(id, from, to) {
    twaver.HTMLLink.superClass.constructor.call(this, id, from, to);
}
twaver.Util.ext('twaver.HTMLLink', twaver.Link, {
    getElementUIClass: function () {
        return twaver.network.HTMLLinkUI;
    },
    getCanvasUIClass : function() {
		return twaver.canvas.HTMLLinkUI;
	},
	getVectorUIClass : function() {
		return twaver.vector.HTMLLinkUI;
	},
});
twaver.Follower = function (id) {
    this._isUpdatingFollower = false;
    this._isUpdatingLocation = false;
    twaver.Follower.superClass.constructor.call(this, id);
};
twaver.Follower.IS_INTERESTED_HOST_GRID_PROPERTY = {
    "location": 1,
    "width": 1,
    "height": 1,
    "S:grid.row.count": 1,
    "S:grid.column.count": 1,
    "S:grid.row.percents": 1,
    "S:grid.column.percents": 1,
    "S:grid.border": 1,
    "S:grid.border.left": 1,
    "S:grid.border.right": 1,
    "S:grid.border.top": 1,
    "S:grid.border.bottom": 1,
    "S:grid.padding": 1,
    "S:grid.padding.left": 1,
    "S:grid.padding.right": 1,
    "S:grid.padding.top": 1,
    "S:grid.padding.bottom": 1
};
twaver.Follower.IS_INTERESTED_FOLLOWER_STYLE = {
    "follower.row.index": 1,
    "follower.column.index": 1,
    "follower.row.span": 1,
    "follower.column.span": 1,
    "follower.padding": 1,
    "follower.padding.left": 1,
    "follower.padding.right": 1,
    "follower.padding.top": 1,
    "follower.padding.bottom": 1
};
_twaver.ext('twaver.Follower', $Node, {
    _host: null,
    getHost: function () {
        return this._host;
    },
    setHost: function (host) {
        if (this === host || this._host === host) {
            return;
        }
        var oldValue = this._host;
        if (oldValue) {
            oldValue._removeFollower(this);
        }
        this._host = host;
        if (this._host) {
            this._host._addFollower(this);
        }
        this.firePropertyChange("host", oldValue, host);
        this.onHostChanged(oldValue, host);
    },
    onStyleChanged: function (styleProp, oldValue, newValue) {
        twaver.Follower.superClass.onStyleChanged.call(this, styleProp, oldValue, newValue);
        if (twaver.Follower.IS_INTERESTED_FOLLOWER_STYLE[styleProp]) {
            this.updateFollower(null);
        }
    },
    setLocation: function () {
        if (this._isUpdatingLocation) {
            return;
        }
        this._isUpdatingLocation = true;
        twaver.Follower.superClass.setLocation.apply(this, arguments);
        this._isUpdatingLocation = false;
    },
    onHostChanged: function (oldHost, newHost) {
        this.updateFollower(null);
    },
    handleHostPropertyChange: function (e) {
        this.updateFollower(e);
    },
    updateFollower: function (e) {
        if (this._isUpdatingFollower || _twaver.isDeserializing) {
            return;
        }
        this._isUpdatingFollower = true;
        this.updateFollowerImpl(e);
        this._isUpdatingFollower = false;
    },
    updateFollowerImpl: function (e) {
        var grid = this.getHost();
        if (grid instanceof twaver.Grid) {
            if (!e || twaver.Follower.IS_INTERESTED_HOST_GRID_PROPERTY[e.property]) {
                var rowIndex = this.getStyle('follower.row.index');
                var columnIndex = this.getStyle('follower.column.index');
                var rect = grid.getCellRect(rowIndex, columnIndex);
                if (!rect) {
                    return;
                }
                var rowSpan = this.getStyle('follower.row.span');
                var columnSpan = this.getStyle('follower.column.span');
                if (rowSpan != 1 || columnSpan != 1) {
                    var rect2 = grid.getCellRect(rowIndex + rowSpan - 1, columnIndex + columnSpan - 1);
                    if (rect2) {
                        rect = $math.unionRect(rect, rect2);
                    }
                }
                $math.addPadding(rect, this, 'follower.padding');
                if (this.getStyle('follower.fill.cell')) {
                    this.setLocation(rect.x, rect.y);
                    this.setWidth(rect.width);
                    this.setHeight(rect.height);
                } else {
                    var position = this.getStyle('follower.cell.position');
                    rect = $position.get(position, rect, this.getRect());
                    this.setLocation(rect.x, rect.y);
                }
            }
        }
        else {
            if (e != null && e.property === "location") {
                var oldLocation = e.oldValue;
                var newLocation = e.newValue;
                var location = this.getLocation();
                this.setLocation(
									location.x + (newLocation.x - oldLocation.x),
									location.y + (newLocation.y - oldLocation.y));
            }
        }
    },
    isHostOn: function (node) {
        if (!node) {
            return false;
        }
        var dic = {};
        var tmpHost = this._host;
        while (tmpHost && tmpHost != this && !dic[tmpHost.getId()]) {
            if (tmpHost === node) {
                return true;
            } else {
                dic[tmpHost.getId()] = tmpHost;
                if (tmpHost instanceof twaver.Follower) {
                    tmpHost = tmpHost.getHost();
                } else {
                    tmpHost = null;
                }
            }
        }
        return false;
    },
    isLoopedHostOn: function (follower) {
        return this.isHostOn(follower) && follower.isHostOn(this);
    }
});
var $Group = function (id) {
    this._isUpdatingLocationFromChildren = false;
    this._isAdjusting = false;
    this._expanded = false;
    $Group.superClass.constructor.call(this, id);
};
twaver.Group = $Group;
_twaver.ext('twaver.Group', twaver.Follower, {
    _image: $Defaults.IMAGE_GROUP,
    _icon: $Defaults.ICON_GROUP,
    isAdjustedToBottom: function () {
        return this.isExpanded() && $element.hasAgentLinks(this);
    },
    onChildAdded: function (child, index) {
        $Group.superClass.onChildAdded.apply(this, arguments);
        this.updateLocationFromChildren();
    },
    onChildRemoved: function (child, index) {
        $Group.superClass.onChildRemoved.apply(this, arguments);
        this.updateLocationFromChildren();
    },
    updateLocationFromChildren: function () {
        if (this._isAdjusting || _twaver.isDeserializing) {
            return;
        }
        var rect, i = 0, n = this.getChildrenSize(), child;
        for (; i < n; i++) {
            child = this.getChildAt(i);
            if (child instanceof $Node) {
                rect = $math.unionRect(rect, this.getChildRect(child));
            }
        }
        if (rect) {
            this._isUpdatingLocationFromChildren = true;
            if($Defaults.GROUP_EXPAND_ALIGN === 'lefttop'){
                this.setLocation(rect.x - this.getWidth() / 2, rect.y - this.getHeight() / 2);
            }else {
                this.setLocation(rect.x + rect.width / 2 - this.getWidth() / 2, rect.y + rect.height / 2 - this.getHeight() / 2);
            }
            this._isUpdatingLocationFromChildren = false;
        }
    },
    getChildRect: function (child) {
        var rect;
        if (child instanceof $Node) {
            if (child instanceof $Group) {
                if (child.isExpanded()) {
                    child.getChildren().forEach(function (element) {
                        rect = $math.unionRect(rect, child.getChildRect(element));
                    });
                }
                if (!rect) {
                    rect = child.getRect();
                }
            } else {
                rect = child.getRect();
            }
        }
        return rect;
    },
    setLocation: function () {
        if (this._isAdjusting) {
            return;
        }
        var location;
        if (arguments.length === 2) {
            location = { x: arguments[0], y: arguments[1] };
        } else {
            location = arguments[0];
        }
        if (!_twaver.isDeserializing && !this._isUpdatingLocationFromChildren) {
            this._isAdjusting = true;
            var dx = location.x - this.getX();
            var dy = location.y - this.getY();
            $element.moveElements(this.getChildren(), dx, dy);
            this._isAdjusting = false;
        }
        $Group.superClass.setLocation.call(this, location);
    },
    reverseExpanded: function () {
        this.setExpanded(!this.isExpanded());
    },
    isExpanded: function () {
        return this._expanded;
    },
    setExpanded: function (expanded) {
        if (this._expanded === expanded) {
            return;
        }
        var oldValue = this._expanded;
        this._expanded = expanded;
        this.firePropertyChange("expanded", oldValue, this._expanded);
        this._checkLinkAgent();
    },
    _checkLinkAgent: function () {
        $Group.superClass._checkLinkAgent.call(this);
        var n = this.getChildrenSize();
        for (var i = 0; i < n; i++) {
            var child = this.getChildAt(i);
            if (child instanceof $Node) {
                child._checkLinkAgent();
            }
        }
    },
    getElementUIClass: function () {
        return twaver.network.GroupUI;
    },
    getCanvasUIClass: function () {
        return twaver.canvas.GroupUI;
    },
    getVectorUIClass : function(){
    	return twaver.vector.GroupUI;
    },
});

twaver.SubNetwork = function (id) {
    twaver.SubNetwork.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.SubNetwork', twaver.Follower, {
    ISubNetwork: true,
    _image: $Defaults.IMAGE_SUBNETWORK,
    _icon: $Defaults.ICON_SUBNETWORK,
    _checkLinkAgent: function () {
        twaver.SubNetwork.superClass._checkLinkAgent.call(this);
        var n = this.getChildrenSize();
        for (var i = 0; i < n; i++) {
            var child = this.getChildAt(i);
            if (child instanceof $Node) {
                child._checkLinkAgent();
            }
        }
    }
});

twaver.Grid = function (id) {
    twaver.Grid.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Grid', twaver.Follower, {
    _icon: $Defaults.ICON_GRID,
    _image: null,
    getCellObject: function (x, y) {
        if (arguments.length === 1) {
            y = x.y;
            x = x.x;
        }
        var rowCount = this.getStyle('grid.row.count');
        var columnCount = this.getStyle('grid.column.count');
        for (var r = 0; r < rowCount; r++) {
            for (var c = 0; c < columnCount; c++) {
                var rect = this.getCellRect(r, c);
                if ($math.containsPoint(rect, x, y)) {
                    return {
                        "rowIndex": r,
                        "columnIndex": c,
                        "rect": rect
                    };
                }
            }
        }
        return null;
    },
    getCellRect: function (rowIndex, columnIndex) {
        var rowCount = this.getStyle('grid.row.count');
        var columnCount = this.getStyle('grid.column.count');
        if (rowCount <= 0 || columnCount <= 0) {
            return null;
        }
        if (rowIndex < 0 || rowIndex >= rowCount) {
            return null;
        }
        if (columnIndex < 0 || columnIndex >= columnCount) {
            return null;
        }
        var rect = this.getRect();
        $math.addPadding(rect, this, 'grid.border');

        var index = 0;
        var rows = this.getStyle('grid.row.percents');
        var columns = this.getStyle('grid.column.percents');
        if (rows && rows.length === rowCount) {
            var h = 0;
            for (index = 0; index < rowIndex; index++) {
                h += rect.height * rows[index];
            }
            rect.y += h;
            rect.height = rect.height * rows[rowIndex];
        } else {
            rect.height = rect.height / rowCount;
            rect.y += rect.height * rowIndex;
        }
        if (columns && columns.length === columnCount) {
            var w = 0;
            for (index = 0; index < columnIndex; index++) {
                w += rect.width * columns[index];
            }
            rect.x += w;
            rect.width = rect.width * columns[columnIndex];
        } else {
            rect.width = rect.width / columnCount;
            rect.x += rect.width * columnIndex;
        }
        $math.addPadding(rect, this, 'grid.padding');
        return rect;
    },
    getElementUIClass: function () {
        return twaver.network.GridUI;
    },
    getCanvasUIClass: function () {
        return twaver.canvas.GridUI;
    },
    getVectorUIClass : function(){
    	return twaver.vector.GridUI;
    },
});

twaver.ShapeNode = function (id) {
    this._isUpdatingShapeNode = false;
    this._points = new $List();
    twaver.ShapeNode.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.ShapeNode', twaver.Follower, {
    _icon: $Defaults.ICON_SHAPENODE,
    __accessor: ['segments'],
    getElementUIClass: function () {
        return twaver.network.ShapeNodeUI;
    },
    getCanvasUIClass: function () {
        return twaver.canvas.ShapeNodeUI;
    },
    getVectorUIClass : function(){
    	return twaver.vector.ShapeNodeUI;
    },
    getPoints: function () {
        return this._points;
    },
    setPoints: function (value) {
        if (!value) {
            value = new $List();
        }
        var oldPoints = new $List(this._points);
        this._points = value;
        this.firePointsChange(oldPoints, this._points);
    },
    getSegments: function () {
        return this._segments;
    },
    setSegments: function (value) {
        if (!value) {
            value = new $List();
        }
        var oldSegments = new $List(this._segments);
        this._segments = value;
        this._reCalculateLineLength();
        this.firePropertyChange("segments", oldSegments, this._segments);
    },
    addPoint: function (point, index) {
        var oldPoints = new $List(this._points);
        this._points.add(point, index);
        this.firePointsChange(oldPoints, this._points);
    },
    setPoint: function (index, point) {
        var oldPoints = new $List(this._points);
        this._points.set(index, point);
        this.firePointsChange(oldPoints, this._points);
    },
    removePoint: function (point) {
        var oldPoints = new $List(this._points);
        this._points.remove(point);
        this.firePointsChange(oldPoints, this._points);
    },
    removeAt: function (index) {
        var oldPoints = new $List(this._points);
        this._points.removeAt(index);
        this.firePointsChange(oldPoints, this._points);
    },
    setWidth: function (width) {
        if (width < 1) {
            width = 1;
        }
        // adjust points according to new width
        if (!this._isUpdatingShapeNode && !_twaver.isDeserializing) {
            this._isUpdatingShapeNode = true;

            var oldPoints = new $List(this._points);
            for (var i = 0; i < this._points.size(); i++) {
                var point = this._points.get(i);
                point.x = (point.x - this.getX()) * width / this.getWidth() + this.getX();
            }

            this.firePointsChange(oldPoints, this._points);
            this._isUpdatingShapeNode = false;
        }
        twaver.ShapeNode.superClass.setWidth.apply(this, arguments);
    },
    setHeight: function (height) {
        if (height < 1) {
            height = 1;
        }
        // adjust points according to new height
        if (!this._isUpdatingShapeNode && !_twaver.isDeserializing) {
            this._isUpdatingShapeNode = true;

            var oldPoints = new $List(this._points);
            for (var i = 0; i < this._points.size(); i++) {
                var point = this._points.get(i);
                point.y = (point.y - this.getY()) * height / this.getHeight() + this.getY();
            }

            this.firePointsChange(oldPoints, this._points);
            this._isUpdatingShapeNode = false;
        }
        twaver.ShapeNode.superClass.setHeight.apply(this, arguments);
    },
    setLocation: function () {
        if (!this._isUpdatingShapeNode && !_twaver.isDeserializing) {
            var location;
            if (arguments.length === 2) {
                location = { x: arguments[0], y: arguments[1] };
            } else {
                location = arguments[0];
            }
            if (!_twaver.num(location.x) || !_twaver.num(location.y)) {
                return;
            }
            var xoffset = location.x - this.getX();
            var yoffset = location.y - this.getY();
            if (xoffset === 0 && yoffset === 0) {
                return;
            }

            // adjust points according to new location
            this._isUpdatingShapeNode = true;
            var oldPoints = new $List(this._points);
            for (var i = 0; i < this._points.size(); i++) {
                var point = this._points.get(i);
                point.x += xoffset;
                point.y += yoffset;
            }
            this.firePointsChange(oldPoints, this._points);
            this._isUpdatingShapeNode = false;
        }
        twaver.ShapeNode.superClass.setLocation.apply(this, arguments);
    },
    firePointsChange: function (oldPoints, newPoints) {
        if (!this._isUpdatingShapeNode && !_twaver.isDeserializing) {
            var rect = $math.getRect(newPoints);
            if (rect) {
                this._isUpdatingShapeNode = true;
                if ($Defaults.CENTER_LOCATION) {
                    this.setLocation(rect.x + rect.width / 2, rect.y + rect.height / 2);
                } else {
                    this.setLocation(rect.x, rect.y);
                }
                this.setWidth(rect.width);
                this.setHeight(rect.height);
                this._isUpdatingShapeNode = false;
            } else {
                this._isUpdatingShapeNode = true;
                this.setWidth(0);
                this.setHeight(0);
                this._isUpdatingShapeNode = false;
            }
        }
        this._reCalculateLineLength();
        this.firePropertyChange("points", oldPoints, newPoints);
    },
    _reCalculateLineLength: function () {
        if (this._points != null && this._points.size() > 0) {
            this._lineLength = $math.calculateLineLength(this._points, this._segments);
        } else {
            this._lineLength = 0;
        }
    },
    getLineLength: function () {
        return this._lineLength;
    }
});

twaver.Bus = function (id) {
    this._styleMap = {};
    this._styleMap['vector.fill'] = false;
    this._styleMap['shapenode.closed'] = false;
    twaver.Bus.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Bus', twaver.ShapeNode, {
    _icon: $Defaults.ICON_BUS,
    firePointsChange: function (oldPoints, newPoints) {
        var count = newPoints.size();
        if (!_twaver.isDeserializing && count >= 2) {
            var lastPoint = newPoints.get(0);
            for (var i = 1; i < count; i++) {
                var point = newPoints.get(i);
                if (Math.abs(point.x - lastPoint.x) > Math.abs(point.y - lastPoint.y)) {
                    point.y = lastPoint.y;
                } else {
                    point.x = lastPoint.x;
                }
                lastPoint = point;
            }
        }
        twaver.Bus.superClass.firePointsChange.apply(this, arguments);
    }
});

twaver.ShapeLink = function (id, fromNode, toNode) {
    this._points = new $List();
    this._styleMap = {};
    this._styleMap['link.bundle.enable'] = false;
    twaver.ShapeLink.superClass.constructor.call(this, id, fromNode, toNode);
};
_twaver.ext('twaver.ShapeLink', twaver.Link, {
    _icon: $Defaults.ICON_SHAPELINK,
    getElementUIClass: function () {
        return twaver.network.ShapeLinkUI;
    },
    getCanvasUIClass: function () {
        return twaver.canvas.ShapeLinkUI;
    },
    getVectorUIClass: function () {
        return twaver.vector.ShapeLinkUI;
    },
    getPoints: function () {
        return this._points;
    },
    setPoints: function (value) {
        if (!value) {
            value = new $List();
        }
        var oldPoints = new $List(this._points);
        this._points = value;
        this.firePointsChange(oldPoints, this._points);
    },
    addPoint: function (point, index) {
        var oldPoints = new $List(this._points);
        this._points.add(point, index);
        this.firePointsChange(oldPoints, this._points);
    },
    setPoint: function (index, point) {
        var oldPoints = new $List(this._points);
        this._points.set(index, point);
        this.firePointsChange(oldPoints, this._points);
    },
    removePoint: function (point) {
        var oldPoints = new $List(this._points);
        this._points.remove(point);
        this.firePointsChange(oldPoints, this._points);
    },
    removeAt: function (index) {
        var oldPoints = new $List(this._points);
        this._points.removeAt(index);
        this.firePointsChange(oldPoints, this._points);
    },
    firePointsChange: function (oldPoints, newPoints) {
        this.firePropertyChange("points", oldPoints, newPoints);
    }
});

twaver.ShapeSubNetwork = function (id) {
    twaver.ShapeSubNetwork.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.ShapeSubNetwork', twaver.ShapeNode, {
    ISubNetwork: true,
    _icon: $Defaults.ICON_SHAPESUBNETWORK,
    _checkLinkAgent: function () {
        twaver.ShapeSubNetwork.superClass._checkLinkAgent.call(this);
        var n = this.getChildrenSize();
        for (var i = 0; i < n; i++) {
            var child = this.getChildAt(i);
            if (child instanceof $Node) {
                child._checkLinkAgent();
            }
        }
    }
});

twaver.LinkSubNetwork = function () {
    twaver.LinkSubNetwork.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.LinkSubNetwork', twaver.Link, {
    ISubNetwork: true,
    _icon: $Defaults.ICON_LINKSUBNETWORK
});

twaver.ShapeLinkSubNetwork = function () {
    twaver.ShapeLinkSubNetwork.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.ShapeLinkSubNetwork', twaver.ShapeLink, {
    ISubNetwork: true,
    _icon: $Defaults.ICON_LINKSUBNETWORK
});

twaver.RotatableNode = function (id) {
    twaver.RotatableNode.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.RotatableNode', twaver.Follower, {
    getWidth: function () {
        if (this._angle == 0) {
            return this._getOrignalWidth();
        } else {
            return this._getRotateRect().width;
        }
    },
    setWidth: function (width) {

    },
    getHeight: function () {
        if (this._angle == 0) {
            return this._getOrignalHeight();
        } else {
            return this._getRotateRect().height;
        }
    },
    setHeight: function (height) {

    },
    getElementUIClass: function () {
        return twaver.network.RotatableNodeUI;
    },
    getCanvasUIClass: function () {
        return twaver.canvas.RotatableNodeUI;
    },
    getVectorUIClass: function () {
        return twaver.vector.RotatableNodeUI;
    },
    _getRotateRect: function () {
        var width = this._getOrignalWidth();
        var height = this._getOrignalHeight();
        var matrix = $math.createMatrix(this._angle * Math.PI / 180, width / 2, height / 2);
        var points = [{ x: 0, y: 0 }, { x: width, y: 0 }, { x: width, y: height }, { x: 0, y: height}];
        for (var i = 0, n = points.length; i < n; i++) {
            points[i] = matrix.transform(points[i]);
        }
        return $math.getRect(points);
    },
    _getOrignalWidth: function () {
        return twaver.RotatableNode.superClass.getWidth.call(this);
    },
    _getOrignalHeight: function () {
        return twaver.RotatableNode.superClass.getHeight.call(this);
    }
});


twaver.controls.ControlBase = function () {
    twaver.controls.ControlBase.superClass.constructor.apply(this, arguments);
    this._pools = new $List();
};
_twaver.ext('twaver.controls.ControlBase', twaver.PropertyChangeDispatcher, {
    _autoAdjustBounds:false,
    addPool: function (pool) {
        if (!this._pools.contains(pool)) {
            this._pools.add(pool);
        }
    },
    removePool: function (pool) {
        this._pools.remove(pool);
    },

    adjustBounds: function (rect) {
        var style = this._view.style;
        style.position = 'absolute';
        style.left = rect.x + 'px';
        style.top = rect.y + 'px';
        style.width = rect.width + 'px';
        style.height = rect.height + 'px';
        if(this._autoAdjustBounds === true){
            style.left = '0px';
            style.top = '0px';
            style.right = '0px';
            style.bottom = '0px';
        }
        if (this.invalidate) {
            this.invalidate();
        }
    },

    setAutoAdjustBounds:function(autoAdjustBounds){
        if(autoAdjustBounds === true){
            $html.addEventListener("resize","_handleResize",window,this);
        }else{
            $html.removeEventListener("resize",window,this);
        }
        this._autoAdjustBounds = autoAdjustBounds;
    },
    isAutoAdjustBounds:function(){
        return this._autoAdjustBounds;
    },
    _handleResize: function(e){
        this.adjustBounds({x:0,y:0,width:document.documentElement.clientWidth,height:document.documentElement.clientHeight});
    },

    getView: function () {
        return this._view;
    },
    invalidate: function (delay) {
        if (!this._invalidate) {
            this._invalidate = true;
            _twaver.callLater(this.validate, this, null, delay);
        }
    },
    validate: function () {
        if (!this._invalidate) {
            return;
        }
        this._invalidate = false;
        if (this._view.offsetWidth === 0 && this._view.offsetHeight === 0 && this._reinvalidateCount !== null) {
            if (this._reinvalidateCount === undefined) {
                this._reinvalidateCount = 100;
            }
            if (this._reinvalidateCount > 0) {
                this._reinvalidateCount--;
            } else {
                this._reinvalidateCount = null;
            }
            this.invalidate();
        } else {
            this.validateImpl();
        }
    },
    validateImpl: function () {
    }
});

twaver.controls.ViewBase = function () {
    twaver.controls.ViewBase.superClass.constructor.apply(this, arguments);
    this._interactionDispatcher = new twaver.EventDispatcher();
    this._viewDispatcher = new twaver.EventDispatcher();
};
_twaver.ext('twaver.controls.ViewBase', twaver.controls.ControlBase, {
    __bool: ['focusOnClick'],
    _focusOnClick: $Defaults.FOCUS_ON_CLICK,

    getSelectionModel: function () {
        return this._selectionModel ? this._selectionModel : this._box.getSelectionModel();
    },
    isShareSelectionModel: function () {
        return this._selectionModel == null;
    },
    setShareSelectionModel: function (shareSelectionModel) {
        var oldValue = this._selectionModel == null;
        if (oldValue === shareSelectionModel) {
            return;
        }
        if (shareSelectionModel) {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
            this._selectionModel.removeSelectionChangeListener(this.handleSelectionChange, this);
            this._selectionModel.dispose();
            this._selectionModel = null;
        } else {
            this._box.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            this._selectionModel = new twaver.SelectionModel(this._box);
            this._selectionModel.addSelectionChangeListener(this.handleSelectionChange, this);
        }
        this.onShareSelectionModelChanged();
        this.firePropertyChange("shareSelectionModel", oldValue, shareSelectionModel);
    },
    onShareSelectionModelChanged: function () {

    },
    removeSelection: function () {
        if (this.getSelectionModel().size() === 0) {
            return null;
        }
        var selection = this.getSelectionModel().toSelection();
        if (this._box._undoManager._enabled) {
            this._box._undoManager.startBatch();
        }
        selection.forEach(function (data) {
            this._box.remove(data);
        }, this);
        if (this._box._undoManager._enabled) {
            this._box._undoManager.endBatch();
        }
        return selection;
    },
    selectAll: function () {
        var list = new $List();
        this._box.forEach(function (data) {
            if (this.isVisible(data)) {
                list.add(data);
            }
        }, this);
        this.getSelectionModel().setSelection(list);
        return list;
    },
    isSelected: function (data) {
        return this.getSelectionModel().contains(data);
    },
    isSelectable: function (data) {
        return this.getSelectionModel().isSelectable(data);
    },

    getLabel: function (data) {
        return data.getName();
    },
    getToolTip: function (data) {
        return data.getToolTip();
    },
    getIcon: function (data) {
        return data.getIcon();
    },
    getSelectColor: function (data) {
        return $Defaults.SELECT_COLOR;
    },
    addViewListener: function (listener, scope, ahead) {
        this._viewDispatcher.add(listener, scope, ahead);
    },
    removeViewListener: function (listener, scope) {
        this._viewDispatcher.remove(listener, scope);
    },
    fireViewEvent: function (evt) {
        this._viewDispatcher.fire(evt);
    },
    addInteractionListener: function (listener, scope, ahead) {
        this._interactionDispatcher.add(listener, scope, ahead);
    },
    removeInteractionListener: function (listener, scope) {
        this._interactionDispatcher.remove(listener, scope);
    },
    fireInteractionEvent: function (evt) {
        this._interactionDispatcher.fire(evt);
    },
    invalidate: function (delay) {
        if (!this._invalidate) {
            this._invalidate = true;
            this.fireViewEvent({ kind: 'invalidate' });
            _twaver.callLater(this.validate, this, null, delay);
        }
    },
    validate: function () {
        if (!this._invalidate) {
            return;
        }
        this._invalidate = false;
        if (!isNodejs && this._view.offsetWidth === 0 && this._view.offsetHeight === 0 && this._reinvalidateCount !== null) {
            if (this._reinvalidateCount === undefined) {
                this._reinvalidateCount = 100;
            }
            if (this._reinvalidateCount > 0) {
                this._reinvalidateCount--;
            } else {
                this._reinvalidateCount = null;
            }
            this.invalidate();
        } else {
            this._isValidating = true;
            this.fireViewEvent({ kind: 'validateStart' });
            this.validateImpl();
            this.fireViewEvent({ kind: 'validateEnd' });
            delete this._isValidating;
        }
    }
});

twaver.controls.View = function () {
    twaver.controls.View.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.controls.View', twaver.controls.ViewBase, {
    _zoom: 1,
    _maxZoom: $Defaults.ZOOM_MAX,
    _minZoom: $Defaults.ZOOM_MIN,
    getRootDiv: function () {
        return this._rootDiv;
    },
    isValidEvent: function (e) {
        return $html.isValidEvent(this._view, e);
    },
    getAlarmFillColor: function (data) {
        if (data.IElement) {
            var severity = data.getAlarmState().getHighestNewAlarmSeverity();
            if (severity) {
                return severity.color;
            }
        }
        return null;
    },
    getInnerColor: function (data) {
        if (data.IElement) {
            var severity = data.getAlarmState().getHighestNativeAlarmSeverity();
            if (severity) {
                return severity.color;
            }
            return data.getStyle('inner.color');
        }
        return null;
    },
    getOuterColor: function (data) {
        if (data.IElement) {
            var severity = data.getAlarmState().getPropagateSeverity();
            if (severity) {
                return severity.color;
            }
            return data.getStyle('outer.color');
        }
        return null;
    },
    zoomOverview: function (animate) {
        var value = Math.min(this._view.clientWidth / this._viewRect.width, this._view.clientHeight / this._viewRect.height);
        this.setZoom(value, animate);
    },
    getLogicalPoint: function (e) {
        return $html.getLogicalPoint(this._view, e, this.getZoom(), this._rootDiv);
    },
    centerByLogicalPoint: function (x, y, animate) {
        if (animate) {
            twaver.animate.AnimateManager.endAnimate();
        }
        var scrollableWidth = this._view.scrollWidth - this._view.clientWidth;
        var scrollableHeight = this._view.scrollHeight - this._view.clientHeight;
        var horizontalOffset = (x - this._view.clientWidth / this._zoom / 2) * this._zoom;
        var verticalOffset = (y - this._view.clientHeight / this._zoom / 2) * this._zoom;
        if (horizontalOffset < 0) {
            horizontalOffset = 0;
        }
        if (verticalOffset < 0) {
            verticalOffset = 0;
        }
        if (horizontalOffset > scrollableWidth) {
            horizontalOffset = scrollableWidth;
        }
        if (verticalOffset > scrollableHeight) {
            verticalOffset = scrollableHeight;
        }

        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateScrollPosition(this._view, horizontalOffset, verticalOffset));
        } else {
            this._view.scrollLeft = horizontalOffset;
            this._view.scrollTop = verticalOffset;
        }
    },
    panByOffset: function (xoffset, yoffset) {
        xoffset *= this.getZoom();
        yoffset *= this.getZoom();
        var newHorizontalOffset = this._view.scrollLeft + xoffset;
        var newVerticalOffset = this._view.scrollTop + yoffset;
        var scrollableWidth = this._view.scrollWidth - this._view.clientWidth;
        var scrollableHeight = this._view.scrollHeight - this._view.clientHeight;
        if (newHorizontalOffset < 0) {
            newHorizontalOffset = 0;
        }
        if (newHorizontalOffset > scrollableWidth) {
            newHorizontalOffset = scrollableWidth;
        }
        if (newVerticalOffset < 0) {
            newVerticalOffset = 0;
        }
        if (newVerticalOffset > scrollableHeight) {
            newVerticalOffset = scrollableHeight;
        }

        var result = {
            x: (newHorizontalOffset - this._view.scrollLeft) / this.getZoom(),
            y: (newVerticalOffset - this._view.scrollTop) / this.getZoom()
        };
        this._view.scrollLeft = newHorizontalOffset;
        this._view.scrollTop = newVerticalOffset;

        return result;
    },
    getMaxZoom: function () {
        return this._maxZoom;
    },
    setMaxZoom: function (value) {
        if (value < 0) {
            return;
        }
        var oldValue = this._maxZoom;
        this._maxZoom = value;
        this.firePropertyChange('maxZoom', oldValue, value);
        if (this.getZoom() > value) {
            this.setZoom(value);
        }
    },
    getMinZoom: function () {
        return this._minZoom;
    },
    setMinZoom: function (value) {
        if (value < 0) {
            return;
        }
        var oldValue = this._minZoom;
        this._minZoom = value;
        this.firePropertyChange('minZoom', oldValue, value);
        if (this.getZoom() < value) {
            this.setZoom(value, false);
        }
    },
    getZoom: function () {
        return this._zoom;
    },
    onZoomChanged: function (oldZoom, newZoom) {},
    zoomIn: function (animate) {
        this.setZoom(this._zoom * $Defaults.ZOOM_INCREMENT, animate);
    },
    zoomOut: function (animate) {
        this.setZoom(this._zoom / $Defaults.ZOOM_INCREMENT, animate);
    },
    zoomReset: function (animate) {
        this.setZoom(1, animate);
    },

    checkZoom: function (value) {
        if (value < this._minZoom) {
            value = this._minZoom;
        }
        if (value > this._maxZoom) {
            value = this._maxZoom;
        }
        return value;
    },

    setZoom: function (value, animate) {
        if (!_twaver.num(value) || value <= 0) {
            return;
        }
        value = this.checkZoom(value);
        if (value === this._zoom) {
            return;
        }
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateZoom(this, value));
        } else {
            var oldCenterX = (this._view.scrollLeft + this._view.clientWidth / 2) / this._zoom;
            var oldCenterY = (this._view.scrollTop + this._view.clientHeight / 2) / this._zoom;
            var oldZoom = this._zoom;
            this._zoom = value;
            $html.setZoom(this._rootDiv, value);
            this.firePropertyChange('zoom', oldZoom, value);
            this.onZoomChanged(oldZoom, value);
            this.centerByLogicalPoint(oldCenterX, oldCenterY, false);
        }
    },
    //setTouchZoom
    setTouchZoom: function (z) {
        this.setZoom(z, false);
    }
});
(function () {
    var r = function (name, width, height, src) {
        var img = new Image();
        img.src = src;
        twaver.Util.registerImage(name, img, width, height);
    }

    r('subnetwork_image', 64, 46, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAuCAYAAACYlx/0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAB1JJREFUeNrkWmtQk1cafr4vUQhEiNeBpkWwXitCqK1WaiU4tCMjlmCnrU4rmE4v2v1Rmf7q7M6is/uj7e4OurMz7fSyiXXVddsasBa0xQawoqiFFPBWJATkVpQSLPdLTt/zkTCgSHVNuISXeZLvnC8JeZ7zvu8578kBRs/UhB0EE6GZwIaBmbCToIEXWSjBcAfCI4GLoZ3QzIX+0RwgpYnUsPT0dGY2m5nDwYagqKiYGQwGlpiYeKsQJvoc1UQjriKYCYwjJiaG5eScYN09fXeF8qsVLDk5hbneT2gWJkpYyARBJQpCMYFNV6nYRx9/wtq7uv8vnD57jkVGRjL+WYRmgsYDg+U+U0ydoiJvNpPjagICA2E6moVlERH39Zkt9hboEuJxobSUN+2iKMR2dPdYxkSAQD+FhoJSxxiLAY9LNsgtBeS6+qYFBuC/piNYGr7MLV/yZksLXkx6FpfKynjTRiJEtbR32EdFgNmB01REeAdjSHFm9N8146Ev8fgTq9zqqr/evImN8XGoq6nhzd1Nv7amelwA9awZOsrQBjizsHLaNCxf8YSEhUseue0L/nT5IgICArAp5RWP5Jeis2fwxpbN0jX3gtobv1g8IkCYOkjFiDiNvI63gx5QQ7/tD1i9Ng5KZcCYJtl3095BdqaJf3NjVX2j3u0CLA4LUTkcDjNzxvfLr24jbIdDmpLH3q7X1yMlKb5/xpGJSTwxOm9ZLldW2+9LgIhF8/vJ05zr76/EO399H0siHh1vawykvf0mSi1Fw9220/1cQRDyCBklV67a7kmA5eFLTNzt/ZVK/Ond3VCHPjwu1xqWwlM4lvnFQLvKehVtra23kyMRKFfsOVdyMfd3BYheHrmV3J4nPPz57/9CcEgoxqsRMdBADbRFQaQ+4HJZCWqrrDhtzkG1zTr49UZC6qnzxfZhBVj75EqVo89RybN9/MZNWLvhuYldg5AaDTVVOPnNURTmmwfCQxTF2O8KCi23CbBO+xQVLSxt+szZSP3LP9DrcHhFGSrQX431CrI/34+6a1VOcUR9tjnfOESAxHVxvD5XPbtZjwWRj8HbzNHTjexDeylELM41hBhlyvpGagibdBv40tYUOGMmknf8ET19ffBGk4si8r76H0rPF0rhIJPJww4czrDLfXx9+bqeprsodHR1w1utF31YGZeAlqYbaGyo4yvbdIJe2KZPLuZbUNoNz2O6ei683dqbfsbxz/e5QiFMrlD4SSs+1aw5cHhJ8hvJlLOCMG/hYtRfq+YZ8C25r59CujHVz9+rQ8Bl3TTIcxeHo7npOp8BtHI/Ig7XBhzDpDDV7GA4eWvkhn37pc650esmRQg4Yx8u3nJrZaV00dbZjclkLt5yV0e1tRwPjtPix6PrA14+0rO2zlaBkHkLJgXpcloROqtAO/eAPC5AydkCPBkXPykE4FydlivnNTOpkVZCNXZXZwf8/JXevRBqa8UZ83EqoQU+8+2V0UODzxS5TibKgnx8fLAoQiOVk96KzH2foOJCKWSiYOvpc2yXkuAUuXwP3TaczMrA07oXoPBSL+Be/n1WJqbK5TT6LLWzpxcyaXXU22tRKnx1zNEbdL2uBo89tVZyEW9CXVUFDO/vAnHkW+pGe1vHe0O2xIJUARpBFHlhhKSt27AmYaPXjHz+14dhMnzY32Ast765JdZ1T+a6aO3sapih9K+Sy2S68pIizJwTBHXo/Akd7/XVVhz453sozMmmmBe5Jxhrm5qTht0Uddl8dbCB3ruVX6+O1yFhy2sTbsQvnj+D77MzYb1UMtDHHCz1al3D7mE3RW+1R8JC0klBfpwFwSFhWP/yqwijCmpckCsqRENVJYLnhsGXCprO9jbUU7ujvRUN1ZVEumzI6xljRsKuS7ZrtuH3De9gkQvn6URBHPhdMJQEWPVMAhZHrRgz8vYbjfgg7W2J9EhGGd5GDxlEfM+P5VbbyBunI9jjSxepyBO4N2wd3B+6aCkio7USRss6O9rw2d92oqF/IG1E7lZiedTH9/1zz124ctc/mt7V+YBoTXgoifAWQUcIdfVvSNmOiFVrRkWAr/Z+iJLTeZIjUNkedaq41OaOz73nEyKxK5drnGJIXrF+y+tYtnK1B0e+HSe+3I/SMyelNidvLvxhbE6IDLb4mGiDS4SlK1YjVrcZvgo/t5JvrK3GsYOfSs/95Jn+WH6B0Z3/477OCCU+rd1JIqTx68AZs6DVbcKCcI0bRr0DRfnfouD4kYH8RyMfeyQnz+JuD7vvQ1LPr39GSyIYXLlhzgMP4dE1cZIQ9+oRLb/cQNm5Avxw8gS6yPWd01gukdd/kfWtzRMh5pZTYi/p1vPZYoczNwwcapxPIoQ8vFASZY76IRJEMeR9P9fWSESvVfyE8rJiNNbVDJ6/eabf9R/TUSM8aG49Jqd/IUkliiIXImXwbHEvRqQtNOJ7/n3osEeJe0SAwbY9ebOGxOBnjGKcYtxJEAsnTfiRkPHBZwdtGEX7TYABAPgBTYK366ChAAAAAElFTkSuQmCC');
    r('bus_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAINJREFUeNqkU0EOgCAMo2Y/1P8Y/6NvnBADwTnGzHYiGetKW8DMKVJLChbVAwCNCrrzp5/Zg/4MaH0JMBOEh08o6OtxtgvXvkFuV/vFBeGEm0WZo8GgF+QlIkI2OrZq5WLAFjuy4DvVWXHl2VodyElMjkxAJNFm4EjmFGAqLKLf+RZgAKkFNRwzv7gHAAAAAElFTkSuQmCC');
    r('data_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAMZJREFUeNqkU8ENwjAM9KEwWwaAKVA3iMQDtRtUTAEDdLZWMkkhIUljU4n7RInP9p3dgoiYBAzDgHAyfykA1rtzbr2bmpDDk5uBvu+ROO98pvs4FqRL10nCogokBS3UBaXCZg9JQ7JQY5qmZoK1trCQCuQJnoS9CsQZHKsNcOyWvS1ehdGqz8xyZ0BXEHG+PTdvj+uJkFsASsusdN5sQSKHGWgWfDxY1GcQfEIYIn4p+HuN+SqXRtL8+ZAOinwm5V+P8ZcAAwC0T1T5kpEqewAAAABJRU5ErkJggg==');
    r('databox_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwMjI+N/BiIBUD0jMp8FpDm4cQ2DvYEiw8EL9/FqBqkBqUc3BGT7/0kbz/6HsXHhS/eewtWBXA7CYAMOX75PlCEgA9ANYYQaADbJVleRAShJ0Csw7+T5G2MaQCpgQReAuQAWqPhokAuYGCgEowZQwwBQuiYn/mGAEZaeYTkSlA6IBeCUCDMA2RBSsjZAgAEAOyp6/CYHWkwAAAAASUVORK5CYII=');
    r('grid_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAFdJREFUeNpi/P//PwMlgImBQsACIhgZGUl2BtDljCguAHkFhIMb1xBkU9ULjCATQV4A2UAsWFsfAvcCzEn/YQBoEEE2VD1Y76gXhpcXyM0LjJRmZ4AAAwCoyOJjz29PsAAAAABJRU5ErkJggg==');
    r('group_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAOFJREFUeNqUUwsOwjAILa67i2fwEMbEnUej55mJO4Rn8DBtglAh6YfOSdJkBfregwEgottiHiAlQuZjh68TQRJzI5L07nSbC//zOrUAmkxAJXBP2VgxRjpDK818z06gZIwrfSACF0iVVZrLiab7ownOl7PTV0QESsRgWqoHt80oD0fpy/BVhuZfsOpkC8LYxAkBw4YedOdDhuRny1UyZEPE334NvbZ6kBYeJGFPKFgp4HsUAqtI9u1AYipJgfQ+GjtQlPvPMkGlBHrLdFjeBeHruE+hYAxSo6C3jb4zyh8BBgBVL19PZ27iaAAAAABJRU5ErkJggg==');
    r('group_image', 32, 29, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAdCAYAAADLnm6HAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABHNJREFUeNqsV1ts21QY/uy4zc1ZnZY2bdbSLMlKxUWkaBJMgJY9gARIax/2NokVofLARWjiBYRY2QMdCGlI440H1ok3btsQ0wAxNdvKpnYdyyYK7UZHVK1L2rRZLo3j2InDOaZD60psp+WXrDjO93/nO7/PfwkDAwu0Nh8jH30wZwc6/f43X9jVJ5gBn/zueJozgaNkUXLtMwLyLt4XDG4Vtj+/B8lMQRf7QLsb079PCpzJnaVnEsmIEeiZgD/Mu5yYT4uYiWd1sW1NTlCsWQGmzC00gOd5lFQVkqLoYiuViobVBNzf3BRaCfUaUyuV2AomXI1sNrmkRUeUZBRlBXJJRVFRdQUoZVXDclvbvUeImn6j3VmAqpjg5ra0xcL2nDwdwW1JQeP2HJLLki7frVQOo+OXwNnttv5fp65vKPSvvLhHmBgf77fV10XqWBaLZPGEgYC0KIFiOYfdBoY8OH72D8QS6ZoX3x1+CFarFZSnxS1gk9OBeUJ+00BAimAolnM6nQDDEDVAHVOpWQBD/Ow2GyhPoyDHWKjYkr+GVrv+GWBmE6BYIsChRYCz0Kt2AWR92GxWUJ7TFy7GWltb9l368ZteM77lcukE53A4tC91VAC7jggwVIANd3h+OHM+Qlj2ktvQv9U0EIAkSZibm7vbNUpcIxxPQsfQV2BhwDHrE2C320F5qPnaPCMkdVel9EdDQ8iLeex/5+27H4dYljnGnRo5B1EUMT1fwI2lUs0CHs9JOD9xGeNjY9i7u9dXkKTovZgvv/j8H+y2njX+3FxiHmKhgHiGhCir1CwgKxawsLgEynP06xO0aO2sxV+rhAopm9migrRUuwCJVDMS8nXXEE2ALMtIF2UskVJaqxWIgIqqrl8ATUGFkNDaLKu174RGjzYWykO9A17P+6pa2WEqhVnmDOfmnUgmk+gN2vBsZ33NAng1DxspIpTH1+H1Pdrz2OCHn34GpaQfFYe1Dm+9+nKY62jzpIcG3xU20gukXAZtzU0Rkoo+mo6/TMZxI6E/Dzz9sFdLXc7jad6pSIW+jQho2OSKjl2djOyiAwmdB8jrLMj6Ka3emQd+Gh2jeUvTp7/aTGBgwyv+cJNm5HLx2plQSmX9AkYuiuXqOUuorKoj1RZ/7fU34PcHMLj/PSwv5/4LMsgy7EtKuTz887kLyMoq7CERi/miroD5TB4Xr/wGrsPT8omqqlV3PjAwgIYGAd9/+xVmrledG46QjhiZjs0iSYtSehk3M6KugAUigGK5rqA/rAc89MEBOJy81qq7u4LVJyYL27eYSkV50hkXxCLmDCKQIhiK5do3e3VL59TUNdrZ0N3dddTgLMQ89zX5XKQtP+m14kGB1QVv4VVMrIwCRn9M6PkAGctN1fjnwk9ddjc2hcxgb6eWov/rWE7tVGS0ZyWjfEYRoxlkVoBAIhE2gYst5vKDpVJ51QR96PBhxONxfHzw4Oo+wFl2mBFAJ1W6+IgR0OGwD2/zda4Z32/99ScpTiU80fPIvT/1/y3AAMOmtJl1Hv9IAAAAAElFTkSuQmCC');
    r('link_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHVJREFUeNqkkwEOgCAIRaEr6nlqdR49I4XTzcqUn39jE5xP1C+LCPkjCl0Kq2NC5fYgRXlMSCw0K6Xozhqaol3ckj+QVwGFNIsI5HPCCunSLZDhGUcQ0033IOb3riE1CLJty/bTVubUBqDyc+Pm01oY8NQpwAAbUwhLBQIWcAAAAABJRU5ErkJggg==');
    r('linksubnetwork_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAU5JREFUeNqUUi1Tw0AQ3cukEY0AwdlDM8XRD41ARAAi/RHoCmQ7/QNofkTQFQh8W9kOOtgiQIBImTnuXbs3udAvduZms5t9b/fdrUiHGW2z0cOdLsdJ71GU46yfUrgL/PWx8HLxsUTOI3EE98mp9ZdXie0K8HgydYXtVtN6znHsTQAwdy2DOcY/TMFytkqogqskLIf6qQhYL7q/PI8cOIoiiuO69bvIRf3o5M/YANVqIZ03GjSbz2m5/KGiKDxgp90irbUINzEz2BSQEMKSwJiEwfgONmlFR4AAhg2yV0talWNfAbfJN4s7KHcCCcBPgy7WhobdM7q9uXbd3TPyhvEOwL4/30kpRVJKwrYySZ7nWABlzpsthM49R5lzYUhAruERr/P7CdZNPJJVakUiuOgAw9jSXOyUX8f4ZkCHGzQvAGIw4v9M4E0CMEh/BRgAwM37IYxGnbkAAAAASUVORK5CYII=');
    r('node_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAGBJREFUeNpiZGBg+M9AJvj//z8jC5RBsmZGRkYwzQITCGlaS7TmNXXBcDYTA4Vg1IDBYAAjJB2Rl5DgKRGWqshyATm2o3uBgcwMBbacBZdmZJfh8CJIASMLodxGCAAEGACTAB0gDBYjygAAAABJRU5ErkJggg==');
    r('node_image', 30, 32, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAgCAYAAAAFQMh/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAO0SURBVHjavJZJaF1lGIaffzzn3pvbxAyYJulgNKJIF7WkuhEHFCy40LpRBLdFcFi4ciOCC9dmU910WbduBEEoRhFEarJw2UaLJXFImya5ubln+AcX5+YG3ZjCaT44cDb/+5zv/Ybzi7npo7Mhhi+886c5hFBaLUshX9dKq8tW2bPjExOHweXW+vpZ7/1lrZWanz52jK+//f5QwC8+8xSrN2/Oa2OM10pJgKwoWd/cRQpRKyzEyMRIk9QatFIYY7xOEou1BoD1zS6ff/kTqbW1grtZyVsvz3N8cgRrDUli0dZabB+kpGSkYdHWUGfOSkT6prLH04m1GFOBBaAkKBkQsU5wACpBYyyJtfSt1hVYVGDZf68rpNjXs1b3rU72rZaAlhFJRMj6wJUm+1bv1diYqrmEFCgJQtaf8Z6gMaaqcbPRpJGmgxprCYhYK1iL/YwbaUqz0UTneUFeusG8uRARNYPLEAn95spLR54X6K+uLDI1NQ3A7e0ey3+UtBJDnfO004vc6WRMjg3zzeIPrK2toje3O6StLWII7GYFt7qOPNS7uTo9x25WEENgY2uLze0Oem9xhOBwwZM5j3WyVnDmPC54QnAoWWlrgBgj3nuc9+yWHq3rBe+Wlbb3nhjjPhiowM7TdQ7t6rW66xzOVeBBpw/AzlM4z3bpkTVnvF1W2t79B1xZXVI4x3bpUfcE7PC+/LfVUgic80giY6lhJDG1gmUESawY/QWhG0aLxBh2dnoMqcBrpyawNWdcuMCQCuzs9EiMoWG00GPDR2QrMVxdWqIsch5L1cCOukJowerKn/x9M6GVGMaGj0hx+uEHrypjzzwwN0cI4Z7et6SU/HbtGr4sftbNVvN9a5NP1m78elpK6a0x9wRalCUhBNUeai0Xhf5ASykXh4fbbxo9+nin2y2v3/i9B3jq29YRUA+dPN5ot1qmdOXS7dvldfHIiRky5wBJt9djfePONHA/4Or6KwJ/TYzet9pqNIBAqjVianSEtY1NgCeBd4FTQBuoq+AS6AC/AAvAj1OjIzAzPoqS8pyAFQHx/x4gzs7OxosXP4ufLizEkydORA5wrv+sKCnPzYyPooFHh5vppQiTB/n8PMt47523Of/qebIsY7fT4eOPPiRJkoMcnxVwCXhOH2kPXWi3WpMH7s48J5Ql1tpq3p3j6Pj44MJ4gJgUUlwQzz5xpgMMHbhFYyRNU55+/gWC93x35Qp5niHu7q60I9545aUeoO5qPkJAqupICOFuoQD+nwEAIKWd899qAZAAAAAASUVORK5CYII=');
    r('shapelink_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIJJREFUeNqkUwsOgCAIxeYN5Ty1Og+ekUarzRwQ5tsYDpTPExIzgwY86uWgtSTwIAF6KTvxg/sMliwwCy27mEVr2Xu7+TjaWm4JqxvKpW/iWowQprX2i8RXhS0xXv+WL0xiKIAVxKssa/0hEMuPiB4epNFxnh7lZG1jdCPdABGcAgwAc06H0rgwLSIAAAAASUVORK5CYII=');
    r('shapenode_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAI9JREFUeNq0UtsNgDAILI0jdZN2Ho3O027SnRA+MNb0QTWS8EPuLncAIKL5UvY5CEdC7h7pjrEtEABgqwucRCBFk7aAfo9uZJtwmXhQCLDyLJlrkSxaMuGgu8QZ8hVhYD8LVgZx9fMO1H9QKXbm+EJvBYwsuSYyFaEmUvyBUkQWCYUDfg5NV8/49xW6dQowAIJydCoPajIHAAAAAElFTkSuQmCC');
    r('shapesubnetwork_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAATBJREFUeNpiDG5cw4ALbO/L+I/M9yyawYjMX1MXzMCCT/PXD69RxLgFREFiKIbADSjzlAfTjq6eYFtBmk+dPgNXaGZqAqZhYjA+igtAmmG2ImuG8UFyIFfAvIPTC+ia0Q2BeYehLpiRCeZfkO37d2/HqRmX4Yxc/CJwZ9+6fYeBEPjw4QOYNjczZfj//z8j3AuMjIjAvXnrNoomdTVVFDkonxEjEIEmgg1C1oAuhw5YQKEZGhHzH9kVbcuPoiiqirSGy5UUF8FtBwFwIK5esYQRaIMfyE/Y/A0yEGbopk2b/FACEeQ0mO1Ati+UvQndFciuAVkG5W5GMQDqV1+QAci2oxuAFC5+4MCBGQIzAEKBBbFimBxILc7MhOQiPzTxTcixwYhsOxLwRWJvxicHEGAAkPKxzyGuYWgAAAAASUVORK5CYII=');
    r('subnetwork_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAOJJREFUeNqkUjsOwjAMzavSBQYY4FDM7SGYOUARHICZQ5SBiUPBAAMLIJk8aFASkoDgSVFlu/68Z6NatCqF3Woqrj2ZreHabVMpnUs+H/eerz8c0+cV0amuTK6XG69bDEWsa5hM0KafU/DZeJRCmBwWsXRUUwEU0Y5tRFLfgHRMARYDeoPRSyy383Zee0nsgO5rcROBzo19FUlOoYG0Bp/0IAW7y4LHQT5GB/UL4F6ie3mX0yFLoTQUTByQxE8lQ51wMRHx1Chd4FtkReQUj3VFktj97ZSDNYkK9h6L/03hLsAAjRx4oMVjqkMAAAAASUVORK5CYII=');

    r = function (name, width, height, src) {
        twaver.Util.registerImage(name, src, width, height);
    }

    r('expand_icon', 16, 18, 'data:image/gif;base64,R0lGODlhEAASAIcAADFKY0L/QpSlvZylvZytxqW11qm92r3GxrnK5MbGxsbW69jh8efv9+vz/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAAQABIAAAhfAAMIHEiwoMGDCBMqXMjQ4AICEAcMECDgwEECDjJmbMAAwEWNDjgi8GgQ40YGCwyQLDjAAYCXL1UeFBAS5QIFBVYSFMBxwU0EOWcyUIDAQIGjOgcegMnUYsOnUKMiDAgAOw==');
    r('collapse_icon', 16, 18, 'data:image/gif;base64,R0lGODlhEAASAIcAADFKY0L/QpSlvZylvZytxqW11qm92r3GxrXI48bGxsbS59Te8efv9+vz/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAEALAAAAAAQABIAAAhhAAMIHEiwoMGDCBMqXMjQ4AICEAcMECDgwEECDjJmbMAAwEWNADgq8GgQY0YADBYYIFlwgAMAMGGuPCjAAUcACxQUYElQAMcFABQg2EmTgVADBZLyHHggplOLDaNKnYowIAA7');
    r('close_icon', 11, 11, 'data:image/gif;base64,R0lGODlhCwALAIcAAHd3d319fUD/QIODg4iIiI6Ojq6urri4uNnZ2eHh4eTk5Ofn5/Dw8PT09Pj4+Pn5+fz8/P39/f///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAMAAAIALAAAAAALAAsAAAhdAAUIOECw4AGBAyUoXCjh4AEJDBA4mIiAQcMDERAUKOBgI4IIBCE0IECSZAMIBB8wYDCg5coHBBkkCECTZgIGMQ0AAKBgpwGcBxgsMLCgKFGcA1cqXXlQoMGCAgMCADs=');

    r('sort_desc', 9, 5, 'data:image/gif;base64,R0lGODlhCQAFAJECAImJiezs7P///wAAACH5BAEAAAIALAAAAAAJAAUAAAIMDI4QYrnC0INxUnYLADs=');
    r('sort_asc', 9, 5, 'data:image/gif;base64,R0lGODlhCQAFAJECAImJiezs7P///wAAACH5BAEAAAIALAAAAAAJAAUAAAIMlAWnwIrcDJwi2HsLADs=');

    r('submenu_enable_icon', 8, 8, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAA7SURBVHjafI9BDgAgDMKqH3c/ryd1iTqOpARARQUYJG0/AWboB2yoAgTG8jtvtXvMSUdVEdXIeN2cAwDPLmAjfDYS7AAAAABJRU5ErkJggg==');
    r('submenu_disable_icon', 8, 8, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAABKSURBVHjafM9BDoAgDETRD1cTz0W9luDZxhUBCjpJkzZ9m0ESkrhLzW0fJ9JjpT4Zl+juBXmwoB0ACH/gOtNhX2B6AjDUtF3NdwAU6zx4LEQe5AAAAABJRU5ErkJggg==');
    
    r('checkbox_selected_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAflJREFUeNqkk09oE1EQxn+7btyIYBRCbayFtlhEtLeAin+KouDNo548eJHCQkFQC1K0Bw8VqT1EVIqo0IMUvejNg6AIIglSsdSCiA0WolaIOWi3+2fGw242CRFBHPjg8d7MfPO+mTEcxzkNDAF5/s1KwE0cxylWKhX1fV89r44gget6bVhd9bRcLqvjOEULyGezWTwvAMAwjIRCRAnD8I/0nZ05gLwZOTYeVBXQOIGgqgk+flrk3MUxVBWRyMeMw5oCG2eREFVBVZibf8+x4ydZLH9GVRISq5W5uXwhDKPSvnz9xolTZ/A29GNZFiJ1kjhBnVFVEw0a7MrQ8HlqbMZwXeYXlpL7ti/Usbz8Hd8PEBGmHzxk9kMVfI+BrWt4PHM/0abtC67r8vTZC4qlWY4c2s/Azh2MTxQwpIPduzZx99Z1bNtu1yBiFp6/fMXr4ht+/NzI+MQNBg/sxdccPbmAqcI1UqkUEresTQMR5ejhQbb19XJ25BJzC8Lbd3dIp22mCtPY9tokuDmB2VyBqtDb082VyxdYv26JXysrTF4dY0uuI3lvoKWCaOoMA1SF7q4u7t2eZObREw7u25MMTbPF8VGCqHNRB4IgQFXY3t/H6MhwLFirGYZBfeItoFSr1fKZTAbVaPbT6fRf19A0TarVKkDJ+N91/j0A8Y5o3Yt7KRAAAAAASUVORK5CYII=');
    r('checkbox_unselected_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAiUlEQVR42qXM3QYFIRiF4d3dJpIhI5FKJCOSSHe7f9gn4ztZo3Wwzt6HvTbHfhdCeD8Nvw27Ad57OI4xUsA5BwMpJQpYa2Eg50wBYwwMlFIocJ4nDFzXRQGtNQzUWilwHAcMtNYooJSCgd47BaSUMDDGoIAQAgbmnBTgnMPAWosCcP3fDdjZNvABvRhVEQglsV8AAAAASUVORK5CYII=');
    r('radiobutton_selected_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAXFJREFUeNrUUz9rwkAUv0syBVxMm01L2lIdilOg4BcQ7eKcIV/AqZAxo1/B2a/QoSSTH6AQCoFMJUSig5C0EiPEv8G+Z604eJNTHxz37vf73Y977+7obrcjlwRHLoyLDYTThWmav6AgKDA9wrg6UF8wvO12O8RFt9s9bwACwvP8U6lUajWbzbYsy/eIR1Hk27b9GgSBlef5O7OEzWZzC5ufNU17gc01gEQcmCOGHGqYJaxWq1qj0WhzHFfwfZ84jrPHVVUliqIUkPM87wOg4KzBcrm8liTpbr1ek8FgQNI03eOz2Yzouk6QQw3zBFmWUewDxnQ6JUmSHHsDRz9qmD0A8ns8HgcortfrRxxzxJBDDfMEi8XC7ff7b4Zh3FSr1UKlUtnjlFI0mCOHGqZBHMd+GIbWZDIROp1OCxqH74HA9Q17vZ7luq4liqJ/uoee/oVyufxX/wPctwqpfKAieB9OsVj8xMVoNDpv8D8/048AAwDskrF8QGeJUgAAAABJRU5ErkJggg==');
    r('radiobutton_unselected_icon', 16, 16, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAATVJREFUeNrUU71qhEAQ9q8S0mhip3C5kCpcFcgjiJfmal/BKr2lr2DtK1wR9BkCaYRUQTzUQtDE5sB/MTOJAQs3jVUGhp2Z75vPnV2XHseRWmMMtdJWC3DzxDTNnyLHbWC5A7+coA/wt77vT5hYlrUsAASKZdkHWZb3mqYdJEm6wXqWZYHneccwDN1hGF6II3Rddw3Nj7quP0HzDko8OsZYQww5RIGmaXaqqh4YhrnA3cwda4ghh3gGdV1fiaK4bdt28cAQQw5RoCxLGr/2lyGHOAKAn0mShDAnteSIIYcoUFWV7zjOM5DPuJPfxik+I4Yc4gh5ngdRFLlpmnKGYew3YFiH6zvZtu36vu/yPB/Me+j5W1AU5XstiuIW7vseQmmCMvg/XgVBeMckjuNlgf/5mL4EGAAhHbltcqEYDQAAAABJRU5ErkJggg==');
    r('right_expand_icon', 6, 11, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAALCAYAAABcUvyWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZBRTFFQjJGQjA1MTFFNUE5M0NCMDAwMTJBRUZCNjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZBRTFFQjNGQjA1MTFFNUE5M0NCMDAwMTJBRUZCNjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCMzYzQTE5MUZBRkYxMUU1QTkzQ0IwMDAxMkFFRkI2OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCMzYzQTE5MkZBRkYxMUU1QTkzQ0IwMDAxMkFFRkI2OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqPQWR4AAABJSURBVHjaYvT08vrPwMAgCsQM27ZufcMABUxQ+jWI8PL2FkGXwJBElkCRRJeAS2KTAEvikhDFJiGKzSi4f5iwCSLrwPA5QIABAAmgFhOOHdKvAAAAAElFTkSuQmCC');
    r('left_expand_icon', 6, 11, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAALCAYAAABcUvyWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N0ZBRTFFQjZGQjA1MTFFNUE5M0NCMDAwMTJBRUZCNjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6N0ZBRTFFQjdGQjA1MTFFNUE5M0NCMDAwMTJBRUZCNjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo3RkFFMUVCNEZCMDUxMUU1QTkzQ0IwMDAxMkFFRkI2OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3RkFFMUVCNUZCMDUxMUU1QTkzQ0IwMDAxMkFFRkI2OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmpWGHAAAABISURBVHjaYvz//z8DDHh5e4tAma+ZsAmCCCZsgiDAfOr0aQxBuA50QZgEhiBMQhSXBAM2SaZtW7e+wSYJ1oFNEu5BdEmAAAMAvV8Xc/cw3YgAAAAASUVORK5CYII=');
    r('up_expand_icon', 11, 6, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAGCAYAAAAVMmT4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjM2M0ExOEZGQUZGMTFFNUE5M0NCMDAwMTJBRUZCNjkiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjM2M0ExOTBGQUZGMTFFNUE5M0NCMDAwMTJBRUZCNjkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpCMzYzQTE4REZBRkYxMUU1QTkzQ0IwMDAxMkFFRkI2OSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpCMzYzQTE4RUZBRkYxMUU1QTkzQ0IwMDAxMkFFRkI2OSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PnCNygcAAABGSURBVHjaYvz//z8DDHh5e4tAma+BWBTE2LZ16xuYPBMOhXAaSRyiGItCBmwaGD29vHApRAaiyM7ApxAuz0SEQrgGgAADALOxFSETkKKwAAAAAElFTkSuQmCC');
    r('down_expand_icon', 11, 6, 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAGCAYAAAAVMmT4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA0xpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDY3IDc5LjE1Nzc0NywgMjAxNS8wMy8zMC0yMzo0MDo0MiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QjM2M0ExOENGQUZGMTFFNUE5M0NCMDAwMTJBRUZCNjkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QjM2M0ExOEJGQUZGMTFFNUE5M0NCMDAwMTJBRUZCNjkiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjQ5ZTRmZmE2LTQzNmYtMTE3OS04NThhLTk1ZGZjOWRiNmNiOCIgc3RSZWY6ZG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjQ5ZTRmZmE2LTQzNmYtMTE3OS04NThhLTk1ZGZjOWRiNmNiOCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PtPgXX8AAAA7SURBVHjaYvH08vrPQCRgAmJRItWKMsEYhBSCTd62desbAhrA4iB1TDAGDg2iyPIwZ2DTIIomzgAQYAAmahUFv1Iq6AAAAABJRU5ErkJggg==');

})();

$extend.__tree = function (p, o) {
    p._rootVisible = true;
    p._initTree = function (dataBox) {
        this._rootData = null;
        this._expandMap = {};
        this._levelMap = {};
    };
    p.validateModel = function () {
        this._rowDatas.clear();
        this._levelMap = {};
        this._dataRowMap = {};

        this._currentLevel = 0;
        if (this._rootData) {
            if (this._rootVisible) {
                if (this.isVisible(this._rootData)) {
                    this._buildData(this._rootData);
                }
            } else {
                this._buildChildren(this._rootData);
            }
        } else {
            this._buildChildren();
        }
        delete this._currentLevel;
    };
    p._buildData = function (data) {
        this._dataRowMap[data.getId()] = this._rowDatas.size();
        this._rowDatas.add(data);
        this._levelMap[data.getId()] = this._currentLevel;
        if (this.isExpanded(data)) {
            this._currentLevel++;
            this._buildChildren(data);
            this._currentLevel--;
        }
    };
    p._buildChildren = function (parent) {
        var children = parent ? parent.getChildren() : this._box.getRoots();
        var sortFunc = this.getCurrentSortFunction();
        if (sortFunc && this.isChildrenSortable(parent)) {
            children.toList(this.isVisible, this).sort(sortFunc).forEach(function (data) {
                this._buildData(data);
            }, this);
        } else {
            children.forEach(function (data) {
                if (this.isVisible(data)) {
                    this._buildData(data);
                }
            }, this);
        }
    };
    p.getLevel = function (data) {
        return this._levelMap[data.getId()];
    };
    p.getToggleImage = function (data) {
        if (data.getChildrenSize() > 0) {
            return this.isExpanded(data) ? this._expandIcon : this._collapseIcon;
        }
        return null;
    };
    p.isCheckable = function (data) {
        return this.isCheckMode();
    };
    p.isCheckMode = function () {
        return $extend.__tree._checkMap[this._checkMode] === 1;
    };
    p.isChildrenSortable = function (parent) {
        return true;
    };
    p.handleDataBoxChange = function (e) {
        if (e.kind === 'remove') {
            delete this._expandMap[e.data.getId()];
        }
        else if (e.kind === 'clear') {
            this._expandMap = {};
        }
        this.invalidateModel();
    };
    p.isExpanded = function (data) {
        return this._expandMap[data.getId()] === 1;
    };
    p.expand = function (data) {
        if (this.isExpanded(data)) {
            return;
        }
        var parent = data.getParent();
        while (parent != null && parent !== this._rootData) {
            this._expandMap[parent.getId()] = 1;
            parent = parent.getParent();
        }
        this._expandMap[data.getId()] = 1;
        this.invalidateModel();
    };
    p.collapse = function (data) {
        if (!this.isExpanded(data)) {
            return;
        }
        delete this._expandMap[data.getId()];
        this.invalidateModel();
    };
    p.expandAll = function () {
        this._box.forEach(function (data) {
            this._expandMap[data.getId()] = 1;
        }, this);
        this.invalidateModel();
    };
    p.collapseAll = function () {
        this._expandMap = {};
        this.invalidateModel();
    };
    p._handleClick = function (e) {
        if (this.isFocusOnClick()) {
            twaver.Util.setFocus(this._view);
        }
        if (this._isValidating) {
            return;
        }
        var data;
        if (e.target._expandData && (!e.target.ableExpand) ) {
            data = e.target._expandData;
            if (this.isExpanded(data)) {
                this.collapse(data);
                this.fireInteractionEvent({ kind: 'collapse', data: data });
            } else {
                this.expand(data);
                this.fireInteractionEvent({ kind: 'expand', data: data });
            }
        } else if (e.target._selectData || e.target.parentNode._selectData) {
            this._handlePressSelection(e.target._selectData || e.target.parentNode._selectData, e);
            if (this.isCheckMode()) {
                var row = this.getRowIndexAt(e);
                if (row >= 0) {
                    this.__handleClick(e);
                }
            }
        } else if (this._treeColumn) {
            data = this.getDataAt(e);
            if (data) {
                if (this.isCheckMode()) {
                    if (!e.target._checkData) {
                        this.__handleClick(e);
                    }
                } else {
                    this._handlePressSelection(data, e);
                }
            }
        } else if (this.isCheckMode() && !e.target._checkData) {
            this.__handleClick(e);
        }
        if (this._currentEditor && !this._isCommitting) {
            this._isCommitting = true;
            this.commitEditValue(this._currentEditor._editInfo, this._currentEditor);
        }
        if (this.updateCurrentEditor) {
            var self = this;
            setTimeout(function () {
                self.updateCurrentEditor(e);
            }, 0);
        }
    };
    p.__handleClick = function (e) {
        var data = this.getDataAt(e);
        if(!data) return;
        var focusedRow = this.getRowIndexByData(data);
        if (this._focusedRow !== focusedRow) {
          var oldData = this._rowDatas.get(this._focusedRow);
          this._focusedRow = focusedRow;
          oldData && this.invalidateData(oldData);
          this.invalidateData(data);
        }
    };
    p._handleDoubleClick = function (e) {
        if (this.isFocusOnClick()) {
            twaver.Util.setFocus(this._view);
        }
        if (this._isValidating) {
            return;
        }
        var data;
        if (e.target.ableExpand && e.target._expandData ) {
            data = e.target._expandData;
            if (this.isExpanded(data)) {
                this.collapse(data);
                this.fireInteractionEvent({ kind: 'collapse', data: data });
            } else {
                this.expand(data);
                this.fireInteractionEvent({ kind: 'expand', data: data });
            }
        }
    }
    p.handleChange = function (e) {
        if (this._isCommitting || this._isCanceling || this._isValidating) {
            return;
        }
        var data = e.target._checkData;
        if (data) {
            var selected = this.isSelected(data);
            var sm = this.getSelectionModel();
            var list;
            if (this._checkMode === 'default') {
                if (selected) {
                    sm.removeSelection(data);
                } else {
                    sm.appendSelection(data);
                }
            }
            else if (this._checkMode === 'children') {
                list = new $List(data);
                list.addAll(data.getChildren());
            }
            else if (this._checkMode === 'descendant') {
                list = new $List();
                _twaver.fillDescendant(data, list);
            }
            else if (this._checkMode === 'descendantAncestor') {
                list = new $List();
                _twaver.fillDescendant(data, list);
                if (!selected) {
                    var parent = data.getParent();
                    while (parent) {
                        list.add(parent);
                        parent = parent.getParent();
                    }
                }
            }
            if (selected) {
                sm.removeSelection(list);
            } else {
                sm.appendSelection(list);
            }
        }
        if (e.target._editInfo && this.commitEditValue) {
            this._isCommitting = true;
            this.commitEditValue(e.target._editInfo, e.target);
        }
    };
    p.onLabelRendered = function (span, data, label, row, level, selected) {

    };
    p.onToggleImageRendered = function(image) {

    };
    p._renderTree = function (div, data, row, selected) {
        var level = this._levelMap[data.getId()];
        var toggleImage = this.getToggleImage(data);
        var lineType = this.getLineType();
        var indent = this._indent;
        var span = this.__spanPool.get();
        span.style.display = 'inline-block';
        span.style.position = 'relative';
        span.style.verticalAlign = 'top';
        span.style.margin = '0px 1px 0px 1px';
        span.style.width = (level+1)*indent + 'px';
        div.appendChild(span);

         // draw line
        var currentNode = data;
        var parentNode = currentNode.getParent();
        var levelsUp = 0;
        
        if(lineType === 'dotted' || lineType === 'solid'){
            if(parentNode == null){
                var icon = this.getIcon(data);
                this._addLine(span, data, icon, true);
            }
            while(parentNode !== null){
                var children = parentNode.getChildren();
                var isLast = currentNode === children.get(children.size() - 1);
                var icon = this.getIcon(currentNode);
                currentNode.setClient('isLast',isLast);
                if(levelsUp == 0){
                    this._addLine(span, data, icon, isLast);
                }
                levelsUp++;
                currentNode = parentNode;
                parentNode = parentNode.getParent();
            }
        }

        if (toggleImage) {
            var image = this.__imagePool.get();
            image.setAttribute('src', _twaver.getImageSrc(toggleImage));
            image.style.verticalAlign = 'middle';
            image._expandData = data;
            image.style.position = 'absolute';
            image.style.right = '0px';
            var that = this;
            image.onload = function(){
                image.style.top = (that.getRowHeight()/2 - image.height/2) +'px';
            }
            span.appendChild(image);
            this.onToggleImageRendered(image);
        }

        var checkable = this.isCheckable(data);
        var disabled = this.getUncheckableStyle() === 'disabled';
        if (checkable || disabled) {
            var checkBox = this._addCheckBox(div, data, selected);
            checkBox.disabled = !checkable;
        }

        var icon = this.getIcon(data);
        if (icon) {
            var selectData = this.isCheckMode() || this._treeColumn ? null : data;
            this._addIcon(div, data, icon, selectData);
        }

        var label = this.getLabel(data);
        if (label) {
            span = this.__textPool.get();
            span.style.whiteSpace = 'nowrap';
            span.style.verticalAlign = 'middle';
            span.style.padding = '1px 2px 1px 2px';
            _twaver.setText(span, label, this._treeColumn ? this._treeColumn.isInnerText() : this._innerText);
            if (toggleImage) {
                span._expandData = data;
                span.ableExpand = true;
            } 
            if (!this.isCheckMode() && !this._treeColumn) {
                span._selectData = data;
                span.style.backgroundColor = selected ? this.getSelectColor(data) : '';
            } else if (this._focusedRow === row) {
                span.style.backgroundColor = this.getSelectColor(data);
            }
            this.onLabelRendered(span, data, label, row, level, selected);
            div.appendChild(span);
            div.title = this.getToolTip(data);
        }
        
    };
};
$extend.__tree._checkMap = {
    'default': 1,
    children: 1,
    descendant: 1,
    descendantAncestor: 1
};

twaver.Column = function (id) {
    twaver.Column.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Column', twaver.Data, {
    IColumn: true,
    __property: 1,
    __accessor: ['width', 'horizontalAlign', 'valueType', 'propertyType', 'propertyName',
                 'editable', 'visible', 'sortable', 'resizable', 'movable',
                 'sortDirection', 'sortFunction', 'enumInfo'],
    __bool: ['innerText'],

    _innerText: $Defaults.COLUMN_INNER_TEXT,
    _width: $Defaults.COLUMN_WIDTH,
    _horizontalAlign: $Defaults.COLUMN_HORIZONTAL_ALIGN,
    _propertyName: null,
    _propertyType: $Defaults.COLUMN_PROPERTY_TYPE,
    _valueType: $Defaults.COLUMN_VALUE_TYPE,
    _editable: $Defaults.COLUMN_EDITABLE,
    _sortable: $Defaults.COLUMN_SORTABLE,
    _visible: $Defaults.COLUMN_VISIBLE,
    _resizable: $Defaults.COLUMN_RESIZABLE,
    _movable: $Defaults.COLUMN_MOVABLE,
    _sortDirection: 'asc', // 'desc', 'asc'
    _sortFunction: $Defaults.SORT_FUNCTION,
    _enumInfo: null, // {map:{1:'male', 2:'female'}, values:[1, 2]}  or  ['male', 'female']
    renderCell: $Defaults.COLUMN_RENDER_CELL,
    renderHeader: $Defaults.COLUMN_RENDER_HEADER,
    renderEditor: $Defaults.COLUMN_RENDER_EDITOR,

    setParent: function (parent) {
        throw 'parent not supported';
    },
    getEnumInfo:function(){
        if(typeof this._enumInfo === "object"){
            return this._enumInfo;
        }else if(typeof this._enumInfo === "function"){
            if(arguments.length === 1){
                return this._enumInfo(arguments[0]);
            }else{
                return this._enumInfo();
            }
        }
    }
});

twaver.ColumnBox = function (name) {
    twaver.ColumnBox.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.ColumnBox', twaver.DataBox, {
    _name: 'ColumnBox',

    add: function (data, index) {
        if (!data.IColumn) {
            throw "Only IColumn can be added into ColumnBox";
        }
        twaver.ColumnBox.superClass.add.apply(this, arguments);
    }
});

twaver.Property = function (id) {
    twaver.Property.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Property', twaver.Data, {
    IProperty: true,
    __property: 1,
    __accessor: ['horizontalAlign', 'valueType', 'editable',
                 'propertyType', 'propertyName', 'categoryName', 'enumInfo'],
    __bool: ['innerText'],

    _innerText: $Defaults.PROPERTY_INNER_TEXT,
    _horizontalAlign: $Defaults.PROPERTY_HORIZONTAL_ALIGN,
    _propertyName: null,
    _propertyType: $Defaults.PROPERTY_PROPERTY_TYPE,
    _valueType: $Defaults.PROPERTY_VALUE_TYPE,
    _editable: $Defaults.PROPERTY_EDITABLE,
    _categoryName: $Defaults.PROPERTY_CATEGORY_NAME,
    _enumInfo: null, // {map:{1:'male', 2:'female'}, values:[1, 2]}  or  ['male', 'female']
    renderName: $Defaults.PROPERTY_RENDER_NAME,
    renderValue: $Defaults.PROPERTY_RENDER_VALUE,
    isVisible: null, // function(data){ return visible or not}
    renderEditor: $Defaults.PROPERTY_RENDER_EDITOR,

    setParent: function (parent) {
        throw 'parent not supported';
    },
    setPropertyName: function (value) {
        var oldValue = this._propertyName;
        this._propertyName = value;
        this.firePropertyChange("propertyName", oldValue, value);
    },
    setPropertyType: function (value) {
        var oldValue = this._propertyType;
        this._propertyType = value;
        this.firePropertyChange("propertyType", oldValue, value);
    },
    getEnumInfo:function(){
        if(typeof this._enumInfo === "object"){
            return this._enumInfo;
        }else if(typeof this._enumInfo === "function"){
            if(arguments.length === 1){
                return this._enumInfo(arguments[0]);
            }else{
                return this._enumInfo();
            }
        }
    }
});

twaver.PropertyBox = function (name) {
    twaver.PropertyBox.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.PropertyBox', twaver.DataBox, {
    _name: 'PropertyBox',

    add: function (data, index) {
        if (!data.IProperty) {
            throw "Only IProperty can be added into PropertyBox";
        }
        twaver.PropertyBox.superClass.add.apply(this, arguments);
    }
});

twaver.Tab = function (id) {
    twaver.Tab.superClass.constructor.call(this, id);
};
_twaver.ext('twaver.Tab', twaver.Data, {
    ITab: true,
    __accessor: ['view', 'width', 'closable', 'resizable', 'movable', 'disabled', 'visible'],

    _icon: null,
    _width: $Defaults.TAB_WIDTH,
    _closable: $Defaults.TAB_CLOSABLE,
    _resizable: $Defaults.TAB_RESIZABLE,
    _movable: $Defaults.TAB_MOVABLE,
    _disabled: $Defaults.TAB_DISABLED,
    _visible: $Defaults.TAB_VISIBLE,

    setParent: function (parent) {
        throw 'parent not supported';
    }
});

twaver.TabBox = function (name) {
    twaver.TabBox.superClass.constructor.apply(this, arguments);
    this.getSelectionModel().setSelectionMode('singleSelection');
};
_twaver.ext('twaver.TabBox', twaver.DataBox, {
    _name: 'TabBox',

    add: function (data, index) {
        if (!data.ITab) {
            throw "Only ITab can be added into TabBox";
        }
        twaver.TabBox.superClass.add.apply(this, arguments);
    }
});

twaver.controls.ListBase = function (dataBox) {
    twaver.controls.ListBase.superClass.constructor.apply(this, arguments);
    this._invalidate = false;
    this._invalidateModel = false;
    this._invalidateDisplay = false;
    this._invalidateDatas = null;

    this._rowDatas = new $List();

    this._startRowIndex = 0;
    this._endRowIndex = 0;
    this._renderMap = {};
    this._dataRowMap = {};

    this.__divPool = new twaver.Pool('div', 20);
    this.__imagePool = new twaver.Pool('img', 20);
    this.__canvasPool = new twaver.Pool('canvas', 20);
    this.__spanPool = new twaver.Pool('span', 20);
    this.__textPool = new twaver.Pool('span', 20);
    this.__checkBoxPool = new twaver.Pool('input', 20);
    this.__linePool = new twaver.Pool('canvas', 20);

    this._pools.add(this.__divPool);
    this._pools.add(this.__linePool);
    this._pools.add(this.__imagePool);
    this._pools.add(this.__canvasPool);
    this._pools.add(this.__spanPool);
    this._pools.add(this.__textPool);
    this._pools.add(this.__checkBoxPool);

    this._view = $html.createView('auto', true);
    this._rootDiv = $html.createDiv();
    this._dataDiv = $html.createDiv();
    this._dataDiv.style.width = "1px";

    this._view.appendChild(this._rootDiv);
    this._rootDiv.appendChild(this._dataDiv);

    this.setDataBox(dataBox ? dataBox : new twaver.DataBox());

    var self = this;
    if (self.handleChange) {
        self._view.addEventListener('change', function (e) {
            self.handleChange(e);
        }, false);
    }

    if ($ua.isTouchable) {
        if ($ua.isMSTouchable) {
            new twaver.controls.ListBaseMSTouchInteraction(this);
        } else {
            new twaver.controls.ListBaseTouchInteraction(this);
            new twaver.controls.ListBaseInteraction(this);
        }
    } else {
        new twaver.controls.ListBaseInteraction(this);
    }

};
_twaver.ext('twaver.controls.ListBase', twaver.controls.View, {
    __bool: ['innerText'],
    _innerText: $Defaults.LISTBASE_INNER_TEXT,

    getDataDiv: function () {
        return this._dataDiv;
    },
    getStartRowIndex: function () {
        return this._startRowIndex;
    },
    getEndRowIndex: function () {
        return this._endRowIndex;
    },
    getRowDatas: function () {
        return this._rowDatas;
    },
    getRowIndexByData: function (data) {
        return this._dataRowMap[data.getId()];
    },
    getRowIndexById: function (id) {
        return this._dataRowMap[id];
    },
    getRowSize: function () {
        return this._rowDatas.size();
    },
    getDataBox: function () {
        return this._box;
    },
    setDataBox: function (dataBox) {
        if (!dataBox) {
            throw "DataBox can not be null";
        }
        if (this._box === dataBox) {
            return;
        }

        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataBoxChangeListener(this.handleDataBoxChange, this);
            oldValue.removeDataPropertyChangeListener(this.handlePropertyChange, this);
            oldValue.removeHierarchyChangeListener(this.handleHierarchyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = dataBox;

        this._box.addDataBoxChangeListener(this.handleDataBoxChange, this);
        this._box.addDataPropertyChangeListener(this.handlePropertyChange, this);
        this._box.addHierarchyChangeListener(this.handleHierarchyChange, this);
        if (this._selectionModel) {
            this._selectionModel._setDataBox(dataBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }

        this.invalidateModel();

        this.firePropertyChange("dataBox", oldValue, this._box);
    },
    onPropertyChanged: function (e) {
        if (e.property === 'zoom') {
            this.invalidate();
        } else {
            this.invalidateModel();
        }
    },
    invalidateModel: function () {
        if (this._invalidateModel) {
            return;
        }
        this._invalidateModel = true;
        this._invalidateDisplay = true;
        this._invalidateDatas = null;
        this.invalidate();
    },
    invalidateDisplay: function () {
        if (this._invalidateDisplay) {
            return;
        }
        this._invalidateDisplay = true;
        this._invalidateDatas = null;
        this.invalidate();
    },
    invalidateData: function (data) {
        if (this._invalidateDisplay) {
            return;
        }
        if (!this._invalidateDatas) {
            this._invalidateDatas = {};
        }
        this._invalidateDatas[data.getId()] = data;
        this.invalidate();
    },
    validateImpl: function () {
        var oldLeft = this._view.scrollLeft;
        var oldTop = this._view.scrollTop;

        if (this._invalidateModel) {
            this._invalidateModel = false;
            this.validateModel();
        }
        if (this._invalidateDisplay) {
            this._invalidateDisplay = false;
            this._renderMap = {};
            $html.release(this._dataDiv);
            this._dataDiv.style.height = this.getRowSize() * this._rowHeight + 'px';
        }
        var id;
        if (this._invalidateDatas) {
            for (id in this._invalidateDatas) {
                var render = this._renderMap[id];
                if (render) {
                    $html.release(render);
                    this._dataDiv.removeChild(render);
                    delete this._renderMap[id];
                }
            }
            this._invalidateDatas = null;
        }

        var y = this._view.scrollTop / this._zoom;
        var h = this._view.clientHeight / this._zoom;
        this._startRowIndex = Math.floor(y / this._rowHeight) - 2;
        this._endRowIndex = Math.ceil((y + h) / this._rowHeight) + 2;

        if (this._startRowIndex < 0) this._startRowIndex = 0;
        if (this._endRowIndex > this._rowDatas.size()) this._endRowIndex = this._rowDatas.size();
        var lhpx = this._rowHeight - this._rowLineWidth - 2 + 'px';
        var lwpx = this._rowLineWidth + 'px';
        for (var i = this._startRowIndex; i < this._endRowIndex; i++) {
            var data = this._rowDatas.get(i);
            id = data.getId();
            var div = this._renderMap[id];
            if (!div) {
                div = this.__divPool.get();
                var style = div.style;
                style.position = 'absolute';
                style.whiteSpace = 'nowrap';
                style.lineHeight = lhpx;
                style.top = i * this._rowHeight + 'px';
                style.borderStyle = 'solid';
                style.borderWidth = '0px';
                style.borderBottomWidth = lwpx;
                style.borderBottomColor = this._rowLineColor;
                style.opacity = data.getStyle ? data.getStyle('whole.alpha') : 1;

                this._dataDiv.appendChild(div);
                this._renderMap[id] = div;
                var selected = this.isSelected(data);
                this.renderData(div, data, i, selected);
                this.onDataRendered(div, data, i, selected);
            }
        }
        this._dataDiv.style.width = this.calculateSumWidth() + "px";
        if (this._dataDiv.style.height === "0px") {
            this._dataDiv.style.height = "1px";
        }

        _twaver.keys(this._renderMap).forEach(function (id) {
            var row = this.getRowIndexById(id);
            if (row < this._startRowIndex || row >= this._endRowIndex) {
                var render = this._renderMap[id];
                $html.release(render);
                this._dataDiv.removeChild(render);
                delete this._renderMap[id];
            }
        }, this);

        this._pools.forEach(function (pool) {
            pool.clear();
        });

        if (this._view.scrollLeft !== oldLeft) {
            this._view.scrollLeft = oldLeft;
        }
        if (this._view.scrollTop !== oldTop) {
            this._view.scrollTop = oldTop;
        }
        this.adjustRowSize();
        this.onValidated();
    },
    adjustRowSize: function () {
        var id, div;
        var hpx = this._rowHeight - this._rowLineWidth + 'px';
        var wpx = Math.floor((this._view.scrollLeft + this._view.clientWidth) / this._zoom) + 'px';
        for (id in this._renderMap) {
            div = this._renderMap[id];
            div.style.height = hpx;
            div.style.width = wpx;
        }
    },
    onValidated: function () {

    },
    onDataRendered: function (div, data, row, selected) {

    },
    calculateSumWidth: function () {
        return 0;
    },
    _addCheckBox: function (div, data, selected) {
        var checkBox = this.__checkBoxPool.get();
        checkBox.keepDefault = true;
        checkBox.type = 'checkbox';
        checkBox.style.margin = '0px 2px';
        checkBox.style.verticalAlign = 'middle';
        checkBox._checkData = data;
        checkBox.checked = selected;
        checkBox.disabled = false;
        div.appendChild(checkBox);
        return checkBox;
    },
    _addIcon: function (div, data, icon, _selectData) {
        var imageAsset = _twaver.getImageAsset(icon);
        var innerColor = this.getInnerColor(data);
        var outerColor = this.getOuterColor(data);
        var alarmColor = this.getAlarmFillColor(data);
        var c;
        if (imageAsset && imageAsset.getImage()) {
            var w = imageAsset.getWidth();
            var h = imageAsset.getHeight();
            c = this.__canvasPool.get();
            c.style.verticalAlign = 'middle';
            c.setAttribute('width', w);
            c.setAttribute('height', h);
            var g = c.getContext('2d');
            g.clearRect(0, 0, w, h);
            var rect = {
                x: 0,
                y: 0,
                width: w,
                height: h
            };
            drawImage(g, icon, innerColor, rect, data, this);
            if (outerColor) {
                g.lineWidth = 2;
                g.strokeStyle = outerColor;
                g.beginPath();
                g.rect(0, 0, w, h);
                g.closePath();
                g.stroke();
            }
            if (alarmColor) {
                g.fillStyle = $g.createRadialGradient(g, alarmColor, 'white', 1, h - 9, 8, 8, 0.75, 0.25);
                g.beginPath();
                g.arc(5, h - 5, 4, 0, Math.PI * 2, true);
                g.closePath();
                g.fill();
            }
        } else {
            c = this.__imagePool.get();
            c.style.verticalAlign = 'middle';
            c.setAttribute('src', _twaver.getImageSrc(icon));
        }
        c.style.margin = '0px 1px 0px 1px';
        c._selectData = _selectData;
        div.appendChild(c);
    },
    _addLine: function (span, data, icon, isLast) {
        var c = this.__linePool.get();
        var imageAsset = _twaver.getImageAsset(icon);
        var self = this;
        var toggleImage = this.getToggleImage(data);
        var level = this._levelMap[data.getId()];
        var indent = this._indent;
        var w, h;
        var iW = indent,
            iH = indent;
        var xoffset = 0;
        var checkable = this.isCheckable(data);
        var disabled = this.getUncheckableStyle() === 'disabled';
        xoffset = 2;

        if (imageAsset) {
            iW = imageAsset.getWidth();
            iH = imageAsset.getHeight();
        }
        w = (level + xoffset - 1) * indent + iW;
        h = this.getRowHeight();

        span.style.width = (level + xoffset - 1) * indent + iW + 'px';
        span.style.height = h + iH + 'px';

        var lineStyle = this.getLineType();
        var lineColor = this.getLineColor();
        var lineAlpha = this.getLineAlpha();
        var lineWidth = this.getLineThickness();
        var lineDash = this.getLineDash();
        var imgSrc = _twaver.getImageSrc(toggleImage);

        c.style.verticalAlign = 'top';
        c.style.margin = '0px 0px 0px 0px';
        c.style.zIndex = -1;
        c.setAttribute('width', w);
        c.setAttribute('height', h);
        var g = c.getContext('2d');
        g.lineWidth = lineWidth;
        g.strokeStyle = lineColor;
        g.globalAlpha = lineAlpha;

        if (lineStyle === 'dotted') {
            g.setLineDash(lineDash);
        }

        var t = (level + xoffset) * 2;
        if (isLast) {
            var currentNode = data;
            var parent = currentNode.getParent();
            g.clearRect(0, 0, w, h);
            var rect = {
                x: 0,
                y: 0,
                width: w,
                height: h
            };
            if (parent === null) {
                if (data.getChildrenSize() !== 0) {
                    if (this.isExpanded(data)) {
                        g.moveTo((level + xoffset + 1) * w / t, h / 2 + iH / 2);
                        g.lineTo((level + xoffset + 1) * w / t, h);
                        g.stroke();
                    }
                }
            }
            for (var i = level * 2 - 1; i >= 1; i -= 2) {
                if (currentNode.getClient('isLast')) {
                    currentNode = parent;
                    parent = currentNode.getParent();
                    if ((i + 1) / 2 != level) {
                        continue;
                    }
                } else {
                    currentNode = parent;
                    parent = currentNode.getParent();
                }

                if (i == level * 2 - 1) {
                    g.moveTo((i + xoffset) * w / t, 0);
                    g.lineTo((i + xoffset) * w / t, h / 2);
                    g.stroke();

                    g.moveTo((i + xoffset) * w / t, h / 2);
                    g.lineTo((i + xoffset + 1) * w / t, h / 2);
                    g.stroke();
                    if (data.getChildrenSize() !== 0) {
                        if (this.isExpanded(data)) {
                            g.moveTo((i + xoffset + 2) * w / t, h / 2 + iH / 2);
                            g.lineTo((i + xoffset + 2) * w / t, h);
                            g.stroke();
                        }
                    }
                } else {
                    g.moveTo((i + xoffset) * w / t, 0);
                    g.lineTo((i + xoffset) * w / t, h);
                    g.stroke();
                }
            }
        } else {
            var currentNode = data;
            var parent = currentNode.getParent();
            g.clearRect(0, 0, w, h);
            var rect = {
                x: 0,
                y: 0,
                width: w,
                height: h
            };
            for (var i = level * 2 - 1; i >= 1; i -= 2) {
                if (currentNode.getClient('isLast')) {
                    currentNode = parent;
                    parent = currentNode.getParent();
                    if ((i + 1) / 2 != level) {
                        continue;
                    }
                } else {
                    currentNode = parent;
                    parent = currentNode.getParent();
                }
                g.moveTo((i + xoffset) * w / t, 0);
                g.lineTo((i + xoffset) * w / t, h);
                g.stroke();
                if (i == level * 2 - 1) {
                    g.moveTo((i + xoffset) * w / t, h / 2);
                    g.lineTo((i + xoffset + 1) * w / t, h / 2);
                    g.stroke();
                    if (data.getChildrenSize() !== 0) {
                        if (this.isExpanded(data)) {
                            g.moveTo((i + xoffset + 2) * w / t, h / 2 + iH / 2);
                            g.lineTo((i + xoffset + 2) * w / t, h);
                            g.stroke();
                        }
                    }
                }

            }
        }
        span.appendChild(c);
        return c;
    },
    isVisible: function (data) {
        if (!this._box.contains(data)) {
            return false;
        }
        return this._visibleFunction ? this._visibleFunction(data) : true;
    },
    handleDataBoxChange: function (e) {
        this.invalidateModel();
    },
    handlePropertyChange: function (e) {
        if (e.property === 'parent') {
            this.invalidateModel();
        } else {
            this.invalidateData(e.source);
        }
    },
    handleHierarchyChange: function (e) {
        this.invalidateModel();
    },
    handleSelectionChange: function (e) {
        e.datas.forEach(function (data) {
            this.invalidateData(data);
        }, this);
        this.onSelectionChanged(e);
    },
    getRowIndexAt: function (e) {
        var point = this.getLogicalPoint(e);
        if (!point) {
            return -1;
        }
        var row = parseInt(point.y / this._rowHeight);
        return (row >= 0 && row < this._rowDatas.size()) ? row : -1;
    },
    getDataAt: function (e) {
        var row = this.getRowIndexAt(e);
        return row >= 0 ? this._rowDatas.get(row) : null;
    },
    getCurrentSortFunction: function () {
        return this._sortFunction;
    },
    validateModel: function () {
        this._rowDatas.clear();
        this._dataRowMap = {};
        this._buildChildren(this._box.getRoots());
        this._rowDatas = this._rowDatas.toList(this.isVisible, this);
        var sf = this.getCurrentSortFunction();
        if (sf) {
            this._rowDatas.sort(sf);
        }
        var size = this._rowDatas.size();
        for (var i = 0; i < size; i++) {
            this._dataRowMap[this._rowDatas.get(i).getId()] = i;
        }
    },
    _buildChildren: function (children) {
        children.forEach(function (data) {
            this._rowDatas.add(data);
            this._buildChildren(data.getChildren());
        }, this);
    },
    _handlePressSelection: function (data, e) {
        var sm = this.getSelectionModel();
        if (_twaver.isCtrlDown(e)) {
            if (sm.contains(data)) {
                sm.removeSelection(data);
            } else {
                sm.appendSelection(data);
            }
        } else if (e.shiftKey && sm.getLastData()) {
            var lastData = sm.getLastData();
            var startIndex = this.getRowIndexByData(lastData);
            var endIndex = this.getRowIndexByData(data);
            var selection = new $List();
            selection.add(this.getRowDatas().get(startIndex));
            while (startIndex !== endIndex) {
                startIndex += endIndex > startIndex ? +1 : -1;
                selection.add(this.getRowDatas().get(startIndex));
            }
            sm.setSelection(selection);
        } else {
            if (sm.size() !== 1 || !sm.contains(data)) {
                sm.setSelection(data);
            }
        }
        this.fireInteractionEvent({
            kind: e.detail === 2 ? 'doubleClick' : 'click',
            data: data
        });
    },
    _handleDoubleClick: function (e) {
        var data = this.getDataAt(e);
        this.fireInteractionEvent({
            kind: e.detail === 2 ? 'doubleClick' : 'click',
            data: data
        });
    },
    _handleClick: function (e) {
        if (this.isFocusOnClick()) {
            twaver.Util.setFocus(this._view);
        }
        var data = this.getDataAt(e);
        if (data) {
            if (this.isCheckMode() && !e.target._checkData) {
                var focusedRow = this.getRowIndexByData(data);
                if (this._focusedRow !== focusedRow) {
                    var oldData = this._rowDatas.get(this._focusedRow);
                    this._focusedRow = focusedRow;
                    oldData && this.invalidateData(oldData);
                    this.invalidateData(data);
                }
            }
            if (!this.isCheckMode()) {
                this._handlePressSelection(data, e);
            }
        }
        if (this._currentEditor) {
            this.commitEditValue(this._currentEditor._editInfo, this._currentEditor);
        }
        if (this.updateCurrentEditor) {
            var self = this;
            setTimeout(function () {
                self.updateCurrentEditor(e);
            }, 0);
        }
    },
    handleChange: function (e) {
        if (this._isCanceling || this._isValidating) {
            return;
        }
        var data = e.target._checkData;
        if (data) {
            var selected = this.isSelected(data);
            var sm = this.getSelectionModel();
            if (selected) {
                sm.removeSelection(data);
            } else {
                sm.appendSelection(data);
            }
        }
        if (e.target._editInfo && this.commitEditValue) {
            this.commitEditValue(e.target._editInfo, e.target);
        }
    },

    scrollToData: function (data) {
        if (!data) return;
        var row = this.getRowIndexById(data.getId());
        if (row < 0) {
            return;
        }
        var start = row * this._rowHeight * this._zoom;
        var end = start + this._rowHeight * this._zoom;
        var newScrollTop = this._view.scrollTop;
        if (this._view.scrollTop > start) {
            newScrollTop = start;
        }
        if (this._view.scrollTop + this._view.clientHeight < end) {
            newScrollTop = end - this._view.clientHeight;
        }
        if (this._view.scrollTop != newScrollTop) {
            this._view.scrollTop = newScrollTop;
            this.invalidate();
        }
    },
    makeVisible: function (data) {
        if (!this.isVisible(data)) {
            return;
        }
        if (this.expand) {
            this.expand(data);
        }
        _twaver.callLater(this.scrollToData, this, [data], $Defaults.CALL_LATER_DELAY * 2);
    },
    onSelectionChanged: function (e) {
        if (this._makeVisibleOnSelected) {
            if (e.kind === 'append' || e.kind === 'set' || e.kind === 'all') {
                if (this.expand) {
                    this.getSelectionModel().getSelection().forEach(function (d) {
                        if (d.getParent()) {
                            this.expand(d.getParent());
                        }
                    }, this);
                }
                _twaver.callLater(this.scrollToData, this, [this.getSelectionModel().getLastData()], $Defaults.CALL_LATER_DELAY * 2);
            }
        }
    },
    onShareSelectionModelChanged: function () {
        this.invalidateModel();
    }
});
twaver.controls.TableBase = function (dataBox) {
    this._columnBox = new twaver.ColumnBox();
    this._columnBox.addDataBoxChangeListener(this.handleColumnBoxChange, this);
    this._columnBox.addDataPropertyChangeListener(this.handleColumnPropertyChange, this);
    this._columnBox.addHierarchyChangeListener(this.handleColumnHierarchyChange, this);

    twaver.controls.TableBase.superClass.constructor.apply(this, arguments);

    this._cellPool = new twaver.Pool('div', 20);
    this._stringPool = new twaver.Pool('span', 20);
    this._booleanPool = new twaver.Pool('input', 20);
    this._colorPool = new twaver.Pool('div', 20);

    this._pools.add(this._cellPool);
    this._pools.add(this._stringPool);
    this._pools.add(this._booleanPool);
    this._pools.add(this._colorPool);
};
_twaver.ext('twaver.controls.TableBase', twaver.controls.ListBase, {
    getColumnBox: function () {
        return this._columnBox;
    },
    handleColumnBoxChange: function (e) {
        this.invalidateDisplay();
    },
    handleColumnPropertyChange: function (e) {
        if (e.source === this._sortColumn &&
            (e.property === 'sortDirection' || e.property === 'sortFunction' || e.property === 'sortable')) {
            this.invalidateModel();
        } else {
            this.invalidateDisplay();
        }
    },
    handleColumnHierarchyChange: function (e) {
        this.invalidateDisplay();
    },
    renderData: function (div, data, row, selected) {
        var columns = this._columnBox.getRoots();
        var count = columns.size();
        var sumWidth = 0;
        var hpx = this._rowHeight - this._rowLineWidth + 'px';

        var style;
        for (var i = 0; i < count; i++) {
            var column = columns.get(i);
            var width = column.getWidth();
            if (width < 0) width = 0;
            var columnLineWidth = Math.min(this._columnLineWidth, width);

            if (column.isVisible()) {
                var cell = this._cellPool.get();
                style = cell.style;
                style.position = 'absolute';
                style.whiteSpace = 'nowrap';
                style.verticalAlign = 'middle';
                style.textAlign = column.getHorizontalAlign();
                style.overflow = 'hidden';
                style.textOverflow = 'ellipsis';
                style.left = sumWidth + 'px';
                style.width = width - columnLineWidth + 'px';
                style.height = hpx;

                style.borderStyle = 'solid';
                style.borderWidth = '0px';
                style.borderRightWidth = columnLineWidth + 'px';
                style.borderRightColor = this._columnLineColor;
                
                if (i === 0) {
                    style.borderLeftWidth = columnLineWidth + 'px';
                    style.borderLeftColor = this._columnLineColor;
                } else {
                    style.borderLeftWidth = '0px';
                }

                div.appendChild(cell);
                var params = {
                    data: data,
                    value: this.getValue(data, column),
                    div: cell,
                    view: this,
                    column: column,
                    rowIndex: row,
                    selected: selected
                }
                this.renderCell(params);
                this.onCellRendered(params);
                sumWidth += width;
            }
        }

        style = div.style;
        style.width = sumWidth + 'px';
        style.height = hpx;
        style.backgroundColor = ((this.isCheckMode() && this._focusedRow === row) || (!this.isCheckMode() && selected)) ? this.getSelectColor(data) : '';

    },
    adjustRowSize: function () {
        // already done when rendering data
    },
    onCellRendered: function (params) {

    },
    calculateSumWidth:function(){
      var columns = this._columnBox.getRoots();
      var count = columns.size();
      var sumWidth = 0;
      for (var i = 0; i < count; i++) {
        var column = columns.get(i);
        var width = column.getWidth();
        if (width < 0) width = 0;
        sumWidth += width;
      }
      return sumWidth;
    },
    getCurrentSortFunction: function () {
        var column = this._sortColumn;
        if (column) {
            var func = column.getSortFunction();
            if (func) {
                var table = this;
                var direction = 'asc' === column.getSortDirection() ? 1 : -1;
                return function (d1, d2) {
                    var v1 = table.getValue(d1, column);
                    var v2 = table.getValue(d2, column);
                    return func.call(table, v1, v2, d1, d2) * direction;
                };
            }
        }
        return this._sortFunction;
    },
    /*
    params
    data: data,
    value: this.getValue(data, column),
    div: cell,
    view: this,
    column: column,
    rowIndex: row,
    selected: selected,
    enumInfo: enumInfo
    */
    renderCell: function (params) {
        var column = params.column;
        if (column.renderCell) {
            column.renderCell(params);
            return;
        }
        var value = params.value;
        var enumInfo = column.getEnumInfo(params.rowIndex);
        if (enumInfo && !Array.isArray(enumInfo)) {
            value = enumInfo.map[value];
        }
        if (params.view.isCellEditable(params.data, column)) {
            params.enumInfo = enumInfo;
            params.div._editInfo = params;
        }
        $render.render(column.getValueType(), value, params.div, params.view, column.isInnerText());
    },
    getValue: function (data, column) {
        return column.getValue(data, this);
    },
    setValue: function (data, column, value) {
        column.setValue(data, value, this);
    },
    getColumnAt: function (e) {
        var point = this.getLogicalPoint(e);
        if (!point) {
            return null;
        }
        var columns = this._columnBox.getRoots();
        for (var i = 0, n = columns.size(), sum = 0; i < n; i++) {
            var column = columns.get(i);
            var width = column.getWidth();
            if (width < 0) width = 0;
            if (point.x > sum && point.x < sum + width) {
                return column;
            }
            sum += width;
        }
        return null;
    },
    isCellEditable: function (data, column) {
        return this.isEditable() && column.isEditable();
    },
    commitEditValue: function (editInfo, target) {
        if (this._isCanceling) {
            return;
        }
        var value;
        if (target.type === 'checkbox') {
            value = target.checked;
        } else {
            value = target.value;
        }
        var column = editInfo.column;
        var type = column.getValueType();
        if (type === 'int' && typeof value === 'string') {
            value = parseInt(value);
        }
        else if (type === 'number' && typeof value === 'string') {
            value = parseFloat(value);
        }else if(type === 'list.points') {
            var array = value.replace(/\]/g, "" ).replace(/\[/g, "" ).split(','); 
            var points = new twaver.List();
            for(var i = 0;i<array.length;i+=2){
                if(i+1 >= array.length) continue;
                points.add({x:parseInt(array[i]),y:parseInt(array[i+1])});
            }
            value = points;
        }
        this.setValue(editInfo.data, column, value);
        if (this._currentEditor) {
            // var editor = this._currentEditor;
            // delete this._currentEditor;
            // this._rootDiv.removeChild(editor);
            // twaver.Util.setFocus(this._view);
            var parentNode = this._currentEditor.parentNode;
            var editor = this._currentEditor;
            delete this._currentEditor;
            parentNode && parentNode.removeChild(editor);
            twaver.Util.setFocus(this._view);
        }
        delete this._isCommitting;
    },
    cancelEditing: function () {
        if (this._currentEditor) {
            // this._isCanceling = true;
            // var editor = this._currentEditor;
            // delete this._currentEditor;
            // this._rootDiv.removeChild(editor);
            // twaver.Util.setFocus(this._view);
            // delete this._isCanceling;

            this._isCanceling = true;
            var parentNode = this._currentEditor.parentNode;
            var editor = this._currentEditor;
            delete this._currentEditor;
            parentNode && parentNode.removeChild(editor);
            twaver.Util.setFocus(this._view);
            delete this._isCanceling;
        }
    },
    renderEditor: function(params){

    },
    onEditorRendered: function(params){

    },
    getEditorValue: function(editInfo){
        var valueType = editInfo.column.getValueType();
        var value = editInfo.value;
        var result = '';
        if(valueType === 'list.points'){
            var array = value._as ? value._as : value;
            array.forEach(function(a,index){
                result += index == (array.length -1)? '[' + a.x + ',' + a.y + ']' : '[' + a.x + ',' + a.y + '],';
            });
        }else{
            result = value;
        }
        return result;
    },
    updateCurrentEditor: function (e) {
        var t = e.target;
        // click on editor
        if (t === this._currentEditor || t.parentNode === this._currentEditor) {
            return;
        }
        var editInfo;
        while (t && t !== this._view && !(editInfo = t._editInfo)) {
            t = t.parentNode;
        }

        if (editInfo && t === editInfo.div) {
            var editor = this.renderEditor && this.renderEditor(editInfo);
            if(editor){
                this._currentEditor = editor.view;
                if (editInfo.value != null) {
                    // this._currentEditor.value = editInfo.value;
                    this._currentEditor.value = this.getEditorValue(editInfo);;
                }
            }else if (editInfo.enumInfo) {
                this._currentEditor = $html.createSelect(editInfo.enumInfo, editInfo.value);
            } else {
                this._currentEditor = document.createElement('input');
                if (editInfo.value != null) {
                    // this._currentEditor.value = editInfo.value;
                    this._currentEditor.value = this.getEditorValue(editInfo);
                }
            }

            var self = this;
            if(editInfo.column && editInfo.column.renderEditor){
                var editor = typeof editInfo.column.renderEditor === 'function' ? editInfo.column.renderEditor(self,editInfo) : editInfo.column.renderEditor;
                if(editor){
                    self._currentEditor = editor;
                }
            }
            if (this._currentEditor) {
                if(editor && editor.onKeyDown){
                    var keydownEvents = editor.onKeyDown;
                    if(keydownEvents && Array.isArray(keydownEvents)){
                        self._currentEditor.addEventListener('keydown', function (e) {
                            // var view = e.target._editInfo.view;
                            for(var k = 0; k<keydownEvents.length; k++){
                                if(keydownEvents[k].combKey){
                                    var evt = null;
                                    switch (keydownEvents[k].combKey){
                                        case 'ctrlKey':
                                        evt = e.ctrlKey;
                                        break;
                                        case 'shiftKey':
                                        evt = e.shiftKey;
                                        break;
                                        case 'altKey':
                                        evt = e.altKey;
                                        break;
                                    }
                                    if(e.keyCode === keydownEvents[k].keyCode && evt){
                                        keydownEvents[k].handlerEvent && keydownEvents[k].handlerEvent(e);
                                    }
                                }else{
                                    if(e.keyCode === keydownEvents[k].keyCode){
                                        keydownEvents[k].handlerEvent && keydownEvents[k].handlerEvent(e);
                                    } 
                                }
                            }
                        });
                        } 
                    }else{
                this._currentEditor.addEventListener('keydown', function (e) {
                    var view = e.target._editInfo.view;
                    if(e.keyCode === 13 && e.shiftKey){
                        return;
                    }else if (e.keyCode === 13) {
                        view.commitEditValue(e.target._editInfo, e.target);
                    } else if (e.keyCode === 27) {
                        view.cancelEditing();
                    }
                }, false);
            }
                this._currentEditor.addEventListener('blur', function (e) {
                    var view = e.target._editInfo.view;
                    if (view._isCanceling) {
                        return;
                    }
                    view.commitEditValue(e.target._editInfo, e.target);
                }, false);
                this._currentEditor.keepDefault = true;
                this._currentEditor._editInfo = editInfo;

                if(!this._currentEditor.parentNode){
                    var style = this._currentEditor.style;
                    style.position = 'absolute';
                    style.margin = '0px';
                    style.border = '0px';
                    style.padding = '0px';
                    style.left = editInfo.div.style.left;
                    style.top = editInfo.div.parentNode.style.top;
                    style.width = editInfo.div.style.width;
                    style.height = editInfo.div.style.height;
                    this._rootDiv.appendChild(this._currentEditor);
                }
                // var style = this._currentEditor.style;
                // style.position = 'absolute';
                // style.margin = '0px';
                // style.border = '0px';
                // style.padding = '0px';
                // style.left = editInfo.div.style.left;
                // style.top = editInfo.div.parentNode.style.top;
                // style.width = editInfo.div.style.width;
                // style.height = editInfo.div.style.height;
                // this._rootDiv.appendChild(this._currentEditor);
                twaver.Util.setFocus(this._currentEditor);
            }
        }
    },
    onColumnSorted: function (column) {

    },
    getCurrentEditor: function () {
        return this._currentEditor;
    }
});

twaver.controls.List = function (dataBox) {
    twaver.controls.List.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.controls.List', twaver.controls.ListBase, {
    __accessor: ['rowHeight', 'indent', 'rowLineWidth', 'rowLineColor',
        'sortFunction', 'visibleFunction'],

    __bool: ['makeVisibleOnSelected', 'keyboardRemoveEnabled', 'keyboardSelectEnabled'],

    _checkMode: false,
    _rowHeight: $Defaults.LIST_ROW_HEIGHT,
    _indent: $Defaults.LIST_INDENT,
    _rowLineWidth: $Defaults.LIST_ROW_LINE_WIDTH,
    _rowLineColor: $Defaults.LIST_ROW_LINE_COLOR,
    _makeVisibleOnSelected: $Defaults.LIST_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: $Defaults.LIST_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: $Defaults.LIST_KEYBOARD_SELECT_ENABLED,

    isCheckMode: function () {
        return this._checkMode;
    },
    setCheckMode: function (v) {
        delete this._focusedRow;
        var oldValue = this._checkMode;
        this._checkMode = v;
        this.firePropertyChange("checkMode", oldValue, v);
    },
    isCheckable: function (data) {
        return this._checkMode === true;
    },
    renderData: function (div, data, row, selected) {
        var span;
        if (this._indent > 0) {
            span = this.__spanPool.get();
            span.style.width = this._indent + 'px';
            span.style.display = 'inline-block';
            div.appendChild(span);
        }

        var checkable = this.isCheckable(data);
        if (checkable) {
            this._addCheckBox(div, data, selected);
        }

        var icon = this.getIcon(data);
        if (icon) {
            this._addIcon(div, data, icon)
        }

        var label = this.getLabel(data);
        if (label) {
            span = this.__textPool.get();
            var style = span.style;
            style.whiteSpace = 'nowrap';
            style.verticalAlign = 'middle';
            style.padding = '1px 2px 1px 2px';
            style.display = 'inline-block';
            _twaver.setText(span, label, this._innerText);
            this.onLabelRendered(span, data, label, row, selected);
            div.appendChild(span);
        }

        if (this.isCheckMode()) {
            div.style.backgroundColor = this._focusedRow === row ? this.getSelectColor(data) : '';
        } else {
            div.style.backgroundColor = selected ? this.getSelectColor(data) : '';
        }
    },
    onLabelRendered: function (span, data, label, row, selected) {

    }

});

twaver.controls.ListBaseInteraction = function (listBase) {
    this.listBase = listBase;
    this.view = listBase._view;
    this.clickTimer = 0;
    this.doubleClickInterval = 300;

    var self = this;
    this.view.addEventListener('scroll', function (e) {
        self.handleScroll(e);
    }, false);
    this.view.addEventListener('mouseup', function (e) {
        self.handleMouseUp(e);
    }, false);
    this.view.addEventListener('keydown', function (e) {
        self.handleKeyDown(e);
    }, false);
};
_twaver.ext('twaver.controls.ListBaseInteraction', Object, {
    handleMouseUp: function (e) {
        var list = this.listBase;
        var self = this;
        if (e.target === list._currentEditor || e.target.parentNode === list._currentEditor) {
            return;
        }

        if (self.clickTimer) {
            clearTimeout(self.clickTimer);
            self.clickTimer = 0;
            list._handleDoubleClick(e);
        } else {
            list._handleClick(e);
            self.clickTimer = setTimeout(function () {
                clearTimeout(self.clickTimer);
                self.clickTimer = 0;
            }, 300);
        }
    },
    handleKeyDown: function (e) {
        var list = this.listBase;
        if (list._currentEditor) {
            return;
        }
        if (_twaver.isCtrlDown(e) && e.keyCode == 65) {
            if (list.isKeyboardSelectEnabled() && list.selectAll().size() > 0) {
                list.fireInteractionEvent({
                    kind: 'selectAll'
                });
            }
            $html.preventDefault(e);
        } else if (e.keyCode == 46) {
            if (list.isKeyboardRemoveEnabled() && list.removeSelection()) {
                list.fireInteractionEvent({
                    kind: 'removeElement'
                });
            }
            $html.preventDefault(e);
        } else if (!list.isCheckMode() && (e.keyCode === 38 || e.keyCode === 40 || e.keyCode === 37 || e.keyCode === 39)) {
            var data = list.getSelectionModel().getLastData();
            if (data) {
                if (e.keyCode === 38 || e.keyCode === 40) {
                    var datas = list.getRowDatas();
                    var index = list.getRowIndexByData(data);
                    if (index >= 0) {
                        if (e.keyCode === 38) {
                            if (index !== 0) {
                                data = datas.get(index - 1);
                                list.getSelectionModel().setSelection(data);
                            }
                        } else {
                            if (index !== datas.size() - 1) {
                                data = datas.get(index + 1);
                                list.getSelectionModel().setSelection(data);
                            }
                        }
                    }
                } else if (list.expand && (e.keyCode === 37 || e.keyCode === 39)) {
                    if (data.hasChildren()) {
                        if (e.keyCode === 37) {
                            list.collapse(data);
                        } else {
                            list.expand(data);
                        }
                    }
                }
            } else {
                if (list.getRowDatas().size() > 0) {
                    data = list.getRowDatas().get(0);
                    list.getSelectionModel().setSelection(data);
                }
            }
        } else {
            _twaver.showVersion(e);
        }
    },
    handleScroll: function (e) {
        this.listBase.invalidate();
    }
});
twaver.controls.ListBaseTouchInteraction = function (listBase) {
    this.listBase = listBase;
    this.view = listBase._view;

    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.controls.ListBaseTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        this.startPoint = this.lastPoint = this.listBase.getLogicalPoint(e);
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.zoom = this.listBase._zoom;
        }
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        var newPoint = this.listBase.getLogicalPoint(e);
        if ($math.getDistance(this.startPoint, newPoint) < 20) {
            return;
        }
        if (!this.moved) {
            this.moved = true;
        }
        if ($touch.isSingleTouch(e)) {
            if (this.lastPoint) {
                var xoffset = this.lastPoint.x - newPoint.x;
                var yoffset = this.lastPoint.y - newPoint.y;
                var result = this.listBase.panByOffset(xoffset, yoffset);
                this.listBase.invalidate();
                this.lastPoint.x -= (xoffset - result.x);
                this.lastPoint.y -= (yoffset - result.y);
            }
        } else {
            if (this.distance) {
                var scale = $touch.getDistance(e) / this.distance;
                this.listBase.setZoom(this.zoom * scale, false);
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        if (!this.moved && e.target !== this.listBase._currentEditor && e.target.parentNode !== this.listBase._currentEditor) {
            this.listBase._handleClick(e);
        }
        delete this.startPoint;
        delete this.lastPoint;
        delete this.moved;
        delete this.distance;
        delete this.zoom;
        $html.removeEventListener('touchmove', this.view, this);
        $html.removeEventListener('touchend', this.view, this);
    }
});

twaver.controls.ListBaseMSTouchInteraction = function (listBase) {
    twaver.controls.ListBaseMSTouchInteraction.superClass.constructor.apply(this, arguments);
    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.view, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.view, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.view, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.view, this);
    this.superHandleMouseDown = twaver.controls.ListBaseMSTouchInteraction.superClass.handleMouseDown;
};
_twaver.ext('twaver.controls.ListBaseMSTouchInteraction', twaver.controls.ListBaseInteraction, {
    handleMouseDown: function (e) {

    },
    handleTouchstart: function (e) {
        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }

        if (!this._pointerMap[e.pointerId] && this.listBase.getLogicalPoint(e) != null) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        if (this._pointerIdArray.length == 1 && e.pointerType == e.MSPOINTER_TYPE_MOUSE) {
            this.superHandleMouseDown(e);
        }

        if (this._pointerIdArray.length == 1) {
            this._startTouchPoint = this.listBase.getLogicalPoint(e);
            this._startTouchTime = new Date();
        }
        else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.listBase.getZoom();
        }
    },
    handleTouchmove: function (e) {
        if (this._startTouchPoint == null || this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.listBase.setZoom(this._zoom * scale, false);
        } else if (this._pointerIdArray.length == 1 && e.pointerType != e.MSPOINTER_TYPE_MOUSE) {
            if (this._startTouchPoint) {
                var newPoint = this.listBase.getLogicalPoint(e);
                if (newPoint == null) {
                    return
                };
                var xoffset = this._startTouchPoint.x - newPoint.x;
                var yoffset = this._startTouchPoint.y - newPoint.y;
                var result = this.listBase.panByOffset(xoffset, yoffset);
                this.listBase.invalidate();
                this._startTouchPoint.x -= (xoffset - result.x);
                this._startTouchPoint.y -= (yoffset - result.y);
            }
        }
    },
    handleTouchend: function (e) {
        if (this._startTouchPoint && this._pointerIdArray.length == 1 && e.pointerType != e.MSPOINTER_TYPE_MOUSE) {
            var currentTouchPoint = this.listBase.getLogicalPoint(e);
            if (currentTouchPoint) {
                var currentTouchTime = new Date();
                if (currentTouchTime.getTime() - this._startTouchTime.getTime() <= 500
                && $math.getDistance(this._startTouchPoint, currentTouchPoint) <= 20) {
                    this.superHandleMouseDown(e);
                }
            }
            
        }
        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.controls.Tree = function (dataBox) {
    this._interactionDispatcher = new twaver.EventDispatcher();
    this._initTree(dataBox);
    twaver.controls.Tree.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.controls.Tree', twaver.controls.ListBase, {
    __tree: 1,

    __accessor: ['rootData', 'sortFunction', 'visibleFunction',
        'indent', 'rowHeight', 'rowLineWidth', 'rowLineColor', 'expandIcon', 'collapseIcon', 'uncheckableStyle', 'lineType',
        'lineColor', 'lineThickness', 'lineAlpha', 'lineDash'
    ],

    __bool: ['rootVisible', 'makeVisibleOnSelected', 'keyboardRemoveEnabled', 'keyboardSelectEnabled'],

    _checkMode: false,
    _indent: $Defaults.TREE_INDENT,
    _rowHeight: $Defaults.TREE_ROW_HEIGHT,
    _rowLineWidth: $Defaults.TREE_ROW_LINE_WIDTH,
    _rowLineColor: $Defaults.TREE_ROW_LINE_COLOR,
    _makeVisibleOnSelected: $Defaults.TREE_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: $Defaults.TREE_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: $Defaults.TREE_KEYBOARD_SELECT_ENABLED,
    _expandIcon: $Defaults.TREE_EXPAND_ICON,
    _collapseIcon: $Defaults.TREE_COLLAPSE_ICON,
    _uncheckableStyle: 'none',
    _lineType: $Defaults.TREE_LINE_TYPE,
    _lineColor: $Defaults.TREE_LINE_COLOR,
    _lineThickness: $Defaults.TREE_LINE_THICKNESS,
    _lineAlpha: $Defaults.TREE_LINE_ALPHA,
    _lineDash: $Defaults.TREE_LINE_DASH,

    getCheckMode: function () {
        return this._checkMode;
    },
    setCheckMode: function (v) {
        delete this._focusedRow;
        var oldValue = this._checkMode;
        this._checkMode = v;
        this.firePropertyChange("checkMode", oldValue, v);
    },
    renderData: function (div, data, row, selected) {
        this._renderTree(div, data, row, selected);
    },
    getToolTip: function (element) {
        return element.getToolTip() || element.getName();
    }
});
twaver.controls.Table = function (dataBox) {
    this._checkColumn = new twaver.Column();
    this._checkColumn.setName('check');
    this._checkColumn.setEditable(true);
    this._checkColumn.setWidth(40);
    this._checkColumn.setHorizontalAlign('center');
    this._checkColumn.renderCell = this.renderCheckCell;
    var self = this;
    this._checkColumn.getValue = function (data, column) {
        return self.isSelected(data);
    };

    twaver.controls.Table.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.controls.Table', twaver.controls.TableBase, {
    __accessor: ['rowHeight', 'rowLineWidth', 'rowLineColor', 'columnLineWidth', 'columnLineColor',
        'sortFunction', 'visibleFunction', 'sortColumn'],

    __bool: ['editable', 'makeVisibleOnSelected', 'keyboardRemoveEnabled', 'keyboardSelectEnabled'],

    _editable: $Defaults.TABLE_EDITABLE,
    _rowHeight: $Defaults.TABLE_ROW_HEIGHT,
    _rowLineWidth: $Defaults.TABLE_ROW_LINE_WIDTH,
    _rowLineColor: $Defaults.TABLE_ROW_LINE_COLOR,
    _columnLineWidth: $Defaults.TABLE_COLUMN_LINE_WIDTH,
    _columnLineColor: $Defaults.TABLE_COLUMN_LINE_COLOR,
    _makeVisibleOnSelected: $Defaults.TABLE_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: $Defaults.TABLE_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: $Defaults.TABLE_KEYBOARD_SELECT_ENABLED,

    getCheckColumn: function () {
        return this._checkColumn;
    },
    isCheckMode: function () {
        return this._columnBox.contains(this._checkColumn);
    },
    setCheckMode: function (value) {
        if (value === this.isCheckMode()) {
            return;
        }
        delete this._focusedRow;
        if (value) {
            this._columnBox.add(this._checkColumn, 0);
        } else {
            this._columnBox.remove(this._checkColumn);
        }
        this.firePropertyChange('checkMode', !value, value);
    },
    renderCheckCell: function (params) {
        var checkBox = params.view._booleanPool.get();
        checkBox.disabled = false;
        checkBox.type = 'checkbox';
        checkBox.style.margin = '0px 2px';
        checkBox.style.verticalAlign = 'middle';
        checkBox.checked = params.selected;
        var div = params.div;
        div.appendChild(checkBox);
        if (div.style.textAlign === '') {
            div.style.textAlign = 'center';
        }
        checkBox._checkData = params.data;
    }
});

twaver.controls.TableHeader = function (table) {
    twaver.controls.TableHeader.superClass.constructor.apply(this, arguments);
    this._invalidateScroll = false;
    this._invalidateDisplay = false;

    this._divPool = new twaver.Pool('div');
    this._imagePool = new twaver.Pool('img');
    this._textPool = new twaver.Pool('span');
    this._resizePool = new twaver.Pool('div');

    this._pools.add(this._divPool);
    this._pools.add(this._imagePool);
    this._pools.add(this._textPool);
    this._pools.add(this._resizePool);

    this._table = table;
    this._tableView = table.getView();
    this._columnBox = table.getColumnBox();
    this._columnBox.addDataBoxChangeListener(this.handleColumnBoxChange, this);
    this._columnBox.addDataPropertyChangeListener(this.handleColumnPropertyChange, this);
    this._columnBox.addHierarchyChangeListener(this.handleColumnHierarchyChange, this);

    var self = this;

    table.getView().addEventListener('scroll', function (e) {
        self.invalidateScroll();
    }, false);
    table.addPropertyChangeListener(function (e) {
        self.invalidateDisplay();
    }, this);

    this._view = $html.createView('hidden');
    this._view.tabIndex = -1;
    this._view.style.background = $Defaults.TABLEHEADER_BACKGROUND;
    this._rootDiv = $html.createDiv();
    this._view.appendChild(this._rootDiv);

    this.invalidateDisplay();

    if ($ua.isTouchable) {
        new twaver.controls.TableHeaderTouchInteraction(this);
    }
    new twaver.controls.TableHeaderInteraction(this);
};
_twaver.ext('twaver.controls.TableHeader', twaver.controls.ControlBase, {
    __accessor: ['height', 'moveBackground', 'insertBackground', 'columnLineColor',
        'resizeTolerance', 'sortDescIcon', 'sortAscIcon', 'sortIconPosition'],

    _height: $Defaults.TABLEHEADER_HEIGHT,
    _moveBackground: $Defaults.TABLEHEADER_MOVE_BACKGROUND,
    _insertBackground: $Defaults.TABLEHEADER_INSERT_BACKGROUND,
    _columnLineColor: $Defaults.TABLEHEADER_COLUMN_LINE_COLOR,
    _resizeTolerance: $Defaults.TABLEHEADER_RESIZE_TOLERANCE,

    _sortDescIcon: $Defaults.TABLEHEADER_SORT_DESC_ICON,
    _sortAscIcon: $Defaults.TABLEHEADER_SORT_ASC_ICON,
    _sortIconPosition: $Defaults.TABLEHEADER_SORT_ICON_POSITION,

    getRootDiv: function () {
        return this._rootDiv;
    },

    handleColumnBoxChange: function (e) {
        this.invalidateDisplay();
    },
    handleColumnPropertyChange: function (e) {
        this.invalidateDisplay();
    },
    handleColumnHierarchyChange: function (e) {
        this.invalidateDisplay();
    },
    onPropertyChanged: function (e) {
        this.invalidateDisplay();
    },
    invalidateScroll: function () {
        if (this._invalidateScroll) {
            return;
        }
        this._invalidateScroll = true;
        this.invalidate();
    },
    invalidateDisplay: function () {
        if (this._invalidateDisplay) {
            return;
        }
        this._invalidateDisplay = true;
        this._invalidateScroll = true;
        this.invalidate();
    },
    validate: function () {
        if (!this._invalidate) {
            return;
        }
        this._invalidate = false;
        if (this._invalidateDisplay) {
            this._invalidateDisplay = false;
            this.validateDisplay();
        }
        if (this._invalidateScroll) {
            this._invalidateScroll = false;
            this._rootDiv.style.left = -this._tableView.scrollLeft + 'px';
        }
    },
    validateDisplay: function () {
        $html.release(this._rootDiv);

        var zoom = this._table.getZoom();
        var hpx = this.getHeight() + 'px';
        var lhpx = this.getHeight() - 2 + 'px';
        var columns = this._table.getColumnBox().getRoots();
        var count = columns.size();
        var sumWidth = 0;
        var normalLineWidth = this._table._columnLineWidth * zoom;

        for (var i = 0; i < count; i++) {
            var column = columns.get(i);

            if (column.isVisible()) {
                var width = column.getWidth() * zoom;
                if (width < 0) width = 0;
                var lineWidth = Math.min(normalLineWidth, width);

                var div = this._divPool.get();
                div._column = column;

                var style = div.style;
                style.position = 'absolute';
                style.whiteSpace = 'nowrap';
                style.lineHeight = lhpx;
                style.overflow = 'hidden';
                style.textOverflow = 'ellipsis';
                style.backgroundPosition = this._sortIconPosition ? this._sortIconPosition : '';
                style.backgroundRepeat = 'no-repeat';
                style.backgroundImage = '';
                style.textAlign = column.getHorizontalAlign();

                style.borderStyle = 'solid';
                style.borderWidth = '0px';
                style.borderRightWidth = lineWidth + 'px';
                style.borderRightColor = this._columnLineColor;
                
                if (i === 0) {
                    style.borderLeftWidth = lineWidth + 'px';
                    style.borderLeftColor = this._columnLineColor;
                } else {
                    style.borderLeftWidth = '0px';
                }

                style.left = sumWidth + 'px';
                style.width = width - lineWidth + 'px';
                style.height = hpx;
                div._x = sumWidth;
                div._width = width - lineWidth;

                this._rootDiv.insertBefore(div, this._rootDiv.firstChild);
                this.renderColumn(div, column);
                this.onColumnRendered(div, column);

                sumWidth += width;

                if (column.isResizable()) {
                    div = this._resizePool.get();
                    div._resizeColumn = column;
                    style = div.style;
                    style.position = 'absolute';
                    style.backgroundColor = 'white';
                    style.opacity = 0;
                    style.left = sumWidth - lineWidth - this._resizeTolerance + 'px';
                    style.width = lineWidth + this._resizeTolerance * 2 + 'px';
                    style.height = hpx;
                    this._rootDiv.appendChild(div);
                }
            }
        }

        this._pools.forEach(function (pool) {
            pool.clear();
        });

        this._rootDiv.style.width = sumWidth + 'px';
        this._rootDiv.style.height = hpx;
    },
    renderColumn: function (div, column) {
        if (column.renderHeader) {
            column.renderHeader(div);
        } else {
            var span = this._textPool.get();
            span.style.whiteSpace = 'nowrap';
            span.style.verticalAlign = 'middle';
            span.style.padding = '1px 2px 1px 2px';
            span.innerHTML = column.getName() ? column.getName() : column.getPropertyName();
            span.setAttribute('title', span.innerHTML);
            div.appendChild(span);

            if ($ua.isOpera) {
                var maskDiv = div.cloneNode(false);
                maskDiv.style.left = '0px';
                maskDiv.style.top = '0px';
                maskDiv.style.opacity = 0;
                div.appendChild(maskDiv);
            }
        }

        if (this._table.getSortColumn() === column && column.isSortable()) {
            var name = column.getSortDirection() === 'asc' ? this._sortAscIcon : this._sortDescIcon;
            var src = _twaver.getImageSrc(name);

            if (!this._sortIconPosition || this._sortIconPosition === '') {
                var image = this._imagePool.get();
                image.setAttribute('src', src);
                image.style.verticalAlign = 'middle';
                div.appendChild(image);
            } else {
                div.style.backgroundImage = 'url(' + src + ')';
            }
        }
    },
    onColumnRendered: function (div, column) {

    }

});

twaver.controls.TableHeaderInteraction = function (tableHeader) {
    this.header = tableHeader;
    this.table = tableHeader._table;
    this.view = tableHeader._view;

    var self = this;
    this.view.addEventListener('mousedown', function (e) {
        self.handleMouseDown(e);
    }, false);
    this.view.addEventListener('mousemove', function (e) {
        self.handleMouseMove(e);
    }, false);
};
_twaver.ext('twaver.controls.TableHeaderInteraction', Object, {
    handleMouseDown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.movableDiv) {
            this.handleMouseUp(e);
            return;
        }
        this.resizeColumn = e.target._resizeColumn;
        if (!this.resizeColumn) {
            this.movableDiv = this.getMovableDivAt(e);
        }
        this.changeCursor(e);
        this._startClient = $html.getClientPoint(e);
        this.lastX = this.getX(e);
        this._startLogicalX = this.lastX;
        $html.handle_mousedown(this, e);
    },
    changeCursor: function (e) {
        var cursor = ''
        if (e.target._resizeColumn) {
            cursor = 'ew-resize';
        } else {
            var column = this.getColumnAt(e);
            if (column && (column.isMovable() || column.isSortable())) {
                cursor = 'pointer';
            }
        }
        this.view.style.cursor = cursor;
    },
    handleMouseMove: function (e) {
        if (this.lastX == null) {
            this.changeCursor(e);
            return;
        }
        if ($html.target !== this) {
            return;
        }
        var x = this._startLogicalX + e.clientX - this._startClient.x;
        // resize column
        if (this.resizeColumn) {
            if (this.stopX != null) {
                if (x < this.stopX) {
                    return;
                } else {
                    delete this.stopX;
                }
            }
            var w = this.resizeColumn.getWidth() + (x - this.lastX) / this.table.getZoom();
            if (w < 10) {
                w = 10;
                this.stopX = x;
            }

            this.resizeColumn.setWidth(w);
            this.lastX = x;
        }
        // move column
        else if (this.movableDiv) {
            var offset = x - this.lastX;

            if (!this.cloneDiv) {
                if (Math.abs(offset) < 3) {
                    return;
                }
                this.cloneDiv = this.movableDiv.cloneNode(true);
                this.cloneDiv._x = this.movableDiv._x;
                this.cloneDiv.style.background = this.header.getMoveBackground();

                this.insertDiv = $html.createDiv();
                this.insertDiv.style.width = '1px';
                this.insertDiv.style.height = this.cloneDiv.style.height;
                this.insertDiv.style.background = this.header.getInsertBackground();

                this.movableDiv.parentNode.appendChild(this.cloneDiv);
                this.movableDiv.parentNode.appendChild(this.insertDiv);
            }


            var left = this.cloneDiv._x + offset;
            this.cloneDiv.style.left = left + 'px';
            this.cloneDiv._x = left;
            this.lastX = x;

            this.columnInfo = this.getColumnInfoAt(e);
            if (this.columnInfo) {
                this.insertDiv.style.left = this.columnInfo.position;
            }
        }
    },
    handleMouseUp: function (e) {
        if (e.button !== 0) {
            return;
        }
        var column;
        if (this.resizeColumn) {
            // do nothing
        } else if (this.movableDiv && this.columnInfo) {
            column = this.movableDiv._column;
            var index = this.columnInfo.index;
            this.table.getColumnBox().moveTo(column, index);
        } else {
            column = this.getColumnAt(e);
            if (column && column.isSortable()) {
                var direction = column.getSortDirection();
                if (this.table.getSortColumn() === column) {
                    if (direction === 'desc') {
                        this.table.setSortColumn(null);
                    }
                    column.setSortDirection(direction === 'asc' ? 'desc' : 'asc');
                } else {
                    this.table.setSortColumn(column);
                }
                this.table.onColumnSorted(this.table.getSortColumn());
            }
        }
        this.clear();
    },
    clear: function () {
        this.view.style.cursor = '';
        if (this.cloneDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.cloneDiv);
        }
        if (this.insertDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.insertDiv);
        }
        delete this.movableDiv;
        delete this.columnInfo;
        delete this.insertDiv;
        delete this.cloneDiv;
        delete this.resizeColumn;
        delete this.stopX;
        delete this.lastX;
        delete this._startClient;
        delete this._startLogicalX;
    },
    getColumnAt: function (e) {
        e = e.target;
        var column;
        while (e && e !== this.view && !(column = e._column)) {
            e = e.parentNode;
        }
        return column;
    },
    getMovableDivAt: function (e) {
        e = e.target;
        var column;
        while (e && e !== this.view && !(column = e._column)) {
            e = e.parentNode;
        }
        if (column && column.isMovable()) {
            return e;
        }
        return null;
    },
    getX: function (e) {
        var p = $html.getLogicalPoint(this.view, e);
        return p ? p.x : null;
    },
    getColumnInfoAt: function (e) {
        var x = this._startLogicalX + e.clientX - this._startClient.x + this.table.getView().scrollLeft;
        var columns = this.table.getColumnBox().getRoots();
        var count = columns.size();
        var zoom = this.table.getZoom();
        var sumWidth = 0;
        var meetMovingColumn = false;
        for (var i = 0; i < count; i++) {
            var column = columns.get(i);
            if (column === this.movableDiv._column) {
                meetMovingColumn = true;
            }
            if (column.isVisible()) {
                var width = column.getWidth() * zoom;
                if (width <= 0) {
                    continue;
                }
                if (x >= sumWidth && x <= sumWidth + width) {
                    var isFront = x < sumWidth + width / 2;
                    if (meetMovingColumn &&
                        !(column === this.movableDiv._column && isFront)) {
                        i--;
                    }
                    var index = isFront ? Math.max(0, i) : Math.min(i + 1, count);
                    var position = isFront ? sumWidth : sumWidth + width;
                    position = Math.max(0, position - 1);
                    return {
                        index: index,
                        column: column,
                        position: position + 'px'
                    };
                }
                sumWidth += width;
            }
        }
        return this.columnInfo;
    }
});

twaver.controls.TableHeaderTouchInteraction = function (tableHeader) {
    this.header = tableHeader;
    this.table = tableHeader._table;
    this.view = tableHeader._view;

    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.controls.TableHeaderTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (this.movableDiv) {
            this.handleTouchend(e);
            return;
        }
        this.resizeColumn = e.target._resizeColumn;
        if (!this.resizeColumn) {
            this.movableDiv = this.getMovableDivAt(e);
        }
        this.lastX = this.getX(e);
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if (this.lastX == null) {
            return;
        }
        var x;
        // resize column
        if (this.resizeColumn) {
            x = this.getX(e);
            if (this.stopX != null) {
                if (x < this.stopX) {
                    return;
                } else {
                    delete this.stopX;
                }
            }
            var w = this.resizeColumn.getWidth() + (x - this.lastX) / this.table.getZoom();
            if (w < 0) {
                w = 0;
                this.stopX = x;
            }

            this.resizeColumn.setWidth(w);
            this.lastX = x;
        }
        // move column
        else if (this.movableDiv) {
            x = this.getX(e);
            var offset = x - this.lastX;

            if (!this.cloneDiv) {
                if (Math.abs(offset) < 3) {
                    return;
                }
                this.cloneDiv = this.movableDiv.cloneNode(true);
                this.cloneDiv._x = this.movableDiv._x;
                this.cloneDiv.style.background = this.header.getMoveBackground();

                this.insertDiv = $html.createDiv();
                this.insertDiv.style.width = '1px';
                this.insertDiv.style.height = this.cloneDiv.style.height;
                this.insertDiv.style.background = this.header.getInsertBackground();

                this.movableDiv.parentNode.appendChild(this.cloneDiv);
                this.movableDiv.parentNode.appendChild(this.insertDiv);
            }


            var left = this.cloneDiv._x + offset;
            this.cloneDiv.style.left = left + 'px';
            this.cloneDiv._x = left;
            this.lastX = x;

            this.columnInfo = this.getColumnInfoAt(e);
            if (this.columnInfo) {
                this.insertDiv.style.left = this.columnInfo.position;
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        var column;
        if (this.resizeColumn) {
            // do nothing
        }
        else if (this.movableDiv && this.columnInfo) {
            column = this.movableDiv._column;
            var index = this.columnInfo.index;
            this.table.getColumnBox().moveTo(column, index);
        }
        else {
            column = this.getColumnAt(e);
            if (column && column.isSortable()) {
                var direction = column.getSortDirection();
                if (this.table.getSortColumn() === column) {
                    if (direction === 'desc') {
                        this.table.setSortColumn(null);
                    }
                    column.setSortDirection(direction === 'asc' ? 'desc' : 'asc');
                } else {
                    this.table.setSortColumn(column);
                }
            }
        }
        this.clear();
        $html.removeEventListener('touchmove', this.view, this);
        $html.removeEventListener('touchend', this.view, this);
    },
    clear: function () {
        if (this.cloneDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.cloneDiv);
        }
        if (this.insertDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.insertDiv);
        }
        delete this.movableDiv;
        delete this.columnInfo;
        delete this.insertDiv;
        delete this.cloneDiv;
        delete this.resizeColumn;
        delete this.stopX;
        delete this.lastX;
    },
    getColumnAt: function (e) {
        e = e.target;
        var column;
        while (e && e !== this.view && !(column = e._column)) {
            e = e.parentNode;
        }
        return column;
    },
    getMovableDivAt: function (e) {
        e = e.target;
        var column;
        while (e && e !== this.view && !(column = e._column)) {
            e = e.parentNode;
        }
        if (column && column.isMovable()) {
            return e;
        }
        return null;
    },
    getX: function (e) {
        var p = $html.getLogicalPoint(this.view, e);
        return p ? p.x : null;
    },
    getColumnInfoAt: function (e) {
        var x = this.getX(e) + this.table.getView().scrollLeft;
        var columns = this.table.getColumnBox().getRoots();
        var count = columns.size();
        var zoom = this.table.getZoom();
        var sumWidth = 0;
        var meetMovingColumn = false;
        for (var i = 0; i < count; i++) {
            var column = columns.get(i);
            if (column === this.movableDiv._column) {
                meetMovingColumn = true;
            }
            if (column.isVisible()) {
                var width = column.getWidth() * zoom;
                if (width <= 0) {
                    continue;
                }
                if (x >= sumWidth && x <= sumWidth + width) {
                    var isFront = x < sumWidth + width / 2;
                    if (meetMovingColumn &&
                        !(column === this.movableDiv._column && isFront)) {
                        i--;
                    }
                    var index = isFront ? Math.max(0, i) : Math.min(i + 1, count);
                    var position = isFront ? sumWidth : sumWidth + width;
                    position = Math.max(0, position - 1);
                    return {
                        index: index,
                        column: column,
                        position: position + 'px'
                    };
                }
                sumWidth += width;
            }
        }
        return this.columnInfo;
    }
});

twaver.controls.TablePane = function (table, tableHeader) {
    twaver.controls.TablePane.superClass.constructor.apply(this, arguments);
    this.invalidate();
    this._table = table;
    this._tableHeader = tableHeader ? tableHeader : new twaver.controls.TableHeader(table);
    this._view = $html.createView('hidden',true);
    this._view.tabIndex = -1;
    this._view.appendChild(this._tableHeader.getView());
    this._view.appendChild(this._table.getView());
    var self = this;
    this._tableHeader.addPropertyChangeListener(function (e) {
        if (e.property === 'height') {
            self.invalidate();
        }
    });
};
_twaver.ext('twaver.controls.TablePane', twaver.controls.ControlBase, {
    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getTable: function () {
        return this._table;
    },
    getTableHeader: function () {
        return this._tableHeader;
    },
    validateImpl: function () {
        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;
        var hh = this._tableHeader.getHeight();

        this._tableHeader.adjustBounds({ x: 0, y: 0, width: w, height: hh });
        this._table.adjustBounds({ x: 0, y: hh, width: w, height: Math.max(0, h - hh) });
    }
});

twaver.controls.TreeTable = function (dataBox) {
    this._treeColumn = new twaver.Column();
    this._treeColumn.setName('tree');
    this._treeColumn.setWidth(120);
    this._treeColumn.renderCell = this.renderTreeCell;
    this._treeColumn.getValue = this.getTreeValue;
    this._treeColumn.setValue = this.setTreeValue;

    this._initTree(dataBox);
    twaver.controls.TreeTable.superClass.constructor.apply(this, arguments);

    this._columnBox.add(this._treeColumn);
};
_twaver.ext('twaver.controls.TreeTable', twaver.controls.TableBase, {
    __tree: 1,

    __accessor: ['sortFunction', 'visibleFunction', 'checkMode', 'rootData', 'sortColumn',
        'indent', 'rowHeight', 'rowLineWidth', 'rowLineColor', 'columnLineWidth', 'columnLineColor',
        'expandIcon', 'collapseIcon', 'uncheckableStyle','lineType',
        'lineColor','lineThickness','lineAlpha','lineDash'],

    __bool: ['editable', 'rootVisible', 'makeVisibleOnSelected', 'keyboardRemoveEnabled', 'keyboardSelectEnabled'],

    _editable: $Defaults.TREETABLE_EDITABLE,
    _indent: $Defaults.TREETABLE_INDENT,
    _rowHeight: $Defaults.TREETABLE_ROW_HEIGHT,
    _rowLineWidth: $Defaults.TREETABLE_ROW_LINE_WIDTH,
    _rowLineColor: $Defaults.TREETABLE_ROW_LINE_COLOR,
    _columnLineWidth: $Defaults.TREETABLE_COLUMN_LINE_WIDTH,
    _columnLineColor: $Defaults.TREETABLE_COLUMN_LINE_COLOR,
    _makeVisibleOnSelected: $Defaults.TREETABLE_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: $Defaults.TREETABLE_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: $Defaults.TREETABLE_KEYBOARD_SELECT_ENABLED,
    _expandIcon: $Defaults.TREETABLE_EXPAND_ICON,
    _collapseIcon: $Defaults.TREETABLE_COLLAPSE_ICON,
    _lineType:$Defaults.TREE_LINE_TYPE,
    _lineColor:$Defaults.TREE_LINE_COLOR,
    _lineThickness:$Defaults.TREE_LINE_THICKNESS,
    _lineAlpha:$Defaults.TREE_LINE_ALPHA,
    _lineDash:$Defaults.TREE_LINE_DASH,

    getTreeColumn: function () {
        return this._treeColumn;
    },

    renderTreeCell: function (params) {
        params.view._renderTree(params.div, params.data, params.rowIndex, params.selected);
    },

    getTreeValue: function (data, table) {
        return table.getLabel(data);
    },

    setTreeValue: function (data, value, table) {
        data.setName(value);
    }
});

twaver.controls.PropertySheet = function (dataBox) {
    twaver.controls.PropertySheet.superClass.constructor.apply(this, arguments);
    this._currentRowIndex = -1;
    this._currentEditor = null;
    this._currentData = null;
    this._invalidate = false;

    this._resizeDiv = $html.createDiv();
    this._resizeDiv.style.backgroundColor = 'white';
    this._resizeDiv.style.opacity = 0;
    this._resizeDiv.style.top = '0px';

    //{'null', 'name1', 'name2' ...}
    this._categoryList = new $List();

    // { ... 'name1':{isExpanded:true, properties:list(prop1, prop2, prop3...)} ... }
    this._categoryMap = {};

    // {name1,{view:sheet, data:currentData, property:property, value:value, rowDiv:div, nameRender:div, valueRender:div}}
    this._rowList = new $List();

    this._propertyBox = new twaver.PropertyBox();
    this._propertyBox.addDataBoxChangeListener(this.invalidatePropertyBox, this);
    this._propertyBox.addDataPropertyChangeListener(this.invalidatePropertyBox, this);
    this._propertyBox.addHierarchyChangeListener(this.invalidatePropertyBox, this);

    this.__divPool = new twaver.Pool('div', 2);
    this.__cellPool = new twaver.Pool('div', 2);
    this.__imagePool = new twaver.Pool('img', 2);
    this.__textPool = new twaver.Pool('span', 2);
    this._stringPool = new twaver.Pool('span', 2);
    this._booleanPool = new twaver.Pool('input', 2);
    this._colorPool = new twaver.Pool('div', 2);

    this._pools.add(this.__divPool);
    this._pools.add(this.__cellPool);
    this._pools.add(this.__imagePool);
    this._pools.add(this.__textPool);
    this._pools.add(this._stringPool);
    this._pools.add(this._booleanPool);
    this._pools.add(this._colorPool);

    this._view = $html.createView('auto');
    this._rootDiv = $html.createDiv();
    this._dataDiv = $html.createDiv();

    this._view.appendChild(this._rootDiv);
    this._rootDiv.appendChild(this._dataDiv);

    this.setDataBox(dataBox ? dataBox : new twaver.DataBox());

    var self = this;
    this._view.addEventListener('change', function (e) {
        self.handleChange(e);
    }, false);

    if($ua.isTouchable){
      if($ua.isMSTouchable){
        new twaver.controls.PropertySheetMSTouchInteraction(this);
    }else{
        new twaver.controls.PropertySheetTouchInteraction(this);
        new twaver.controls.PropertySheetInteraction(this);
    }
}else{
  new twaver.controls.PropertySheetInteraction(this);
}

};
_twaver.ext('twaver.controls.PropertySheet', twaver.controls.View, {
    __accessor: ['indent', 'rowHeight', 'sumWidth', 'propertyNameWidth', 'propertyNameHorizontalAlign',
    'autoAdjustable', 'rowLineWidth', 'columnLineWidth', 'borderColor', 'categorizable', 'resizeTolerance',
    'editable', 'selectColor', 'expandIcon', 'collapseIcon', 'sortFunction', 'visibleFunction'],

    _autoAdjustable: $Defaults.PROPERTYSHEET_AUTO_ADJUSTABLE,
    _selectColor: $Defaults.SELECT_COLOR,
    _categorizable: $Defaults.PROPERTYSHEET_CATEGORIZABLE,
    _editable: $Defaults.PROPERTYSHEET_EDITABLE,
    _propertyNameWidth: $Defaults.PROPERTYSHEET_PROPERTY_NAME_WIDTH,
    _propertyNameHorizontalAlign: $Defaults.PROPERTYSHEET_PROPERTY_NAME_HORIZONTAL_ALIGN,
    _sumWidth: $Defaults.PROPERTYSHEET_SUM_WIDTH,
    _indent: $Defaults.PROPERTYSHEET_INDENT,
    _rowHeight: $Defaults.PROPERTYSHEET_ROW_HEIGHT,
    _rowLineWidth: $Defaults.PROPERTYSHEET_ROW_LINE_WIDTH,
    _columnLineWidth: $Defaults.PROPERTYSHEET_COLUMN_LINE_WIDTH,
    _borderColor: $Defaults.PROPERTYSHEET_BORDER_COLOR,
    _expandIcon: $Defaults.PROPERTYSHEET_EXPAND_ICON,
    _collapseIcon: $Defaults.PROPERTYSHEET_COLLAPSE_ICON,
    _resizeTolerance: $Defaults.PROPERTYSHEET_RESIZE_TOLERANCE,

    getPropertyBox: function () {
        return this._propertyBox;
    },
    getCurrentData: function () {
        return this._currentData;
    },
    getDataDiv: function () {
        return this._dataDiv;
    },
    getDataBox: function () {
        return this._box;
    },
    setDataBox: function (dataBox) {
        if (!dataBox) {
            throw "DataBox can not be null";
        }
        if (this._box === dataBox) {
            return;
        }
        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataPropertyChangeListener(this.handlePropertyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = dataBox;

        this._box.addDataPropertyChangeListener(this.handlePropertyChange, this);
        if (this._selectionModel) {
            this._selectionModel._setDataBox(dataBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }

        this.invalidate();
        this.firePropertyChange("dataBox", oldValue, this._box);
    },
    invalidatePropertyBox: function () {
        if (!this._isValidating) {
            this.invalidate();
        }
    },
    onPropertyChanged: function (e) {
        if (e.property !== 'zoom') {
            this.invalidate();
        }
    },
    isVisible: function (property) {
        if (property.isVisible && !property.isVisible(this._currentData, this)) {
            return false;
        }
        return this._visibleFunction ? this._visibleFunction(property) : true;
    },
    handlePropertyChange: function (e) {
        if (this._currentData === e.source) {
            this.invalidate();
        }
    },
    handleSelectionChange: function (e) {
        if (this._currentData !== this.getSelectionModel().getLastData()) {
            this._currentRowIndex = -1;
            this.invalidate();
        }
    },
    isExpanded: function (categoryName) {
        if (!categoryName) {
            return true;
        }
        var c = this._categoryMap[categoryName];
        return c ? c.isExpanded : $Defaults.PROPERTYSHEET_EXPAND_CATEGORY;
    },
    expand: function (categoryName) {
        if (!categoryName) {
            return;
        }
        var c = this._categoryMap[categoryName];
        if (!c || c.isExpanded) {
            return;
        }
        c.isExpanded = true;
        this.invalidate();
    },
    expandAll: function () {
        for (var n in this._categoryMap) {
            var c = this._categoryMap[n];
            if (c) {
                c.isExpanded = true;
            }
        }
        this.invalidate();
    },
    collapse: function (categoryName) {
        if (!categoryName) {
            return;
        }
        var c = this._categoryMap[categoryName];
        if (!c || !c.isExpanded) {
            return;
        }
        c.isExpanded = false;
        this.invalidate();
    },
    collapseAll: function () {
        for (var n in this._categoryMap) {
            var c = this._categoryMap[n];
            if (c) {
                c.isExpanded = false;
            }
        }
        this.invalidate();
    },
    getCategoryName: function (property) {
        if (!this.isCategorizable()) {
            return 'null';
        }
        var name = property.getCategoryName();
        return name ? name : 'null';
    },
    validateModel: function () {
        this._rowList.clear();
        this._categoryList.clear();
        var map = {};
        var list = new $List();
        var properties = this._currentData ? this._propertyBox.getRoots() : new $List();
        var i, j, name, count, property;
        count = properties.size();
        for (i = 0; i < count; i++) {
            property = properties.get(i);
            if (this.isVisible(property)) {
                list.add(property);
                name = this.getCategoryName(property);
                if (!map[name]) {
                    this._categoryList.add(name);
                    map[name] = {
                        isExpanded: this.isExpanded(name),
                        properties: new $List()
                    };
                }
            }
        }
        if (this._sortFunction) {
            list.sort(this._sortFunction);
        }
        this._categoryMap = map;
        count = list.size();

        for (i = 0; i < this._categoryList.size(); i++) {
            name = this._categoryList.get(i);
            if (name !== 'null') {
                this._rowList.add(name);
            }
            var obj = map[name];
            if (obj.isExpanded) {
                for (j = 0; j < count; j++) {
                    property = list.get(j);
                    if (this.getCategoryName(property) === name) {
                        obj.properties.add(property);
                        this._rowList.add({
                            view: this,
                            data: this._currentData,
                            property: property,
                            value: this._currentData ? this.getValue(this._currentData, property) : null
                        });

                    }
                }
            }
        }

    },
    adjustWidth: function () {
        var width = this._view.offsetWidth;
        var height = this._view.offsetHeight;
        if (width <= this._indent || height <= 0) {
            return;
        }
        width -= this._indent;
        if (this._rowList.size() * this._rowHeight > height) {
            width -= $Defaults.SCROLL_BAR_WIDTH;
            if (width <= 0) {
                return;
            }
        }
        if (this._sumWidth === 0 || this._propertyNameWidth > this._sumWidth) {
            this._propertyNameWidth = width / 2;
        } else {
            this._propertyNameWidth = width * (this._propertyNameWidth / this._sumWidth);
        }
        this._sumWidth = width;
        this._view.style.overflowX = 'hidden';
        this._view.style.overflowY = 'auto';
    },
    validateDisplay: function () {
        var count = this._rowList.size();
        var color = this._borderColor;
        var indent = this._indent;
        var rowHeight = this._rowHeight;
        var nameWidth = this._propertyNameWidth;
        var valueWidth = Math.max(0, this._sumWidth - nameWidth);
        var rowLineWidth = this._rowLineWidth;
        var columnLineWidth = this._columnLineWidth;
        var cellheightpx = rowHeight - rowLineWidth + 'px';
        var lineheightpx = rowHeight - rowLineWidth - 2 + 'px';
        var indentpx = indent + 'px';
        var namepx = nameWidth - columnLineWidth + 'px';
        var valuepx = valueWidth - columnLineWidth + 'px';
        var rowwidthpx = nameWidth + valueWidth + 'px';
        var rowlinepx = rowLineWidth + 'px';
        var columnlinepx = columnLineWidth + 'px';
        var valueleftpx = nameWidth + 'px';

        var parent = this._dataDiv;
        var style = parent.style;
        style.height = count * rowHeight + 'px';
        style.width = indent + nameWidth + valueWidth + 'px';

        var div = this.__divPool.get();
        style = div.style;
        style.position = 'absolute';
        style.left = '0px';
        style.top = '0px';
        style.width = indentpx;
        style.height = parent.style.height;
        style.borderWidth = '0px';
        style.backgroundColor = color;
        parent.appendChild(div);

        for (var i = 0; i < count; i++) {
            var rowInfo = this._rowList.get(i);
            var tpx = i * rowHeight + 'px';

            var rowDiv = this.__divPool.get();
            rowInfo.rowDiv = rowDiv;
            style = rowDiv.style;
            style.position = 'absolute';
            style.whiteSpace = 'nowrap';
            style.overflow = 'hidden';
            style.textOverflow = 'ellipsis';
            style.left = indentpx;
            style.top = tpx;
            style.width = rowwidthpx;
            style.height = cellheightpx;
            style.lineHeight = lineheightpx;
            style.borderStyle = 'solid';
            style.borderWidth = '0px';
            style.borderBottomWidth = rowlinepx;
            style.borderBottomColor = color;
            parent.appendChild(rowDiv);

            // category
            if (typeof rowInfo === 'string') {
                style.backgroundColor = color;

                div = this.__divPool.get();
                style = div.style;
                style.position = 'absolute';
                style.left = '0px';
                style.top = tpx;
                style.width = indentpx;
                style.height = cellheightpx;
                style.lineHeight = lineheightpx;
                style.borderWidth = '0px';
                parent.appendChild(div);

                var image = this.__imagePool.get();
                var toggleImage = this.isExpanded(rowInfo) ? this._expandIcon : this._collapseIcon;
                image.setAttribute('src', _twaver.getImageSrc(toggleImage));
                style = image.style;
                style.verticalAlign = 'middle';
                image._expandData = rowInfo;
                div.appendChild(image);

                this.renderCategory(rowDiv, rowInfo);
                this.onCategoryRendered(rowDiv, rowInfo);
            }

            // property
            else {
                var property = rowInfo.property;
                var cell = this.__cellPool.get();
                rowInfo.nameRender = cell;

                style = cell.style;
                if (this._currentRowIndex === i) {
                    style.backgroundColor = this.getSelectColor();
                }
                style.position = 'absolute';
                style.verticalAlign = 'middle';
                style.textAlign = this._propertyNameHorizontalAlign;
                style.overflow = 'hidden';
                style.textOverflow = 'ellipsis';
                style.whiteSpace = 'nowrap';
                style.left = '0px';
                style.top = '0px';
                style.width = namepx;
                style.height = cellheightpx;
                style.borderStyle = 'solid';
                style.borderWidth = '0px';
                style.borderRightWidth = columnlinepx;
                style.borderRightColor = color;
                rowDiv.appendChild(cell);

                this.renderName(rowInfo);
                this.onNameRendered(rowInfo);

                cell = this.__cellPool.get();
                rowInfo.valueRender = cell;

                style = cell.style;
                style.position = 'absolute';
                style.verticalAlign = 'middle';
                style.textAlign = property.getHorizontalAlign();
                style.whiteSpace = 'nowrap';
                style.overflow = 'hidden';
                style.textOverflow = 'ellipsis';
                style.left = valueleftpx;
                style.top = '0px';
                style.width = valuepx;
                style.height = cellheightpx;
                style.borderStyle = 'solid';
                style.borderWidth = '0px';
                style.borderRightWidth = columnlinepx;
                style.borderRightColor = color;
                rowDiv.appendChild(cell);

                this.renderValue(rowInfo);
                this.onValueRendered(rowInfo);
            }
        }

        style = this._resizeDiv.style;
        style.left = indent + nameWidth - columnLineWidth - this._resizeTolerance + 'px';
        style.width = columnLineWidth + this._resizeTolerance * 2 + 'px';
        style.height = parent.style.height;
        parent.appendChild(this._resizeDiv);
    },
    renderCategory: function (div, categoryName) {
        var text = this.__textPool.get();
        var style = text.style;
        style.fontWeight = 'bold';
        style.whiteSpace = 'nowrap';
        style.overflow = 'hidden';
        style.textOverflow = 'ellipsis';
        style.verticalAlign = 'middle';
        style.padding = '1px 2px 1px 2px';
        text.innerHTML = categoryName;
        text.setAttribute('title', categoryName);
        div.appendChild(text);
    },
    onCategoryRendered: function (div, categoryName) {

    },
    renderName: function (params) {
        if (params.property.renderName) {
            params.property.renderName(params);
            return;
        }
        var text = this.__textPool.get();
        var style = text.style;
        style.fontWeight = '';
        style.whiteSpace = 'nowrap';
        style.verticalAlign = 'middle';
        style.padding = '1px 2px 1px 2px';
        var name = params.property.getName();
        if (!name) {
            name = params.property.getPropertyName();
        }
        text.innerHTML = name;
        text.setAttribute('title', name);
        params.nameRender.appendChild(text);
    },
    onNameRendered: function (params) {

    },
    renderValue: function (params) {
        var property = params.property;
        if (property.renderValue) {
            property.renderValue(params);
            return;
        }
        var value = params.value;
        var enumInfo = property.getEnumInfo(this._currentData);
        if (enumInfo && !Array.isArray(enumInfo)) {
            value = enumInfo.map[value];
        }
        if (params.view.isCellEditable(params.data, property)) {
            params.enumInfo = enumInfo;
            params.valueRender._editInfo = params;
        }
        params.valueRender.innerHTML = '';
        $render.render(property.getValueType(), value, params.valueRender, params.view, property.isInnerText());
    },
    onValueRendered: function (params) {

    },
    renderEditor: function(params){

    },
    onEditorRendered: function(params){

    },
    updateCurrentData: function () {
        this._currentData = this.getSelectionModel().getLastData();
    },
    validateImpl: function () {
        var oldLeft = this._view.scrollLeft;
        var oldTop = this._view.scrollTop;

        $html.release(this._dataDiv);

        this.updateCurrentData();
        this.validateModel();
        if (this.isAutoAdjustable()) {
            this.adjustWidth();
        }
        this.validateDisplay();

        this._pools.forEach(function (pool) {
            pool.clear();
        });

        if (this._view.scrollLeft !== oldLeft) {
            this._view.scrollLeft = oldLeft;
        }
        if (this._view.scrollTop !== oldTop) {
            this._view.scrollTop = oldTop;
        }
    },
    getValue: function (data, property) {
        if (!data) {
            return null;
        }
        return property.getValue(data, this);
    },
    setValue: function (data, property, value) {
        if (!data) {
            return;
        }
        property.setValue(data, value, this);
    },
    isCellEditable: function (data, property) {
        if (!data) {
            return false;
        }
        return this.isEditable() && property.isEditable();
    },
    getRowIndexAt: function (e) {
        var point = this.getLogicalPoint(e);
        if (!point) {
            return -1;
        }
        var row = parseInt(point.y / this._rowHeight);
        return (row >= 0 && row < this._rowList.size()) ? row : -1;
    },
    handleChange: function (e) {
        if (this._isCommitting || this._isCanceling || this._isValidating) {
            return;
        }
        if (e.target._editInfo && this.commitEditValue) {
            this.commitEditValue(e.target._editInfo, e.target);
        }
    },
    commitEditValue: function (editInfo, target) {
        var value;
        if (target.type === 'checkbox') {
            value = target.checked;
        } else {
            value = target.value;
        }
        var property = editInfo.property;
        var type = property.getValueType();
        if (type === 'int' && typeof value === 'string') {
            value = parseInt(value);
        }
        else if (type === 'number' && typeof value === 'string') {
            value = parseFloat(value);
        }
        else if (type === 'array.string') {
            value = value.split(',');
        }
        else if (type === 'array.number') {
            value = value.split(',');
            for (var i = 0, c = value.length; i < c; i++) {
                value[i] = parseFloat(value[i]);
            }
        }else if(type === 'list.points') {
            var array = value.replace(/\]/g, "" ).replace(/\[/g, "" ).split(','); 
            var points = new twaver.List();
            for(var i = 0;i<array.length;i+=2){
                if(i+1 >= array.length) continue;
                points.add({x:parseInt(array[i]),y:parseInt(array[i+1])});
            }
            value = points;
        }

        if(target._rowInfo){
            target._rowInfo.value = value;
            this.renderValue(target._rowInfo);
        }
        this.setValue(editInfo.data, property, value);
        twaver.Util.setFocus(this._view);
        if (this._currentEditor) {
            // this._rootDiv.removeChild(this._currentEditor);
            var parentNode = this._currentEditor.parentNode;
            parentNode && parentNode.removeChild(this._currentEditor);
            delete this._currentEditor;
        }
        delete this._isCommitting;
    },
    cancelEditing: function () {
        if (this._currentEditor) {
            // this._rootDiv.removeChild(this._currentEditor);
            var parentNode = this._currentEditor.parentNode;
            parentNode && parentNode.removeChild(this._currentEditor);
            delete this._currentEditor;
            delete this._isCanceling;
        }
    },
    getEditorValue: function(rowInfo){
        var editInfo = rowInfo.valueRender._editInfo;
        var valueType = editInfo.property.getValueType();
        var value = rowInfo.valueRender._editInfo.value;
        var result = '';
        if(valueType === 'list.points'){
            var array = value._as ? value._as : value;
            array.forEach(function(a,index){
                result += index == (array.length -1)? '[' + a.x + ',' + a.y + ']' : '[' + a.x + ',' + a.y + '],';
            });
        }else{
            result = value;
        }
        return result;
    },
    updateCurrentRowIndex: function (newIndex) {
        var count = this._rowList.size();
        if (newIndex < 0 || newIndex >= count) {
            newIndex = -1;
        }
        var oldIndex = this._currentRowIndex,
        rowInfo;
        if (newIndex !== oldIndex) {
            // clear select background color
            if (oldIndex >= 0 && oldIndex < count) {
                rowInfo = this._rowList.get(oldIndex);
                if (rowInfo.nameRender) {
                    rowInfo.nameRender.style.backgroundColor = '';
                }
            }
            this._currentRowIndex = newIndex;
        }
        if (newIndex >= 0) {
            rowInfo = this._rowList.get(newIndex);
            if (rowInfo.nameRender) {
                // update select background color
                rowInfo.nameRender.style.backgroundColor = this.getSelectColor();
                // update current editor
                if (!this._currentEditor) {
                    if (rowInfo.valueRender && rowInfo.valueRender._editInfo) {
                        var editInfo = rowInfo.valueRender._editInfo;
                        var editor = this.renderEditor && this.renderEditor(rowInfo);
                        if(editor){
                            this._currentEditor = editor.view;
                            if (editInfo.value != null) {
                                // this._currentEditor.value = editInfo.value;
                                this._currentEditor.value = this.getEditorValue(rowInfo);
                            }
                        }else if (editInfo.enumInfo) {
                            this._currentEditor = $html.createSelect(editInfo.enumInfo, editInfo.value);
                        } else {
                            this._currentEditor = document.createElement('input');

                            if (editInfo.value != null) {
                                // this._currentEditor.value = editInfo.value;
                                this._currentEditor.value = this.getEditorValue(rowInfo);
                            }
                        }
                        var self = this;
                        if(rowInfo.property && rowInfo.property.renderEditor){
                            var editor = typeof rowInfo.property.renderEditor === 'function' ? rowInfo.property.renderEditor(self,rowInfo) : rowInfo.property.renderEditor;
                            if(editor){
                                self._currentEditor = editor;
                            }
                        }
                        if (this._currentEditor) {
                            if(editor && editor.onKeyDown){
                                var keydownEvents = editor.onKeyDown;
                                if(keydownEvents && Array.isArray(keydownEvents)){
                                    self._currentEditor.addEventListener('keydown', function (e) {
                                        for(var k = 0; k<keydownEvents.length; k++){
                                            if(keydownEvents[k].combKey){
                                                var evt = null;
                                                switch (keydownEvents[k].combKey){
                                                    case 'ctrlKey':
                                                    evt = e.ctrlKey;
                                                    break;
                                                    case 'shiftKey':
                                                    evt = e.shiftKey;
                                                    break;
                                                    case 'altKey':
                                                    evt = e.altKey;
                                                    break;
                                                }
                                                if(e.keyCode === keydownEvents[k].keyCode && evt){
                                                    keydownEvents[k].handlerEvent && keydownEvents[k].handlerEvent(e);
                                                }
                                            }else{
                                                if(e.keyCode === keydownEvents[k].keyCode){
                                                    keydownEvents[k].handlerEvent && keydownEvents[k].handlerEvent(e);
                                                } 
                                            }
                                        }
                                    });
                                } 
                            }else{
                                this._currentEditor.addEventListener('keydown', function (e) {
                                    var view = e.target._editInfo.view;
                                    if(e.keyCode === 13 && e.shiftKey){
                                        return;
                                    }else if (e.keyCode === 13) {
                                        if (view._isCommitting) {
                                            return;
                                        }
                                        view._isCommitting = true;
                                        view.commitEditValue(e.target._editInfo, e.target);
                                    } else if (e.keyCode === 27) {
                                        view._isCanceling = true;
                                        view.cancelEditing();
                                    }
                                }, false);
                            }
                            this._currentEditor.addEventListener('blur', function (e) {
                                var view = e.target._editInfo.view;
                                if (view._isCommitting || view._isCanceling) {
                                    return;
                                }
                                view._isCommitting = true;
                                view.commitEditValue(e.target._editInfo, e.target);
                            }, false);
                            this._currentEditor.keepDefault = true;
                            this._currentEditor._rowInfo = rowInfo;
                            this._currentEditor._editInfo = editInfo;
                            if(!this._currentEditor.parentNode){
                                var style = this._currentEditor.style;
                                style.position = 'absolute';
                                style.margin = '0px';
                                style.border = '0px';
                                style.padding = '0px';
                                style.left = this._indent + this._propertyNameWidth + 'px';
                                style.top = rowInfo.rowDiv.style.top;
                                style.width = rowInfo.valueRender.style.width;
                                style.height = rowInfo.valueRender.style.height;
                                this._rootDiv.appendChild(this._currentEditor);
                            }
                            twaver.Util.setFocus(this._currentEditor);
                            this.onEditorRendered && this.onEditorRendered(rowInfo);
                        }
                    }
                }
            }
        }
    }
});

twaver.controls.PropertySheetInteraction = function (propertySheet) {
    this.sheet = propertySheet;
    this.view = propertySheet._view;
    this.resizeDiv = propertySheet._resizeDiv;

    var self = this;
    this.view.addEventListener('mousedown', function (e) {
        if (e.button === 0) {
            self.handleMouseDown(e);
        }
    }, false);
    this.view.addEventListener('mousemove', function (e) {
        self.handleMouseMove(e);
    }, false);
};
_twaver.ext('twaver.controls.PropertySheetInteraction', Object, {
    minGap: 10,
    handleMouseDown: function (e) {
        if (e.target === this.sheet._currentEditor || e.target.parentNode === this.sheet._currentEditor) {
            return;
        }
        if (this.sheet.isFocusOnClick()) {
            twaver.Util.setFocus(this.view);
        }
        if (this.sheet._isValidating) {
            return;
        }
        if (e.target._expandData) {
            var name = e.target._expandData;
            if (this.sheet.isExpanded(name)) {
                this.sheet.collapse(name);
            } else {
                this.sheet.expand(name);
            }
        } else if (e.target === this.resizeDiv) {
            this.lastX = this.getX(e);
            $html.handle_mousedown(this, e);
        } else {
            if (this.sheet._currentEditor && !this.sheet._isCommitting) {
                this.sheet._isCommitting = true;
                this.sheet.commitEditValue(this.sheet._currentEditor._editInfo, this.sheet._currentEditor);
            }
            var newIndex = this.sheet.getRowIndexAt(e);
            this.sheet.updateCurrentRowIndex(newIndex);
        }
    },
    handleMouseMove: function (e) {
        if (this.lastX == null && !$html.target) {
            this.changeCursor(e);
            return;
        }
        if ($html.target !== this || this.lastX == null) {
            return;
        }
        var x = this.getX(e);
        if (this.stopLeft != null) {
            if (x < this.stopLeft) {
                return;
            } else {
                delete this.stopLeft;
            }
        }
        if (this.stopRight != null) {
            if (x > this.stopRight) {
                return;
            } else {
                delete this.stopRight;
            }
        }
        var w = this.sheet.getPropertyNameWidth() + (x - this.lastX);
        if (w < this.minGap) {
            w = this.minGap;
            this.stopLeft = x;
        }
        else if (w > this.sheet.getSumWidth() - this.minGap) {
            w = this.sheet.getSumWidth() - this.minGap;
            this.stopRight = x;
        }
        this.sheet.setPropertyNameWidth(w);
        this.lastX = x;
    },
    handleMouseUp: function (e) {
        if (e.button !== 0) {
            return;
        }
        this.view.style.cursor = 'default';
        delete this.stopLeft;
        delete this.stopRight;
        delete this.lastX;
    },
    changeCursor: function (e) {
        this.view.style.cursor = e.target === this.resizeDiv ? 'ew-resize' : 'default';
    },
    getX: function (e) {
        return e.clientX / this.sheet.getZoom();
    }
});

twaver.controls.PropertySheetTouchInteraction = function (propertySheet) {
    this.sheet = propertySheet;
    this.view = propertySheet._view;
    this.resizeDiv = propertySheet._resizeDiv;

    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.controls.PropertySheetTouchInteraction', Object, {
    minGap: 10,
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (e.target === this.sheet._currentEditor || e.target.parentNode === this.sheet._currentEditor) {
            return;
        }
        if (this.sheet.isFocusOnClick()) {
            twaver.Util.setFocus(this.view);
        }
        if (this.sheet._isValidating) {
            return;
        }
        if (e.target === this.resizeDiv) {
            this.lastX = this.getX(e);
        }
        this.lastPoint = this.sheet.getLogicalPoint(e);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.zoom = this.sheet.getZoom();
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if (!this.moved) {
            this.moved = true;
        }
        if (this.lastX == null) {
            if ($touch.isSingleTouch(e)) {
                if (this.lastPoint) {
                    var newPoint = this.sheet.getLogicalPoint(e);
                    var xoffset = this.lastPoint.x - newPoint.x;
                    var yoffset = this.lastPoint.y - newPoint.y;
                    var result = this.sheet.panByOffset(xoffset, yoffset);
                    this.lastPoint.x -= (xoffset - result.x);
                    this.lastPoint.y -= (yoffset - result.y);
                }
            } else {
                if (this.distance) {
                    var scale = $touch.getDistance(e) / this.distance;
                    this.sheet.setZoom(this.zoom * scale, false);
                }
            }
            return;
        }
        var x = this.getX(e);
        if (this.stopLeft != null) {
            if (x < this.stopLeft) {
                return;
            } else {
                delete this.stopLeft;
            }
        }
        if (this.stopRight != null) {
            if (x > this.stopRight) {
                return;
            } else {
                delete this.stopRight;
            }
        }
        var w = this.sheet.getPropertyNameWidth() + (x - this.lastX);
        if (w < this.minGap) {
            w = this.minGap;
            this.stopLeft = x;
        }
        else if (w > this.sheet.getSumWidth() - this.minGap) {
            w = this.sheet.getSumWidth() - this.minGap;
            this.stopRight = x;
        }
        this.sheet.setPropertyNameWidth(w);
        this.lastX = x;
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        if (!this.moved) {
            if (e.target._expandData) {
                var name = e.target._expandData;
                if (this.sheet.isExpanded(name)) {
                    this.sheet.collapse(name);
                } else {
                    this.sheet.expand(name);
                }
            }
            else if (e.target === this.resizeDiv) {
            }
            else {
                var newIndex = this.sheet.getRowIndexAt(e);
                this.sheet.updateCurrentRowIndex(newIndex);
            }
        }
        delete this.stopLeft;
        delete this.stopRight;
        delete this.lastX;
        delete this.lastPoint;
        delete this.distance;
        delete this.zoom;
        delete this.moved;
        $html.removeEventListener('touchmove', this.view, this);
        $html.removeEventListener('touchend', this.view, this);
    },
    getX: function (e) {
        var touch = e.changedTouches[0];
        return touch.clientX;
    }
});

twaver.controls.PropertySheetMSTouchInteraction = function (propertySheet) {
    this.sheet = propertySheet;
    this.view = propertySheet._view;
    this.resizeDiv = propertySheet._resizeDiv;

    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.view, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.view, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.view, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.view, this);
    this.superHandleMouseDown = twaver.controls.PropertySheetMSTouchInteraction.superClass.handleMouseDown;
};
_twaver.ext('twaver.controls.PropertySheetMSTouchInteraction', twaver.controls.PropertySheetInteraction, {
    handleMouseDown: function (e) {},
    handleTouchstart: function (e) {
        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }

        if (!this._pointerMap[e.pointerId] && this.sheet.getLogicalPoint(e) != null) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        if (this._pointerIdArray.length == 1 && e.pointerType == e.MSPOINTER_TYPE_MOUSE) {
            this.superHandleMouseDown(e);
        }

        if (this._pointerIdArray.length == 1) {
            this._startTouchPoint = this.sheet.getLogicalPoint(e);
            this._startTouchTime = new Date();
        }
        else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.sheet.getZoom();
        }
    },
    handleTouchmove: function (e) {
        if (this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.sheet.setZoom(this._zoom * scale, false);
        } else if (this._pointerIdArray.length == 1 && e.pointerType != e.MSPOINTER_TYPE_MOUSE) {
            if (this._startTouchPoint) {
                var newPoint = this.sheet.getLogicalPoint(e);
                if (newPoint == null) {
                    return
                };
                var xoffset = this._startTouchPoint.x - newPoint.x;
                var yoffset = this._startTouchPoint.y - newPoint.y;
                var result = this.sheet.panByOffset(xoffset, yoffset);
                this._startTouchPoint.x -= (xoffset - result.x);
                this._startTouchPoint.y -= (yoffset - result.y);
            }
        }
    },
    handleTouchend: function (e) {
        if (this._pointerIdArray.length == 1 && e.pointerType != e.MSPOINTER_TYPE_MOUSE) {
            var currentTouchPoint = this.sheet.getLogicalPoint(e);
            var currentTouchTime = new Date();
            if (currentTouchTime.getTime() - this._startTouchTime.getTime() <= 500
                && $math.getDistance(this._startTouchPoint, currentTouchPoint) <= 20) {
                this.superHandleMouseDown(e);
            }
        }
        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.controls.SplitPane = function (firstView, nextView, orientation, position) {
    twaver.controls.SplitPane.superClass.constructor.apply(this, arguments);
    this._view = $html.createView('hidden', true);
    this._view.tabIndex = -1;
    this._dividerDiv = $html.createDiv();
    this._dividerDiv.tabIndex = -1;
    this._isPercentPosition = true;
    this._view.appendChild(this._dividerDiv);

    if (firstView) this.setFirstView(firstView);
    if (nextView) this.setNextView(nextView);
    if (orientation) this.setOrientation(orientation); 
    if (position > 1) 
        this._isPercentPosition = false;
    if (position != null) this.setPosition(position, this._isPercentPosition);
    this.setDividerDraggable(true);
    this.setExpandable(false),

    this.invalidate();

    if ($ua.isTouchable) {
        new twaver.controls.SplitPaneTouchInteraction(this);
    }
    new twaver.controls.SplitPaneInteraction(this);

};
_twaver.ext('twaver.controls.SplitPane', twaver.controls.ControlBase, {
    __accessor: ['orientation', 'dividerWidth', 'dividerBackground', 'dividerOpacity', 'maskBackground', 'upExpandIcon','downExpandIcon','leftExpandIcon','rightExpandIcon'],
    __bool: ['dividerDraggable','expandable'],
    _position: $Defaults.SPLITPANE_POSITION, // 0 ~ 1
    _orientation: $Defaults.SPLITPANE_ORIENTATION, // 'horizontal' 'vertical'
    _dividerWidth: $Defaults.SPLITPANE_DIVIDER_WIDTH,
    _dividerBackground: $Defaults.SPLITPANE_DIVIDER_BACKGROUND,
    _dividerOpacity: $Defaults.SPLITPANE_DIVIDER_OPACITY,
    _maskBackground: $Defaults.SPLITPANE_MASK_BACKGROUND,
    _upExpandIcon:$Defaults.SPLITPANE_UP_EXPAND_ICON,
    _downExpandIcon:$Defaults.SPLITPANE_DOWN_EXPAND_ICON,
    _leftExpandIcon:$Defaults.SPLITPANE_LEFT_EXPAND_ICON,
    _rightExpandIcon:$Defaults.SPLITPANE_RIGHT_EXPAND_ICON,

    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getDividerDiv: function () {
        return this._dividerDiv;
    },
    getPosition: function () {
        return this._position;
    },
    setPosition: function (value,isPercentPosition) {
        if(isPercentPosition) {
            if (value < 0) value = 0;
        }
        if (value === this._position) {
            return;
        }
        var oldValue = this._position;
        this._position = value;
        this.firePropertyChange('position', oldValue, value);
        if(this.lastDividerLocation == null){
          this.lastDividerLocation = value;
      }
  },
  setFirstView: function (value) {
    if (this._firstView === value) {
        return;
    }
    var oldValue = this._firstView;
    if (oldValue) {
        if (oldValue.getView) {
            this._view.removeChild(oldValue.getView());
        } else {
            this._view.removeChild(oldValue);
        }
    }
    this._firstView = value;
    if (value) {
        if (value.getView) {
            this._view.insertBefore(value.getView(), this._dividerDiv);
        } else {
            this._view.insertBefore(value, this._dividerDiv);
        }
    }
    this.firePropertyChange('firstView', oldValue, value);
},
getFirstView: function () {
    return this._firstView;
},
setNextView: function (value) {
    if (this._nextView === value) {
        return;
    }
    var oldValue = this._nextView;
    if (oldValue) {
        if (oldValue.getView) {
            this._view.removeChild(oldValue.getView());
        } else {
            this._view.removeChild(oldValue);
        }
    }
    this._nextView = value;
    if (value) {
        if (value.getView) {
            this._view.insertBefore(value.getView(), this._dividerDiv);
        } else {
            this._view.insertBefore(value, this._dividerDiv);
        }
    }
    this.firePropertyChange('nextView', oldValue, value);
},
getNextView: function () {
    return this._nextView;
},
validateImpl: function () {
    var p = this._position;
    var w = this._view.offsetWidth;
    var h = this._view.offsetHeight;
    var s = this._dividerWidth;
    var expandDiv;
    var btnCtx;

    if (s >= 8 || s === 0) {
        if (this._coverDiv) {
            this._dividerDiv.removeChild(this._coverDiv);
            delete this._coverDiv;
        }
    } else {
        if (!this._coverDiv) {
            this._coverDiv = $html.createDiv();
            this._coverDiv.tabIndex = -1;
            this._dividerDiv.appendChild(this._coverDiv);
        }
    }

        // 
        // First View || Next View
        //


        if (this._orientation === 'horizontal') {
            if (s > w) s = w;
            if (this._isPercentPosition) {
               var w1 = (w - s) * p;
           } else {
               var w1 = p;
           }
           var w2 = w - s - w1 + 1;
           _twaver.setViewBounds(this._firstView, { x: 0, y: 0, width: w1, height: h });
           _twaver.setViewBounds(this._nextView, { x: w1 + s, y: 0, width: w2, height: h });
           _twaver.setViewBounds(this._dividerDiv, { x: w1, y: 0, width: s, height: h });
           this._dividerDiv.position = w1;

           if (this._coverDiv) {
            _twaver.setViewBounds(this._coverDiv, { x: s / 2 - 4, y: 0, width: 8, height: h });
        }
        if(this._expandable){
          if(!this._expandCvs1){
            expandDiv = _twaver.html.createDiv();
            expandDiv.tabIndex = -1;
            _twaver.setViewBounds(expandDiv, { x: 0, y: 0, width: s, height: 11 });
            this._expandCvs1 = _twaver.html.createImg(_twaver.getImageSrc(this._leftExpandIcon));
            this._expandCvs1.style.left = (s/2 -3) +"px";
            expandDiv.appendChild(this._expandCvs1);
            this._dividerDiv.appendChild(expandDiv); 
        }
        if(!this._expandCvs2){
            expandDiv = _twaver.html.createDiv();
            expandDiv.tabIndex = -1;
            _twaver.setViewBounds(expandDiv, { x: 0, y: 15, width: s, height: 11 });
            this._expandCvs2 = _twaver.html.createImg(_twaver.getImageSrc(this._rightExpandIcon)); 
            this._expandCvs2.style.left = (s/2 -3) +"px";            
            expandDiv.appendChild(this._expandCvs2);                               
            this._dividerDiv.appendChild(expandDiv);
        }
    }
}

        // First View
        // ==========
        // Next View
        else {
            if (s > h) s = h;
            if (this._isPercentPosition) {
               var h1 = (h - s) * p;
           } else {
               var h1 = p;
           }
            //var h1 = (h - s) * p;
            //var h1 = p;
            var h2 = h - s - h1;
            _twaver.setViewBounds(this._firstView, { x: 0, y: 0, width: w, height: h1 });
            _twaver.setViewBounds(this._nextView, { x: 0, y: h1 + s, width: w, height: h2 });
            _twaver.setViewBounds(this._dividerDiv, { x: 0, y: h1, width: w, height: s });
            this._dividerDiv.position = h1;

            if (this._coverDiv) {
                _twaver.setViewBounds(this._coverDiv, { x: 0, y: s / 2 - 4, width: w, height: 8 });
            }
            if(this._expandable){
              if(!this._expandCvs1){
                expandDiv = _twaver.html.createDiv();
                expandDiv.tabIndex = -1;
                _twaver.setViewBounds(expandDiv, { x: 0, y: 0, width: 11, height: s });
                this._expandCvs1 = _twaver.html.createImg(_twaver.getImageSrc(this._upExpandIcon));
                this._expandCvs1.style.top = (s/2 -3) +"px";
                expandDiv.appendChild(this._expandCvs1);
                this._dividerDiv.appendChild(expandDiv);  
            } 
            if(!this._expandCvs2){
                expandDiv = _twaver.html.createDiv();
                expandDiv.tabIndex = -1;
                _twaver.setViewBounds(expandDiv, { x: 15, y: 0, width: 11, height: s });
                this._expandCvs2 = _twaver.html.createImg(_twaver.getImageSrc(this._downExpandIcon));
                this._expandCvs2.style.top = (s/2 -3) +"px";
                expandDiv.appendChild(this._expandCvs2);
                this._dividerDiv.appendChild(expandDiv);
            }          
        }
    }
    var style = this._dividerDiv.style;
    style.background = this._dividerBackground;
   
}
});

twaver.controls.SplitPaneInteraction = function (splitPane) {
    this.splitPane = splitPane;
    this.view = splitPane._view;
    this.dividerDiv = splitPane._dividerDiv;
    this.isPercentPosition = splitPane._isPercentPosition;

    var self = this;
    this.view.addEventListener('mousedown', function (e) {
        if (e.button === 0) {
            self.handleMouseDown(e);
        }
    }, false);
    this.view.addEventListener('mousemove', function (e) {
        self.handleMouseMove(e);
    }, false);
};
_twaver.ext('twaver.controls.SplitPaneInteraction', Object, {
    handleMouseDown: function (e) {
        if(this.splitPane.isExpandable()){
          var s = this.splitPane._dividerWidth;
          var w,h;
          if(e.target === this.splitPane._expandCvs1){
            if(this.splitPane._orientation === "horizontal"){
              w = this.view.clientWidth;
              if (s > w) s = w;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(0);
              }else if(this.splitPane.lastDividerLocation < this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }else{
              h = this.view.clientHeight;
              if (s > h) s = h;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(0);
              }else if(this.splitPane.lastDividerLocation < this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }
            return;
          }else if(e.target === this.splitPane._expandCvs2){
            if(this.splitPane._orientation === "horizontal"){
              w = this.view.clientWidth;
              if (s > w) s = w;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(1);
              }else if(this.splitPane.lastDividerLocation > this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }else{
              h = this.view.clientHeight;
              if (s > h) s = h;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(1);
              }else if(this.splitPane.lastDividerLocation > this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }
            return;
          }
        }
        if (!this.splitPane.isDividerDraggable()) return;
        if (this.resizeDiv) {
            this.clear(e);
        } else if (e.target === this.dividerDiv || e.target === this.splitPane._coverDiv) {
            this.resizeDiv = $html.createDiv();
            var style = this.resizeDiv.style;
            style.left = this.dividerDiv.style.left;
            style.top = this.dividerDiv.style.top;
            style.width = this.dividerDiv.style.width;
            style.height = this.dividerDiv.style.height;
            style.opacity = this.splitPane.getDividerOpacity();
            style.background = this.splitPane.getDividerBackground();
            this.resizeDiv.lastPosition = this.splitPane._orientation === 'horizontal' ? e.clientX : e.clientY;

            this.resizeDiv.maskDiv = $html.createDiv();
            style = this.resizeDiv.maskDiv.style;
            style.left = '0px';
            style.top = '0px';
            style.width = this.view.clientWidth + 'px';
            style.height = this.view.clientHeight + 'px';
            style.background = this.splitPane.getMaskBackground();

            this.view.appendChild(this.resizeDiv.maskDiv);
            this.view.appendChild(this.resizeDiv);

            $html.handle_mousedown(this, e);
            e.preventDefault();
        }
    },
    handleMouseMove: function (e) {
        if(this.splitPane.isExpandable()){
          if(e.target === this.splitPane._expandCvs1 || e.target === this.splitPane._expandCvs2){
            return;
          }
        }
        if (!this.splitPane.isDividerDraggable()) return;
        if (!this.resizeDiv && !$html.target) {
            var cursor = this.splitPane._orientation === 'horizontal' ? 'ew-resize' : 'ns-resize';
            this.view.style.cursor = e.target === this.dividerDiv || e.target === this.splitPane._coverDiv ? cursor : 'default';
        } else if (this.resizeDiv && $html.target === this) {
            if (this.splitPane._orientation === 'horizontal') {
                this.resizeDiv.style.left = this.dividerDiv.position + e.clientX - this.resizeDiv.lastPosition + 'px';
            } else {
                this.resizeDiv.style.top = this.dividerDiv.position + e.clientY - this.resizeDiv.lastPosition + 'px';
            }
        }
    },
    handleMouseUp: function (e) {
        if(this.splitPane.isExpandable()){
          if(e.target === this.splitPane._expandCvs1 || e.target === this.splitPane._expandCvs2){
            return;
          }
        }
        if (!this.splitPane.isDividerDraggable()) return;
        if (e.button === 0) {
            this.clear(e);
        }
    },
    clear: function (e) {
        if (this.resizeDiv) {
            var s = this.splitPane._dividerWidth,
            	v;
            // 
            // First View || Next View
            //
            if (this.splitPane._orientation === 'horizontal') {
                var w = this.view.clientWidth;
                if (s > w) s = w;
                v = this.dividerDiv.position + e.clientX - this.resizeDiv.lastPosition;
                if (this.isPercentPosition) {
                  this.splitPane.setPosition(v / (w - s));
                } else {
                  
                  this.splitPane.setPosition(v);
                }
            }
            // First View
            // ==========
            // Next View
            else {
                var h = this.view.clientHeight;
                if (s > h) s = h;
                v = this.dividerDiv.position + e.clientY - this.resizeDiv.lastPosition;
                if (this.isPercentPosition) {
                  this.splitPane.setPosition(v / (h - s));
                } else {
                  this.splitPane.setPosition(v);
                }
            }
            this.splitPane.lastDividerLocation = this.splitPane.getPosition();
            this.view.removeChild(this.resizeDiv.maskDiv);
            this.view.removeChild(this.resizeDiv);
            delete this.resizeDiv;
        }
    }
});

twaver.controls.SplitPaneTouchInteraction = function (splitPane) {
    this.splitPane = splitPane;
    this.view = splitPane._view;
    this.dividerDiv = splitPane._dividerDiv;
    this.isPercentPosition = splitPane._isPercentPosition;

    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.controls.SplitPaneTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if(this.splitPane.isExpandable()){
          var s = this.splitPane._dividerWidth;
          var w,h;
          if(e.target === this.splitPane._expandCvs1){
            if(this.splitPane._orientation === "horizontal"){
              w = this.view.clientWidth;
              if (s > w) s = w;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(0);
              }else if(this.splitPane.lastDividerLocation < this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }else{
              h = this.view.clientHeight;
              if (s > h) s = h;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(0);
              }else if(this.splitPane.lastDividerLocation < this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }
            return;
          }else if(e.target === this.splitPane._expandCvs2){
            if(this.splitPane._orientation === "horizontal"){
              w = this.view.clientWidth;
              if (s > w) s = w;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(1);
              }else if(this.splitPane.lastDividerLocation > this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }else{
              h = this.view.clientHeight;
              if (s > h) s = h;
              if(this.splitPane.lastDividerLocation === this.splitPane.getPosition()){
                this.splitPane.setPosition(1);
              }else if(this.splitPane.lastDividerLocation > this.splitPane.getPosition()){
                this.splitPane.setPosition(this.splitPane.lastDividerLocation);
                this.splitPane.lastDividerLocation = this.splitPane.getPosition();
              }
            }
            return;
          }
        }
        if (this.resizeDiv) {
            this.clear(e);
        } else if (e.target === this.dividerDiv || e.target === this.splitPane._coverDiv) {
            this.resizeDiv = $html.createDiv();
            var style = this.resizeDiv.style;
            style.left = this.dividerDiv.style.left;
            style.top = this.dividerDiv.style.top;
            style.width = this.dividerDiv.style.width;
            style.height = this.dividerDiv.style.height;
            style.opacity = this.splitPane.getDividerOpacity();
            style.background = this.splitPane.getDividerBackground();
            var touch = e.changedTouches[0];
            this.resizeDiv.lastPosition = this.splitPane._orientation === 'horizontal' ? touch.clientX : touch.clientY;

            this.resizeDiv.maskDiv = $html.createDiv();
            var style = this.resizeDiv.maskDiv.style;
            style.left = '0px';
            style.top = '0px';
            style.width = this.view.clientWidth + 'px';
            style.height = this.view.clientHeight + 'px';
            style.background = this.splitPane.getMaskBackground();

            this.view.appendChild(this.resizeDiv.maskDiv);
            this.view.appendChild(this.resizeDiv);
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if(this.splitPane.isExpandable()){
          if(e.target === this.splitPane._expandCvs1 || e.target === this.splitPane._expandCvs2){
            return;
          }
        }
        if (!this.resizeDiv) {
        } else {
            var touch = e.changedTouches[0];
            if (this.splitPane._orientation === 'horizontal') {
                this.resizeDiv.style.left = this.dividerDiv.position + touch.clientX - this.resizeDiv.lastPosition + 'px';
            } else {
                this.resizeDiv.style.top = this.dividerDiv.position + touch.clientY - this.resizeDiv.lastPosition + 'px';
            }
        }
    },
    handleTouchend: function (e) {
        if(this.splitPane.isExpandable()){
          if(e.target === this.splitPane._expandCvs1 || e.target === this.splitPane._expandCvs2){
            return;
          }
        }
        $html.removeEventListener('touchmove', this.view, this);
        $html.removeEventListener('touchend', this.view, this);
        this.clear(e);
    },
    clear: function (e) {
        var touch = e.changedTouches[0];
        if (this.resizeDiv) {
            var s = this.splitPane._dividerWidth;
            // 
            // First View || Next View
            //
            if (this.splitPane._orientation === 'horizontal') {
                var w = this.view.clientWidth;
                if (s > w) s = w;
                var v = this.dividerDiv.position + touch.clientX - this.resizeDiv.lastPosition;
                if (this.isPercentPosition) {
                  this.splitPane.setPosition(v / (w - s));
                } else {
                
                  this.splitPane.setPosition(v);
                }
            }
            // First View
            // ==========
            // Next View
            else {
                var h = this.view.clientHeight;
                if (s > h) s = h;
                var v = this.dividerDiv.position + touch.clientY - this.resizeDiv.lastPosition;
                if (this.isPercentPosition) {
                  this.splitPane.setPosition(v / (h - s));
                } else {
                  this.splitPane.setPosition(v);
                }
            }
            this.splitPane.lastDividerLocation = this.splitPane.getPosition();
            this.view.removeChild(this.resizeDiv.maskDiv);
            this.view.removeChild(this.resizeDiv);
            delete this.resizeDiv;
        }
    }
});

twaver.controls.TabPane = function () {
    twaver.controls.TabPane.superClass.constructor.apply(this, arguments);
    this._tabBox = new twaver.TabBox();
    this._tabBox.addDataBoxChangeListener(this.handleTabChange, this);
    this._tabBox.addDataPropertyChangeListener(this.handleTabChange, this);
    this._tabBox.addHierarchyChangeListener(this.handleTabChange, this);
    this._tabBox.getSelectionModel().addSelectionChangeListener(this.handleTabChange, this);

    this._view = $html.createView('hidden', true);
    this._tabDiv = $html.createDiv();
    this._tabDiv.onmousedown = $html.preventDefault;
    this._tabDiv.onkeydown = $html.preventDefault;

    this._contentDiv = $html.createDiv();
    this._view.appendChild(this._tabDiv);
    this._view.appendChild(this._contentDiv);

    this._divPool = new twaver.Pool('div');
    this._iconPool = new twaver.Pool('img');
    this._closePool = new twaver.Pool('img');
    this._textPool = new twaver.Pool('span');
    this._resizePool = new twaver.Pool('div');

    this._pools.add(this._divPool);
    this._pools.add(this._iconPool);
    this._pools.add(this._closePool);
    this._pools.add(this._textPool);
    this._pools.add(this._resizePool);

    this.invalidateTab();
    if ($ua.isTouchable) {
        new twaver.controls.TabPaneTouchInteraction(this);
    }
    new twaver.controls.TabPaneInteraction(this);
};
_twaver.ext('twaver.controls.TabPane', twaver.controls.ControlBase, {
    __accessor: ['tabGap', 'tabRadius', 'tabHeight', 'horizontalAlign', 'tabOrientation', 'resizeTolerance',
                 'tabBackground', 'selectBackground', 'moveBackground', 'insertBackground', 'closeIcon', 'disabledColor'],
    __bool: ['selectNextOnClose', 'selectNextOnInVisible'],

    _tabGap: $Defaults.TABPANE_TAB_GAP,
    _tabRadius: $Defaults.TABPANE_TAB_RADIUS,
    _tabHeight: $Defaults.TABPANE_TAB_HEIGHT,
    _resizeTolerance: $Defaults.TABPANE_RESIZE_TOLERANCE,
    _tabOrientation: $Defaults.TABPANE_TAB_ORIENTATION,
    _tabBackground: $Defaults.TABPANE_TAB_BACKGROUND,
    _disabledColor: $Defaults.TABPANE_DISABLED_COLOR,
    _selectBackground: $Defaults.TABPANE_SELECT_BACKGROUND,
    _moveBackground: $Defaults.TABPANE_MOVE_BACKGROUND,
    _insertBackground: $Defaults.TABPANE_INSERT_BACKGROUND,
    _horizontalAlign: $Defaults.TABPANE_HORIZONTAL_ALIGN,
    _closeIcon: $Defaults.TABPANE_CLOSE_ICON,
    _selectNextOnClose: $Defaults.TABPANE_SELECT_NEXT_ON_CLOSE,
    _selectNextOnInVisible: $Defaults.TABPANE_SELECT_NEXT_ON_INVISIBLE,

    onPropertyChanged: function (e) {
        this.invalidateTab();
    },
    getTabBox: function () {
        return this._tabBox;
    },
    getTabDiv: function () {
        return this._tabDiv;
    },
    getContentDiv: function () {
        return this._contentDiv;
    },
    handleTabChange: function (e) {
        if (this._selectNextOnInVisible
    			&& e.property === 'visible'
    			&& !e.newValue
    			&& this._tabBox.getSelectionModel().contains(e.source)) {
            var tab = e.source,
    			index = this._tabBox.getRoots().indexOf(tab),
    			roots = this._tabBox.getRoots(),
    			size = roots.size(),
    			next = index, nextTab, selectedTab;
            while (next < size - 1) {
                nextTab = roots.get(++next);
                if (nextTab.isVisible() && !nextTab.isDisabled()) {
                    selectedTab = nextTab;
                    break;
                }
            }
            if (!selectedTab) {
                next = index;
                while (next > 0) {
                    nextTab = roots.get(--next);
                    if (nextTab.isVisible() && !nextTab.isDisabled()) {
                        selectedTab = nextTab;
                        break;
                    }
                }
            }
            this._tabBox.getSelectionModel().setSelection(selectedTab);
        }
        this.invalidateTab();
    },
    invalidateTab: function (delay) {
        if (!this._invalidateTab) {
            this._invalidateTab = true;
            this.invalidate(delay);
        }
    },
    validateImpl: function () {
        if (this._invalidateTab) {
            this._invalidateTab = false;
            this.validateTab();
        }
        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;

        var rect;
        if (this._tabOrientation === 'top') {
            this._tabDiv.style.top = '0px';
            rect = { x: 0, y: this._tabHeight, width: w, height: Math.max(0, h - this._tabHeight) };
        }
        else {
            this._tabDiv.style.top = h - this._tabHeight + 'px';
            rect = { x: 0, y: 0, width: w, height: Math.max(0, h - this._tabHeight) };
        }
        if (this._currentView) {
            _twaver.setViewBounds(this._currentView, rect);
        }
    },
    getCurrentTab: function () {
        return this._currentTab;
    },
    getCurrentView: function () {
        return this._currentView;
    },
    onViewRemoved: function (view) {

    },
    onViewAdded: function (view) {

    },
    validateTab: function () {
        this._currentTab = this._tabBox.getSelectionModel().getLastData();
        var view = this._currentTab ? this._currentTab.getView() : null;
        if (view !== this._currentView) {
            var oldUi, newUi;
            if (this._currentView) {
                oldUi = this._currentView.getView ? this._currentView.getView() : this._currentView;
                oldUi.style.visibility = 'hidden';
                this.onViewRemoved(this._currentView);
            }
            if (view) {
                newUi = view.getView ? view.getView() : view;
                newUi.style.visibility = 'inherit';
                if (!newUi.parentNode) {
                    this._contentDiv.appendChild(newUi);
                }
                this.onViewAdded(view);
            }
            this._currentView = view;
        }

        $html.release(this._tabDiv);

        var tabs = this._tabBox.getRoots();
        var hpx = this._tabHeight + 'px';
        var lhpx = this._tabHeight - 2 + 'px';
        var rpx = this._tabRadius + 'px';
        var count = tabs.size();
        var sumWidth = 0;

        for (var i = 0; i < count; i++) {
            var tab = tabs.get(i);
            if (tab.isVisible()) {
                var selected = this._currentTab === tab;

                var width = tab.getWidth();
                if (width < 0) width = 0;
                var gap = Math.min(this._tabGap, width);

                var div = this._divPool.get();
                div._tab = tab;

                var style = div.style;
                style.position = 'absolute';
                style.whiteSpace = 'nowrap';
                style.lineHeight = lhpx;
                style.overflow = 'hidden';
                style.textOverflow = 'ellipsis';
                style.background = selected ? this._selectBackground : this._tabBackground;
                style.textAlign = this._horizontalAlign;

                if (this._tabOrientation === 'top') {
                    style.borderTopLeftRadius = rpx;
                    style.borderTopRightRadius = rpx;
                    style.borderBottomLeftRadius = '0px';
                    style.borderBottomRightRadius = '0px';
                } else {
                    style.borderTopLeftRadius = '0px';
                    style.borderTopRightRadius = '0px';
                    style.borderBottomLeftRadius = rpx;
                    style.borderBottomRightRadius = rpx;
                }

                style.left = sumWidth + 'px';
                style.width = width - gap + 'px';
                style.height = hpx;
                div._x = sumWidth;
                div._width = width - gap;

                this.renderTab(div, tab);
                this.onTabRendered(div, tab);
                this._tabDiv.insertBefore(div, this._tabDiv.firstChild);

                sumWidth += width;

                if (tab.isResizable()) {
                    div = this._resizePool.get();
                    div._resizeTab = tab;
                    style = div.style;
                    style.position = 'absolute';
                    style.backgroundColor = 'white';
                    style.opacity = 0;
                    style.left = sumWidth - gap - this._resizeTolerance + 'px';
                    style.width = gap + this._resizeTolerance * 2 + 'px';
                    style.height = hpx;
                    this._tabDiv.appendChild(div);
                }
            }
        }

        this._tabDiv.style.left = '0px';
        this._tabDiv.style.width = sumWidth + 'px';
        this._tabDiv.style.height = this._tabHeight + 'px';

        this._pools.forEach(function (pool) {
            pool.clear();
        });
    },
    renderTab: function (div, tab) {
        if (tab.renderTab) {
            tab.renderTab(div);
        } else {
            var icon = tab.getIcon()
            if (icon) {
                var image = this._iconPool.get();
                image.setAttribute('src', _twaver.getImageSrc(icon));
                image.style.paddingLeft = '4px';
                image.style.verticalAlign = 'middle';
                div.appendChild(image);
            }
            var name = tab.getName();
            if (name) {
                var span = this._textPool.get();
                span.style.whiteSpace = 'nowrap';
                span.style.verticalAlign = 'middle';
                span.style.padding = '2px 4px';
                span.innerHTML = name;
                div.appendChild(span);
            }
            if ($ua.isOpera) {
                var maskDiv = div.cloneNode(false);
                maskDiv.style.left = '0px';
                maskDiv.style.top = '0px';
                maskDiv.style.opacity = 0;
                div.appendChild(maskDiv);
            }
        }

        if (tab.isClosable()) {
            var m = this._tabRadius / 4 + 2;
            var image = this._closePool.get();
            image._closeTab = tab;
            image.setAttribute('src', _twaver.getImageSrc(this._closeIcon));
            image.style.position = 'absolute';
            image.style.top = m + 'px';
            image.style.right = m + 'px';
            div.appendChild(image);
        }

        if (tab.isDisabled()) {
            div.style.color = this.getDisabledColor();
        } else {
            div.style.color = ''
        }

    },
    onTabRendered: function (div, tab) {

    }
});

twaver.controls.TabPaneInteraction = function (tabPane) {
    this.tabPane = tabPane;
    this.view = tabPane.getTabDiv();

    var self = this;
    this.view.addEventListener('mousedown', function (e) {
        self.handleMouseDown(e);
    }, false);
    this.view.addEventListener('mousemove', function (e) {
        self.handleMouseMove(e);
    }, false);
};
_twaver.ext('twaver.controls.TabPaneInteraction', Object, {
    handleMouseDown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.movableDiv) {
            this.handleMouseUp(e);
            return;
        }
        this.resizeTab = e.target._resizeTab;
        if (!this.resizeTab) {
            this.movableDiv = this.getMovableDivAt(e);
        }
        this.changeCursor(e);
        this.lastX = this.getX(e);
        this._startClient = $html.getClientPoint(e);
        this._startLogicalX = this.lastX;
        $html.handle_mousedown(this, e);
    },
    changeCursor: function (e) {
        var cursor = ''
        if (e.target._resizeTab) {
            cursor = 'ew-resize';
        }
        else {
            var tab = this.getTabAt(e);
            if (tab && (!tab.isDisabled() || tab.isMovable())) {
                cursor = 'pointer';
            }
        }
        this.view.style.cursor = cursor;
    },
    handleMouseMove: function (e) {
        if (this.lastX == null) {
            this.changeCursor(e);
            return;
        }
        if ($html.target !== this) {
            return;
        }
        var x = this._startLogicalX + e.clientX - this._startClient.x;
        // resize tab
        if (this.resizeTab) {
            if (this.stopX != null) {
                if (x < this.stopX) {
                    return;
                } else {
                    delete this.stopX;
                }
            }
            var w = this.resizeTab.getWidth() + (x - this.lastX);
            if (w < 10) {
                w = 10;
                this.stopX = x;
            }

            this.resizeTab.setWidth(w);
            this.lastX = x;
        }
        // move tab
        else if (this.movableDiv) {
            var offset = x - this.lastX;

            if (!this.cloneDiv) {
                if (Math.abs(offset) < 3) {
                    return;
                }
                this.cloneDiv = this.movableDiv.cloneNode(true);
                this.cloneDiv._x = this.movableDiv._x;
                this.cloneDiv.style.background = this.tabPane.getMoveBackground();

                this.insertDiv = $html.createDiv();
                this.insertDiv.style.width = '1px';
                this.insertDiv.style.height = this.cloneDiv.style.height;
                this.insertDiv.style.background = this.tabPane.getInsertBackground();

                this.movableDiv.parentNode.appendChild(this.cloneDiv);
                this.movableDiv.parentNode.appendChild(this.insertDiv);
            }


            var left = this.cloneDiv._x + offset;
            this.cloneDiv.style.left = left + 'px';
            this.cloneDiv._x = left;
            this.lastX = x;

            this.tabInfo = this.getTabInfoAt(e);
            if (this.tabInfo) {
                this.insertDiv.style.left = this.tabInfo.position;
            }
        }
    },
    handleMouseUp: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.resizeTab) {
            // do nothing
        }
        else if (this.movableDiv && this.tabInfo) {
            var tab = this.movableDiv._tab;
            var index = this.tabInfo.index;
            this.tabPane.getTabBox().moveTo(tab, index);
        }
        else {
            // close tab
            var box = this.tabPane.getTabBox();
            var tab = e.target._closeTab;
            if (tab) {
                // select next tab on close
                if (this.tabPane.isSelectNextOnClose() && this.tabPane.getCurrentTab() === tab) {
                    var roots = box.getRoots();
                    var index = roots.indexOf(tab);
                    box.remove(tab);
                    if (roots.size() > 0) {
                        if (index >= roots.size()) {
                            index = roots.size() - 1;
                        }
                        box.getSelectionModel().setSelection(roots.get(index));
                    }
                } else {
                    box.remove(tab);
                }
            } else {
                // select tab
                var tab = this.getTabAt(e);
                if (tab && !tab.isDisabled()) {
                    box.getSelectionModel().setSelection(tab);
                }
            }
        }
        this.clear();
    },
    clear: function () {
        this.view.style.cursor = '';
        if (this.cloneDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.cloneDiv);
        }
        if (this.insertDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.insertDiv);
        }
        delete this.movableDiv;
        delete this.tabInfo;
        delete this.insertDiv;
        delete this.cloneDiv;
        delete this.resizeTab;
        delete this.stopX;
        delete this.lastX;
        delete this._startLogicalX;
        delete this._startClient;
    },
    getTabAt: function (e) {
        e = e.target;
        var tab;
        while (e && e !== this.view && !(tab = e._tab)) {
            e = e.parentNode;
        }
        return tab;
    },
    getMovableDivAt: function (e) {
        e = e.target;
        var tab;
        while (e && e !== this.view && !(tab = e._tab)) {
            e = e.parentNode;
        }
        if (tab && tab.isMovable()) {
            return e;
        }
        return null;
    },
    getX: function (e) {
        var p = $html.getLogicalPoint(this.view, e);
        return p ? p.x : null;
    },
    getTabInfoAt: function (e) {
        var x = this._startLogicalX + e.clientX - this._startClient.x;
        var tabs = this.tabPane.getTabBox().getRoots();
        var count = tabs.size();
        var sumWidth = 0;
        var meetMovingTab = false;
        for (var i = 0; i < count; i++) {
            var tab = tabs.get(i);
            if (tab === this.movableDiv._tab) {
                meetMovingTab = true;
            }
            if (tab.isVisible()) {
                var width = tab.getWidth();
                if (width <= 0) {
                    continue;
                }
                if (x >= sumWidth && x <= sumWidth + width) {
                    var isFront = x < sumWidth + width / 2;
                    if (meetMovingTab &&
                        !(tab === this.movableDiv._tab && isFront)) {
                        i--;
                    }
                    var index = isFront ? Math.max(0, i) : Math.min(i + 1, count);
                    var position = isFront ? sumWidth : sumWidth + width;
                    position = Math.max(0, position - 1);
                    return {
                        index: index,
                        tab: tab,
                        position: position + 'px'
                    };
                }
                sumWidth += width;
            }
        }
        return this.tabInfo;
    }
});

twaver.controls.TabPaneTouchInteraction = function (tabPane) {
    this.tabPane = tabPane;
    this.view = tabPane.getTabDiv();

    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.controls.TabPaneTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (this.movableDiv) {
            this.handleTouchend(e);
            return;
        }
        this.resizeTab = e.target._resizeTab;
        if (!this.resizeTab) {
            this.movableDiv = this.getMovableDivAt(e);
        }
        this.lastX = this.getX(e);
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        if (this.lastX == null) {
            return;
        }
        // resize tab
        if (this.resizeTab) {
            var x = this.getX(e);
            if (this.stopX != null) {
                if (x < this.stopX) {
                    return;
                } else {
                    delete this.stopX;
                }
            }
            var w = this.resizeTab.getWidth() + (x - this.lastX);
            if (w < 0) {
                w = 0;
                this.stopX = x;
            }

            this.resizeTab.setWidth(w);
            this.lastX = x;
        }
        // move tab
        else if (this.movableDiv) {
            var x = this.getX(e);
            var offset = x - this.lastX;

            if (!this.cloneDiv) {
                if (Math.abs(offset) < 3) {
                    return;
                }
                this.cloneDiv = this.movableDiv.cloneNode(true);
                this.cloneDiv._x = this.movableDiv._x;
                this.cloneDiv.style.background = this.tabPane.getMoveBackground();

                this.insertDiv = $html.createDiv();
                this.insertDiv.style.width = '1px';
                this.insertDiv.style.height = this.cloneDiv.style.height;
                this.insertDiv.style.background = this.tabPane.getInsertBackground();

                this.movableDiv.parentNode.appendChild(this.cloneDiv);
                this.movableDiv.parentNode.appendChild(this.insertDiv);
            }


            var left = this.cloneDiv._x + offset;
            this.cloneDiv.style.left = left + 'px';
            this.cloneDiv._x = left;
            this.lastX = x;

            this.tabInfo = this.getTabInfoAt(e);
            if (this.tabInfo) {
                this.insertDiv.style.left = this.tabInfo.position;
            }
        }
    },
    handleTouchend: function (e) {
        if (this.resizeTab) {
            // do nothing
        }
        else if (this.movableDiv && this.tabInfo) {
            var tab = this.movableDiv._tab;
            var index = this.tabInfo.index;
            this.tabPane.getTabBox().moveTo(tab, index);
        }
        else {
            // close tab
            var box = this.tabPane.getTabBox();
            var tab = e.target._closeTab
            if (tab) {
                // select next tab on close
                if (this.tabPane.isSelectNextOnClose() && this.tabPane.getCurrentTab() === tab) {
                    var roots = box.getRoots();
                    var index = roots.indexOf(tab);
                    box.remove(tab);
                    if (roots.size() > 0) {
                        if (index >= roots.size()) {
                            index = roots.size() - 1;
                        }
                        box.getSelectionModel().setSelection(roots.get(index));
                    }
                } else {
                    box.remove(tab);
                }
            } else {
                // select tab
                var tab = this.getTabAt(e);
                if (tab && !tab.isDisabled()) {
                    box.getSelectionModel().setSelection(tab);
                }
            }
        }
        this.clear();
        $html.removeEventListener('touchmove', this.view, this);
        $html.removeEventListener('touchend', this.view, this);
    },
    clear: function () {
        if (this.cloneDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.cloneDiv);
        }
        if (this.insertDiv && this.movableDiv) {
            this.movableDiv.parentNode.removeChild(this.insertDiv);
        }
        delete this.movableDiv;
        delete this.tabInfo;
        delete this.insertDiv;
        delete this.cloneDiv;
        delete this.resizeTab;
        delete this.stopX;
        delete this.lastX;
    },
    getTabAt: function (e) {
        e = e.target;
        var tab;
        while (e && e !== this.view && !(tab = e._tab)) {
            e = e.parentNode;
        }
        return tab;
    },
    getMovableDivAt: function (e) {
        e = e.target;
        var tab;
        while (e && e !== this.view && !(tab = e._tab)) {
            e = e.parentNode;
        }
        if (tab && tab.isMovable()) {
            return e;
        }
        return null;
    },
    getX: function (e) {
        var p = $html.getLogicalPoint(this.view, e);
        return p ? p.x : null;
    },
    getTabInfoAt: function (e) {
        var x = this.getX(e);
        var tabs = this.tabPane.getTabBox().getRoots();
        var count = tabs.size();
        var sumWidth = 0;
        var meetMovingTab = false;
        for (var i = 0; i < count; i++) {
            var tab = tabs.get(i);
            if (tab === this.movableDiv._tab) {
                meetMovingTab = true;
            }
            if (tab.isVisible()) {
                var width = tab.getWidth();
                if (width <= 0) {
                    continue;
                }
                if (x >= sumWidth && x <= sumWidth + width) {
                    var isFront = x < sumWidth + width / 2;
                    if (meetMovingTab &&
                        !(tab === this.movableDiv._tab && isFront)) {
                        i--;
                    }
                    var index = isFront ? Math.max(0, i) : Math.min(i + 1, count);
                    var position = isFront ? sumWidth : sumWidth + width;
                    position = Math.max(0, position - 1);
                    return {
                        index: index,
                        tab: tab,
                        position: position + 'px'
                    };
                }
                sumWidth += width;
            }
        }
        return this.tabInfo;
    }
});

twaver.controls.TitlePane = function (content, title, icon) {
    twaver.controls.TitlePane.superClass.constructor.apply(this, arguments);
    this.invalidate();

    this._titleDiv = $html.createDiv();
    this._titleDiv.tabIndex = -1;
    this._titleDiv.style.verticalAlign = 'middle';
    this._titleDiv.style.fontWeight = 'bold';
    this._titleDiv.style.textOverflow = 'ellipsis';
    this._titleDiv.style.overflow = 'hidden';
    this._titleDiv.style.whiteSpace = 'nowrap';
    this._titleDiv.onmousedown = $html.preventDefault;

    this._span = document.createElement('span');
    this._span.style.verticalAlign = 'middle';
    this._span.style.paddingLeft = '4px';
    this._span.style.paddingRight = '4px';

    this._img = document.createElement('img');
    this._img.style.verticalAlign = 'middle';
    this._img.style.paddingLeft = '4px';

    this._view = $html.createView('hidden', true);
    this._view.tabIndex = -1;
    this._view.appendChild(this._titleDiv);

    if (title) this.setTitle(title);
    if (content) this.setContent(content);
    if (icon) this.setIcon(icon);
};
_twaver.ext('twaver.controls.TitlePane', twaver.controls.ControlBase, {
    __accessor: ['icon', 'title', 'titleHeight', 'titleHorizontalAlign', 'titleBackground'],

    _titleHeight: $Defaults.TITLEPANE_TITLE_HEIGHT,
    _titleBackground: $Defaults.TITLEPANE_TITLE_BACKGROUND,
    _titleHorizontalAlign: $Defaults.TITLEPANE_TITLE_HORIZONTAL_ALIGN,

    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getTitleDiv: function () {
        return this._titleDiv;
    },
    getContent: function () {
        return this._content;
    },
    setContent: function (value) {
        if (this._content === value) {
            return;
        }
        var oldValue = this._content;
        if (oldValue) {
            if (oldValue.getView) {
                this._view.removeChild(oldValue.getView());
            } else {
                this._view.removeChild(oldValue);
            }
        }
        this._content = value;
        if (value) {
            if (value.getView) {
                this._view.appendChild(value.getView());
            } else {
                this._view.appendChild(value);
            }
        }
        this.firePropertyChange('content', oldValue, value);
    },
    validateImpl: function () {
        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;

        var style = this._titleDiv.style;
        style.textAlign = this._titleHorizontalAlign;
        style.lineHeight = this._titleHeight - 2 + 'px';
        style.background = this._titleBackground;

        $html.clear(this._titleDiv);

        if (this._icon) {
            this._img.setAttribute('src', _twaver.getImageSrc(this._icon));
            this._titleDiv.appendChild(this._img);
        }
        if (this._title) {
            this._span.innerHTML = this._title;
            this._span.setAttribute('title', this._title);
            this._titleDiv.appendChild(this._span);
        }

        var style = this._titleDiv.style;
        style.left = '0px';
        style.top = '0px';
        style.width = w + 'px';
        style.height = this._titleHeight + 'px';

        _twaver.setViewBounds(this._content, {
            x: 0,
            y: this._titleHeight,
            width: w,
            height: Math.max(h - this._titleHeight, 0)
        });
    }
});

twaver.controls.Accordion = function () {
    twaver.controls.Accordion.superClass.constructor.apply(this, arguments);
    this._titleMap = {}; // title: {content:content, titleDiv:div, span:span, img:img}
    this._titleList = new $List();
    this._currentTitle = null;
    this._currentView = null;

    this._view = $html.createView('hidden', true);
    this.invalidate();

    var self = this;
    this._view.addEventListener('mousedown', function (e) {
        self.handleMouseDown(e);
    }, false);
};
_twaver.ext('twaver.controls.Accordion', twaver.controls.ControlBase, {
    __accessor: ['expandIcon', 'collapseIcon', 'titleHeight', 'titleBackground', 'borderBottomColor', 'iconPosition'],

    _expandIcon: $Defaults.ACCORDION_EXPAND_ICON,
    _collapseIcon: $Defaults.ACCORDION_COLLAPSE_ICON,

    _titleHeight: $Defaults.ACCORDION_TITLE_HEIGHT,
    _titleBackground: $Defaults.ACCORDION_TITLE_BACKGROUND,
    _borderBottomColor: $Defaults.ACCORDION_BORDER_BOTTOM_COLOR,
    _iconPosition: $Defaults.ACCORDION_ICON_POSITION,

    onPropertyChanged: function (e) {
        this.invalidate();
    },
    handleMouseDown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var title = e.target._title;
        if (!title) {
            title = e.target.parentNode._title;
        }
        if (title) {
            if (this._currentTitle === title) {
                this.collapse();
            } else {
                this.expand(title);
            }
        }
    },
    getTitles: function () {
        return this._titleList;
    },
    getCurrentTitle: function () {
        return this._currentTitle;
    },
    add: function (title, content) {
        if (this._titleMap[title]) {
            throw "Title ' + title + ' already exists";
        }

        var titleDiv = $html.createDiv();
        titleDiv._title = title;
        titleDiv.onmousedown = $html.preventDefault;
        titleDiv.style.cursor = 'pointer';
        titleDiv.style.textAlign = 'left';
        titleDiv.style.textOverflow = 'ellipsis';
        titleDiv.style.whiteSpace = 'nowrap';
        titleDiv.style.overflow = 'hidden';
        titleDiv.style.borderBottomWidth = '1px';
        titleDiv.style.borderBottomStyle = 'solid';

        var img = document.createElement('img');
        img.style.verticalAlign = 'middle';
        img.style.paddingLeft = '4px';

        var span = document.createElement('span');
        span.style.verticalAlign = 'middle';
        span.style.paddingLeft = '4px';
        span.innerHTML = title;
        span.setAttribute('title', title);

        this._view.appendChild(titleDiv);
        titleDiv.appendChild(img);
        titleDiv.appendChild(span);
        if(this._iconPosition == 'right'){
            var s = img.style;
            var top = (this._titleHeight - 8) / 2;
            s.marginTop = top + 'px';
            s.right = '15px';
            s.position = 'absolute';
        }


        this._titleMap[title] = {
            content: content,
            titleDiv: titleDiv,
            span: span,
            img: img
        };
        this._titleList.add(title);
        this.invalidate();
    },
    remove: function (title) {
        var info = this._titleMap[title];
        if (info) {
            this._view.removeChild(info.titleDiv);
        }
        delete this._titleMap[title];
        this._titleList.remove(title);
        this.invalidate();
    },
    clear: function () {
        var self = this;
        Object.keys(self._titleMap).forEach(function (title) {
            self._view.removeChild(self._titleMap[title].titleDiv);
        });
        self._titleMap = {};
        self._titleList.clear();
        self.invalidate();
    },
    expand: function (title) {
        if (this._titleMap[title] && this._currentTitle !== title) {
            this._currentTitle = title;
            this.onExpanded(title);
            this.invalidate();
        }
    },
    onExpanded: function (title) {
        // do nothing
    },
    collapse: function () {
        if (this._currentTitle) {
            this.onCollapsed(this._currentTitle);
            this._currentTitle = null;
            this.invalidate();
        }
    },
    onCollapsed: function (title) {
        // do nothing
    },
    validateImpl: function () {
        var oldView = this._currentView;
        this._currentView = null;

        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;
        var count = this._titleList.size();

        var y = 0;
        for (var i = 0; i < count; i++) {
            var title = this._titleList.get(i);
            var info = this._titleMap[title];

            var style = info.titleDiv.style;
            style.lineHeight = this._titleHeight - 3 + 'px';
            style.background = this._titleBackground;
            style.borderBottomColor = this._borderBottomColor;
            style.left = '0px';
            style.top = y + 'px';
            style.width = w + 'px';
            style.height = this._titleHeight - 1 + 'px';

            var isExpanded = this._currentTitle === title;
            var icon = isExpanded ? this._expandIcon : this._collapseIcon;
            info.img.setAttribute('src', _twaver.getImageSrc(icon));

            if (isExpanded) {
                var contentHeight = Math.max(0, h - count * this._titleHeight);
                if (info.content) {
                    this._currentView = info.content.getView ? info.content.getView() : info.content;
                    _twaver.setViewBounds(info.content, {
                        x: 0,
                        y: y + this._titleHeight,
                        width: w,
                        height: contentHeight
                    });
                    info.content.style.overflowY = 'auto'; 
                }
                y += this._titleHeight + contentHeight;
            } else {
                y += this._titleHeight;
            }
        }

        if (this._currentView && this._currentView !== oldView) {
            this._view.appendChild(this._currentView);
        }
        if (oldView && oldView !== this._currentView) {
            this._view.removeChild(oldView);
        }
    }
});

twaver.controls.BorderPane = function (center, top, right, bottom, left) {
    twaver.controls.BorderPane.superClass.constructor.apply(this, arguments);
    this.invalidate();

    this._view = $html.createView('hidden', true);
    this._view.tabIndex = -1;

    if (center) this.setCenter(center);
    if (top) this.setTop(top);
    if (right) this.setRight(right);
    if (bottom) this.setBottom(bottom);
    if (left) this.setLeft(left);
};
_twaver.ext('twaver.controls.BorderPane', twaver.controls.ControlBase, {
    __accessor: ['hGap', 'vGap', 'topHeight', 'bottomHeight', 'leftWidth', 'rightWidth'],
    _hGap: $Defaults.BORDERPANE_HGAP,
    _vGap: $Defaults.BORDERPANE_VGAP,
    _topHeight: 0,
    _bottomHeight: 0,
    _leftWidth: 0,
    _rightWidth: 0,
    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getCenter: function () {
        return this._center;
    },
    setCenter: function (value) {
        this._setContent('center', value);
    },
    getTop: function () {
        return this._top;
    },
    setTop: function (value) {
        this._setContent('top', value);
    },
    getRight: function () {
        return this._right;
    },
    setRight: function (value) {
        this._setContent('right', value);
    },
    getBottom: function () {
        return this._bottom;
    },
    setBottom: function (value) {
        this._setContent('bottom', value);
    },
    getLeft: function () {
        return this._left;
    },
    setLeft: function (value) {
        this._setContent('left', value);
    },
    _setContent: function (name, value) {
        var oldValue = this['_' + name];
        if (oldValue === value) {
            return;
        }
        if (oldValue) {
            var oldView = oldValue.getView ? oldValue.getView() : oldValue;
            if (this._view.contains(oldView)) {
                this._view.removeChild(oldView);
            }
        }
        this['_' + name] = value;
        if (value) {
            if (value.getView) {
                this._view.appendChild(value.getView());
            } else {
                this._view.appendChild(value);
            }
        }
        this.firePropertyChange(name, oldValue, value);
    },
    validateImpl: function () {
        var w = this._view.offsetWidth, h = this._view.offsetHeight;
        var lx = 0, ty = 0, rx = w, by = h, th = 0, bh = 0, lw = 0, rw = 0;
        if (this._top) {
            th = this._topHeight || (this._top.getView ? this._top.getView().offsetHeight : this._top.offsetHeight);
            ty = th + this._vGap;
        }
        if (this._bottom) {
            bh = this._bottomHeight || (this._bottom.getView ? this._bottom.getView().offsetHeight : this._bottom.offsetHeight);
            by = h - bh - this._vGap;
        }
        if (this._left) {
            lw = this._leftWidth || (this._left.getView ? this._left.getView().offsetWidth : this._left.offsetWidth);
            lx = lw + this._hGap;
        }
        if (this._right) {
            rw = this._rightWidth || (this._right.getView ? this._right.getView().offsetWidth : this._right.offsetWidth);
            rx = w - rw - this._hGap;
        }
        var cw = Math.max(0, rx - lx);
        var ch = Math.max(0, by - ty);

        if (this._top) {
            _twaver.setViewBounds(this._top, { x: 0, y: 0, width: w, height: th });
        }
        if (this._bottom) {
            _twaver.setViewBounds(this._bottom, { x: 0, y: by, width: w, height: bh });
        }
        if (this._left) {
            _twaver.setViewBounds(this._left, { x: 0, y: ty, width: lw, height: ch });
        }
        if (this._right) {
            _twaver.setViewBounds(this._right, { x: rx, y: ty, width: rw, height: ch });
        }
        if (this._center) {
            _twaver.setViewBounds(this._center, { x: lx, y: ty, width: cw, height: ch });
        }
    }
});

twaver.controls.PopupMenu = function (contextView) {
    this._view = $html.createDiv();
    this._view.style.zIndex = 100001;
    this._items = [];
    this._itemsMap = {};
    this.setContextView(contextView);
    var view = this._view, self = this;
    view.addEventListener('mouseover', function (e) {
        self._mouseOver = true;
    }, false);
    view.addEventListener('mouseout', function (e) {
        self._mouseOver = false;
    }, false);
    view.oncontextmenu = function (e) {
        e.preventDefault();
    };
    $html.addEventListener('mousedown', '_handleClick', view, this);
};
_twaver.ext('twaver.controls.PopupMenu', Object, {
    _width: 200,
    _xOffset:0,
    _yOffset:0,
    _menuItemHeight: 25,
    _background: '#F9F9F9',
    _border: '2px outset white',
    _disabledColor: '#BABBBC',
    _focusColor: 'white',
    _focusBackground: '#C2CFF1',
    _color: 'black',
    _subMenuEnableIcon: $Defaults.POPUPMENU_SUBNENU_ENABLE_ICON,
    _subMenuDisableIcon: $Defaults.POPUPMENU_SUBNENU_DISABLE_ICON,
    _checkboxSelectedIcon: $Defaults.POPUPMENU_CHECKBOX_SELECTED_ICON,
    _checkboxUnselectedIcon: $Defaults.POPUPMENU_CHECKBOX_UNSELECTED_ICON,
    _radiobuttonSelectedIcon: $Defaults.POPUPMENU_RADIOBUTTON_SELECTED_ICON,
    _radiobuttonUnselectedIcon: $Defaults.POPUPMENU_RADIOBUTTON_UNSELECTED_ICON,

    getView: function () {
        return this._view;
    },
    getContextView: function () {
        return this._contextView;
    },
    setContextView: function (contextView) {
        this._removeContextmenuListener();
        this._contextView = contextView;
        if (contextView) {
            var view = contextView.getView ? contextView.getView() : contextView;
            if ($ua.isTouchable) {
                view.addEventListener('touchstart', this._getTouchStartListener(), false);
                view.addEventListener('touchmove', this._getTouchMoveListener(), false);
                view.addEventListener('touchend', this._getTouchEndListener(), false);
                $html.addEventListener('contextmenu', '_handleContextmenu', view, this);
            } else {
                $html.addEventListener('contextmenu', '_handleContextmenu', view, this);
            }
        }
    },
    getMenuItems: function () {
        return this._items;
    },
    setMenuItems: function (menuItems) {
        this._items = [];
        this._itemsMap = {};
        if (menuItems) {
            for (var i = 0, n = menuItems.length; i < n; i++) {
                this.addMenuItem(menuItems[i]);
            }
        }
    },
    /*
    * {id, type, icon, label, visible, enabled, separator, action, items, selected, groupName}
    */
    addMenuItem: function (menuItem) {
        if (menuItem.separator !== true) {
            this._itemsMap[menuItem.id || menuItem.label] = menuItem;
        }
        this._items.push(menuItem);
    },
    getMenuItem: function (id) {
        return this._itemsMap[id];
    },
    addSeparator: function () {
        this.addMenuItem({ separator: true });
    },
    getMenuItemById: function (id) {
        return this._itemsMap[id];
    },
    isVisible: function (menuItem) {
        return menuItem.visible !== false;
    },
    isEnabled: function (menuItem) {
        return menuItem.enabled !== false;
    },
    show: function (e) {
        this.hide();
        var view = this._view,
        style = this._view.style,
        x, y;
        if ($ua.isTouchable) {
            x = e.changedTouches && e.changedTouches[0].clientX || e.clientX;
            y = e.changedTouches && e.changedTouches[0].clientY || e.clientY;
        } else {
            x = e.clientX,
            y = e.clientY;
        }
        $html.clear(view);
        this.renderMenu(view, this._items);
        if (this._height === 0) {
            return;
        }
        if($ua.isTouchable){
            $html.addEventListener('touchstart','_handleBodyClicked', document.body, this);
        }
        $html.addEventListener('mousedown', '_handleBodyClicked', document.body, this);

        var maxX = $html.windowWidth() - this._width - 10, maxY = $html.windowHeight() - this._height - 10;
        x = x > maxX ? maxX : x;
        y = y > maxY ? maxY : y;
        x = x < 0 ? 0 : x;
        y = y < 0 ? 0 : y;
        style.left = x + $touch.scrollLeft() + this._xOffset + 'px';
        style.top = y + $touch.scrollTop() + this._yOffset+ 'px';
        document.body.appendChild(view);
    },
    _showMenuItem: function (e, div) {
        this._hideMenuItem(div);
        var view = document.createElement('div');
        div.menuItem.childrenDiv = view;
        var style = view.style;
        style.color = '#000000';
        style.position = 'absolute';
        var x = this._width;
        var y = div.offsetTop;
        var items = div.menuItem.items;
        this._itemsShow = true;
        div._itemsShow = true;
        $html.clear(view);
        this.renderMenu(view, items);
        if (this._height === 0) {
            return;
        }
        var maxX = $html.windowWidth() - this._width - 10;
        var maxY = $html.windowHeight() - 10;
        var viewPosition = this._getPosition(this._view);
        x = (viewPosition.left + this._width) > maxX ? -this._width : x;
        y = (viewPosition.top + y + items.length * this._menuItemHeight) > (maxY) ? y - (items.length - 1) * this._menuItemHeight : y;
        style.left = x + 'px';
        style.top = y + 'px';
        div.appendChild(view);
    },
    hide: function () {
        if (document.body.contains(this._view)) {
            document.body.removeChild(this._view);
        }
        delete this._mouseOver;
        delete this._itemsShow;
        if($ua.isTouchable){
            $html.removeEventListener('touchstart',document.body, this);
        }
        $html.removeEventListener('mousedown', document.body, this);
    },
    _hideMenuItem: function (div) {
        var childrenDiv = div.menuItem.childrenDiv;
        if(childrenDiv && div.contains(childrenDiv)){
            div.removeChild(childrenDiv);
        }
        this._itemsShow = false;
        div._itemsShow = false;
    },
    dispose: function () {
        this._removeContextmenuListener();
        this.hide();
    },
    onMenuShowing: function (e) {
        return true;
    },
    onAction: function (menuItem) {

    },
    renderMenu: function (view, menuItems) {
        var style = view.style;
        style.background = this._background;
        style.border = this._border;
        style.width = this._width + 'px';
        this._height = 0;
        delete this._separator;
        view.menuItems = menuItems;
        for (var i = 0, n = menuItems.length, menuItem; i < n; i++) {
            menuItem = menuItems[i];
            if (this.isVisible(menuItem)) {
                if (menuItem.separator === true) {
                    this._separator = true;
                } else {
                    var div = document.createElement('div');
                    if (this.isEnabled(menuItem)) {
                        this._addMouseoverListener(div, menuItem);
                    }
                    div._itemsShow = false;
                    div.menuItem = menuItem;
                    view.appendChild(div);
                    this.renderMenuItem(div, menuItem);
                    this.onMenuItemRendered(div, menuItem);
                    this._separator = false;
                    this._height += this._menuItemHeight;
                }
            }
        }
    },
    renderMenuItem: function (div, menuItem) {
        var style = div.style;
        style.height = this._menuItemHeight + 'px';
        if (this._separator) {
            style.borderTop = '1px solid gray';
        }
        if (!this.isEnabled(menuItem)) {
            style.color = this._disabledColor;
        }

        var span = document.createElement('span');
        style = span.style;
        style.position = 'absolute';
        style.width = '25px';
        style.height = this._menuItemHeight + 'px';
        style.lineHeight = this._menuItemHeight + 'px';
        style.textAlign = 'center';

        div.appendChild(span);
        var icon;
        if (menuItem.type === 'check') {
            icon = menuItem.selected ? this._checkboxSelectedIcon : this._checkboxUnselectedIcon;
        } else if (menuItem.type === 'radio') {
            icon = menuItem.selected ? this._radiobuttonSelectedIcon : this._radiobuttonUnselectedIcon;
        } else if (menuItem.icon) {
            icon = menuItem.icon;
        }
        if (icon) {
            var image = new Image();
            image.src = _twaver.getImageSrc(icon);
            image.style.verticalAlign = 'middle';
            span.appendChild(image);
        }

        var label = document.createElement('label');
        _twaver.setText(label, menuItem.label, true);
        style = label.style;
        style.position = 'absolute';
        style.height = this._menuItemHeight + 'px';
        style.lineHeight = this._menuItemHeight + 'px';
        style.left = '25px';
        div.appendChild(label);
        if(menuItem.items && div.parentNode){
            var subMenuIcon = document.createElement('img');
            style = subMenuIcon.style;
            if (!this.isEnabled(menuItem)) {
                subMenuIcon.setAttribute('src',_twaver.getImageSrc(this._subMenuDisableIcon));
            }else{
                subMenuIcon.setAttribute('src',_twaver.getImageSrc(this._subMenuEnableIcon));
            }
            var top = (this._menuItemHeight - 8) / 2;
            style.marginTop = top + 'px';
            style.right = '5px';
            style.position = 'absolute';
            div.appendChild(subMenuIcon);
        }
    },
    onMenuItemRendered: function (div, menuItem) {

    },
    _addMouseoverListener: function (div, menuItem) {
        var self = this;
        var view = this._contextView;
        if($ua.isTouchable){ 
            div.addEventListener('touchstart', function (e) {
                div.style.background = self._focusBackground;
                div.style.color = self._focusColor;
                if (this !== e.relatedTarget && !this.contains(e.relatedTarget)){
                    if(menuItem.items && !self._itemsShow && div.parentNode == self._view){
                        self._showMenuItem(e, div);
                    }
                }
            }, false);
            div.addEventListener('touchend', function (e) {
                div.style.background = self._background;
                div.style.color = self._color;
                if (this !== e.relatedTarget && !this.contains(e.relatedTarget)){
                    if(menuItem.items && div.parentNode === self._view){
                        var x = e.clientX;
                        var y = e.clientY;
                        var childrenDiv = menuItem.childrenDiv;
                        var p = self._getPosition(childrenDiv);
                        if ((x < p.left + 2 || x > (p.left + childrenDiv.offsetWidth - 2))
                            || (y < p.top + 2 || y > (p.top + childrenDiv.offsetHeight - 2))) {
                            self._hideMenuItem(div);
                    }
                }
            }
        }, false);
        }
        div.addEventListener('mouseenter', function (e) {
            div.style.background = self._focusBackground;
            div.style.color = self._focusColor;
            if (this !== e.relatedTarget && !this.contains(e.relatedTarget)){
                if(menuItem.items && !this._itemsShow && this.parentNode){
                    self._showMenuItem(e, this);
                }
            }
        }, false);

        div.addEventListener('mouseleave', function (e) {
            this.style.background = self._background;
            this.style.color = self._color;
            if (this !== e.relatedTarget && !this.contains(e.relatedTarget)){
                if(menuItem.items && this.parentNode){
                    var x = e.clientX;
                    var y = e.clientY;
                    var childrenDiv = menuItem.childrenDiv;
                    var p = self._getPosition(childrenDiv);
                    if ((x < p.left + 2 || x > (p.left + childrenDiv.offsetWidth - 2))
                        || (y < p.top + 2 || y > (p.top + childrenDiv.offsetHeight - 2))) {
                        self._hideMenuItem(this);
                }
            }
        }
    }, false);
    },
    _getPosition : function(div) {
      var topValue = 0, leftValue = 0;
      while (div) {
       leftValue += div.offsetLeft;
       topValue += div.offsetTop;
       div = div.offsetParent;
   }
   return {
       left : leftValue,
       top : topValue
   };
},
_removeContextmenuListener: function () {
    var view = this._contextView;
    if (view) {
        view = view.getView ? view.getView() : view;
        if ($ua.isTouchable) {
            view.removeEventListener('touchstart', this._getTouchStartListener(), false);
            view.removeEventListener('touchmove', this._getTouchMoveListener(), false);
            view.removeEventListener('touchend', this._getTouchEndListener(), false);
            $html.removeEventListener('contextmenu', view, this);
        } else {
            $html.removeEventListener('contextmenu', view, this);
        }
    }
},
_handleContextmenu: function (e) {
    if (this.onMenuShowing(e) === true) {
        this.show(e);
    }
    e.preventDefault();
},
_handleBodyClicked: function (e) {
    if ($ua.isTouchable) {
        var target = e.target;
        while (target && target !== this._view) {
            target = target.parentElement;
        }
        if (target !== this._view) {
            this.hide();
        }
    } else {
        if (!this._mouseOver) {
            this.hide();
        }
    }

},
_handleClick: function (e) {
    if (e.button !== 0) {
        return;
    }
    var target = e.target;
    while (!target.menuItem && target.parentElement) {
        target = target.parentElement;
    }
    var menuItem = target ? target.menuItem : null;
    if (menuItem && this.isEnabled(menuItem)) {
        if (menuItem.type === 'check') {
            menuItem.selected = !menuItem.selected;
        }
        if (menuItem.type === 'radio') {
            if (menuItem.groupName) {
                menuItem.selected = true;
                this._items.forEach(function (item) {
                    if (menuItem !== item && item.groupName === menuItem.groupName) {
                        item.selected = false;
                    }
                    if (item.items) {
                        item.items.forEach(function (subItem) {
                            if (menuItem !== subItem && subItem.groupName === menuItem.groupName) {
                                subItem.selected = false;
                            }
                        });
                    }
                });
            } else {
                menuItem.selected = !menuItem.selected;
            }
        }
        if (menuItem.action) {
            menuItem.action(menuItem);
        }
        this.onAction(menuItem);
        if(!(menuItem.items && menuItem.items.length > 0)){
            this.hide();
        }
    }
},
_getTouchStartListener: function () {
    if (!this._touchStartListener) {
        var self = this;
        this._touchStartListener = function (e) {
            self._touchMoved = false;
            self._lastTouch = new Date();
        };
    }
    return this._touchStartListener;
},
_getTouchMoveListener: function () {
    if (!this._touchMoveListener) {
        var self = this;
        this._touchMoveListener = function (e) {
            self._touchMoved = true;
        };
    }
    return this._touchMoveListener;
},
_getTouchEndListener: function () {
    if (!this._touchEndListener) {
        var self = this;
        this._touchEndListener = function (e) {
            if (!self._touchMoved && new Date().getTime() - self._lastTouch.getTime() > 1000) {
                self._handleContextmenu(e);
            }
        };
    }
    return this._touchEndListener;
},
getWidth: function () {
    return this._width;
},
setWidth: function (value) {
    this._width = value;
},
getMenuItemHeight: function () {
    return this._menuItemHeight;
},
setMenuItemHeight: function (value) {
    this._menuItemHeight = value;
},
getBackground: function () {
    return this._background;
},
setBackground: function (value) {
    this._background = value;
},
getBorder: function () {
    return this._border;
},
setBorder: function (value) {
    this._border = value;
},
getDisabledColor: function () {
    return this._disabledColor;
},
setDisabledColor: function (value) {
    this._disabledColor = value;
},
getFocusColor: function () {
    return this._focusColor;
},
setFocusColor: function (value) {
    this._focusColor = value;
},
getFocusBackground: function () {
    return this._focusBackground;
},
setFocusBackground: function (value) {
    this._focusBackground = value;
},
getColor: function () {
    return this._color;
},
setColor: function (value) {
    this._color = value;
},
getSubMenuEnableIcon: function () {
    return this._subMenuEnableIcon;
},
setSubMenuEnableIcon: function (value) {
    this._subMenuEnableIcon = value;
},
getSubMenuDisableIcon: function () {
    return this._subMenuDisableIcon;
},
setSubMenuDisableIcon: function (value) {
    this._subMenuDisableIcon = value;
},
getCheckboxSelectedIcon: function () {
    return this._checkboxSelectedIcon;
},
setCheckboxSelectedIcon: function (value) {
    this._checkboxSelectedIcon = value;
},
getCheckboxUnselectedIcon: function () {
    return this._checkboxUnselectedIcon;
},
setCheckboxUnselectedIcon: function (value) {
    this._checkboxUnselectedIcon = value;
},
getRadiobuttonSelectedIcon: function () {
    return this._radiobuttonSelectedIcon;
},
setRadiobuttonSelectedIcon: function (value) {
    this._radiobuttonSelectedIcon = value;
},
getRadiobuttonUnselectedIcon: function () {
    return this._radiobuttonUnselectedIcon;
},
setRadiobuttonUnselectedIcon: function (value) {
    this._radiobuttonUnselectedIcon = value;
},
getXOffset : function(){
    return this._xOffset;
},
setXOffset : function(value){
    this._xOffset = value;
},
getYOffset : function(){
    return this._yOffset;
},
setYOffset : function(value){
  this._yOffset = value;
},
});
twaver.charts.IS_INVALIDATE_PROPERTY = {
    "xZoom": 1,
    "xTranslate": 1,
    "yZoom": 1,
    "yTranslate": 1
};
twaver.charts.ChartBase = function (dataBox) {
    twaver.charts.ChartBase.superClass.constructor.apply(this, arguments);
    this._uniqueColors = {};
    this._nonDataColors = {};
    this._publishedDatas = new $List();

    this._view = $html.createView('hidden');
    this._canvas = $html.createCanvas();
    this._view.appendChild(this._canvas);

    this.setDataBox(dataBox ? dataBox : new twaver.ElementBox());
    this.invalidate();

    if($ua.isTouchable){
      if($ua.isMSTouchable){
        new twaver.charts.ChartMSTouchInteraction(this);
      }else{
        new twaver.charts.ChartTouchInteraction(this);
        new twaver.charts.ChartInteraction(this);
      }
    } else {
      new twaver.charts.ChartInteraction(this);
    }

    this.setToolTipEnabled($Defaults.CHART_TOOLTIP_ENABLED);
};
_twaver.ext('twaver.charts.ChartBase', twaver.controls.ViewBase, {
    __accessor: [
    'xGap', 'yGap', 'xTranslate', 'yTranslate', 'valueVisible', 'sortFunction', 'visibleFunction',
    'xTranslateEnabled', 'yTranslateEnabled', 'xZoomEnabled', 'yZoomEnabled', 'selectTolerance',
    'backgroundVisible', 'backgroundFill', 'backgroundFillColor', 'backgroundOutlineWidth',
    'backgroundOutlineColor', 'backgroundGradient', 'backgroundGradientColor','outerZoom'
    ],

    __bool: ['doubleClickToReset', 'focusOnClick'],

    _backgroundVisible: $Defaults.CHART_BACKGROUND_VISIBLE,
    _backgroundFill: $Defaults.CHART_BACKGROUND_FILL,
    _backgroundFillColor: $Defaults.CHART_BACKGROUND_FILL_COLOR,
    _backgroundOutlineWidth: $Defaults.CHART_BACKGROUND_OUTLINE_WIDTH,
    _backgroundOutlineColor: $Defaults.CHART_BACKGROUND_OUTLINE_COLOR,
    _backgroundGradient: $Defaults.CHART_BACKGROUND_GRADIENT,
    _backgroundGradientColor: $Defaults.CHART_BACKGROUND_GRADIENT_COLOR,

    _selectTolerance: $Defaults.CHART_SELECT_TOLERANCE,
    _doubleClickToReset: $Defaults.CHART_DOUBLE_CLICK_TO_RESET,
    _focusOnClick: $Defaults.FOCUS_ON_CLICK,
    _sortFunction: null,
    _visibleFunction: null,

    _canvasWidth: 0,
    _canvasHeight: 0,
    _outerZoomL: 1,

    _xGap: $Defaults.CHART_XGAP,
    _yGap: $Defaults.CHART_YGAP,

    _xTranslate: 0,
    _yTranslate: 0,
    _xTranslateEnabled: $Defaults.CHART_XTRANSLATE_ENABLED,
    _yTranslateEnabled: $Defaults.CHART_YTRANSLATE_ENABLED,

    _xZoom: 1,
    _yZoom: 1,
    _maxZoom: $Defaults.ZOOM_MAX,
    _minZoom: $Defaults.ZOOM_MIN,
    _xZoomEnabled: $Defaults.CHART_XZOOM_ENABLED,
    _yZoomEnabled: $Defaults.CHART_YZOOM_ENABLED,

    _valueVisible: $Defaults.CHART_VALUE_VISIBLE,
    _valueFont: $Defaults.CHART_VALUE_FONT,

    isToolTipEnabled: function () {
        return this._toolTipListener ? true : false;
    },
    setToolTipEnabled: function (value) {
        if (value) {
            if (!this._toolTipListener) {
                var self = this;
                this._toolTipListener = function (e) {
                    $popup.showToolTip(e, self.getToolTip(e));
                };
                this._canvas.addEventListener('mousemove', this._toolTipListener, true);
                this.firePropertyChange('toolTipEnabled', false, true);
            }
        } else {
            if (this._toolTipListener) {
                $popup.hideToolTip();
                this._canvas.removeEventListener('mousemove', this._toolTipListener, true);
                delete this._toolTipListener;
                this.firePropertyChange('toolTipEnabled', true, false);
            }
        }
    },
    getToolTip: function (evt) {
        if (this._toolTipInfos) {
            var p = this.getLogicalPoint(evt);
            p.x -= this._xTranslate;
            p.y -= this._yTranslate;
            var count = this._toolTipInfos.size();
            for (var i = count - 1; i >= 0; i--) {
                var info = this._toolTipInfos.get(i);
                if (info.rect && $math.containsPoint(info.rect, p)) {
                    return this.getToolTipByData(info.data, info);
                }
            }
        }
        else {
            var data = this.tryGetDataAt(evt);
            if (data) {
                return this.getToolTipByData(data, { value: this.getValue(data) });
            }
        }
        return null;
    },
    getToolTipByData: function (data, info) {
        if (info.value !== undefined) {
            return this.formatValueText(info.value, data);
        }
        return null;
    },
    addToolTipInfo: function (x, y, w, h, value, data, index) {
        if (this._toolTipInfos) {
            this._toolTipInfos.add({
                data: data,
                rect: { x: x, y: y, width: w, height: h },
                value: value,
                index: index
            });
        }
    },
    getLogicalPoint: function (e) {
        return $html.getLogicalPoint(this._canvas, e, this._outerZoom);
    },
    getTextSize: function (font, text) {
        var size = $g.getTextSize(font, text);
        if (size.width) {
            size.width += 4;
        }
        return size;
    },
    getUniqueColor: function (color, data) {
        if (color == null) {
            return null;
        }
        var c;
        if (!data) {
            c = this._nonDataColors[color];
            if (c) {
                return c;
            }
        }
        var d = $g.getColorArray(color);
        if (!data) {
            if (d[3] != 255) {
                c = color;
            } else {
                c = 'rgba(' + d[0] + ',' + d[1] + ',' + d[2] + ',0.99)';
            }
            this._nonDataColors[color] = c;
            return c;
        }
        var rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
        if (this._uniqueColors[rgb] === undefined || this._uniqueColors[rgb] === data) {
            // do nothing
        }
        else {
            var kr = 1;
            var kg = -1;
            var kb = 1;
            // in opera d is a kind of byte array
            if ($ua.isOpera) {
                d = [d[0], d[1], d[2]];
            }
            while (true) {
                // adjust r
                d[0] += kr;
                if (d[0] >= 255) {
                    d[0] = 255;
                    kr = -1;
                } else if (d[0] <= 0) {
                    d[0] = 0;
                    kr = 1;
                }
                rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
                if (this._uniqueColors[rgb] === undefined || this._uniqueColors[rgb] === data) {
                    break;
                }

                // adjust g
                d[1] += kg;
                if (d[1] >= 255) {
                    d[1] = 255;
                    kg = -1;
                } else if (d[1] <= 0) {
                    d[1] = 0;
                    kg = 1;
                }
                rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
                if (this._uniqueColors[rgb] === undefined || this._uniqueColors[rgb] === data) {
                    break;
                }

                // adjust b
                d[2] += kb;
                if (d[2] >= 255) {
                    d[2] = 255;
                    kb = -1;
                } else if (d[2] <= 0) {
                    d[2] = 0;
                    kb = 1;
                }
                rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
                if (this._uniqueColors[rgb] === undefined || this._uniqueColors[rgb] === data) {
                    break;
                }
            }
        }
        this._uniqueColors[rgb] = data;
        return rgb;
    },
    tryGetDataAt: function (point, tolerance) {
        if (tolerance == null || tolerance < 0) {
            tolerance = this._selectTolerance;
        }
        if (point.target) {
            point = $html.getLogicalPoint(this._canvas, arguments[0], this._outerZoom);
        }
        if (!point) {
            return null;
        }
        var x = point.x - tolerance;
        var y = point.y - tolerance;
        var w = tolerance * 2 + 1;
        var h = tolerance * 2 + 1;
        try {
            var d = this._canvas.getContext('2d').getImageData(x, y, w, h).data;
            for (var i = 0, n = d.length; i < n; i += 4) {
                if (d[i + 3] === 255) {
                    var rgb = 'rgb(' + d[i] + ',' + d[i + 1] + ',' + d[i + 2] + ')';
                    var data = this._uniqueColors[rgb];
                    if (data) {
                        return data;
                    }
                }
            }
        } catch (e) {
        }
        return null;
    },
    _getPoint: function () {
        var x, y;
        if (arguments.length === 2) {
            x = arguments[0];
            y = arguments[1];
        }
        else if (arguments[0].target) {
            var p = $html.getLogicalPoint(this._canvas, arguments[0], this._outerZoom);
            if (p) {
                x = p.x;
                y = p.y;
            } else {
                return null;
            }
        }
        else {
            x = arguments[0].x;
            y = arguments[0].y;
        }
        return { x: x, y: y };
    },
    getDataAt: function () {
        var point = this._getPoint.apply(this, arguments),
        x = point.x,
        y = point.y;
        if (x < 0 || y < 0 || x > this._canvasWidth || y > this._canvasHeight) {
            return null;
        }
        try {
            var d = this._canvas.getContext('2d').getImageData(x, y, 1, 1).data;
            if (d[3] === 255) {
                var rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
                var data = this._uniqueColors[rgb];
                if (data) {
                    return data;
                }
            }
        } catch (e) {
        }
        return null;
    },
    getBackgroundRect: function () {
        return this._backgroundRect;
    },
    drawBackground: function (g, rect) {
        this._backgroundRect = _twaver.clone(rect);
        if (rect != null && rect.width > 0 && rect.height > 0 && this._backgroundVisible) {
            if (this._backgroundFill) {
                $g.fill(g,
                    this.getUniqueColor(this._backgroundFillColor),
                    this._backgroundGradient,
                    this.getUniqueColor(this._backgroundGradientColor),
                    rect);
            }
            if (this._backgroundOutlineWidth > 0) {
                g.lineWidth = this._backgroundOutlineWidth;
                g.strokeStyle = this._backgroundOutlineColor;
            }
            g.beginPath();
            g.rect(rect.x, rect.y, rect.width, rect.height);
            g.closePath();
            if (this._backgroundFill) {
                g.fill();
            }
            if (this._backgroundOutlineWidth > 0) {
                g.stroke();
            }
        }
    },
    getName: function (data) {
        return data.getName();
    },
    getColor: function (data) {
        return data.getStyle ? data.getStyle('chart.color') : data.getClient('chart.color');
    },
    getValue: function (data) {
        return data.getStyle ? data.getStyle('chart.value') : 0;
    },
    getValueColor: function (data) {
        return data.getStyle ? data.getStyle('chart.value.color') : twaver.Styles.getStyle('chart.value.color');
    },
    setValueFont: function (value) {
        if (value === this._valueFont) {
            return;
        }
        var oldValue = value;
        this._valueFont = value;
        this.firePropertyChange('valueFont', oldValue, value);
    },
    getValueFont: function (data) {
        if (data) {
            var font = data.getStyle ? data.getStyle('chart.value.font') : twaver.Styles.getStyle('chart.value.font');
            if (font) {
                return font;
            }
        }
        return this._valueFont;
    },
    formatValueText: function (value, data) {
        return value;
    },
    getCanvasWidth: function () {
        return this._canvasWidth;
    },
    getCanvasHeight: function () {
        return this.canvasHeight;
    },
    getCanvas: function () {
        return this._canvas;
    },
    isVisible: function (data) {
        if (this._internalVisibleFunction && !this._internalVisibleFunction(data)) {
            return false;
        }
        return this._visibleFunction ? this._visibleFunction(data) : true;
    },
    onPropertyChanged: function (e) {
        if (twaver.charts.IS_INVALIDATE_PROPERTY[e.property]) {
            this.invalidate();
        } else {
            this.invalidateModel();
        }
    },
    getDataBox: function () {
        return this._box;
    },
    setDataBox: function (dataBox) {
        if (!dataBox) {
            throw "DataBox can not be null";
        }
        if (this._box === dataBox) {
            return;
        }

        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataBoxChangeListener(this.handleDataBoxChange, this);
            oldValue.removeDataPropertyChangeListener(this.handlePropertyChange, this);
            oldValue.removeHierarchyChangeListener(this.handleHierarchyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = dataBox;

        this._box.addDataBoxChangeListener(this.handleDataBoxChange, this);
        this._box.addDataPropertyChangeListener(this.handlePropertyChange, this);
        this._box.addHierarchyChangeListener(this.handleHierarchyChange, this);
        if (this._selectionModel) {
            this._selectionModel._setDataBox(dataBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }

        this.invalidateModel();

        this.firePropertyChange("dataBox", oldValue, this._box);
    },
    handleDataBoxChange: function (e) {
        this.invalidateModel();
    },
    handlePropertyChange: function (e) {
        this.invalidateModel();
    },
    handleHierarchyChange: function (e) {
        this.invalidateModel();
    },
    handleSelectionChange: function (e) {
        this.invalidateModel();
    },
    getUnfilteredDatas: function () {
        return this._unfilteredDatas ? this._unfilteredDatas : this._publishedDatas;
    },
    getPublishedDatas: function () {
        return this._publishedDatas;
    },
    createPublishedDatas: function () {
        this._unfilteredDatas = new $List();
        this._buildChildren(this._box.getRoots(), this._unfilteredDatas);
        if (this._sortFunction) {
            this._unfilteredDatas.sort(this._sortFunction);
        }
        return this._unfilteredDatas.toList(this.isVisible, this);
    },
    _buildChildren: function (children, list) {
        children.forEach(function (data) {
            list.add(data);
            this._buildChildren(data.getChildren(), list);
        }, this);
    },
    invalidateModel: function () {
        if (this._invalidateModel) {
            return;
        }
        this._invalidateModel = true;
        this.invalidate();
    },
    validateImpl: function () {
        // validate model
        if (this._invalidateModel) {
            this._invalidateModel = false;
            this._uniqueColors = {};
            this._nonDataColors = {};
            this._publishedDatas = this.createPublishedDatas();
            this._publishedDatas.forEach(function (data) {
                if (data.IStyle) {
                    if (!data.getStyle('chart.color')) {
                        data.setStyle('chart.color', _twaver.nextColor());
                    }
                } else {
                    if (!data.getClient('chart.color')) {
                        data.setClient('chart.color', _twaver.nextColor());
                    }
                }
            });
            this.validateModel();
        }
        // reset canvas
        var g = this._canvas.getContext('2d');
        this._canvasWidth = this._view.clientWidth;
        this._canvasHeight = this._view.clientHeight;
        this._canvas.setAttribute('width', this._canvasWidth);
        this._canvas.setAttribute('height', this._canvasHeight);
        g.clearRect(0, 0, this._canvasWidth, this._canvasHeight);
        twaver.Util.makeHighRes(this._canvas);
        // validate display
        if (this._canvasWidth > 0 && this._canvasHeight > 0) {
            g.translate(this._xTranslate, this._yTranslate);
            this._valueTexts = this._valueVisible ? new $List() : null;
            this.validateDisplay(g, this._canvasWidth * this._xZoom, this._canvasHeight * this._yZoom);
            delete this._valueTexts;
            g.translate(-this._xTranslate, -this._yTranslate);
        }
    },
    adjustBounds: function (rect) {
        twaver.charts.ChartBase.superClass.adjustBounds.apply(this, arguments);
        // if (typeof twaver.gis == 'undefined') {
        //     twaver.Util.makeHighRes(this._canvas);
        // }
    },
    validateModel: function () {

   },
   validateDisplay: function (g, width, height) {

   },
   drawLine: function (g, color, width, x1, y1, x2, y2) {
    if (width > 0) {
        g.lineWidth = width;
        g.strokeStyle = this.getUniqueColor(color);
        g.beginPath();
        g.moveTo(x1, y1);
        g.lineTo(x2, y2);
        g.stroke();
    }
},
    // list: [{text:t, font:f, color:color, x:x, y:y} ... ]
    drawValueTexts: function (g) {
        if (this._valueTexts) {
            this._valueTexts.forEach(function (v) {
                $g.drawText(g, v.text, v, v.font, v.color);
            });
        }
    },
    drawVerticalText: function (g, text, cx, font, color) {
        color = this.getUniqueColor(color);
        g.translate(cx.x, cx.y);
        g.rotate(-Math.PI / 2);
        $g.drawText(g, text, null, font, color);
        g.rotate(Math.PI / 2);
        g.translate(-cx.x, -cx.y);
    },
    _getValueTextInfo: function (data, value) {
        if (this._valueTexts) {
            var text = this.formatValueText(value, data);
            if (text && text !== '') {
                var color = this.getValueColor(data);
                var info = {
                    text: text,
                    font: this.getValueFont(data),
                    color: this.getUniqueColor(color, data)
                };
                this._valueTexts.add(info);
                return info;
            }
        }
        return null;
    },
    // max zoom
    getMaxZoom: function () {
        return this._maxZoom;
    },
    setMaxZoom: function (value) {
        if (value < 0) {
            return;
        }
        var oldValue = this._maxZoom;
        this._maxZoom = value;
        this.firePropertyChange('maxZoom', oldValue, value);
        if (this.getXZoom() > value) {
            this.setXZoom(value, false);
        }
        if (this.getYZoom() > value) {
            this.setYZoom(value, false);
        }
    },
    // min zoom
    getMinZoom: function () {
        return this._minZoom;
    },
    setMinZoom: function (value) {
        if (value < 0) {
            return;
        }
        var oldValue = this._minZoom;
        this._minZoom = value;
        this.firePropertyChange('minZoom', oldValue, value);
        if (this.getXZoom() < value) {
            this.setXZoom(value);
        }
        if (this.getYZoom() < value) {
            this.setYZoom(value);
        }
    },
    // xy zoom
    zoomIn: function (animate) {
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateXYZoom(
                this,
                this._xZoom * $Defaults.ZOOM_INCREMENT,
                this._yZoom * $Defaults.ZOOM_INCREMENT));
        } else {
            this.xZoomIn(false);
            this.yZoomIn(false);
        }
    },
    zoomOut: function (animate) {
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateXYZoom(
                this,
                this._xZoom / $Defaults.ZOOM_INCREMENT,
                this._yZoom / $Defaults.ZOOM_INCREMENT));
        } else {
            this.xZoomOut(false);
            this.yZoomOut(false);
        }
    },
    zoomReset: function (animate) {
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateXYZoom(this, 1, 1));
        } else {
            this.xZoomReset(false);
            this.yZoomReset(false);
        }
    },
    // x zoom
    getXZoom: function () {
        return this._xZoom;
    },
    onXZoomChanged: function (oldZoom, newZoom) {
    },
    xZoomIn: function (animate) {
        this.setXZoom(this._xZoom * $Defaults.ZOOM_INCREMENT, animate);
    },
    xZoomOut: function (animate) {
        this.setXZoom(this._xZoom / $Defaults.ZOOM_INCREMENT, animate);
    },
    xZoomReset: function (animate) {
        this.setXZoom(1, animate);
    },
    setXZoom: function (value, animate) {
        if (!_twaver.num(value) || value <= 0) {
            return;
        }
        if (value < this._minZoom) {
            value = this._minZoom;
        }
        if (value > this._maxZoom) {
            value = this._maxZoom;
        }
        if (value === this.xZoom) {
            return;
        }
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateXZoom(this, value));
        } else {
            var oldZoom = this._xZoom;
            var newXTranslate = this._xTranslate - (this._canvasWidth / 2 - this._xTranslate) / oldZoom * (value - oldZoom);
            this._xZoom = value;
            this.firePropertyChange('xZoom', oldZoom, value);
            this.onXZoomChanged(oldZoom, value);
            this.setXTranslate(newXTranslate);
        }
    },
    // y zoom
    getYZoom: function () {
        return this._yZoom;
    },
    onYZoomChanged: function (oldZoom, newZoom) {
    },
    yZoomIn: function (animate) {
        this.setYZoom(this._yZoom * $Defaults.ZOOM_INCREMENT, animate);
    },
    yZoomOut: function (animate) {
        this.setYZoom(this._yZoom / $Defaults.ZOOM_INCREMENT, animate);
    },
    yZoomReset: function (animate) {
        this.setYZoom(1, animate);
    },
    setYZoom: function (value, animate) {
        if (!_twaver.num(value) || value <= 0) {
            return;
        }
        if (value < this._minZoom) {
            value = this._minZoom;
        }
        if (value > this._maxZoom) {
            value = this._maxZoom;
        }
        if (value === this.YZoom) {
            return;
        }
        if (animate == null) {
            animate = $Defaults.ZOOM_ANIMATE;
        }
        if (animate) {
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateYZoom(this, value));
        } else {
            var oldZoom = this._yZoom;
            var newYTranslate = this._yTranslate - (this._canvasHeight / 2 - this._yTranslate) / oldZoom * (value - oldZoom);
            this._yZoom = value;
            this.firePropertyChange('yZoom', oldZoom, value);
            this.onYZoomChanged(oldZoom, value);
            this.setYTranslate(newYTranslate);
        }
    }
});

twaver.charts.ScaleChart = function (dataBox) {
    twaver.charts.ScaleChart.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.charts.ScaleChart', twaver.charts.ChartBase, {
    __accessor: [
            'upperLimit', 'lowerLimit',
            'xAxisText', 'xAxisLineColor', 'xAxisLineWidth', 'xAxisTextColor', 'xAxisTextFont',
            'yAxisText', 'yAxisLineColor', 'yAxisLineWidth', 'yAxisTextColor', 'yAxisTextFont',
            'xScaleTexts', 'xScaleTextFont', 'xScaleTextColor', 'xScaleTextOrientation',
            'yScaleTextVisible', 'yScaleTextColor', 'yScaleTextFont', 'yScaleLineColor',
            'yScaleLineWidth', 'yScaleValueGap', 'yScalePixelGap', 'yScaleMinTextVisible',
            'valueSpanCount',
        ],

    _reset: function () {
        this._map = {};
        this._max = 0;
        this._min = 0;
        this._columnCount = this._xScaleTexts ? this._xScaleTexts.size() : 0;

        if (this._upperLimit != null) {
            this._max = this._upperLimit;
        }
        if (this._lowerLimit != null) {
            this._min = this._lowerLimit;
        }
    },
    getMin: function () {
        return this._min;
    },
    getMax: function () {
        return this._max;
    },
    getRange: function () {
        return this._range;
    },
    getColumnCount: function () {
        return this._columnCount;
    },
    getColumnWidth: function () {
        return this._columnWidth;
    },
    getValues: function (data) {
        return data.getStyle ? data.getStyle('chart.values') : null;
    },
    formatYScaleText: function (value) {
        return value.toFixed(2);
    },

    _initRange: function () {
        if (this._lowerLimit == null) {
            if (this._min >= this._max) {
                this._min = this._max - Math.abs(this._max) * 0.1;
            }
            this._min = this._min - (this._max - this._min) * 0.1;
        }
        this._range = this._max - this._min;
    },
    _initValuesProportion: function () {
        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            info.values.forEach(function (value) {
                if (value == null) {
                    info.proportions.add(null);
                } else {
                    info.proportions.add(this._range == 0 ? 0 : value / this._range);
                }
            }, this);
        }, this);
    },
    _commonValidateModel: function () {
        this._publishedDatas.forEach(function (data) {
            var values = new $List(this.getValues(data));
            if (values.size() > this._columnCount) {
                this._columnCount = values.size();
            }
            var info = {
                data: data,
                values: values,
                proportions: new $List(),
                color: this.getUniqueColor(this.getColor(data), data)
            };
            if (this._initInfo) {
                this._initInfo(data, info);
            }
            this._map[data.getId()] = info;

            if (this._upperLimit == null || this._lowerLimit == null) {
                values.forEach(function (value) {
                    if (value != null) {
                        if (this._upperLimit == null && value > this._max) {
                            this._max = value;
                        }
                        if (this._lowerLimit == null && value < this._min) {
                            this._min = value;
                        }
                    }
                }, this);
            }
        }, this);

        this._initRange();
        this._initValuesProportion();
    },
    //  
    //  ---------------------------------------------------------------------------|
    //  |                                             yGap                         |
    //  |      ---------------------------------------------------------------|    |
    //  |      |            |             | yAxisHeight                       |    |
    //  |      |            |             | validHeight                       |    |
    //  |      |            |             |                                   |    |
    //  |      |            |             |           backgroundRect          |    |
    //  |      |            |             |                                   |    |
    //  |      |            |             |                                   |    |
    //  | xGap |yAxisTextGap|yScaleTextGap|              baseline             |xGap|
    //  |      |            |             |-----------------------------------|    |
    //  |      |            |                    xScaleTextGap                |    |
    //  |      |            |-------------------------------------------------|    |
    //  |      |                                  xAxisTextGap                |    |
    //  |      |--------------------------------------------------------------|    |
    //  |                                              yGap                   |    |
    //  ---------------------------------------------------------------------------|
    //
    validateDisplay: function (g, width, height) {
        // get xAxisTextGap value
        var xAxisTextGap = 0;
        if (this._xAxisText) {
            xAxisTextGap = this.getTextSize(this._xAxisTextFont, this._xAxisText).height;
        }

        // get xScaleTextGap value
        var xScaleTextGap = 0;
        if (this._xScaleTexts) {
            this._xScaleTexts.forEach(function (text) {
                var size = this.getTextSize(this._xScaleTextFont, text);
                var v = this._xScaleTextOrientation === 'vertical' ? size.width : size.height;
                if (v > xScaleTextGap) xScaleTextGap = v;
            }, this);
        }

        // get baseline value
        var baseline = height - this._yGap - xAxisTextGap - xScaleTextGap;

        // get yAxisHeight value
        var yAxisHeight = baseline - this._yGap;

        // get validHeight value
        var validHeight = this._upperLimit == null ? yAxisHeight * 0.9 : yAxisHeight;

        // get yAxisTextGap value
        var yAxisTextGap = 0;
        if (this._yAxisText) {
            yAxisTextGap = this.getTextSize(this._yAxisTextFont, this._yAxisText).height;
        }

        // get pixelGap and valueGap
        var pixelGap, valueGap;
        if (this._yScaleValueGap > 0) {
            pixelGap = Math.max(this._yScaleValueGap / this._range * validHeight, 1);
            valueGap = this._yScaleValueGap
        } else {
            pixelGap = Math.max(this._yScalePixelGap, 1);
            valueGap = this._range * (pixelGap / validHeight);
        }

        // get yScaleTextGap value
        var yScaleTextGap = 0, yScaleTextInfos = new $List(), cursor, text;
        if (this._yScaleTextVisible) {
            cursor = this._yScaleMinTextVisible ? 0 : pixelGap;
            var value = this._min + (this._yScaleMinTextVisible ? 0 : valueGap);
            while (cursor <= yAxisHeight + 1) {
                text = this.formatYScaleText(value);
                if (text) {
                    var size = this.getTextSize(this._yScaleTextFont, text);
                    if (size.width > yScaleTextGap) {
                        yScaleTextGap = size.width;
                    }
                    yScaleTextInfos.add({
                        text: text,
                        size: size,
                        cursor: cursor
                    });
                }
                cursor += pixelGap;
                value += valueGap;
            }
        }

        // get background rect
        var rect = {
            x: this._xGap + yAxisTextGap + yScaleTextGap,
            y: this._yGap,
            width: width - this._xGap - yAxisTextGap - yScaleTextGap - this._xGap,
            height: height - this._yGap - xScaleTextGap - xAxisTextGap - this._yGap
        };
        this.drawBackground(g, rect);

        // get column width
        if (this._columnCount > 0) {
            this._columnWidth = rect.width / (this._columnCount * 3 + 1) * 2;
        } else {
            this._columnWidth = rect.width / 2;
        }
        if (this._columnWidth === 0) {
            this._columnWidth = 1;
        }

        // draw yScaleLine
        if (this._yScaleLineWidth > 0) {
            cursor = 0;
            while (cursor <= yAxisHeight + 1) {
                this.drawLine(g, this._yScaleLineColor, this._yScaleLineWidth,
                        rect.x, baseline - cursor,
                        rect.x + rect.width, baseline - cursor);
                cursor += pixelGap;
            }
        }

        // draw x axis text
        if (this._xAxisText) {
            $g.drawText(g, this._xAxisText, {
                x: rect.x + rect.width / 2,
                y: baseline + xScaleTextGap + xAxisTextGap / 2
            },
            this._xAxisTextFont, this.getUniqueColor(this._xAxisTextColor));
        }

        // draw y axis text
        if (this._yAxisText) {
            this.drawVerticalText(g, this._yAxisText, {
                x: this._xGap + yAxisTextGap / 2,
                y: yAxisHeight / 2 + this._yGap
            }, this._yAxisTextFont, this.getUniqueColor(this._yAxisTextColor));
        }

        // draw y axis line
        this.drawLine(g, this._yAxisLineColor, this._yAxisLineWidth,
                        rect.x, rect.y + rect.height,
                        rect.x, rect.y);

        // draw yScaleText
        var color = this.getUniqueColor(this._yScaleTextColor);
        yScaleTextInfos.forEach(function (info) {
            var point = {
                x: this._xGap + yAxisTextGap + yScaleTextGap - info.size.width / 2,
                y: baseline - info.cursor
            }
            $g.drawText(g, info.text, point, this._yScaleTextFont, color);
        }, this);

        // draw xScale
        var y = rect.y + rect.height + xScaleTextGap / 2;
        color = this.getUniqueColor(this._xScaleTextColor);
        var lineColor = this._xScaleLineWidth > 0 ? this.getUniqueColor(this._xScaleLineColor) : null;
        for (var i = 0; i < this._columnCount; i++) {
            var x = rect.x + this._columnWidth * (1 + i * 1.5);
            if (this._xScaleTexts && i < this._xScaleTexts.size()) {
                text = this._xScaleTexts.get(i);
                if (text) {
                    var p = {
                        x: x,
                        y: y
                    };
                    if (this._xScaleTextOrientation === 'vertical') {
                       this.drawVerticalText(g, text, p, this._yScaleTextFont, color);
                    } else {
                        if(this._valueSpanCount){
                            if(i%this._valueSpanCount == 0){
                               $g.drawText(g, text, p, this._xScaleTextFont, color);
                            }
                        }else{
                           $g.drawText(g, text, p, this._xScaleTextFont, color);
                        }
                    }
                }
            }
            if (this._type !== 'default' && lineColor) {
                if(this._valueSpanCount){
                    if(i%this._valueSpanCount == 0){
                        this.drawLine(g, lineColor, this._xScaleLineWidth, x, rect.y + rect.height, x, rect.y);
                    }
                }else{
                    this.drawLine(g, lineColor, this._xScaleLineWidth, x, rect.y + rect.height, x, rect.y);
                }
            }
        }

        // get skyline
        var skyline = baseline + this._min / valueGap * pixelGap;

        // draw content
        if (this._publishedDatas.size() > 0 && this._columnCount > 0) {
            this.drawContent(g, rect, validHeight, skyline);
        }

        // draw x axis line
        this.drawLine(g, this._xAxisLineColor, this._xAxisLineWidth,
                        rect.x, rect.y + rect.height,
                        rect.x + rect.width, rect.y + rect.height);

    }
});

twaver.charts.PieChart = function (dataBox) {
    this._sum = 0;
    this._map = {};
    twaver.charts.PieChart.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.charts.PieChart', twaver.charts.ChartBase, {
    __accessor: ['type', 'selectOffset', 'startAngle', 'shadowColor', 'shadowOffset', 'lineRate', 'donutRate', 'valuePosition'],

    _type: $Defaults.PIECHART_TYPE,
    _lineRate: $Defaults.PIECHART_LINE_RATE,
    _donutRate: $Defaults.PIECHART_DONUT_RATE,
    _startAngle: $Defaults.PIECHART_START_ANGLE,
    _shadowColor: $Defaults.PIECHART_SHADOW_COLOR,
    _shadowOffset: $Defaults.PIECHART_SHADOW_OFFSET,
    _selectOffset: $Defaults.PIECHART_SELECT_OFFSET,
    _valuePosition: $Defaults.PIECHART_VALUE_POSITION,

    getSum: function () {
        return this._sum;
    },
    validateModel: function () {
        this._sum = 0;
        this._map = {};

        this._publishedDatas.forEach(function (data) {
            var value = this.getValue(data);
            this._map[data.getId()] = {
                data: data,
                value: value,
                color: this.getUniqueColor(this.getColor(data), data)
            };
            this._sum += value;
        }, this);

        var angle = this._startAngle;
        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            info.proportion = this._sum === 0 ? 0 : info.value / this._sum;
            if (this._type !== 'line') {
                info.startAngle = angle;
                info.arc = info.proportion * Math.PI * 2;
                angle += info.arc;
            }
        }, this);
    },
    validateDisplay: function (g, width, height) {
        var rect = {
            x: this._xGap,
            y: this._yGap,
            width: width - this._xGap * 2,
            height: height - this._yGap * 2
        };
        this.drawBackground(g, rect);

        $math.grow(rect, -4, -4);
        if (rect.width <= 0 || rect.height <= 0) {
            return;
        }
        var offset = this._shadowOffset;
        if (offset > 0) {
            g.shadowOffsetX = offset;
            g.shadowOffsetY = offset;
            g.shadowBlur = offset * 1.5;
            g.shadowColor = this._shadowColor;
        }
        if (this._type === 'oval' || this._type === 'circle') {
            var cx = rect.x + rect.width / 2;
            var cy = rect.y + rect.height / 2;
            var rx = rect.width / 2;
            var ry = rect.height / 2;
            if (this._type === 'circle') {
                rx = ry = Math.min(rx, ry);
            }
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (info.arc === 0) {
                    return;
                }
                var sx = 0;
                var sy = 0;
                if (this.isSelected(data)) {
                    var angle = info.startAngle + info.arc / 2;
                    sx = Math.cos(angle) * this._selectOffset;
                    sy = Math.sin(angle) * this._selectOffset * ry / rx;
                }
                g.fillStyle = info.color;
                g.beginPath();
                g.moveTo(cx + sx, cy - sy);
                $g.drawArc(g, cx + sx, cy - sy, info.startAngle, info.arc, rx, ry, true);
                g.closePath();
                g.fill();

                var valueText = this._getValueTextInfo(data, info.value);
                if (valueText) {
                    var angle = info.startAngle + info.arc / 2;
                    valueText.x = cx + sx + Math.cos(angle) * rx * this._valuePosition;
                    valueText.y = cy - sy - Math.sin(angle) * ry * this._valuePosition;
                }
            }, this);
        }
        else if (this._type === 'donut' || this._type === 'ovalDonut') {
            var cx = rect.x + rect.width / 2;
            var cy = rect.y + rect.height / 2;
            var rx = rect.width / 2;
            var ry = rect.height / 2;
            if (this._type === 'donut') {
                rx = ry = Math.min(rx, ry);
            }
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (info.arc === 0) {
                    return;
                }
                var sx = 0;
                var sy = 0;
                if (this.isSelected(data)) {
                    var angle = info.startAngle + info.arc / 2;
                    sx = Math.cos(angle) * this._selectOffset;
                    sy = Math.sin(angle) * this._selectOffset * ry / rx;
                }
                var p1x = cx + Math.cos(info.startAngle) * rx * this._donutRate;
                var p1y = cy - Math.sin(info.startAngle) * ry * this._donutRate;

                var p2x = cx + Math.cos(info.startAngle + info.arc) * rx * this._donutRate;
                var p2y = cy - Math.sin(info.startAngle + info.arc) * ry * this._donutRate;

                g.fillStyle = info.color;
                g.beginPath();
                g.moveTo(p1x + sx, p1y - sy);
                $g.drawArc(g, cx + sx, cy - sy, info.startAngle, info.arc, rx, ry, true);
                g.lineTo(p2x + sx, p2y - sy);
                $g.drawArc(g, cx + sx, cy - sy, info.startAngle + info.arc, -info.arc, rx * this._donutRate, ry * this._donutRate, true);
                g.closePath();
                g.fill();

                var valueText = this._getValueTextInfo(data, info.value);
                if (valueText) {
                    var angle = info.startAngle + info.arc / 2;
                    var rate = this._donutRate + (1 - this._donutRate) * this._valuePosition;
                    valueText.x = cx + sx + Math.cos(angle) * rx * rate;
                    valueText.y = cy - sy - Math.sin(angle) * ry * rate;
                }
            }, this);
        }
        else if (this._type === 'line') {
            var h = rect.height * this._lineRate;
            rect.y = rect.y + rect.height / 2 - h / 2;
            rect.height = h;
            var startx = rect.x;
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                var w = rect.width * info.proportion;
                if (w === 0) {
                    return;
                }
                g.beginPath();
                g.fillStyle = info.color;
                var sf = this.isSelected(data) ? -this._selectOffset : 0;
                g.rect(startx, rect.y + sf, w, rect.height);
                g.closePath();
                g.fill();

                var valueText = this._getValueTextInfo(data, info.value);
                if (valueText) {
                    valueText.x = startx + w / 2;
                    valueText.y = rect.y + rect.height + sf - rect.height * this._valuePosition;
                }

                startx += w;
            }, this);
        }
        if (this._shadowOffset > 0) {
            g.shadowOffsetX = 0;
            g.shadowOffsetY = 0;
            g.shadowBlur = 0;
        }
        // draw value text
        this.drawValueTexts(g);
    }
});

twaver.charts.BarChart = function (dataBox) {
    twaver.charts.BarChart.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.charts.BarChart', twaver.charts.ScaleChart, {
    __accessor: ['type'],

    _upperLimit: $Defaults.BARCHART_UPPER_LIMIT,
    _lowerLimit: $Defaults.BARCHART_LOWER_LIMIT,
    _type: $Defaults.BARCHART_TYPE,

    _xAxisText: null,
    _xAxisTextColor: $Defaults.BARCHART_XAXIS_TEXT_COLOR,
    _xAxisTextFont: $Defaults.BARCHART_XAXIS_TEXT_FONT,
    _xAxisLineColor: $Defaults.BARCHART_XAXIS_LINE_COLOR,
    _xAxisLineWidth: $Defaults.BARCHART_XAXIS_LINE_WIDTH,

    _yAxisText: null,
    _yAxisTextColor: $Defaults.BARCHART_YAXIS_TEXT_COLOR,
    _yAxisTextFont: $Defaults.BARCHART_YAXIS_TEXT_FONT,
    _yAxisLineColor: $Defaults.BARCHART_YAXIS_LINE_COLOR,
    _yAxisLineWidth: $Defaults.BARCHART_YAXIS_LINE_WIDTH,

    _xScaleTexts: null,
    _xScaleTextFont: $Defaults.BARCHART_XSCALE_TEXT_FONT,
    _xScaleTextColor: $Defaults.BARCHART_XSCALE_TEXT_COLOR,
    _xScaleTextOrientation: $Defaults.BARCHART_XSCALE_TEXT_ORIENTATION,

    _yScaleTextVisible: $Defaults.BARCHART_YSCALE_TEXT_VISIBLE,
    _yScaleTextColor: $Defaults.BARCHART_YSCALE_TEXT_COLOR,
    _yScaleTextFont: $Defaults.BARCHART_YSCALE_TEXT_FONT,
    _yScaleLineColor: $Defaults.BARCHART_YSCALE_LINE_COLOR,
    _yScaleLineWidth: $Defaults.BARCHART_YSCALE_LINE_WIDTH,
    _yScaleValueGap: $Defaults.BARCHART_YSCALE_VALUE_GAP,
    _yScalePixelGap: $Defaults.BARCHART_YSCALE_PIXEL_GAP,
    _yScaleMinTextVisible: $Defaults.BARCHART_YSCALE_MIN_TEXT_VISIBLE,

    validateModel: function () {
        var funcName = this._type + 'ValidateModel';
        if (this[funcName]) {
            this._reset();
            this[funcName]();
        }
    },

    defaultValidateModel: function () {
        this._columnCount = this._publishedDatas.size();
        this._publishedDatas.forEach(function (data) {
            var value = this.getValue(data);
            if (this._upperLimit == null && value > this._max) {
                this._max = value;
            }
            if (this._lowerLimit == null && value < this._min) {
                this._min = value;
            }
            this._map[data.getId()] = {
                data: data,
                value: value,
                color: this.getUniqueColor(this.getColor(data), data)
            };
        }, this);

        this._initRange();

        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            info.proportion = this._range == 0 ? 0 : info.value / this._range;
        }, this);
    },

    layerValidateModel: function () {
        this._commonValidateModel();
    },

    groupValidateModel: function () {
        this._commonValidateModel()
    },

    stackValidateModel: function () {
        this._publishedDatas.forEach(function (data) {
            var values = new $List(this.getValues(data));
            if (values.size() > this._columnCount) {
                this._columnCount = values.size();
            }
            var info = {
                data: data,
                values: values,
                proportions: new $List(),
                color: this.getUniqueColor(this.getColor(data), data)
            };
            this._map[data.getId()] = info;
        }, this);

        if (this._upperLimit == null || this._lowerLimit == null) {
            for (var i = 0; i < this._columnCount; i++) {
                var upSum = 0;
                var lowSum = 0;
                this._publishedDatas.forEach(function (data) {
                    var info = this._map[data.getId()];
                    if (info.values.size() > i) {
                        var value = info.values.get(i);
                        if (value != null) {
                            if (value >= 0) {
                                upSum += value;
                            } else {
                                lowSum += value;
                            }
                        }
                    }
                }, this);
                if (this._upperLimit == null && upSum > this._max) {
                    this._max = upSum;
                }
                if (this._lowerLimit == null && lowSum < this._min) {
                    this._min = lowSum;
                }
            }
        }

        this._initRange();
        this._initValuesProportion();
    },

    percentValidateModel: function () {
        this._publishedDatas.forEach(function (data) {
            var values = new $List(this.getValues(data));
            if (values.size() > this._columnCount) {
                this._columnCount = values.size();
            }
            var info = {
                data: data,
                values: values,
                proportions: new $List(),
                color: this.getUniqueColor(this.getColor(data), data)
            };
            this._map[data.getId()] = info;
        }, this);

        var sums = new $List();
        for (var i = 0; i < this._columnCount; i++) {
            var sum = 0;
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (info.values.size() > i) {
                    var value = info.values.get(i);
                    if (value != null) {
                        sum += value;
                    }
                }
            }, this);
            sums.add(sum);
        }
        for (var i = 0; i < this._columnCount; i++) {
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                var sum = sums.get(i);
                if (sum !== 0 && info.values.size() > i) {
                    var value = info.values.get(i);
                    if (value != null) {
                        info.proportions.add(value / sum);
                        return;
                    }
                }
                info.proportions.add(null);
            }, this);
        }
        this._min = 0;
        this._max = 1;
        this._range = 1;
    },
    drawRect: function (g, color, selected, x, y, w, h) {
        g.fillStyle = color;
        if (selected) {
            this._selectInfos.add({
                x: x,
                y: y,
                w: w,
                h: h,
                color: this.getUniqueColor($g.darker(color))
            });
        }
        g.beginPath();
        g.rect(x, y, w, h);
        g.closePath();
        g.fill();
    },
    drawContent: function (g, rect, validHeight, skyline) {
        this._selectInfos = new $List();
        this._toolTipInfos = this.isToolTipEnabled() ? new $List() : null;

        // default type
        if (this._type === 'default') {
            this.drawDefaultContent(g, rect, validHeight, skyline);
        }
        // group type
        else if (this._type === 'group') {
            this.drawGroupContent(g, rect, validHeight, skyline);
        }
        // percent type
        else if (this._type === 'percent') {
            this.drawPercentContent(g, rect, validHeight, skyline);
        }
        // stack type
        else if (this._type === 'stack') {
            this.drawStackContent(g, rect, validHeight, skyline);
        }
        // layer type
        else if (this._type === 'layer') {
            this.drawLayerContent(g, rect, validHeight, skyline);
        }

        // draw value text
        this.drawValueTexts(g);

        // draw select rects
        this._selectInfos.forEach(function (info) {
            g.lineWidth = 2;
            g.strokeStyle = info.color;
            g.beginPath();
            g.rect(info.x, info.y, info.w, info.h);
            g.closePath();
            g.stroke();
        }, this);

        delete this._selectInfos;
    },

    drawDefaultContent: function (g, rect, validHeight, skyline) {
        var count = this._publishedDatas.size();
        var w = this._columnWidth;
        for (var i = 0; i < count; i++) {
            var data = this._publishedDatas.get(i);
            var info = this._map[data.getId()];
            var x = rect.x + w * (0.5 + i * 1.5);
            var h = Math.abs(validHeight * info.proportion);
            var y = info.proportion > 0 ? skyline - h : skyline;
            this.drawRect(g, info.color, this.isSelected(data), x, y, w, h);
            this.addToolTipInfo(x, y, w, h, info.value, data);
            var valueText = this._getValueTextInfo(data, info.value);
            if (valueText) {
                var size = this.getTextSize(valueText.font, valueText.text);
                valueText.x = x + w / 2;
                valueText.y = y - size.height / 2 + 1;
            }
        }
    },
    drawPercentContent: function (g, rect, validHeight, skyline) {
        this.drawStackContent(g, rect, validHeight, skyline);
    },
    drawStackContent: function (g, rect, validHeight, skyline) {
        var count = this._columnCount;
        var w = this._columnWidth;
        for (var i = 0; i < count; i++) {
            var y = skyline;
            var x = rect.x + w * (0.5 + i * 1.5);
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (i < info.proportions.size()) {
                    var proportion = info.proportions.get(i);
                    if (proportion != null) {
                        var h = validHeight * proportion;
                        y -= h;
                        this.drawRect(g, info.color, this.isSelected(data), x, y, w, h);
                        this.addToolTipInfo(x, y, w, h, info.values.get(i), data);
                        var valueText = this._getValueTextInfo(data, info.values.get(i));
                        if (valueText) {
                            valueText.x = x + w / 2;
                            valueText.y = y + h / 2;
                        }
                    }
                }
            }, this);
        }
    },
    drawLayerContent: function (g, rect, validHeight, skyline) {
        var eCount = this._publishedDatas.size();
        var count = this._columnCount;
        var w = this._columnWidth;
        var gap = w * 3 / 8 / eCount;
        for (var i = 0; i < count; i++) {
            var x = rect.x + w * (0.5 + i * 1.5);
            var j = 0;
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (i < info.proportions.size()) {
                    var proportion = info.proportions.get(i);
                    if (proportion != null) {
                        var h = validHeight * proportion;
                        var y = skyline - h;
                        var xxx = x + w / 2 - w / 8 - gap * (eCount - j);
                        var www = (w / 8 + gap * (eCount - j)) * 2;
                        this.drawRect(g, info.color, this.isSelected(data), xxx, y, www, h);
                        this.addToolTipInfo(xxx, y, www, h, info.values.get(i), data);
                        var valueText = this._getValueTextInfo(data, info.values.get(i));
                        if (valueText) {
                            var size = this.getTextSize(valueText.font, valueText.text);
                            valueText.x = xxx + www / 2;
                            valueText.y = y - size.height / 2 + 1;
                        }
                    }
                }
                j++;
            }, this);
        }
    },
    drawGroupContent: function (g, rect, validHeight, skyline) {
        var eCount = this._publishedDatas.size();
        var count = this._columnCount;
        var w = this._columnWidth;
        var ww = w / eCount;
        for (var i = 0; i < count; i++) {
            var x = rect.x + w * (0.5 + i * 1.5);
            var j = 0;
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                if (i < info.proportions.size()) {
                    var proportion = info.proportions.get(i);
                    if (proportion != null) {
                        var h = validHeight * proportion;
                        var y = skyline - h;
                        this.drawRect(g, info.color, this.isSelected(data), x + ww * j, y, ww, h);
                        this.addToolTipInfo(x + ww * j, y, ww, h, info.values.get(i), data);
                        var valueText = this._getValueTextInfo(data, info.values.get(i));
                        if (valueText) {
                            var size = this.getTextSize(valueText.font, valueText.text);
                            valueText.x = x + ww * j + ww / 2;
                            valueText.y = y - size.height / 2 + 1;
                        }
                    }
                }
                j++;
            }, this);
        }
    }


});

twaver.charts.LineChart = function (dataBox) {
    twaver.charts.LineChart.superClass.constructor.apply(this, arguments);
    this._selectTolerance = 2;
};
_twaver.ext('twaver.charts.LineChart', twaver.charts.ScaleChart, {
    __accessor: ['xScaleLineColor', 'xScaleLineWidth', 'interruptable'],

    _interruptable: $Defaults.LINECHART_INTERRUPTABLE,
    _upperLimit: $Defaults.LINECHART_UPPER_LIMIT,
    _lowerLimit: $Defaults.LINECHART_LOWER_LIMIT,

    _xAxisText: null,
    _xAxisTextColor: $Defaults.LINECHART_XAXIS_TEXT_COLOR,
    _xAxisTextFont: $Defaults.LINECHART_XAXIS_TEXT_FONT,
    _xAxisLineColor: $Defaults.LINECHART_XAXIS_LINE_COLOR,
    _xAxisLineWidth: $Defaults.LINECHART_XAXIS_LINE_WIDTH,

    _yAxisText: null,
    _yAxisTextColor: $Defaults.LINECHART_YAXIS_TEXT_COLOR,
    _yAxisTextFont: $Defaults.LINECHART_YAXIS_TEXT_FONT,
    _yAxisLineColor: $Defaults.LINECHART_YAXIS_LINE_COLOR,
    _yAxisLineWidth: $Defaults.LINECHART_YAXIS_LINE_WIDTH,

    _xScaleTexts: null,
    _xScaleTextFont: $Defaults.LINECHART_XSCALE_TEXT_FONT,
    _xScaleTextColor: $Defaults.LINECHART_XSCALE_TEXT_COLOR,
    _xScaleTextOrientation: $Defaults.LINECHART_XSCALE_TEXT_ORIENTATION,
    _xScaleLineColor: $Defaults.LINECHART_XSCALE_LINE_COLOR,
    _xScaleLineWidth: $Defaults.LINECHART_XSCALE_LINE_WIDTH,
    _valueSpanCount: $Defaults.LINECHART_VALUESPANCOUNT,

    _yScaleTextVisible: $Defaults.LINECHART_YSCALE_TEXT_VISIBLE,
    _yScaleTextColor: $Defaults.LINECHART_YSCALE_TEXT_COLOR,
    _yScaleTextFont: $Defaults.LINECHART_YSCALE_TEXT_FONT,
    _yScaleLineColor: $Defaults.LINECHART_YSCALE_LINE_COLOR,
    _yScaleLineWidth: $Defaults.LINECHART_YSCALE_LINE_WIDTH,
    _yScaleValueGap: $Defaults.LINECHART_YSCALE_VALUE_GAP,
    _yScalePixelGap: $Defaults.LINECHART_YSCALE_PIXEL_GAP,
    _yScaleMinTextVisible: $Defaults.LINECHART_YSCALE_MIN_TEXT_VISIBLE,

    getLineWidth: function (data) {
        return data.getStyle ? data.getStyle('chart.line.width') : twaver.Styles.getStyle('chart.line.width');
    },
    getMarkerShape: function (data) {
        return data.getStyle ? data.getStyle('chart.marker.shape') : twaver.Styles.getStyle('chart.marker.shape');
    },
    getMarkerSize: function (data) {
        return data.getStyle ? data.getStyle('chart.marker.size') : twaver.Styles.getStyle('chart.marker.size');
    },

    _initInfo: function (data, info) {
        info.markerShape = this.getMarkerShape(data);
        info.markerSize = this.getMarkerSize(data);
        info.lineWidth = this.getLineWidth(data);
        if (this.isSelected(data)) {
            info.lineWidth += 2;
        }
    },

    validateModel: function () {
        this._reset();
        this._commonValidateModel();
    },
    getPointIndexAt: function () {
        var point = this._getPoint.apply(this, arguments),
        	data = this.tryGetDataAt(point);
        if (!data) {
            return -1;
        }
        var info = this._map[data.getId()],
        	points = info.points,
        	size = info.markerSize;
        for (var i = 0, c = points.size(), p; i < c; i++) {
            p = points.get(i);
            if (p) {
                if ($math.getDistance(point, p) <= size) {
                    return i;
                }
            }
        }
        return -1;
    },
    drawContent: function (g, rect, validHeight, skyline) {

        this._toolTipInfos = this.isToolTipEnabled() ? new $List() : null;

        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            var markers = info.markerSize > 0 ? new $List() : null;

            g.strokeStyle = info.color;
            g.lineWidth = info.lineWidth;
            g.beginPath();

            var proportions = info.proportions;
            var lastPoint = null;
            var c = proportions.size();
            var points = new $List();
            info.points = points;

            for (var i = 0; i < c; i++) {
                var proportion = proportions.get(i);
                if (proportion != null) {
                    var point = {
                        x: rect.x + this._columnWidth * (1 + i * 1.5),
                        y: skyline - validHeight * proportion
                    };
                    points.add(point);

                    // draw line
                    if (lastPoint == null) {
                        g.moveTo(point.x, point.y);
                    } else {
                        g.lineTo(point.x, point.y);
                    }

                    // draw text
                    var value = info.values.get(i);
                    var valueText = this._getValueTextInfo(data, value);
                    if (valueText) {
                        var size = this.getTextSize(valueText.font, valueText.text);
                        valueText.x = point.x;
                        valueText.y = point.y - size.height / 2 + 2;
                    }

                    // draw marker
                    if (markers) {
                        markers.add({
                            point: point,
                            value: value,
                            data: data,
                            index: i
                        });
                    }

                    lastPoint = point;
                } else if (this._interruptable) {
                    lastPoint = null;
                    points.add(null);
                }
            }
            g.stroke();

            // draw marker
            if (markers) {
                var offset = info.markerSize / 2;
                markers.forEach(function (markInfo) {
                    g.fillStyle = info.color;
                    var x = markInfo.point.x - offset;
                    var y = markInfo.point.y - offset;
                    var w = info.markerSize;
                    var h = info.markerSize;
                    $g.drawVector(g, info.markerShape, null, x, y, w, h);
                    g.fill();
                    this.addToolTipInfo(x, y, w, h, markInfo.value, markInfo.data, markInfo.index);
                }, this);
            }

        }, this);

        // draw value text
        this.drawValueTexts(g);
    }


});

twaver.charts.BubbleChart = function (dataBox) {
    twaver.charts.BubbleChart.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.charts.BubbleChart', twaver.charts.ScaleChart, {
    __accessor: ['xAxisUpperLimit', 'xAxisLowerLimit', 'xScaleLineColor', 'xScaleLineWidth', 'selectShadowColor', 'selectShadowOffset'],

    _upperLimit: $Defaults.BUBBLECHART_UPPER_LIMIT,
    _lowerLimit: $Defaults.BUBBLECHART_LOWER_LIMIT,
    _xAxisUpperLimit: $Defaults.BUBBLECHART_XAXIS_UPPER_LIMIT,
    _xAxisLowerLimit: $Defaults.BUBBLECHART_XAXIS_LOWER_LIMIT,

    _xAxisText: null,
    _xAxisTextColor: $Defaults.BUBBLECHART_XAXIS_TEXT_COLOR,
    _xAxisTextFont: $Defaults.BUBBLECHART_XAXIS_TEXT_FONT,
    _xAxisLineColor: $Defaults.BUBBLECHART_XAXIS_LINE_COLOR,
    _xAxisLineWidth: $Defaults.BUBBLECHART_XAXIS_LINE_WIDTH,

    _yAxisText: null,
    _yAxisTextColor: $Defaults.BUBBLECHART_YAXIS_TEXT_COLOR,
    _yAxisTextFont: $Defaults.BUBBLECHART_YAXIS_TEXT_FONT,
    _yAxisLineColor: $Defaults.BUBBLECHART_YAXIS_LINE_COLOR,
    _yAxisLineWidth: $Defaults.BUBBLECHART_YAXIS_LINE_WIDTH,

    _xScaleTexts: null,
    _xScaleTextFont: $Defaults.BUBBLECHART_XSCALE_TEXT_FONT,
    _xScaleTextColor: $Defaults.BUBBLECHART_XSCALE_TEXT_COLOR,
    _xScaleTextOrientation: $Defaults.BUBBLECHART_XSCALE_TEXT_ORIENTATION,
    _xScaleLineColor: $Defaults.BUBBLECHART_XSCALE_LINE_COLOR,
    _xScaleLineWidth: $Defaults.BUBBLECHART_XSCALE_LINE_WIDTH,

    _yScaleTextVisible: $Defaults.BUBBLECHART_YSCALE_TEXT_VISIBLE,
    _yScaleTextColor: $Defaults.BUBBLECHART_YSCALE_TEXT_COLOR,
    _yScaleTextFont: $Defaults.BUBBLECHART_YSCALE_TEXT_FONT,
    _yScaleLineColor: $Defaults.BUBBLECHART_YSCALE_LINE_COLOR,
    _yScaleLineWidth: $Defaults.BUBBLECHART_YSCALE_LINE_WIDTH,
    _yScaleValueGap: $Defaults.BUBBLECHART_YSCALE_VALUE_GAP,
    _yScalePixelGap: $Defaults.BUBBLECHART_YSCALE_PIXEL_GAP,
    _yScaleMinTextVisible: $Defaults.BUBBLECHART_YSCALE_MIN_TEXT_VISIBLE,

    _selectShadowColor: $Defaults.BUBBLECHART_SELECT_SHADOW_COLOR,
    _selectShadowOffset: $Defaults.BUBBLECHART_SELECT_SHADOW_OFFSET,

    _resetX: function () {
        this._xMax = 0;
        this._xMin = 0;

        if (this._xAxisUpperLimit != null) {
            this._xMax = this._xAxisUpperLimit;
        }
        if (this._xAxisLowerLimit != null) {
            this._xMin = this._xAxisLowerLimit;
        }
    },
    getXMin: function () {
        return this._xMin;
    },
    getXMax: function () {
        return this._xMax;
    },
    getXRange: function () {
        return this._xRange;
    },

    getShape: function (data) {
        return data.getStyle ? data.getStyle('chart.bubble.shape') : twaver.Styles.getStyle('chart.bubble.shape');
    },
    getSize: function (data, value) {
        return value;
    },
    getNames: function (data) {
        return data.getStyle ? data.getStyle('chart.names') : twaver.Styles.getStyle('chart.names');
    },
    getXAxisValues: function (data) {
        return data.getStyle ? data.getStyle('chart.xaxis.values') : twaver.Styles.getStyle('chart.xaxis.values');
    },
    getYAxisValues: function (data) {
        return data.getStyle ? data.getStyle('chart.yaxis.values') : twaver.Styles.getStyle('chart.yaxis.values');
    },

    _initXRange: function () {
        if (this._xAxisLowerLimit == null) {
            if (this._xMin >= this._xMax) {
                this._xMin = this._xMax - Math.abs(this._xMax) * 0.1;
            }
            this._xMin = this._xMin - (this._xMax - this._xMin) * 0.1;
        }
        this._xRange = this._xMax - this._xMin;
    },
    _initXYValuesProportion: function () {
        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            info.xAxisValues.forEach(function (value) {
                if (value == null) {
                    info.xAxisProportions.add(null);
                } else {
                    info.xAxisProportions.add(this._xRange == 0 ? 0 : value / this._xRange);
                }
            }, this);
            info.yAxisValues.forEach(function (value) {
                if (value == null) {
                    info.yAxisProportions.add(null);
                } else {
                    info.yAxisProportions.add(this._range == 0 ? 0 : value / this._range);
                }
            }, this);
        }, this);
    },

    validateModel: function () {
        this._reset();
        this._resetX();
        this._columnCount = this._xScaleTexts == null ? 0 : this._xScaleTexts.size();
        this._publishedDatas.forEach(function (data) {
            var yAxisValues = new $List(this.getYAxisValues(data));
            var xAxisValues = new $List(this.getXAxisValues(data));
            var values = new $List(this.getValues(data));
            if (values.size() > this._columnCount) {
                this._columnCount = values.size();
            }
            var info = {
                data: data,
                values: values,
                yAxisValues: yAxisValues,
                xAxisValues: xAxisValues,
                yAxisProportions: new $List(),
                xAxisProportions: new $List(),
                color: this.getUniqueColor(this.getColor(data), data),
                anchorShape: this.getShape(data)
            };
            this._map[data.getId()] = info;

            if (this._upperLimit == null || this._lowerLimit == null) {
                yAxisValues.forEach(function (value) {
                    if (value != null) {
                        if (this._upperLimit == null && value > this._max) {
                            this._max = value;
                        }
                        if (this._lowerLimit == null && value < this._min) {
                            this._min = value;
                        }
                    }
                }, this);
            }
            if (this._upperLimit == null || this._lowerLimit == null) {
                xAxisValues.forEach(function (value) {
                    if (value != null) {
                        if (this._xAxisUpperLimit == null && value > this._xMax) {
                            this._xMax = value;
                        }
                        if (this._xAxisLowerLimit == null && value < this._xMin) {
                            this._xMin = value;
                        }
                    }
                }, this);
            }
        }, this);

        this._initRange();
        this._initXRange();
        this._initXYValuesProportion();
    },

    drawContent: function (g, rect, validHeight, skyline) {

        this._toolTipInfos = this.isToolTipEnabled() ? new $List() : null;

        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            var yAxisProportions = info.yAxisProportions;
            var xAxisProportions = info.xAxisProportions;
            var values = info.values;
            var c = info.yAxisProportions.size();

            var offset = this._selectShadowOffset;
            if (this.isSelected(data) && offset > 0) {
                g.shadowOffsetX = offset;
                g.shadowOffsetY = offset;
                g.shadowBlur = offset * 2;
                g.shadowColor = this._selectShadowColor;
            } else {
                g.shadowOffsetX = 0;
                g.shadowOffsetY = 0;
                g.shadowBlur = 0;
                g.shadowColor = info.color;
            }
            g.fillStyle = info.color;

            for (var i = 0; i < c; i++) {
                var yAxisProportion = yAxisProportions.get(i);
                var xAxisProportion = xAxisProportions.get(i);
                if (yAxisProportion != null) {
                    var point = {
                        x: rect.x + rect.width * xAxisProportion,
                        y: skyline - validHeight * yAxisProportion
                    };

                    // draw marker
                    var value = values.get(i);
                    var size = this.getSize(data, value);
                    var offset = size / 2;

                    var x = point.x - offset;
                    var y = point.y - offset;
                    var w = size;
                    var h = size;
                    $g.drawVector(g, info.anchorShape, null, x, y, w, h);
                    g.fill();
                    this.addToolTipInfo(x, y, w, h, value, data, i);

                    // draw text
                    var valueText = this._getValueTextInfo(data, value);
                    if (valueText) {
                        var size = this.getTextSize(valueText.font, valueText.text);
                        valueText.x = point.x;
                        valueText.y = point.y;
                    }
                }
            }
        }, this);

        // draw value text
        this.drawValueTexts(g);
    }
});

twaver.charts.DialChart = function (dataBox) {
    twaver.charts.DialChart.superClass.constructor.apply(this, arguments);
};
_twaver.ext('twaver.charts.DialChart', twaver.charts.ChartBase, {
    __accessor: ['upperLimit', 'lowerLimit', 'startAngle', 'endAngle', 'innerRadius', 'colorRangeFillColor', 'outlineWidth', 'outlineColor',
                    'majorScaleCount', 'majorScaleLineWidth', 'majorScaleLineLength', 'majorScaleLineColor',
                    'minorScaleCount', 'minorScaleLineWidth', 'minorScaleLineLength', 'minorScaleLineColor',
                    'scaleTextVisible', 'scaleUpperLimitTextVisible', 'scaleLowerLimitTextVisible', 'scaleTextFont', 'scaleTextColor',
                    'pivotRadius', 'pivotFillColor', 'pivotOutlineWidth', 'pivotOutlineColor', 'pivotGradient', 'pivotGradientColor',
                    'valuePosition', 'colorRangeList', 'innerDarkerRadius', 'outerBrighterRadius', 'selectShadowColor', 'selectShadowOffset'],

    __bool: ['scaleInside', 'pivotFill'],

    _upperLimit: $Defaults.DIALCHART_UPPER_LIMIT,
    _lowerLimit: $Defaults.DIALCHART_LOWER_LIMIT,
    _startAngle: $Defaults.DIALCHART_START_ANGLE,
    _endAngle: $Defaults.DIALCHART_END_ANGLE,
    _innerRadius: $Defaults.DIALCHART_INNER_RADIUS,
    _colorRangeFillColor: $Defaults.DIALCHART_COLOR_RANGE_FILL_COLOR,
    _outlineWidth: $Defaults.DIALCHART_OUTLINE_WIDTH,
    _outlineColor: $Defaults.DIALCHART_OUTLINE_COLOR,

    _scaleInside: $Defaults.DIALCHART_SCALE_INSIDE,
    _majorScaleCount: $Defaults.DIALCHART_MAJOR_SCALE_COUNT,
    _majorScaleLineWidth: $Defaults.DIALCHART_MAJOR_SCALE_LINE_WIDTH,
    _majorScaleLineLength: $Defaults.DIALCHART_MAJOR_SCALE_LINE_LENGTH,
    _majorScaleLineColor: $Defaults.DIALCHART_MAJOR_SCALE_LINE_COLOR,

    _minorScaleCount: $Defaults.DIALCHART_MINOR_SCALE_COUNT,
    _minorScaleLineWidth: $Defaults.DIALCHART_MINOR_SCALE_LINE_WIDTH,
    _minorScaleLineLength: $Defaults.DIALCHART_MINOR_SCALE_LINE_LENGTH,
    _minorScaleLineColor: $Defaults.DIALCHART_MINOR_SCALE_LINE_COLOR,

    _scaleTextVisible: $Defaults.DIALCHART_SCALE_TEXT_VISIBLE,
    _scaleUpperLimitTextVisible: $Defaults.DIALCHART_SCALE_UPPER_LIMIT_TEXT_VISIBLE,
    _scaleLowerLimitTextVisible: $Defaults.DIALCHART_SCALE_LOWER_LIMIT_TEXT_VISIBLE,
    _scaleTextFont: $Defaults.DIALCHART_SCALE_TEXT_FONT,
    _scaleTextColor: $Defaults.DIALCHART_SCALE_TEXT_COLOR,

    _pivotRadius: $Defaults.DIALCHART_PIVOT_RADIUS,
    _pivotFill: $Defaults.DIALCHART_PIVOT_FILL,
    _pivotFillColor: $Defaults.DIALCHART_PIVOT_FILL_COLOR,
    _pivotOutlineWidth: $Defaults.DIALCHART_PIVOT_OUTLINE_WIDTH,
    _pivotOutlineColor: $Defaults.DIALCHART_PIVOT_OUTLINE_COLOR,
    _pivotGradient: $Defaults.DIALCHART_PIVOT_GRADIENT,
    _pivotGradientColor: $Defaults.DIALCHART_PIVOT_GRADIENT_COLOR,

    _valuePosition: $Defaults.DIALCHART_VALUE_POSITION,
    _innerDarkerRadius: $Defaults.DIALCHART_INNER_DARKER_RADIUS,
    _outerBrighterRadius: $Defaults.DIALCHART_OUTER_BRIGHTER_RADIUS,

    _selectShadowColor: $Defaults.DIALCHART_SELECT_SHADOW_COLOR,
    _selectShadowOffset: $Defaults.DIALCHART_SELECT_SHADOW_OFFSET,

    formatScaleText: function (value) {
        return value.toFixed(2);
    },
    validateModel: function () {
        this._map = {};
        this._valueRange = this._upperLimit - this._lowerLimit;
        var startAngle = this._startAngle;
        if (startAngle != 0) {
            startAngle = (startAngle % 360 + 360) % 360;
            if (startAngle == 0) {
                startAngle = 360;
            }
        }
        this._positiveStartAngle = startAngle;
        var endAngle = this._endAngle;
        if (endAngle != 0) {
            endAngle = (endAngle % 360 + 360) % 360;
            if (endAngle == 0) {
                endAngle = 360;
            }
        }
        this._positiveEndAngle = endAngle;
        this._whole = Math.abs(startAngle - endAngle) == 360;
        this._startAngleByRadian = startAngle * Math.PI / 180;
        this._endAngleByRadian = endAngle * Math.PI / 180;
        this._clockwise = this._startAngleByRadian > this._endAngleByRadian;
        this._angleRange = Math.abs(this._startAngleByRadian - this._endAngleByRadian);

        this._publishedDatas.forEach(function (data) {
            var value = this.getValue(data);
            this._map[data.getId()] = {
                data: data,
                value: value,
                color: this.getUniqueColor(this.getColor(data), data),
                angle: this._startAngleByRadian + (this._clockwise ? -1 : 1) * value / this._valueRange * this._angleRange
            };
        }, this);
    },
    validateDisplay: function (g, width, height) {
        var rect = {
            x: this._xGap,
            y: this._yGap,
            width: width - this._xGap * 2,
            height: height - this._yGap * 2
        };
        this.drawBackground(g, rect);

        if (this._startAngleByRadian == this._endAngleByRadian) {
            return;
        }

        var i;
        var value = this._lowerLimit;
        var avgValue = this._majorScaleCount > 1 ? this._valueRange / (this._majorScaleCount - 1) : 0;
        var maxWidth = 0, maxHeight = 0, size;
        var scaleTextInfos = null;
        var text = null;
        if (this._scaleTextVisible) {
            scaleTextInfos = new $List();
            for (i = 0; i < this._majorScaleCount; i++) {
                if ((i == 0 && !this._scaleLowerLimitTextVisible) || (i == this._majorScaleCount - 1 && !this._scaleUpperLimitTextVisible)) {
                    size = null;
                    scaleTextInfos.add({ text: '', size: { width: 0, height: 0} });
                } else {
                    text = this.formatScaleText(value);
                    size = this.getTextSize(this._scaleTextFont, text);
                    scaleTextInfos.add({ text: text, size: size });
                }
                if (!this._scaleInside && size != null) {
                    if (size.width > maxWidth) {
                        maxWidth = size.width;
                    }
                    if (size.height > maxHeight) {
                        maxHeight = size.height;
                    }
                }
                value += avgValue;
            }
        }
        if (this._angleRange <= Math.PI) {
            maxWidth = Math.max(maxWidth, this._pivotRadius);
            maxHeight = Math.max(maxHeight, this._pivotRadius);
        }
        $math.grow(rect, -maxWidth, -maxHeight);
        this._calcluateCenterAndRadius(rect);

        //draw color range
        g.lineWidth = 0;
        if (this._colorRangeList == null || this._colorRangeList.size() == 0) {
            this._drawArcGroup(g, this._startAngleByRadian, this._endAngleByRadian, this.getUniqueColor(this._colorRangeFillColor));
            this._drawArcOutLine(g, this._startAngleByRadian, this._endAngleByRadian, true, true);
        } else {
            var avgRangeDegree = this._angleRange / this._colorRangeList.size();
            var currentAngle = this._startAngleByRadian;
            for (i = 0; i < this._colorRangeList.size(); i++) {
                var color = this.getUniqueColor(this._colorRangeList.get(i));
                var end = currentAngle + ((this._clockwise ? -1 : 1) * avgRangeDegree);
                this._drawArcGroup(g, currentAngle, end, color);
                this._drawArcOutLine(g, currentAngle, currentAngle + ((this._clockwise ? -1 : 1) * avgRangeDegree), i == 0, i == this._colorRangeList.size() - 1);
                currentAngle += ((this._clockwise ? -1 : 1) * avgRangeDegree);
            }
        }

        //draw scale
        var angle = this._startAngleByRadian;
        var avgAngle = this._majorScaleCount > 1 ? this._angleRange / (this._majorScaleCount - 1) : 0;
        var j, startX, startY, endX, endY, startRadius, endMajorRadius, endMinorRadius;
        startRadius = this._scaleInside ? this._innerRadiusByPixel : this._outerRadius;
        endMajorRadius = startRadius + this._majorScaleLineLength * (this._scaleInside ? 1 : -1);
        endMinorRadius = startRadius + this._minorScaleLineLength * (this._scaleInside ? 1 : -1);
        for (i = 0; i < this._majorScaleCount; i++) {
            //draw major scale
            startX = this._center.x + Math.cos(angle) * startRadius;
            startY = this._center.y + Math.sin(-angle) * startRadius;
            endX = this._center.x + Math.cos(angle) * endMajorRadius;
            endY = this._center.y + Math.sin(-angle) * endMajorRadius;
            g.lineWidth = this._majorScaleLineWidth;
            g.strokeStyle = this.getUniqueColor(this._majorScaleLineColor);
            g.beginPath();
            g.moveTo(startX, startY);
            g.lineTo(endX, endY);
            g.closePath();
            g.stroke();

            //draw scale text
            if (this._scaleTextVisible) {
                if ((i == 0 && !this._scaleLowerLimitTextVisible) || (i == this._majorScaleCount - 1 && !this._scaleUpperLimitTextVisible)) {
                } else {
                    var scaleTextInfo = scaleTextInfos.get(i);
                    if (scaleTextInfo) {
                        var position = this.getScaleTextPosition(angle / Math.PI * 180, startX, startY, scaleTextInfo.size.width, scaleTextInfo.size.height);
                        scaleTextInfo.x = position.x;
                        scaleTextInfo.y = position.y;
                    }
                }
            }

            if (this._whole || (!this._whole && i < this._majorScaleCount - 1)) {
                //draw minor scale
                var minorAngle = angle;
                var avgMinorAngle = this._minorScaleCount > 0 ? avgAngle / (this._minorScaleCount + 1) : 0;
                for (j = 0; j < this._minorScaleCount; j++) {
                    minorAngle += ((this._clockwise ? -1 : 1) * avgMinorAngle);
                    startX = this._center.x + Math.cos(minorAngle) * startRadius;
                    startY = this._center.y + Math.sin(-minorAngle) * startRadius;
                    endX = this._center.x + Math.cos(minorAngle) * endMinorRadius;
                    endY = this._center.y + Math.sin(-minorAngle) * endMinorRadius;
                    g.lineWidth = this._minorScaleLineWidth;
                    g.strokeStyle = this.getUniqueColor(this._minorScaleLineColor);
                    g.beginPath();
                    g.moveTo(startX, startY);
                    g.lineTo(endX, endY);
                    g.closePath();
                    g.stroke();
                }
            }

            angle += ((this._clockwise ? -1 : 1) * avgAngle);
        }

        //draw pivot
        if (this._pivotFill) {
            $g.fill(g, this.getUniqueColor(this._pivotFillColor), this._pivotGradient, this._pivotGradientColor, this._center.x - this._pivotRadius, this._center.y - this._pivotRadius, this._pivotRadius * 2, this._pivotRadius * 2);
        }

        g.lineWidth = this._pivotOutlineWidth;
        g.strokeStyle = this.getUniqueColor(this._pivotOutlineColor);
        g.beginPath();
        g.arc(this._center.x, this._center.y, this._pivotRadius, 0, Math.PI * 2, true);
        g.closePath();

        if (this._pivotFill) {
            g.fill();
        }

        // draw scale texts
        if (scaleTextInfos) {
            scaleTextInfos.forEach(function (v) {
                if (v) {
                    $g.drawText(g, v.text, v, this._scaleTextFont, this._scaleTextColor);
                }
            }, this);
        }

        // draw hand
        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            var rearExtension = this._getDataStyle('dialchart.rear.extension', data);
            var baseWidth = this._getDataStyle('dialchart.base.width', data);
            var topWidth = this._getDataStyle('dialchart.top.width', data);
            var radius = this._getDataStyle('dialchart.radius', data);

            if (radius >= -1 && radius <= 1) {
                radius = radius * this._innerRadiusByPixel;
            }

            g.fillStyle = info.color;
            g.lineWidth = 0;

            var matrix = $math.createMatrix(-info.angle, this._center.x, this._center.y);
            var p1 = matrix.transform(this._center.x + radius, this._center.y + topWidth / 2);
            var p2 = matrix.transform(this._center.x + radius, this._center.y - topWidth / 2);
            var p3 = matrix.transform(this._center.x - rearExtension, this._center.y - baseWidth / 2);
            var p4 = matrix.transform(this._center.x - rearExtension, this._center.y + baseWidth / 2);

            var offset = this._selectShadowOffset;
            if (this.isSelected(data) && offset > 0) {
                g.shadowOffsetX = offset;
                g.shadowOffsetY = offset;
                g.shadowBlur = offset * 2;
                g.shadowColor = this._selectShadowColor;
            } else {
                g.shadowOffsetX = 0;
                g.shadowOffsetY = 0;
                g.shadowBlur = 0;
                g.shadowColor = info.color;
            }
            g.beginPath();
            g.moveTo(p1.x, p1.y);
            g.lineTo(p2.x, p2.y);
            g.lineTo(p3.x, p3.y);
            g.lineTo(p4.x, p4.y);
            g.lineTo(p1.x, p1.y);
            g.closePath();

            g.fill();

            var valueText = this._getValueTextInfo(data, info.value);
            if (valueText) {
                var p5 = matrix.transform(this._center.x + radius * this._valuePosition, this._center.y);
                valueText.x = p5.x;
                valueText.y = p5.y;
            }
        }, this);

        // draw value text
        this.drawValueTexts(g);
    },
    _getDataStyle: function (style, data) {
        if (data.getStyle) {
            return data.getStyle(style);
        }
        return data.getClient(style);
    },
    _calcluateCenterAndRadius: function (rect) {
        var start = this._clockwise ? this._positiveEndAngle : this._positiveStartAngle;
        var end = this._clockwise ? this._positiveStartAngle : this._positiveEndAngle;
        var range = Math.abs(this._positiveEndAngle - this._positiveStartAngle);

        if (0 <= start && start < 90) {
            if (0 <= end && end <= 90) {
                this._outerRadius = Math.min(rect.width, rect.height);
                this._center = { x: rect.x + (rect.width - this._outerRadius) / 2, y: rect.y + (rect.height + this._outerRadius) / 2 };
            } else if (90 < end && end <= 180) {
                this._outerRadius = Math.min(rect.width / 2, rect.height);
                this._center = { x: rect.x + rect.width / 2, y: rect.y + (rect.height + this._outerRadius) / 2 };
            } else {
                this._center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
                this._outerRadius = Math.min(rect.width, rect.height) / 2;
            }
        } else if (90 <= start && start < 180) {
            if (90 <= end && end <= 180) {
                this._outerRadius = Math.min(rect.width, rect.height);
                this._center = { x: rect.x + (rect.width + this._outerRadius) / 2, y: rect.y + (rect.height + this._outerRadius) / 2 };
            } else if (180 < end && end <= 270) {
                this._outerRadius = Math.min(rect.width, rect.height / 2);
                this._center = { x: rect.x + (rect.width + this._outerRadius) / 2, y: rect.y + rect.height / 2 };
            } else {
                this._center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
                this._outerRadius = Math.min(rect.width, rect.height) / 2;
            }
        } else if (180 <= start && start < 270) {
            if (180 <= end && end <= 270) {
                this._outerRadius = Math.min(rect.width, rect.height);
                this._center = { x: rect.x + (rect.width + this._outerRadius) / 2, y: rect.y + (rect.height - this._outerRadius) / 2 };
            } else {
                this._outerRadius = Math.min(rect.width / 2, rect.height);
                this._center = { x: rect.x + rect.width / 2, y: rect.y + (rect.height - this._outerRadius) / 2 };
            }
        } else {
            this._outerRadius = Math.min(rect.width, rect.height);
            this._center = { x: rect.x + (rect.width - this._outerRadius) / 2, y: rect.y + (rect.height - this._outerRadius) / 2 };
        }

        this._innerRadiusByPixel = this._innerRadius > 1 ? this._innerRadius : this._outerRadius * this._innerRadius;
        this._innerDarkerRadiusByPixel = this._innerDarkerRadius > 1 ? this._innerDarkerRadius : this._outerRadius * this._innerDarkerRadius;
        this._outerBrighterRadiusByPixel = this._outerBrighterRadius > 1 ? this._outerBrighterRadius : this._outerRadius * this._outerBrighterRadius;
    },
    _drawArcOutLine: function (g, start, end, startLine, endLine) {
        if (this._outlineWidth <= 0) {
            return;
        }
        var range = Math.abs(start - end);

        var x1 = this._center.x + Math.cos(start) * this._innerRadiusByPixel;
        var y1 = this._center.y + Math.sin(-start) * this._innerRadiusByPixel;
        var x2 = this._center.x + Math.cos(start) * this._outerRadius;
        var y2 = this._center.y + Math.sin(-start) * this._outerRadius;
        var x3 = this._center.x + Math.cos(end) * this._innerRadiusByPixel;
        var y3 = this._center.y + Math.sin(-end) * this._innerRadiusByPixel;
        var x4 = this._center.x + Math.cos(end) * this._outerRadius;
        var y4 = this._center.y + Math.sin(-end) * this._outerRadius;

        if (this._clockwise) {
            g.lineWidth = this._outlineWidth;
            g.strokeStyle = this.getUniqueColor(this._outlineColor);
            g.beginPath();
            g.moveTo(this._center.x, this._center.y);
            $g.drawArc(g, this._center.x, this._center.y, end, range, this._outerRadius, this._outerRadius, false);
            g.stroke();

            if (!this._whole && startLine) {
                g.lineWidth = this._outlineWidth;
                g.strokeStyle = this.getUniqueColor(this._outlineColor);
            } else {
                g.lineWidth = 0;
            }
            g.lineTo(x1, y1);
            g.stroke();

            g.beginPath();
            g.lineWidth = this._outlineWidth;
            g.strokeStyle = this.getUniqueColor(this._outlineColor);
            g.moveTo(this._center.x, this._center.y);
            $g.drawArc(g, this._center.x, this._center.y, start, -range, this._innerRadiusByPixel, this._innerRadiusByPixel, false);
            g.stroke();

            if (!this._whole && endLine) {
                g.lineWidth = this._outlineWidth;
                g.strokeStyle = this.getUniqueColor(this._outlineColor);
            } else {
                g.lineWidth = 0;
            }
            g.lineTo(x4, y4);
            g.stroke();
        } else {
            g.lineWidth = this._outlineWidth;
            g.strokeStyle = this.getUniqueColor(this._outlineColor);
            g.beginPath();
            g.moveTo(this._center.x, this._center.y);
            $g.drawArc(g, this._center.x, this._center.y, start, range, this._outerRadius, this._outerRadius, false);
            g.stroke();

            if (!this._whole && endLine) {
                g.lineWidth = this._outlineWidth;
                g.strokeStyle = this.getUniqueColor(this._outlineColor);
            } else {
                g.lineWidth = 0;
            }
            g.lineTo(x3, y3);
            g.stroke();

            g.lineWidth = this._outlineWidth;
            g.strokeStyle = this.getUniqueColor(this._outlineColor);
            g.beginPath();
            g.moveTo(this._center.x, this._center.y);
            $g.drawArc(g, this._center.x, this._center.y, end, -range, this._innerRadiusByPixel, this._innerRadiusByPixel, false);
            g.stroke();

            if (!this._whole && startLine) {
                g.lineWidth = this._outlineWidth;
                g.strokeStyle = this.getUniqueColor(this._outlineColor);
            } else {
                g.lineWidth = 0;
            }
            g.lineTo(x2, y2);
            g.stroke();
        }
    },
    _drawArcGroup: function (g, start, end, fillColor) {
        if (this._outerBrighterRadiusByPixel != 0) {
            this._drawArc(g, start, end, this._outerRadius - this._outerBrighterRadiusByPixel, this._outerRadius, $g.brighter(fillColor));
        }
        this._drawArc(g, start, end, this._innerRadiusByPixel + this._innerDarkerRadiusByPixel, this._outerRadius - this._outerBrighterRadiusByPixel, fillColor);
        if (this._innerDarkerRadiusByPixel != 0) {
            this._drawArc(g, start, end, this._innerRadiusByPixel, this._innerRadiusByPixel + this._innerDarkerRadiusByPixel, $g.darker(fillColor, 20));
        }
    },
    _drawArc: function (g, start, end, innerRadius, outerRadius, fillColor) {
        var range = Math.abs(start - end);
        g.lineWidth = 0;
        g.fillStyle = fillColor;

        var x1 = this._center.x + Math.cos(start) * innerRadius;
        var y1 = this._center.y + Math.sin(-start) * innerRadius;
        var x2 = this._center.x + Math.cos(start) * outerRadius;
        var y2 = this._center.y + Math.sin(-start) * outerRadius;
        var x3 = this._center.x + Math.cos(end) * innerRadius;
        var y3 = this._center.y + Math.sin(-end) * innerRadius;
        var x4 = this._center.x + Math.cos(end) * outerRadius;
        var y4 = this._center.y + Math.sin(-end) * outerRadius;

        g.beginPath();
        if (this._clockwise) {
            g.moveTo(x3, y3);
            $g.drawArc(g, this._center.x, this._center.y, end, range, outerRadius, outerRadius, true);
            g.lineTo(x1, y1);
            $g.drawArc(g, this._center.x, this._center.y, start, -range, innerRadius, innerRadius, true);
            g.closePath();
        } else {
            g.moveTo(x1, y1);
            $g.drawArc(g, this._center.x, this._center.y, start, range, outerRadius, outerRadius, true);
            g.lineTo(x3, y3);
            $g.drawArc(g, this._center.x, this._center.y, end, -range, innerRadius, innerRadius, true);
            g.closePath();
        }

        g.fill();
    },
    getScaleTextPosition: function (angle, cx, cy, width, height) {
        angle = (angle % 360 + 360) % 360;
        var position = { x: cx, y: cy };
        if (angle == 0) {
            position = this._scaleInside ? { x: cx - width / 2, y: cy} : { x: cx + width / 2, y: cy };
        }
        if (angle == 180) {
            position = this._scaleInside ? { x: cx + width / 2, y: cy} : { x: cx - width / 2, y: cy };
        }
        if (angle == 90) {
            position = this._scaleInside ? { x: cx, y: cy + height / 2} : { x: cx, y: cy - height / 2 };
        }
        if (angle == 270) {
            position = this._scaleInside ? { x: cx, y: cy - height / 2} : { x: cx, y: cy + height / 2 };
        }
        if (angle > 270 && angle < 360) {
            position = this._scaleInside ? { x: cx - width / 2, y: cy - height / 2} : { x: cx + width / 2, y: cy + height / 2 };
        }
        if (angle > 180 && angle < 270) {
            position = this._scaleInside ? { x: cx + width / 2, y: cy - height / 2} : { x: cx - width / 2, y: cy + height / 2 };
        }
        if (angle > 90 && angle < 180) {
            position = this._scaleInside ? { x: cx + width / 2, y: cy + height / 2} : { x: cx - width / 2, y: cy - height / 2 };
        }
        if (angle > 0 && angle < 90) {
            position = this._scaleInside ? { x: cx - width / 2, y: cy + height / 2} : { x: cx + width / 2, y: cy - height / 2 };
        }
        return position;
    }
});

twaver.charts.RadarChart = function (dataBox) {
    twaver.charts.RadarChart.superClass.constructor.apply(this, arguments);
    this._selectTolerance = 2;
};
_twaver.ext('twaver.charts.RadarChart', twaver.charts.ChartBase, {
    __accessor: ['axisTextVisible', 'axisTextFont', 'axisTextColor',
                    'scaleTextVisible', 'scaleTextFont', 'scaleTextColor',
                    'axisVisible', 'axisLineColor', 'axisLineWidth', 'axisStartAngle',
                    'ringVisible', 'ringType', 'ringLineColor', 'ringLineWidth',
                    'scaleCount', 'scaleMaxValue', 'scaleMinValue',
                    'anchorVisible', 'areaFillAlpha', 'areaSelectFillAlpha', 'axisList'],

    __bool: ['areaFill'],

    _axisTextVisible: $Defaults.RADARCHART_AXIS_TEXT_VISIBLE,
    _axisTextFont: $Defaults.RADARCHART_AXIS_TEXT_FONT,
    _axisTextColor: $Defaults.RADARCHART_AXIS_TEXT_COLOR,

    _scaleTextVisible: $Defaults.RADARCHART_SCALE_TEXT_VISIBLE,
    _scaleTextFont: $Defaults.RADARCHART_SCALE_TEXT_FONT,
    _scaleTextColor: $Defaults.RADARCHART_SCALE_TEXT_COLOR,

    _axisVisible: $Defaults.RADARCHART_AXIS_VISIBLE,
    _axisLineColor: $Defaults.RADARCHART_AXIS_LINE_COLOR,
    _axisLineWidth: $Defaults.RADARCHART_AXIS_LINE_WIDTH,
    _axisStartAngle: $Defaults.RADARCHART_AXIS_START_ANGLE,

    _ringVisible: $Defaults.RADARCHART_RING_VISIBLE,
    _ringType: $Defaults.RADARCHART_RING_TYPE,
    _ringLineColor: $Defaults.RADARCHART_RING_LINE_COLOR,
    _ringLineWidth: $Defaults.RADARCHART_RING_LINE_WIDTH,

    _scaleCount: $Defaults.RADARCHART_SCALE_COUNT,
    _scaleMaxValue: $Defaults.RADARCHART_SCALE_MAXVALUE,
    _scaleMinValue: $Defaults.RADARCHART_SCALE_MINVALUE,

    _anchorVisible: $Defaults.RADARCHART_ANCHOR_VISIBLE,
    _areaFill: $Defaults.RADARCHART_AREA_FILL,
    _areaFillAlpha: $Defaults.RADARCHART_AREA_FILL_ALPHA,
    _areaSelectFillAlpha: $Defaults.RADARCHART_AREA_SELECT_FILL_ALPHA,

    getAxisCount: function () {
        return this._axisCount;
    },
    formatScaleText: function (value, axisIndex) {
        return value.toFixed(2);
    },
    getAnchorSize: function (data) {
        return data.getStyle ? data.getStyle('chart.marker.size') : twaver.Styles.getStyle('chart.marker.size');
    },
    getAnchorShape: function (data) {
        return data.getStyle ? data.getStyle('chart.marker.shape') : twaver.Styles.getStyle('chart.marker.shape');
    },
    getLineWidth: function (data) {
        return data.getStyle ? data.getStyle('chart.line.width') : twaver.Styles.getStyle('chart.line.width');
    },
    getValues: function (data) {
        return data.getStyle ? data.getStyle('chart.values') : null;
    },
    tryGetDataAt: function (point, tolerance) {
        if (tolerance == null || tolerance < 0) {
            tolerance = this._selectTolerance;
        }
        if (point.target) {
            point = $html.getLogicalPoint(this._canvas, arguments[0], 1);
        }
        if (!point) {
            return null;
        }

        if (!this._areaFill) {
            var x = point.x - tolerance;
            var y = point.y - tolerance;
            var w = tolerance * 2 + 1;
            var h = tolerance * 2 + 1;
            try {
                var d = this._canvas.getContext('2d').getImageData(x, y, w, h).data;
                for (var i = 0, n = d.length; i < n; i += 4) {
                    if (d[i + 3] === 255) {
                        var rgb = 'rgb(' + d[i] + ',' + d[i + 1] + ',' + d[i + 2] + ')';
                        var data = this._uniqueColors[rgb];
                        if (data) {
                            return data;
                        }
                    }
                }
            } catch (e) {
            }
            return null;
        }

        if (!this._center) {
            return null;
        }
        point = { x: point.x - this._xTranslate, y: point.y - this._yTranslate };
        for (var i = this._publishedDatas.size() - 1; i >= 0; i--) {
            var data = this._publishedDatas.get(i);
            var info = this._map[data.getId()];
            var result = $math.isPointInPolygon(info.points, point);
            if (result) {
                return data;
            }
        }
        return null;
    },
    getDataAt: function () {
        var x, y;
        if (arguments.length === 2) {
            x = arguments[0];
            y = arguments[1];
        }
        else if (arguments[0].target) {
            var p = $html.getLogicalPoint(this._canvas, arguments[0], 1);
            if (p) {
                x = p.x;
                y = p.y;
            } else {
                return;
            }
        }
        else {
            x = arguments[0].x;
            y = arguments[0].y;
        }
        if (x < 0 || y < 0 || x > this._canvasWidth || y > this._canvasHeight) {
            return null;
        }

        if (!this._areaFill) {
            try {
                var d = this._canvas.getContext('2d').getImageData(x, y, 1, 1).data;
                if (d[3] === 255) {
                    var rgb = 'rgb(' + d[0] + ',' + d[1] + ',' + d[2] + ')';
                    var data = this._uniqueColors[rgb];
                    if (data) {
                        return data;
                    }
                }
            } catch (e) {
            }
            return null;
        }

        for (var i = this._publishedDatas.size() - 1; i >= 0; i--) {
            var data = this._publishedDatas.get(i);
            var info = this._map[data.getId()];
            var result = $math.isPointInPolygon(info.points, { x: x - this._xTranslate, y: y - this._yTranslate });
            if (result) {
                return data;
            }
        }
        return null;
    },
    validateModel: function () {
        this._map = {};
        this._axisTexts = new $List();
        this._axisMaxValues = new $List();
        this._axisMinValues = new $List();
        this._axisRangeValues = new $List();
        this._axisCount = this._axisList == null ? 0 : this._axisList.size();

        if (this._axisCount == 0) {
            return;
        }
        this._averageAngleByRadian = Math.PI * 2 / this._axisCount;
        this._averageAngle = 360 / this._axisCount;

        this._axisList.forEach(function (axis) {
            if (typeof axis == 'string') {
                this._axisTexts.add(axis);
                this._axisMaxValues.add(this._scaleMaxValue);
                this._axisMinValues.add(this._scaleMinValue);
                this._axisRangeValues.add(this._scaleMaxValue - this._scaleMinValue);
            } else {
                this._axisTexts.add(axis.text);
                var max = isNaN(axis.max) ? this._scaleMaxValue : axis.max;
                var min = isNaN(axis.min) ? this._scaleMinValue : axis.min;
                this._axisMaxValues.add(max);
                this._axisMinValues.add(min);
                this._axisRangeValues.add(max - min);
            }
        }, this);

        this._publishedDatas.forEach(function (data) {
            var values = new $List(this.getValues(data));
            var info = {
                data: data,
                values: values,
                proportions: new $List(),
                color: this.getUniqueColor(this.getColor(data), data),
                anchorShape: this.getAnchorShape(data),
                anchorSize: this.getAnchorSize(data),
                lineWidth: this.getLineWidth(data),
                points: new $List()
            };
            if (this.isSelected(data)) {
                info.lineWidth += 2;
            }
            this._map[data.getId()] = info;
        }, this);

        for (var i = 0; i < this._axisCount; i++) {
            this._publishedDatas.forEach(function (data) {
                var info = this._map[data.getId()];
                var proportion = 0;
                if (info.values.size() > i) {
                    var value = info.values.get(i);
                    var min = this._axisMinValues.get(i);
                    var range = this._axisRangeValues.get(i);
                    if (range > 0) {
                        proportion = (value - min) / range;
                    }
                }
                info.proportions.add(proportion);
            }, this);
        }
    },
    validateDisplay: function (g, width, height) {
        var rect = {
            x: this._xGap,
            y: this._yGap,
            width: width - this._xGap * 2,
            height: height - this._yGap * 2
        };
        this.drawBackground(g, rect);

        if (rect.width <= 0 || rect.height <= 0 || this._axisCount < 3) {
            return;
        }

        var maxWidth = 0, maxHeight = 0, i = 0, size = null, position = null, text = null;
        var axisTextInfos = null;
        if (this._axisTextVisible) {
            axisTextInfos = new $List();
            for (i = 0; i < this._axisCount; i++) {
                text = this._axisTexts.get(i);
                size = this.getTextSize(this._axisTextFont, text);
                axisTextInfos.add({ text: text, size: size });
                if (size.width > maxWidth) {
                    maxWidth = size.width;
                }
                if (size.height > maxHeight) {
                    maxHeight = size.height;
                }
            }
        }
        var radius = rect.width / 2 - maxWidth > rect.height / 2 - maxHeight ? rect.height / 2 - maxHeight * 2 : rect.width / 2 - maxWidth;
        var center = { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 };
        this._center = { x: center.x + this._xTranslate, y: center.y + this._yTranslate };

        var scaleTextInfos = null;
        if (this._scaleTextVisible) {
            scaleTextInfos = new $List();
        }

        var angleByRadian = this._axisStartAngle / 180 * Math.PI;
        for (i = 0; i < this._axisCount; i++) {
            var angle = angleByRadian * 180 / Math.PI;
            var x1 = center.x + Math.cos(angleByRadian) * radius;
            var y1 = center.y + Math.sin(-angleByRadian) * radius;

            var scaleTextInfo = null;
            if (scaleTextInfos) {
                scaleTextInfo = new $List();
                scaleTextInfos.add(scaleTextInfo);
            }

            if (this._ringVisible && this._ringLineWidth > 0) {
                g.lineWidth = this._ringLineWidth;
                g.strokeStyle = this._ringLineColor;
            }
            for (var j = 1; j <= this._scaleCount; j++) {
                var percent = j / this._scaleCount;
                var radiusScale = radius * percent;
                var x2 = center.x + Math.cos(angleByRadian) * radiusScale;
                var y2 = center.y + Math.sin(-angleByRadian) * radiusScale;

                // draw ring
                if (this._ringVisible && this._ringLineWidth > 0) {
                    var x3 = center.x + Math.cos(angleByRadian + this._averageAngleByRadian) * radiusScale;
                    var y3 = center.y + Math.sin(-angleByRadian - this._averageAngleByRadian) * radiusScale;

                    if (this._ringType == 'line') {
                        this.drawLine(g, this._ringLineColor, this._ringLineWidth, x2, y2, x3, y3);
                    } else if (this._ringType == 'arc') {
                        g.beginPath();
                        g.moveTo(center.x, center.y);
                        $g.drawArc(g, center.x, center.y, angleByRadian, this._averageAngleByRadian, radiusScale, radiusScale, true);
                        g.closePath();
                        g.stroke();
                    }
                }

                // int scale text
                if (scaleTextInfo) {
                    text = this.formatScaleText(this._axisMinValues.get(i) + this._axisRangeValues.get(i) * percent, i);
                    size = this.getTextSize(this._scaleTextFont, text);
                    position = this.getScaleTextPosition(angle, x2, y2, size.width, size.height);
                    scaleTextInfo.add({
                        text: text,
                        x: position.x,
                        y: position.y
                    });
                }
            }
            // draw scale
            if (this._axisVisible) {
                this.drawLine(g, this._axisLineColor, this._axisLineWidth, center.x, center.y, x1, y1);
            }

            // int axis text
            if (axisTextInfos) {
                var axisTextInfo = axisTextInfos.get(i);
                position = this.getAxisTextPosition(angle, x1, y1, axisTextInfo.size.width, axisTextInfo.size.height);
                axisTextInfo.x = position.x;
                axisTextInfo.y = position.y;
            }
            angleByRadian += this._averageAngleByRadian;
        }

        this._publishedDatas.forEach(function (data) {
            var info = this._map[data.getId()];
            info.points.clear();
            var anchors = info.anchorSize > 0 ? new $List() : null;
            var proportions = info.proportions;

            g.lineWidth = 0;
            g.globalAlpha = this.isSelected(data) ? this._areaSelectFillAlpha : this._areaFillAlpha;
            if (this._areaFill) {
                g.fillStyle = info.color;
            }
            this._drawItem(g, proportions, center, radius, anchors, info);
            if (this._areaFill) {
                g.fill();
            }

            g.lineWidth = info.lineWidth;
            g.strokeStyle = info.color;
            g.globalAlpha = 1;
            this._drawItem(g, proportions, center, radius);

            // draw anchor
            g.lineWidth = 0;
            if (anchors != null && anchors.size() > 0) {
                var offset = info.anchorSize / 2;
                anchors.forEach(function (p) {
                    g.fillStyle = info.color;
                    $g.drawVector(g, info.anchorShape, null, p.x - offset, p.y - offset, info.anchorSize, info.anchorSize);
                    g.fill();
                });
            }
        }, this);

        // draw scale texts
        if (scaleTextInfos) {
            scaleTextInfos.forEach(function (t) {
                t.forEach(function (v) {
                    $g.drawText(g, v.text, v, this._scaleTextFont, this._scaleTextColor);
                }, this);
            }, this);
        }
        // draw axis texts
        if (axisTextInfos) {
            axisTextInfos.forEach(function (v) {
                $g.drawText(g, v.text, v, this._axisTextFont, this._axisTextColor);
            }, this);
        }
    },
    _drawItem: function (g, proportions, center, radius, anchors, info) {
        var angleByRadian = this._axisStartAngle / 180 * Math.PI;
        var firstPoint = null;
        g.beginPath();
        for (var i = 0; i < this._axisCount; i++) {
            var proportion = proportions.get(i);
            var point = {
                x: center.x + Math.cos(angleByRadian) * radius * proportion,
                y: center.y + Math.sin(-angleByRadian) * radius * proportion
            };

            // draw line
            if (firstPoint == null) {
                g.moveTo(point.x, point.y);
            } else {
                g.lineTo(point.x, point.y);
            }

            // draw anchor
            if (anchors != null && this._anchorVisible) {
                anchors.add(point);
            }
            if (info) {
                info.points.add(point);
            }

            if (i == 0) {
                firstPoint = point;
            }
            angleByRadian += this._averageAngleByRadian;
        }
        if (firstPoint != null) {
            g.lineTo(firstPoint.x, firstPoint.y);
        }
        g.closePath();
        g.stroke();
    },
    getAxisTextPosition: function (angle, cx, cy, width, height) {
        angle = (angle % 360 + 360) % 360;
        var position = { x: cx, y: cy };
        if (angle == 0) {
            position = { x: cx + width / 2, y: cy };
        }
        if (angle == 180) {
            position = { x: cx - width / 2, y: cy };
        }
        if (angle == 90) {
            position = { x: cx, y: cy - height / 2 };
        }
        if (angle == 270) {
            position = { x: cx, y: cy + height / 2 };
        }
        if (angle > 270 && angle < 360) {
            position = { x: cx + width / 2, y: cy + height / 2 };
        }
        if (angle > 180 && angle < 270) {
            position = { x: cx - width / 2, y: cy + height / 2 };
        }
        if (angle > 90 && angle < 180) {
            position = { x: cx - width / 2, y: cy - height / 2 };
        }
        if (angle > 0 && angle < 90) {
            position = { x: cx + width / 2, y: cy - height / 2 };
        }
        return position;
    },
    getScaleTextPosition: function (angle, cx, cy, width, height) {
        angle = (angle % 360 + 360) % 360;
        var position = { x: cx, y: cy };
        if (angle == 0) {
            position = { x: cx, y: cy + height / 2 };
        }
        if (angle == 180) {
            position = { x: cx - width / 2, y: cy + height / 2 };
        }
        if (angle == 90) {
            position = { x: cx + width / 2, y: cy };
        }
        if (angle == 270) {
            position = { x: cx + width / 2, y: cy };
        }
        if (angle > 270 && angle < 360) {
            position = { x: cx + width / 2, y: cy - height / 2 };
        }
        if (angle > 180 && angle < 270) {
            position = { x: cx - width / 2, y: cy - height / 2 };
        }
        if (angle > 90 && angle < 180) {
            position = { x: cx - width / 2, y: cy + height / 2 };
        }
        if (angle > 0 && angle < 90) {
            position = { x: cx + width / 2, y: cy + height / 2 };
        }
        return position;
    }
});

twaver.charts.LegendPane = function (chart) {
    twaver.charts.LegendPane.superClass.constructor.apply(this, arguments);
    this._divPool = new twaver.Pool('div');
    this._iconPool = new twaver.Pool('div');
    this._textPool = new twaver.Pool('span');

    this._pools.add(this._divPool);
    this._pools.add(this._iconPool);
    this._pools.add(this._textPool);

    this._chart = chart;
    this._chart.addViewListener(this.handleViewChange, this);

    this._view = $html.createView('hidden');
    this._view.style.verticalAlign = 'middle';

    this._legendDiv = $html.createDiv();
    this._legendDiv.style.whiteSpace = 'nowrap';
    this._legendDiv.style.verticalAlign = 'middle';
    this._legendDiv.style.position = '';

    this._view.appendChild(this._legendDiv);

    this._hiddenMap = {};
    var self = this;
    this._chart._internalVisibleFunction = function (data) {
        return !self.isHidden(data);
    };

    if ($ua.isTouchable) {
        new twaver.charts.LegendPaneTouchInteraction(this);
    }
    new twaver.charts.LegendPaneInteraction(this);
};
_twaver.ext('twaver.charts.LegendPane', twaver.controls.ControlBase, {
    __accessor: ['iconWidth', 'iconHeight', 'iconRadius', 'rowHeight', 'orientation', 'hiddenColor',
                        'selectBackgroundColor', 'selectForegroundColor'],

    _iconWidth: $Defaults.LEGENDPANE_ICON_WIDTH,
    _iconHeight: $Defaults.LEGENDPANE_ICON_HEIGHT,
    _iconRadius: $Defaults.LEGENDPANE_ICON_RADIUS,
    _rowHeight: $Defaults.LEGENDPANE_ROW_HEIGHT,
    _orientation: $Defaults.LEGENDPANE_ORIENTATION,
    _hiddenColor: $Defaults.LEGENDPANE_HIDDEN_COLOR,
    _selectBackgroundColor: $Defaults.LEGENDPANE_SELECT_BACKGROUND_COLOR,
    _selectForegroundColor: $Defaults.LEGENDPANE_SELECT_FOREGROUND_COLOR,

    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getChart: function () {
        return this._chart;
    },
    isHidden: function (data) {
        return this._hiddenMap[data.getId()] != null;
    },
    handleViewChange: function (e) {
        if (e.kind === 'validateEnd') {
            this._invalidate = true;
            this.validate();
        }
    },
    validate: function () {
        if (!this._invalidate) {
            return;
        }
        this._invalidate = false;
        $html.release(this._legendDiv);

        _twaver.keys(this._hiddenMap).forEach(function (id) {
            if (!this._chart.getDataBox().containsById(id)) {
                delete this._hiddenMap[id];
            }
        }, this);

        var datas = new $List(this._chart.getUnfilteredDatas());
        for (var i = 0; i < datas.size(); i++) {
            var data = datas.get(i);
            if (!this._chart.isVisible(data) && !this.isHidden(data)) {
                datas.removeAt(i);
                i--;
            }
        }
        var count = datas.size();

        var style = this._view.style;
        var horizontal = this._orientation === 'horizontal';
        if (horizontal) {
            style.textAlign = 'center';
            style.height = this._rowHeight + 'px';
        } else {
            style.textAlign = '';
            style.height = this._rowHeight * count + 'px';
        }
        style.lineHeight = this._rowHeight - 2 + 'px';

        for (i = 0; i < count; i++) {
            var data = datas.get(i);
            var div = this._divPool.get();
            div._data = data;
            div.style.cursor = 'pointer';
            div.style.height = this._rowHeight + 'px';
            if (horizontal) {
                div.style.display = 'inline-block';
            } else {
                div.style.display = 'block';
            }

            this._legendDiv.appendChild(div);
            // render legend
            this.renderLegend(div, data);
            this.onLegendRendered(div, data);
        }
        this._pools.forEach(function (pool) {
            pool.clear();
        });
    },
    renderLegend: function (div, data) {
        var visible = !this.isHidden(data);
        var selected = this._chart.isSelected(data);

        var icon = this._iconPool.get();
        var style = icon.style;
        style.display = 'inline-block';
        style.verticalAlign = 'middle';
        style.marginLeft = '4px';
        style.width = this.getIconWidth() + 'px';
        style.height = this.getIconHeight() + 'px';
        if (visible) {
            style.backgroundColor = this._chart.getColor(data);
        } else {
            style.backgroundColor = this.getHiddenColor();
        }
        div.appendChild(icon);

        var text = this._textPool.get();
        style = text.style;
        style.paddingLeft = '2px';
        style.paddingRight = '4px';
        style.display = 'inline-block';
        style.verticalAlign = 'middle';
        if (visible) {
            style.color = selected ? this._selectForegroundColor : '';
        } else {
            style.color = this.getHiddenColor();
        }
        text.innerHTML = this._chart.getName(data);
        div.appendChild(text);
        if (visible && selected) {
            div.style.backgroundColor = this._selectBackgroundColor;
        } else {
            div.style.backgroundColor = '';
        }
    },
    onLegendRendered: function (div, data) {

    }
});

twaver.charts.ChartPane = function (chart, title, legendOrientation, legendWidth) {
    twaver.charts.ChartPane.superClass.constructor.apply(this, arguments);
    this.invalidate();

    this._chart = chart;
    this._legendPane = new twaver.charts.LegendPane(chart);

    this._titleDiv = $html.createDiv();
    this._titleDiv.style.verticalAlign = 'middle';
    this._titleDiv.style.whiteSpace = 'nowrap';

    this._view = $html.createView('hidden');
    this._view.appendChild(this._titleDiv);
    this._view.appendChild(this._legendPane.getView());
    this._view.appendChild(this._chart.getView());

    var self = this;
    this._legendPane.addPropertyChangeListener(function (e) {
        if (e.property === 'rowHeight' || e.porperty === 'orientation') {
            self.invalidate();
        }
    });

    if (arguments.length > 1) this.setTitle(title);
    if (arguments.length > 2) this.setLegendOrientation(legendOrientation);
    if (arguments.length > 3) this.setLegendWidth(legendWidth);
};
_twaver.ext('twaver.charts.ChartPane', twaver.controls.ControlBase, {
    __accessor: ['title', 'titleHorizontalAlign', 'titleHeight', 'legendWidth'],

    _title: null,
    _titleHeight: $Defaults.CHARTPANE_TITLE_HEIGHT,
    _titleHorizontalAlign: $Defaults.CHARTPANE_TITLE_HORIZONTAL_ALIGN,
    _legendOrientation: $Defaults.CHARTPANE_LEGEND_ORIENTATION,
    _legendWidth: $Defaults.CHARTPANE_LEGEND_WIDTH,

    getLegendOrientation: function () {
        return this._legendOrientation;
    },
    setLegendOrientation: function (value) {
        if (this._legendOrientation === value) {
            return;
        }
        var oldValue = this._legendOrientation;
        this._legendOrientation = value;
        this.firePropertyChange('orientation', oldValue, value);
        this._adjustLegendOrientation();
    },
    _adjustLegendOrientation: function () {
        if (this._legendOrientation === 'left' || this._legendOrientation === 'right') {
            this._legendPane.setOrientation('vertical');
        } else {
            this._legendPane.setOrientation('horizontal');
        }
    },
    onPropertyChanged: function (e) {
        this.invalidate();
    },
    getTitleDiv: function () {
        return this._titleDiv;
    },
    getChart: function () {
        return this._chart;
    },
    getLegendPane: function () {
        return this._legendPane;
    },
    validateImpl: function () {
        this._adjustLegendOrientation();

        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;
        var legendHeight = this._legendPane.getRowHeight();

        var titleHeight;
        if (this._title && this._title !== '') {
            titleHeight = this._titleHeight;
            this._titleDiv.innerHTML = this._title;
        } else {
            titleHeight = 0;
            this._titleDiv.innerHTML = '';
        }
        this._titleDiv.innerHTML = this._title ? this._title : '';
        this._titleDiv.style.textAlign = this._titleHorizontalAlign;
        this._titleDiv.style.lineHeight = this._titleHeight - 2 + 'px';

        var style = this._titleDiv.style;
        style.left = '0px';
        style.top = '0px';
        style.width = w + 'px';
        style.height = titleHeight + 'px';

        var chartRect;
        var legendRect;
        if (this._legendOrientation === 'bottom') {
            chartRect = {
                x: 0,
                y: titleHeight,
                width: w,
                height: Math.max(h - titleHeight - legendHeight, 0)
            };
            legendRect = {
                x: 0,
                y: Math.max(h - legendHeight, 0),
                width: w,
                height: legendHeight
            };
        }
        else if (this._legendOrientation === 'right') {
            chartRect = {
                x: 0,
                y: titleHeight,
                width: Math.max(w - this._legendWidth, 0),
                height: Math.max(h - titleHeight, 0)
            };
            legendRect = {
                x: Math.max(w - this._legendWidth, 0),
                y: titleHeight,
                width: this._legendWidth,
                height: Math.max(h - titleHeight, 0)
            };
        }
        else if (this._legendOrientation === 'top') {
            chartRect = {
                x: 0,
                y: titleHeight + legendHeight,
                width: w,
                height: Math.max(h - titleHeight - legendHeight, 0)
            };
            legendRect = {
                x: 0,
                y: titleHeight,
                width: w,
                height: legendHeight
            };
        }
        else if (this._legendOrientation === 'left') {
            chartRect = {
                x: this._legendWidth,
                y: titleHeight,
                width: Math.max(w - this._legendWidth, 0),
                height: Math.max(h - titleHeight, 0)
            };
            legendRect = {
                x: 0,
                y: titleHeight,
                width: this._legendWidth,
                height: Math.max(h - titleHeight, 0)
            };
        }

        if (chartRect) {
            this._chart.adjustBounds(chartRect);
        }
        if (legendRect) {
            this._legendPane.adjustBounds(legendRect);
        }
    }
});

twaver.charts.ChartInteraction = function (chart) {
    this.chart = chart;
    this.canvas = chart._canvas;

    var self = this;
    this.canvas.addEventListener('mousedown', function (e) {
        if (e.button === 0) {
            self.handleMouseDown(e);
        }
        e.preventDefault();
    }, false);
    var wheel = $ua.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
    this.canvas.addEventListener(wheel, function (e) {
        self.handleMouseWheel(e);
    }, false);
};
_twaver.ext('twaver.charts.ChartInteraction', Object, {
    handleMouseDown: function (e) {
        if (this.chart.isFocusOnClick()) {
            twaver.Util.setFocus(this.canvas);
        }
        this.lastPoint = this.chart.getLogicalPoint(e);
        var data = this.chart.tryGetDataAt(e);
        if (e.detail === 2 && data == null) {
            if (this.chart.isDoubleClickToReset()) {
                this.chart.zoomReset(false);
                this.chart.setXTranslate(0);
                this.chart.setYTranslate(0);
            }
        } else {
            this._startLogical = this.lastPoint;
            this._startClient = $html.getClientPoint(e);
            $html.handle_mousedown(this, e);
        }
    },
    handleMouseMove: function (e) {
        if (this.lastPoint) {
            var point = {
                x: this._startLogical.x + e.clientX - this._startClient.x,
                y: this._startLogical.y + e.clientY - this._startClient.y
            };
            if (!this.startPan && $math.getDistance(this.lastPoint, point) > 3) {
                this.startPan = true;
                this.lastPoint = point;
            }
            if (this.startPan) {
                if (this.chart.isXTranslateEnabled()) {
                    this.chart.setXTranslate(this.chart.getXTranslate() + point.x - this.lastPoint.x);
                }
                if (this.chart.isYTranslateEnabled()) {
                    this.chart.setYTranslate(this.chart.getYTranslate() + point.y - this.lastPoint.y);
                }
                this.lastPoint = point;
            }
        }
    },
    handleMouseUp: function (e) {
        if (!this.startPan && e.detail === 1) {
            var data = this.chart.tryGetDataAt(e);
            var sm = this.chart.getSelectionModel();
            if (data) {
                if (_twaver.isCtrlDown(e)) {
                    if (sm.contains(data)) {
                        sm.removeSelection(data);
                    } else {
                        sm.appendSelection(data);
                    }
                } else {
                    if (!sm.contains(data)) {
                        sm.setSelection(data);
                    }
                }
            } else {
                if (!_twaver.isCtrlDown(e)) {
                    sm.clearSelection();
                }
            }
        }
        delete this.lastPoint;
        delete this.startPan;
        delete this._startClient;
        delete this._startLogical;
    },
    handleMouseWheel: function (e) {
        $html.preventDefault(e);
        var delta = $ua.isFirefox ? -e.detail : e.wheelDelta;
        if (delta > 0) {
            if (this.chart.isXZoomEnabled()) {
                this.chart.setXZoom(this.chart.getXZoom() * 1.1, false);
            }
            if (this.chart.isYZoomEnabled()) {
                this.chart.setYZoom(this.chart.getYZoom() * 1.1, false);
            }
        } else if (delta < 0) {
            if (this.chart.isXZoomEnabled()) {
                this.chart.setXZoom(this.chart.getXZoom() / 1.1, false);
            }
            if (this.chart.isYZoomEnabled()) {
                this.chart.setYZoom(this.chart.getYZoom() / 1.1, false);
            }
        }
    }
});

twaver.charts.ChartTouchInteraction = function (chart) {
    this.chart = chart;
    this.canvas = chart._canvas;

    $html.addEventListener('touchstart', 'handleTouchstart', this.canvas, this);
};
_twaver.ext('twaver.charts.ChartTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (this.chart.isFocusOnClick()) {
            twaver.Util.setFocus(this.canvas);
        }
        this.endPoint = this.chart.getLogicalPoint(e);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.xZoom = this.chart.getXZoom();
            this.yZoom = this.chart.getYZoom();
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.canvas, this);
        $html.addEventListener('touchend', 'handleTouchend', this.canvas, this);
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if (!this.endPoint) {
            return;
        }
        var point = this.chart.getLogicalPoint(e);
        if (!this.moved && $math.getDistance(this.endPoint, point) > 10) {
            this.moved = true;
            this.lastPoint = point;
        }
        if (!this.moved) {
            return;
        }
        if ($touch.isSingleTouch(e)) {
            if (this.endPoint) {
                if (this.chart.isXTranslateEnabled()) {
                    this.chart.setXTranslate(this.chart.getXTranslate() + point.x - this.endPoint.x);
                }
                if (this.chart.isYTranslateEnabled()) {
                    this.chart.setYTranslate(this.chart.getYTranslate() + point.y - this.endPoint.y);
                }
                this.endPoint = point;
            }
        } else {
            if (this.distance) {
                var scale = $touch.getDistance(e) / this.distance;
                var newXZoom = this.xZoom * scale;
                var newYZoom = this.yZoom * scale;
                if (this.chart.isXZoomEnabled()) {
                    this.chart.setXZoom(newXZoom, false);
                }
                if (this.chart.isYZoomEnabled()) {
                    this.chart.setYZoom(newYZoom, false);
                }
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        if (!this.moved) {
            this.endPoint = this.chart.getLogicalPoint(e);
            var isDoubleTouch = this.lastPoint && this.lastTouchStartTime
                && (new Date().getTime() - this.lastTouchStartTime.getTime() <= 300)
                && (Math.abs(this.endPoint.x - this.lastPoint.x) <= 10)
                && (Math.abs(this.endPoint.y - this.lastPoint.y) <= 10);
            if (isDoubleTouch) {
                this.lastPoint = null;
                this.lastTouchStartTime = null;
            } else {
                this.lastPoint = this.endPoint;
                this.lastTouchStartTime = new Date();
            }
            var data = this.chart.tryGetDataAt(e);
            if (isDoubleTouch && data == null) {
                if (this.chart.isDoubleClickToReset()) {
                    this.chart.zoomReset(false);
                    this.chart.setXTranslate(0);
                    this.chart.setYTranslate(0);
                }
            } else {
                var sm = this.chart.getSelectionModel();
                if (data) {
                    if (!sm.contains(data)) {
                        sm.setSelection(data);
                    }
                } else {
                    sm.clearSelection();
                }
            }
        }
        delete this.endPoint;
        delete this.distance;
        delete this.xZoom;
        delete this.yZoom;
        delete this.moved;
        $html.removeEventListener('touchmove', this.canvas, this);
        $html.removeEventListener('touchend', this.canvas, this);
    }
});

twaver.charts.ChartMSTouchInteraction = function (chart) {
    this.chart = chart;
    this.canvas = chart._canvas;

    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.canvas, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.canvas, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.canvas, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.canvas, this);

    var wheel = $ua.isFirefox ? 'DOMMouseScroll' : 'mousewheel';
    this.canvas.addEventListener(wheel, function (e) {
        self.handleMouseWheel(e);
    }, false);
};
_twaver.ext('twaver.charts.ChartMSTouchInteraction', Object, {
    handleTouchstart: function (e) {
        if (this.chart.isFocusOnClick()) {
            twaver.Util.setFocus(this.canvas);
        }

        var newPoint = this.chart.getLogicalPoint(e);
        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }
        if (!this._pointerMap[e.pointerId] && newPoint) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        var data = this.chart.tryGetDataAt(e);
        if (this._pointerIdArray.length == 1 && newPoint) {
            var isDoubleTouch = this._startTouchPoint && this._startTouchTime
                && (new Date().getTime() - this._startTouchTime.getTime() <= 500)
                && $math.getDistance(this._startTouchPoint, newPoint) <= 10;

            if (isDoubleTouch && data == null) {
                if (this.chart.isDoubleClickToReset()) {
                    this.chart.zoomReset(false);
                    this.chart.setXTranslate(0);
                    this.chart.setYTranslate(0);
                    this._startTouchPoint = null;
                    this._startTouchTime = null;
                    this._startClientPoint = null;
                }
            } else {
                this._startTouchPoint = newPoint;
                this._startTouchTime = new Date();
                this._startClientPoint = { x: e.clientX, y: e.clientY }
                $html.handle_mousedown(this, e);
            }
        } else if (this._pointerIdArray.length == 2) {
            this.xZoom = this.chart.getXZoom();
            this.yZoom = this.chart.getYZoom();
            this._distance = this._getDistance();
        }
    },
    handleTouchmove: function (e) {
        if (this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 3) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            var newXZoom = this.xZoom * scale;
            var newYZoom = this.yZoom * scale;
            if (this.chart.isXZoomEnabled()) {
                this.chart.setXZoom(newXZoom, false);
            }
            if (this.chart.isYZoomEnabled()) {
                this.chart.setYZoom(newYZoom, false);
            }
        }
    },
    handleTouchend: function (e) {
        var newEndTouchPoint = this.chart.getLogicalPoint(e);
        if (this._pointerIdArray.length == 1 && newEndTouchPoint && !this.moved) {
            var data = this.chart.tryGetDataAt(e);
            var isSingleTouch = this._startTouchPoint && this._startTouchTime
                && (new Date().getTime() - this._startTouchTime.getTime() <= 500)
                && $math.getDistance(this._startTouchPoint, newEndTouchPoint) <= 10;

            var sm = this.chart.getSelectionModel();
            if (data && isSingleTouch) {
                if (_twaver.isCtrlDown(e)) {
                    if (sm.contains(data)) {
                        sm.removeSelection(data);
                    } else {
                        sm.appendSelection(data);
                    }
                } else {
                    if (!sm.contains(data)) {
                        sm.setSelection(data);
                    }
                }
            } else {
                if (!_twaver.isCtrlDown(e)) {
                    sm.clearSelection();
                }
            }
        }
        this.moved = false;
        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    handleMouseWheel: function (e) {
        $html.preventDefault(e);
        var delta = $ua.isFirefox ? -e.detail : e.wheelDelta;
        if (delta > 0) {
            if (this.chart.isXZoomEnabled()) {
                this.chart.setXZoom(this.chart.getXZoom() * 1.1, false);
            }
            if (this.chart.isYZoomEnabled()) {
                this.chart.setYZoom(this.chart.getYZoom() * 1.1, false);
            }
        } else if (delta < 0) {
            if (this.chart.isXZoomEnabled()) {
                this.chart.setXZoom(this.chart.getXZoom() / 1.1, false);
            }
            if (this.chart.isYZoomEnabled()) {
                this.chart.setYZoom(this.chart.getYZoom() / 1.1, false);
            }
        }
    },
    handle_mousemove: function (e) {
        if (this._pointerIdArray.length == 1 && this._startTouchPoint && this._startClientPoint) {
            var newPoint = {
                x: this._startTouchPoint.x + (e.clientX - this._startClientPoint.x) / this.chart.getXZoom(),
                y: this._startTouchPoint.y + (e.clientY - this._startClientPoint.y) / this.chart.getYZoom()
            }
            if ($math.getDistance(this._startTouchPoint, newPoint) > 3) {
                this.moved = true;
                if (this.chart.isXTranslateEnabled()) {
                    this.chart.setXTranslate(this.chart.getXTranslate() + newPoint.x - this._startTouchPoint.x);
                }
                if (this.chart.isYTranslateEnabled()) {
                    this.chart.setYTranslate(this.chart.getYTranslate() + newPoint.y - this._startTouchPoint.y);
                }
                this._startClientPoint.x = e.clientX;
                this._startClientPoint.y = e.clientY;
            }
        }
    },
    handle_mouseup: function (e) {
        this.handleTouchend(e);
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.charts.LegendPaneInteraction = function (legendPane) {
    this.legendPane = legendPane;

    var self = this;
    this.legendPane._legendDiv.addEventListener('mousedown', function (e) {
        self.handleMouseDown(e);
    }, false);
};
_twaver.ext('twaver.charts.LegendPaneInteraction', Object, {
    handleMouseDown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var data = e.target._data;
        if (!data) {
            data = e.target.parentNode._data;
        }
        if (data) {
            if (this.legendPane._hiddenMap[data.getId()]) {
                delete this.legendPane._hiddenMap[data.getId()];
            } else {
                this.legendPane._hiddenMap[data.getId()] = data;
            }
            this.legendPane._chart.invalidateModel();
        }
    }
});

twaver.charts.LegendPaneTouchInteraction = function (legendPane) {
    this.legendPane = legendPane;

    $html.addEventListener('touchstart', 'handleTouchstart', this.legendPane._legendDiv, this);
};
_twaver.ext('twaver.charts.LegendPaneTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);

        var data = e.target._data;
        if (!data) {
            data = e.target.parentNode._data;
        }
        if (data) {
            if (this.legendPane._hiddenMap[data.getId()]) {
                delete this.legendPane._hiddenMap[data.getId()];
            } else {
                this.legendPane._hiddenMap[data.getId()] = data;
            }
            this.legendPane._chart.invalidateModel();
        }
    }
});

twaver.network.Network = function (elementBox) {
    twaver.network.Network.superClass.constructor.apply(this, arguments);
    this._elementUIMap = {};
    this._layerMap = {};
    this._layerList = new $List();

    /* 
    network hierarchy:
    -> view		   
    -> rootDiv
    -> topDiv
    -> attachmentDiv
    -> layersDiv
    -> layer n
    -> layer ...
    -> default layer
    -> bottomDiv
    */
    this._view = $html.createView('auto');
    this._rootDiv = $html.createDiv();
    this._topDiv = $html.createDiv();
    this._attachmentDiv = $html.createDiv();
    this._layersDiv = $html.createDiv();
    this._bottomDiv = $html.createDiv();

    this._rootDiv.appendChild(this._bottomDiv);
    this._rootDiv.appendChild(this._layersDiv);
    this._rootDiv.appendChild(this._attachmentDiv);
    this._rootDiv.appendChild(this._topDiv);
    this._view.appendChild(this._rootDiv);

    this.setElementBox(elementBox ? elementBox : new twaver.ElementBox());
    if($ua.isTouchable){
        if($ua.isMSTouchable){
            this.setMSTouchInteractions();
        }else{
            this.setTouchInteractions();
        }
    }else{
        this.setDefaultInteractions(false);
    }

    var self = this;
    this._flowLink = function () {
        if (self.isMovingElement() || self.isSelectingElement() || self.isEditingElement() || self._box._layoutMovingElements) {
            return;
        }
        if (!self._flowLinkQuickFinder) {
            self._flowLinkQuickFinder = new twaver.QuickFinder(self._box, "link.flow", "style");
        }
        var links = self._flowLinkQuickFinder.find(true);
        links.forEach(function (link) {
            link._styleMap["link.flow.offset"] = self.getLinkFlowOffset(link);
            var ui = self.getElementUI(link);
            ui.drawBody();
        })
    }
    this.setToolTipEnabled($Defaults.NETWORK_TOOLTIP_ENABLED);
    
    this._view.addEventListener('scroll',function(e){
    	__l.twm(self);
    });
    
    this.addPropertyChangeListener(function(e){
    	if(e.property === 'zoom'){
         	__l.twm(self);
    	}
    });
    twaver.imageUtil.addEventListener(this.invalidateElementUIs, this);
};
_twaver.ext('twaver.network.Network', twaver.controls.View, {
    __accessor: ['selectMode', 'makeVisibleOnSelected', 'movableFunction',
        'editPointSize', 'editPointFillColor',
		'editPointOutlineWidth', 'editPointOutlineColor', 'editLineColor',
		'editLineWidth', 'resizePointSize', 'resizePointFillColor', 'resizePointOutlineWidth',
		'resizePointOutlineColor', 'resizeLineColor', 'resizeLineWidth',
        'rotatePointSize','rotatePointFillColor','rotatePointOffset',
        'rotatePointOutlineWidth','rotatePointOutlineColor','rotateScaleFillColor','rotateScaleFontColor','rotateScaleWidth','rotateScaleHeight',
		'selectOutlineColor', 'selectOutlineWidth', 'selectFillColor',
		'lazyMoveOutlineColor', 'lazyMoveOutlineWidth', 'lazyMoveFillColor',
		'rectSelectFilter', 'selectionTolerance'],

    __bool: ['doubleClickToUpSubNetwork', 'doubleClickToSubNetwork', 'doubleClickToEmptySubNetwork',
			    'doubleClickToLinkBundle', 'doubleClickToGroupExpand',
			    'subNetworkAnimate', 'lazyMoveAnimate', 'resizeAnimate',
			    'noAgentLinkVisible', 'keyboardRemoveEnabled', 'keyboardSelectEnabled',
			    'sendToTopOnSelected', 'lazyMoveFill', 'editingElement','rotatingElement', 'movingElement',
                'selectingElement', 'rectSelectEnabled', 'limitElementInPositiveLocation', 'showRotateScale', 'transparentSelectionEnable'],

    _viewRect: { x: 0, y: 0, width: 0, height: 0 },
    _currentSubNetwork: null,
    _selectMode: $Defaults.NETWORK_SELECT_MODE,
    _noAgentLinkVisible: $Defaults.NETWORK_NO_AGENT_LINK_VISIBLE,
    _makeVisibleOnSelected: $Defaults.NETWORK_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: $Defaults.NETWORK_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: $Defaults.NETWORK_KEYBOARD_SELECT_ENABLED,
    _rectSelectEnabled: $Defaults.NETWORK_RECT_SELECT_ENABLED,
    _rectSelectFilter: null,
    _subNetworkAnimate: $Defaults.NETWORK_SUBNETWORK_ANIMATE,
    _transparentSelectable: $Defaults.NETWORK_TRANSPARENT_SELECTABLE,
    _removeElementUIOnInvisible: $Defaults.NETWORK_REMOVE_ELEMENTUI_ON_INVISIBLE,
    _elementUIFunction: $Defaults.ELEMENTUI_FUNCTION,

    _doubleClickToUpSubNetwork: $Defaults.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
    _doubleClickToSubNetwork: $Defaults.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
    _doubleClickToEmptySubNetwork: $Defaults.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
    _doubleClickToLinkBundle: $Defaults.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
    _doubleClickToGroupExpand: $Defaults.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,

    _sendToTopOnSelected: $Defaults.NETWORK_SENDTOTOP_ON_SELECTED,
    _selectOutlineColor: $Defaults.NETWORK_SELECT_OUTLINE_COLOR,
    _selectOutlineWidth: $Defaults.NETWORK_SELECT_OUTLINE_WIDTH,
    _selectFillColor: $Defaults.NETWORK_SELECT_FILL_COLOR,

    _lazyMoveOutlineColor: $Defaults.NETWORK_LAZYMOVE_OUTLINE_COLOR,
    _lazyMoveOutlineWidth: $Defaults.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
    _lazyMoveFillColor: $Defaults.NETWORK_LAZYMOVE_FILL_COLOR,
    _lazyMoveFill: $Defaults.NETWORK_LAZYMOVE_FILL,
    _lazyMoveAnimate: $Defaults.NETWORK_LAZYMOVE_ANIMATE,

    _editPointSize: $Defaults.NETWORK_EDIT_POINT_SIZE,
    _editPointFillColor: $Defaults.NETWORK_EDIT_POINT_FILL_COLOR,
    _editPointOutlineColor: $Defaults.NETWORK_EDIT_POINT_OUTLINE_COLOR,
    _editPointOutlineWidth: $Defaults.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
    _editLineColor: $Defaults.NETWORK_EDIT_LINE_COLOR,
    _editLineWidth: $Defaults.NETWORK_EDIT_LINE_WIDTH,

    _resizePointSize: $Defaults.NETWORK_RESIZE_POINT_SIZE,
    _resizePointFillColor: $Defaults.NETWORK_RESIZE_POINT_FILL_COLOR,
    _resizePointOutlineColor: $Defaults.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
    _resizePointOutlineWidth: $Defaults.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
    _resizeLineColor: $Defaults.NETWORK_RESIZE_LINE_COLOR,
    _resizeLineWidth: $Defaults.NETWORK_RESIZE_LINE_WIDTH,
    _resizeAnimate: $Defaults.NETWORK_RESIZE_ANIMATE,

    _rotatePointSize: $Defaults.NETWORK_ROTATE_POINT_SIZE,
    _rotatePointFillColor: $Defaults.NETWORK_ROTATE_POINT_FILL_COLOR,
    _rotatePointOffset: $Defaults.NETWORK_ROTATE_POINT_OFFSET,
    _rotatePointOutlineWidth: $Defaults.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
    _rotatePointOutlineColor: $Defaults.NETWORK_ROTATE_POINT_OUTLINE_COLOR,

    _rotateScaleWidth: $Defaults.NETWORK_ROTATE_SCALE_WIDTH,
    _rotateScaleHeight: $Defaults.NETWORK_ROTATE_SCALE_HEIGHT,
    _rotateScaleFillColor: $Defaults.NETWORK_ROTATE_SCALE_FILL_COLOR,
    _rotateScaleFontColor: $Defaults.NETWORK_ROTATE_SCALE_FONT_COLOR,

    _limitElementInPositiveLocation: $Defaults.NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION,


    _linkFlowInterval: $Defaults.NETWORK_LINK_FLOW_INTERVAL,
    _selectionTolerance: $Defaults.NETWORK_SELECTION_TOLERANCE,

    _invalidate: false,
    _invalidateElementVisibility: false,
    _invalidateElementIndex: false,

    _isEditingElement: false,
    _isRotatingElement: false,
    _isMovingElement: false,
    _isSelectingElement: false,
    _hasEditInteraction: false,
    _showRotateScale: true,
    _transparentSelectionEnable:twaver.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,

    getLabel: function (element) {
        return element.getStyle('network.label') || element.getName();
    },
    isToolTipEnabled: function () {
        return this._toolTipEnabled ? true : false;
    },
    setToolTipEnabled: function (value) {
        this._toolTipEnabled = value;
        if (value) {
            if (!this._toolTipListener) {
                var self = this;
                this._toolTipListener = function (e) {
                    var element = self.getElementAt(e);
                    if (self._preElement === element) {
                        return;
                    }
                    self._preElement = element;
                    if (element) {
                        var toolTip = self.getToolTip(element);
                        $popup.showToolTip({ x: e.pageX, y: e.pageY }, toolTip);
                        var toolTipDiv = $popup.getToolTipDiv();
                        if (toolTipDiv.children.length > 0) {
                            var viewBounds = self._view.getBoundingClientRect();
                            var toolTipBounds = toolTipDiv.getBoundingClientRect();
                            if (toolTipBounds.width + toolTipBounds.left > viewBounds.width + viewBounds.left) {
                                toolTipDiv.style.left = (viewBounds.width + viewBounds.left - toolTipBounds.width + (document.documentElement.scrollLeft || document.body.scrollLeft)) + "px";
                            }
                            if (toolTipBounds.height + toolTipBounds.top > viewBounds.height + viewBounds.top) {
                                toolTipDiv.style.top = (viewBounds.height + viewBounds.top - toolTipBounds.height + (document.documentElement.scrollTop || document.body.scrollTop)) + "px";
                            }
                        }
                    } else {
                        $popup.hideToolTip();
                    }
                };
                this._view.addEventListener('mousemove', this._toolTipListener, true);
                this.firePropertyChange('toolTipEnabled', false, true);
            }
        } else {
            if (this._toolTipListener) {
                $popup.hideToolTip();
                this._view.removeEventListener('mousemove', this._toolTipListener, true);
                delete this._toolTipListener;
                this.firePropertyChange('toolTipEnabled', true, false);
            }
        }
    },
    isLinkFlowEnabled: function () {
        return this._linkFlowEnabled ? true : false;
    },
    setLinkFlowEnabled: function (value) {
        if (value) {
            if (!this._linkFlowEnabled) {
                this._linkFlowEnabled = true;
                this.firePropertyChange('linkFlowEnabled', false, true);
            }
            clearInterval(this._linkFlowTimerId);
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        } else {
            if (this._linkFlowEnabled) {
                this._linkFlowEnabled = false;
                this.firePropertyChange('linkFlowEnabled', true, false);
            }
            clearInterval(this._linkFlowTimerId);
            delete this._linkFlowTimerId;
        }
    },
    getLinkFlowInterval: function () {
        return this._linkFlowInterval;
    },
    setLinkFlowInterval: function (value) {
        var oldValue = this._linkFlowInterval;
        this._linkFlowInterval = value;
        this.firePropertyChange('linkFlowInterval', oldValue, value);

        clearInterval(this._linkFlowTimerId);
        if (this.isLinkFlowEnabled()) {
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        }
    },
    getTopDiv: function () {
        return this._topDiv;
    },
    getAttachmentDiv: function () {
        return this._attachmentDiv;
    },
    getLayersDiv: function () {
        return this._layersDiv;
    },
    getBottomDiv: function () {
        return this._bottomDiv;
    },
    validateImpl: function () {
    	__l.twm(this);
    	if(!this.__lics__){
    		return;
    	}
        var i = 0;
        var canvas = null;
        var attachments = null;
        var attachment = null;

        var needToUpdateViewRect = this._invalidateElementVisibility;

        if (this._invalidateElementVisibility) {
            this._invalidateElementVisibility = false;

            // in this case we should update element index too.
            if (this._removeElementUIOnInvisible) {
                this._invalidateElementIndex = true;
            }

            this.forEachElementUI(function (ui) {
                ui.validate();
                var element = ui.getElement();
                ui.setVisible(this.isVisible(element));

                // remove element ui when invisible
                if (this._removeElementUIOnInvisible) {
                    canvas = this.getLayerDivByElement(element);
                    if (ui.isVisible()) {
                        if (ui.getView().parentNode !== canvas) {
                            canvas.appendChild(ui.getView());
                            attachments = ui.getAttachments();
                            for (i = 0; i < attachments.size(); i++) {
                                attachment = attachments.get(i);
                                if (attachment.isShowInAttachmentDiv()) {
                                    this._attachmentDiv.appendChild(attachment.getView());
                                }
                            }
                        }
                    }
                    else {
                        if (ui.getView().parentNode === canvas) {
                            canvas.removeChild(ui.getView());
                            attachments = ui.getAttachments();
                            for (i = 0; i < attachments.size(); i++) {
                                attachment = attachments.get(i);
                                if (attachment.isShowInAttachmentDiv()) {
                                    this._attachmentDiv.removeChild(attachment.getView());
                                }
                            }
                        }
                    }
                }
                else {
                    // keep elementui in layer canvas 
                    if (!ui.getView().parentNode) {
                        canvas = this.getLayerDivByElement(element);
                        canvas.appendChild(ui.getView());
                        attachments = ui.getAttachments();
                        for (i = 0; i < attachments.size(); i++) {
                            attachment = attachments.get(i);
                            if (attachment.isShowInAttachmentDiv()) {
                                this._attachmentDiv.appendChild(attachment.getView());
                            }
                        }
                    }
                }
            }, null, this);
        }
        if (this._invalidateElementIndex) {
            this._invalidateElementIndex = false;
            var attachmentRef;
            var self = this;
            this._box.getLayerBox().forEachByDepthFirst(function (layer) {
                var canvas = self._layerMap[layer.getId()];
                var viewRef;
                self._box.forEachByLayer(function (element) {
                    var ui = self._elementUIMap[element.getId()];
                    if (ui && ui.getView().parentNode === canvas) {
                        //ui.getView().style.zIndex = index++;
                        viewRef = $html.insertAfter(ui.getView(), viewRef);
                        var attachments = ui.getAttachments();
                        for (var i = 0; i < attachments.size(); i++) {
                            var attachment = attachments.get(i);
                            if (attachment.getView().parentNode === self._attachmentDiv) {
                                //attachment.getView().style.zIndex = attachmentIndex++;
                                attachmentRef = $html.insertAfter(attachment.getView(), attachmentRef);
                            }
                        }
                    }
                }, layer);
            });
        }

        if (needToUpdateViewRect && !this._invalidateElementVisibility) {
            var unionRect;
            for (var o in this._elementUIMap) {
                var ui = this._elementUIMap[o];
                if (ui.isVisible()) {
                    unionRect = $math.unionRect(unionRect, ui.getViewRect());
                }
            }
            if (unionRect) {
                unionRect = { x: 0, y: 0, width: unionRect.x + unionRect.width, height: unionRect.y + unionRect.height };
            } else {
                unionRect = { x: 0, y: 0, width: 0, height: 0 };
            }

            if (unionRect.x !== this._viewRect.x ||
                unionRect.y !== this._viewRect.y ||
                unionRect.width !== this._viewRect.width ||
                unionRect.height !== this._viewRect.height) {

                var oldValue = this._viewRect;
                this._viewRect = unionRect;

                this._rootDiv.style.left = '0px';
                this._rootDiv.style.top = '0px';
                this._rootDiv.style.width = unionRect.width + 'px';
                this._rootDiv.style.height = unionRect.height + 'px';

                this.firePropertyChange("viewRect", oldValue, unionRect);
            }
        }
    },
    setInteractions: function (interactions) {
        var oldValue = this._interactions;
        if (oldValue) {
            oldValue.forEach(function (handler) {
                handler.tearDown();
            });
        }
        this._interactions = interactions;
        if (interactions) {
            interactions.forEach(function (handler) {
                handler.setUp();
            });
        }
        this.invalidateSelectedElementUIs(true);
        this.firePropertyChange("interactions", oldValue, interactions);
    },
    getInteractions: function () {
        return this._interactions;
    },
    upSubNetwork: function (animate, finishFunction) {
        if (this._currentSubNetwork) {
            this.setCurrentSubNetwork($element.getSubNetwork(this._currentSubNetwork), animate, finishFunction);
        }
    },
    sendToTop: function (element) {
        if (!this.isVisible(element)) {
            return;
        }
        var parent = element;
        while (this.isVisible(parent.getParent())) {
            parent = parent.getParent();
            if (!parent) {
                break;
            }
        }
        if (parent !== element) {
            this._box.adjustElementIndex(parent);
        }
        this._box.adjustElementIndex(element);
    },
    invalidateElementIndex: function () {
        if (!this._invalidateElementIndex) {
            this._invalidateElementIndex = true;
            this.invalidate();
        }
    },
    invalidateElementVisibility: function () {
        if (!this._invalidateElementVisibility) {
            this._invalidateElementVisibility = true;
            this.invalidate();
        }
    },
    updateLayers: function () {
        $html.clear(this._layersDiv);
        $html.clear(this._attachmentDiv);
        this._layerMap = {};
        this._layerList.clear();
        var self = this;
        this._box.getLayerBox().forEachByDepthFirst(function (layer) {
            var canvas = $html.createDiv();
            $html.setVisible(canvas, layer.isVisible());
            self._layerMap[layer.getId()] = canvas;
            self._layersDiv.appendChild(canvas);
            self._layerList.add(layer);
        });

        this._box.forEach(this.createElementUI, this);
    },
    getCurrentSubNetwork: function () {
        return this._currentSubNetwork;
    },
    setCurrentSubNetwork: function (currentSubNetwork, animate, finishFunction) {
        var a = twaver.animate.AnimateManager;
        a.endAnimate();
        if (animate) {
            if (this._currentSubNetwork === currentSubNetwork) {
                return;
            }
            if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
                throw currentSubNetwork + " is not contained in this network's elementBox";
            }
            a.start(new twaver.animate.AnimateSubNetwork(this, currentSubNetwork, finishFunction));
        } else {
            this._setCurrentSubNetwork(currentSubNetwork);
            if (finishFunction) {
                finishFunction();
            }
        }
    },
    _setCurrentSubNetwork: function (currentSubNetwork) {
        if (this._currentSubNetwork === currentSubNetwork) {
            return;
        }
        if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
            throw currentSubNetwork + " is not contained in this network's elementBox";
        }
        var oldValue = this._currentSubNetwork;
        this._currentSubNetwork = currentSubNetwork;
        this.firePropertyChange("currentSubNetwork", oldValue, currentSubNetwork);

        this.invalidateElementVisibility();
    },
    isVisible: function (element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if(!element.isVisible()) {
            return false;
        }
        if (this._visibleFunction && !this._visibleFunction(element)) {
            return false;
        }
        if (!this._box.getLayerBox().getLayerByElement(element).isVisible()) {
            return false;
        }
        if ($element.getSubNetwork(element) !== this._currentSubNetwork) {
            return false;
        }
        if (element instanceof twaver.Link) {
            if (!this.isNoAgentLinkVisible()) {
                if (!element.getFromAgent() || !element.getToAgent()) {
                    return false;
                }
                if (!this.isVisible(element.getFromAgent()) || !this.isVisible(element.getToAgent())) {
                    return false;
                }
            }
            if (element.getBundleIndex() > 0 && element.getBundleCount() > 1 && !element.getStyle("link.bundle.expanded")) {
                return false;
            }
        }
        else {
            var parent = element.getParent();
            while (parent && !parent.ISubNetwork) {
                if (parent instanceof $Group) {
                    if (!parent.isExpanded() || !this.isVisible(parent)) {
                        return false;
                    }
                }
                parent = parent.getParent();
            }
        }
        if (element.IDummy) {
            return false;
        }
        return true;
    },
    isMovable: function (element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (element instanceof twaver.Link) {
            return false;
        }
        if (this._movableFunction && !this._movableFunction(element)) {
            return false;
        }
        return this._box.getLayerBox().getLayerByElement(element).isMovable();
    },
    isEditable: function (element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (this._editableFunction && !this._editableFunction(element)) {
            return false;
        }
        return this._box.getLayerBox().getLayerByElement(element).isEditable();
    },
    isRotatable: function (element) {
        if (this._rotatableFunction && !this._rotatableFunction(element)) {
            return false;
        }
        return true;
    },
    getVisibleFunction: function () {
        return this._visibleFunction;
    },
    setVisibleFunction: function (value) {
        var oldValue = this._visibleFunction;
        this._visibleFunction = value;
        this.firePropertyChange("visibleFunction", oldValue, value);
        this.invalidateElementVisibility();
    },
    getEditableFunction: function () {
        return this._editableFunction;
    },
    setEditableFunction: function (value) {
        var oldValue = this._editableFunction;
        this._editableFunction = value;
        this.firePropertyChange("editableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    getRotatableFunction: function () {
        return this._rotatableFunction;
    },
    setRotatableFunction: function (value) {
        var oldValue = this._rotatableFunction;
        this._rotatableFunction = value;
        this.firePropertyChange("rotatableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    isLinkable: function (node) {
        return (this._linkableFunction == null || this._linkableFunction(node));
    },
    getLinkableFunction: function () {
        return this._linkableFunction;
    },
    setLinkableFunction: function (value) {
        var oldValue = this._linkableFunction;
        this._linkableFunction = value;
        this.firePropertyChange("linkableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    onShareSelectionModelChanged: function () {
        this.invalidateElementUIs();
    },
    getElementBox: function () {
        return this._box;
    },
    setElementBox: function (elementBox) {
        if (!elementBox) {
            throw "ElementBox can not be null";
        }
        if (this._box === elementBox) {
            return;
        }

        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataBoxChangeListener(this.handleElementBoxChange, this);
            oldValue.removeDataPropertyChangeListener(this.handleElementPropertyChange, this);
            oldValue.removePropertyChangeListener(this.handleElementBoxPropertyChange, this);
            oldValue.removeIndexChangeListener(this.handleIndexChange, this);
            oldValue.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this);
            oldValue.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this);
            oldValue.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = elementBox;

        this._box.addDataBoxChangeListener(this.handleElementBoxChange, this);
        this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this);
        this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this);
        this._box.addIndexChangeListener(this.handleIndexChange, this);
        this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this);
        this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this);
        this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this);
        if (this._flowLinkQuickFinder) {
            this._flowLinkQuickFinder.dispose();
            this._flowLinkQuickFinder = new twaver.QuickFinder(this._box, "link.flow", "style");
        }
        if (this._selectionModel) {
            this._selectionModel._setDataBox(elementBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }

        this._elementUIMap = {};
        this.updateLayers();
        this.invalidateElementVisibility();

        this.firePropertyChange("elementBox", oldValue, this._box);
    },
    invalidateElementUI: function (element, checkAttachments) {
        var ui = this.getElementUI(element);
        if (ui) {
            ui.invalidate(checkAttachments);
        }
    },
    invalidateElementUIs: function (checkAttachments) {
        for (var o in this._elementUIMap) {
            var ui = this._elementUIMap[o];
            ui.invalidate(checkAttachments);
        }
    },
    invalidateSelectedElementUIs: function (checkAttachments) {
        this.getSelectionModel().getSelection().forEach(function (element) {
            this.invalidateElementUI(element, checkAttachments);
        }, this);
    },
    getElementUI: function (element) {
        if (!element) {
            return null;
        }
        return this._elementUIMap[element.getId()];
    },
    getLayerDivByElement: function (element) {
        var layer = this._box.getLayerBox().getLayerByElement(element);
        if (!layer) {
            return null;
        }
        return this._layerMap[layer.getId()];
    },
    createElementUI: function (element) {
        var ui = this._elementUIMap[element.getId()];
        if (!ui) {
            ui = this._elementUIFunction(this, element);
            if (ui) {
                this._elementUIMap[element.getId()] = ui;
            }
        }
        if (ui) {
            var canvas = this.getLayerDivByElement(element);
            if (ui.getView().parentNode !== canvas) {
                canvas.appendChild(ui.getView());
                ui.getAttachments().forEach(function (attachment) {
                    if (attachment.isShowInAttachmentDiv() && attachment.getView().parentNode !== this._attachmentDiv) {
                        this._attachmentDiv.appendChild(attachment.getView());
                    }
                }, this)
            }
            this.invalidateElementIndex();
        }
    },
    invalidateBundleLink: function (element) {
        if (element instanceof twaver.Link && element._bundleLinks) {
            var elementUIMap = this._elementUIMap;
            element._bundleLinks.forEachSiblingLink(function (link) {
                if (link !== element) {
                    var ui = elementUIMap[link._id];
                    if (ui) {
                        ui.invalidate(false);
                    }
                }
            }, this);
        }
    },
    handleLayerBoxChange: function (e) {
        this.updateLayers();
        this.invalidateElementVisibility();
    },
    handleLayerPropertyChange: function (e) {
        var layer = e.source;
        if (e.property === "visible") {
            var canvas = this._layerMap[layer.getId()];
            $html.setVisible(canvas, layer.isVisible());
        }
        else if (e.property === "editable") {
            this.invalidateSelectedElementUIs(true);
        }
        this.invalidateElementVisibility();
    },
    handleLayerHierarchyChange: function (e) {
        var i = 0;
        var lastCanvas;
        this._layerList.clear();
        this._box.getLayerBox().forEachByDepthFirst(function (layer) {
            var canvas = this._layerMap[layer.getId()];
            //canvas.style.zIndex = i++;
            lastCanvas = $html.insertAfter(canvas, lastCanvas);
            this._layerList.add(layer);
        }, null, this);
        this.invalidateElementVisibility();
    },
    handleSelectionChange: function (e) {
        e.datas.forEach(function (element) {
            var ui = this.getElementUI(element);
            if (ui) {
                ui.handleSelectionChange(e);
            }
        }, this);
        this.invalidateElementVisibility();

        var element = this.getSelectionModel().getLastData();
        if (element) {
            if (e.kind === 'append' || e.kind === 'set') {
                if (this.isMakeVisibleOnSelected()) {
                    this.makeVisible(element);
                }
                if (this.isSendToTopOnSelected()) {
                    this.sendToTop(element);
                }
            }
        }

    },
    makeVisible: function (element) {
        var ui = this.getElementUI(element);
        if (!ui) {
            return;
        }
        var subNetwork = $element.getSubNetwork(element);
        if (subNetwork !== this._currentSubNetwork) {
            var self = this;
            this.setCurrentSubNetwork(subNetwork, this.isSubNetworkAnimate(), function () {
                _twaver.callLater(self.makeVisible, self, [element]);
            });
            return;
        }
        var e = element;
        while ((e = e.getParent()) && e !== subNetwork) {
            if (e instanceof $Group) {
                e.setExpanded(true);
            }
        }
        var bounds = ui.getUnionBodyBounds();
        if (!bounds) {
            return;
        }
        var viewRect = { x: this._view.scrollLeft / this._zoom, y: this._view.scrollTop / this._zoom,
            width: this._view.clientWidth / this._zoom, height: this._view.clientHeight / this._zoom
        };
        if (!$math.intersects(viewRect, bounds)) {
            if (this.isVisible(element)) {
                _twaver.callLater(this.centerByLogicalPoint, this, [bounds.x + bounds.width / 2, bounds.y + bounds.height / 2]);
            }
        }
    },
    handleElementBoxChange: function (e) {
        var element = e.data;
        if (e.kind === 'add') {
            this.createElementUI(element);
            this.invalidateBundleLink(element);
        }
        else if (e.kind === 'remove') {
            var ui = this.getElementUI(element);
            if (ui) {
                var layer = this._box.getLayerBox().getLayerByElement(element);
                var canvas = this._layerMap[layer.getId()];
                if (ui.getView().parentNode === canvas) {
                    canvas.removeChild(ui.getView());
                }
                ui.dispose();
                delete this._elementUIMap[element.getId()];
            }
            if (element === this._currentSubNetwork && this._currentSubNetwork != null) {
                this._setCurrentSubNetwork(null);
            }
        }
        else if (e.kind === 'clear') {
            this.forEachElementUI(function (elementUI) {
                elementUI.dispose();
            });
            this._elementUIMap = {};
            this.updateLayers();
            if (this._currentSubNetwork != null) {
                this._setCurrentSubNetwork(null);
            }
        }
        this.invalidateElementVisibility();
    },
    handleElementPropertyChange: function (e) {
        var element = e.source;
        var ui = this.getElementUI(element);
        if (ui) {
            ui.handlePropertyChange(e);
            if (e.property === "layerId") {
                var layer = this._box.getLayerBox().getLayerByElement(element);
                var canvas = this._layerMap[layer.getId()];
                if (ui.getView().parentNode !== canvas) {
                    canvas.appendChild(ui.getView());
                    this.invalidateElementIndex();
                }
            }
        }
        this.invalidateBundleLink(element);
        this.invalidateElementVisibility();
    },
    handleElementBoxPropertyChange: function (e) {
        this.invalidateElementVisibility();
    },
    handleIndexChange: function (e) {
        this.invalidateElementIndex();
    },
    getElementUIFunction: function () {
        return this._elementUIFunction;
    },
    setElementUIFunction: function (value) {
        if (!value) {
            throw "ElementUIFunction can not be null";
        }
        if (this._elementUIFunction === value) {
            return;
        }
        var oldValue = this._elementUIFunction;
        this._elementUIFunction = value;
        this.firePropertyChange("elementUIFunction", oldValue, value);
        if (!this._box.isEmpty()) {
            this.updateLayers();
        }
    },
    getIconsNames: function (element) {
        return element.getStyle('icons.names');
    },
    getIconsColors: function (element) {
        return element.getStyle('icons.colors');
    },
    getLinkHandlerLabel: function (link) {
        if (link.isBundleAgent()) {
            return "+(" + link.getBundleCount() + ")";
        }
        return null;
    },
    getSelectColor: function (element) {
        return element.getStyle('select.color');
    },
    getShadowColor: function (element) {
        var color = element.getStyle('shadow.color');
        if (!color && this.isSelected(element) && element.getStyle('select.style') === 'shadow') {
            return element.getStyle('select.color')
        }
        return color;
    },
    getAlarmLabel: function (element) {
        var severity = element.getAlarmState().getHighestNewAlarmSeverity();
        if (severity) {
            var label = element.getAlarmState().getNewAlarmCount(severity) + severity.nickName;
            if (element.getAlarmState().hasLessSevereNewAlarms()) {
                label += "+";
            }
            return label;
        }
        return null;
    },
    isRemoveElementUIOnInvisible: function () {
        return this._removeElementUIOnInvisible;
    },
    setRemoveElementUIOnInvisible: function (value) {
        var oldValue = this._removeElementUIOnInvisible;
        this._removeElementUIOnInvisible = value;
        this.firePropertyChange("removeElementUIOnInvisible", oldValue, value);
        this.invalidateElementVisibility();
    },
    setDefaultInteractions: function (lazyMode, moveLink) {
        var interactions = [
			new twaver.network.interaction.SelectInteraction(this),
			new twaver.network.interaction.MoveInteraction(this, lazyMode),
			new twaver.network.interaction.DefaultInteraction(this)
        ];
		if (moveLink) interactions.push(new twaver.network.interaction.MoveLinkInteraction(this, lazyMode));
        this.setInteractions(interactions);
    },
    setPanInteractions: function () {
        this.setInteractions([
			new twaver.network.interaction.PanInteraction(this),
			new twaver.network.interaction.DefaultInteraction(this)
        ]);
    },
    setEditInteractions: function (lazyMode, moveLink) {
        var interactions = [
			new twaver.network.interaction.SelectInteraction(this),
			new twaver.network.interaction.EditInteraction(this, lazyMode),
			new twaver.network.interaction.MoveInteraction(this, lazyMode),
			new twaver.network.interaction.DefaultInteraction(this)
        ];
		if (moveLink) interactions.push(new twaver.network.interaction.MoveLinkInteraction(this, lazyMode));
        this.setInteractions(interactions);
    },
    setCreateElementInteractions: function (type) {
        this.setInteractions([
			new twaver.network.interaction.CreateElementInteraction(this, type),
			new twaver.network.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateLinkInteractions: function (type) {
        this.setInteractions([
			new twaver.network.interaction.CreateLinkInteraction(this, type),
			new twaver.network.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateShapeLinkInteractions: function (type) {
        this.setInteractions([
			new twaver.network.interaction.CreateShapeLinkInteraction(this, type),
			new twaver.network.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateShapeNodeInteractions: function (type) {
        this.setInteractions([
			new twaver.network.interaction.CreateShapeNodeInteraction(this, type),
			new twaver.network.interaction.DefaultInteraction(this),
        ]);
    },
    setTouchInteractions: function () {
        var interactions = [
            new twaver.network.interaction.SelectInteraction(this),
            new twaver.network.interaction.MoveInteraction(this, false),
            new twaver.network.interaction.DefaultInteraction(this),
            new twaver.network.interaction.TouchInteraction(this)
        ];
        this.setInteractions(interactions);
    },
    setMSTouchInteractions: function () {
        this.setInteractions([
            new twaver.network.interaction.MSTouchInteraction(this)
        ]);
    },
    setMagnifyInteractions: function () {
        this.setInteractions([
		    new twaver.network.interaction.SelectInteraction(this),
		    new twaver.network.interaction.MoveInteraction(this),
		    new twaver.network.interaction.DefaultInteraction(this),
            new twaver.network.interaction.MagnifyInteraction(this)
        ]);
    },
    hasEditInteraction: function () {
        return this._hasEditInteraction;
    },
    setHasEditInteraction: function (value) {
        var oldValue = this._hasEditInteraction;
        this._hasEditInteraction = value;
        this.firePropertyChange("hasEditInteraction", oldValue, value);
    },
    moveSelectedElements: function (xoffset, yoffset, animate, finishFunction) {
        if (xoffset === 0 && yoffset === 0) {
            return;
        }
        var bound = this.getMovableSelectedElementsRect();
        if (bound == null) {
            return;
        }
        if (this._limitElementInPositiveLocation) {
            if (bound.x + xoffset < 0) {
                xoffset = -bound.x;
            }
            if (bound.y + yoffset < 0) {
                yoffset = -bound.y;
            }
        }
        twaver.Util.moveElements(this.getMovableSelectedElements(), xoffset, yoffset, animate, finishFunction, this);
    },
    getMovableSelectedElements: function () {
        return this.getSelectionModel().toSelection(function (element) {
            return this.isMovable(element);
        }, this);
    },
    hasMovableSelectedElements: function () {
        var selection = this.getSelectionModel().getSelection();
        for (var i = 0; i < selection.size(); i++) {
            var element = selection.get(i);
            if (this.isMovable(element)) {
                return true;
            }
        }
        return false;
    },
    getMovableSelectedElementsRect: function () {
        var elements = this.getMovableSelectedElements();
        if (elements.size() === 0) {
            return null;
        }
        var unionRect = null;
        for (var i = 0, n = elements.size(); i < n; i++) {
            var element = elements.get(i);
            if (element instanceof $Node) {
                var ui = this.getElementUI(element);
                if (ui) {
                    unionRect = $math.unionRect(unionRect, ui.getViewRect());
                }
            }
        }
        return unionRect;
    },
    getLayerByElement: function (element) {
        return this._box.getLayerBox().getLayerByElement(element);
    },
    getPosition: function (position, obj, tarSize, xoffset, yoffset) {
        var point;
        var ui = obj instanceof twaver.network.ElementUI ? obj : this.getElementUI(obj);
        if (ui) {
            if (position === 'from' || position === 'to') {
                if (ui.getFromPosition) {
                    point = position === 'from' ? ui.getFromPosition(xoffset, yoffset) : ui.getToPosition(xoffset, yoffset);
                    if (point) {
                        return { x: point.x - tarSize.width / 2, y: point.y - tarSize.height / 2 };
                    }
                }
            } else if (position === 'hotspot') {
                point = ui.getHotSpot();
            } else {
                point = $position.get(position, ui.getBodyRect(), tarSize);
            }
        }
        if (!point && obj.getRect) {
            point = $position.get(position, obj.getRect(), tarSize);
        }
        if (point) {
            return { x: point.x + xoffset, y: point.y + yoffset };
        }
        throw "position '" + position + "' object '" + obj + "'";
    },
    getViewRect: function () {
        if (this._viewRect) {
            return _twaver.clone(this._viewRect);
        }
        return { x: 0, y: 0, width: 0, height: 0 };
    },
    forEachElementUI: function (callbackFunction, layer, scope) {
        if (layer) {
            this._box.forEachReverse(function (element) {
                if (this.getLayerByElement(element) === layer) {
                    var ui = this.getElementUI(element);
                    if (ui) {
                        if (scope) {
                            callbackFunction.call(scope, ui);
                        } else {
                            callbackFunction(ui);
                        }
                    }
                }
            }, this);
        } else {
            this._layerList.forEachReverse(function (layer) {
                this.forEachElementUI(callbackFunction, layer, scope);
            }, this);
        }
    },
    findFirstElement: function (matchFunction, scope) {
        var layerSize = this._layerList.size() - 1;
        var elementSize = this._box.size() - 1;
        for (var i = layerSize; i >= 0; i--) {
            var layer = this._layerList.get(i);
            for (var j = elementSize; j >= 0; j--) {
                var element = this._box.getDataAt(j);
                if (this.getLayerByElement(element) === layer) {
                    if (scope) {
                        if (matchFunction.call(scope, element) === true) {
                            return element;
                        }
                    } else {
                        if (matchFunction(element) === true) {
                            return element;
                        }
                    }
                }
            }
        }
        return null;
    },
    /*
    * getElementAt(point, selectable)
    * getElementAt(evt, selectable)
    */
    getElementAt: function (point, selectable) {
        if (arguments.length === 1) {
            selectable = true;
        }
        if (!this.isValidEvent(point)) {
            return null;
        }
        point = this._getPoint(point);
        if (!point) {
            console.log('null');
        }
        var x = point.x, y = point.y;
        var tolerance = this._selectionTolerance;
        if (tolerance && tolerance > 0) {
            var targetRect = { x: x, y: y, width: 0, height: 0 };
            $math.grow(targetRect, tolerance, tolerance);
        }
        return this.findFirstElement(function (element) {
            if (selectable && !this.isSelectable(element)) {
                return false;
            }
            var ui = this.getElementUI(element);
            if (ui) {
                if (targetRect) {
                    return !!ui.intersectsTest(targetRect);
                } else {
                    return !!ui.hitTest(x, y);
                }
            }
            return false;
        }, this);
    },
    _getPoint: function (point) {
        if (!point) {
            return null;
        }
        if (point.target) {
            return this.getLogicalPoint(point);
        } else {
            return point;
        }
    },
    getElementsAtRect: function (rect, intersectMode, filter, selectable) {
        var list = new $List();
        selectable = selectable === undefined ? true : selectable;
        this.forEachElementUI(function (ui) {
            if (ui.isVisible() && (!filter || filter(ui._element)) && ((selectable && this.isSelectable(ui._element)) || !selectable)) {
                if (intersectMode) {
                    if (ui.intersectsTest(rect)) {
                        list.add(ui._element);
                    }
                } else {
                    if ($math.contains(rect, ui.getViewRect())) {
                        list.add(ui._element);
                    }
                }
            }
        }, null, this);
        return list;
    },
    hitTest: function (point) {
        var element = this.getElementAt(point);
        if (!element) {
            return null;
        }
        var elementUI = this.getElementUI(element);
        if (!elementUI) {
            return null;
        }
        point = this._getPoint(point);
        return elementUI.hitTest(point.x, point.y);
    },
    addElementByInteraction: function (element) {
        if (!element.getParent()) {
            element.setParent(this._currentSubNetwork);
        }
        this._box.add(element);
        this.getSelectionModel().setSelection(element);
        this.fireInteractionEvent({ kind: 'createElement', element: element });
    },
    getLinkFlowStepping: function (link) {
        var stepping = parseInt(link.getStyle("link.flow.stepping"));
        if (!stepping) {
            stepping = $Defaults.NETWORK_LINK_FLOW_STEPPING;
        }
        return stepping;
    },
    getLinkFlowOffset: function (link) {
        var currentOffset = link.getStyle("link.flow.offset");
        if (isNaN(currentOffset)) {
            currentOffset = 0;
        }
        return currentOffset + this.getLinkFlowStepping(link);
    },
    toCanvas: function (w, h, c) {
        if (!c) {
            c = $html.createCanvas();
        }
        c.setAttribute('width', w);
        c.setAttribute('height', h);
        if (c._viewRect) {
            c._viewRect.width = w;
            c._viewRect.height = h;
        } else {
            c._viewRect = { x: 0, y: 0, width: w, height: h };
        }
        var g = c.getContext('2d');
        g.clearRect(0, 0, w, h);

        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }
        var sx = w / this._view.scrollWidth * this._zoom;
        var sy = h / this._view.scrollHeight * this._zoom;
        g.scale(sx, sy);

        $html.forEach(this._view, function (e) {
            if ((e.tagName === 'CANVAS' || e.tagName === 'IMG') && !e._isIgnored) {
                var rect = e._viewRect;
                if (rect) {
                    try {
                        g.drawImage(e, rect.x, rect.y, rect.width, rect.height);
                    } catch (e) {
                    }
                }
            }
        });

        return c;
    },
    toCanvasByRegion: function (rect, scale, c) {
        if (!c) {
            c = $html.createCanvas();
        }
        var width = rect.width * scale;
        var height = rect.height * scale;
        c.setAttribute('width', width);
        c.setAttribute('height', height);
        var g = c.getContext('2d');
        g.clearRect(0, 0, width, height);

        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }
        
        g.save();
        g.scale(scale, scale);

        $html.forEach(this._view, function (e) {
            if ((e.tagName === 'CANVAS' || e.tagName === 'IMG') && !e._isIgnored) {
                var viewRect = e._viewRect;
                if (viewRect && $math.intersects(viewRect, rect)) {
                    try {
                        g.drawImage(e, viewRect.x - rect.x, viewRect.y - rect.y, viewRect.width, viewRect.height);
                    } catch (e) {
                    }
                }
            }
        });

        g.restore();
        return c;
    },
    getGroupChildrenRects: function (group) {
        var list = new $List();
        group.getChildren().forEach(function (child) {
            if (child instanceof $Node) {
                var ui = this.getElementUI(child);
                if (ui) {
                    var rect = ui.getViewRect();
                    if (rect) {
                        list.add(rect);
                    }
                }
            }
        }, this);
        return list;
    },
    getLinkPathFunction: function () {
        return this._linkPathFunction;
    },
    setLinkPathFunction: function (value) {
        var oldValue = this._linkPathFunction;
        this._linkPathFunction = value;
        this.firePropertyChange("linkPathFunction", oldValue, value);
        this.invalidateElementUIs();
    },
    onClickElement: function (element, e) {

    },
    onClickBackground: function (e) {

    },
    onDoubleClickElement: function (element, e) {

    },
    onDoubleClickBackground: function (e) {
        
    },
    onLongClickElement: function (element, e) {

    },
    onLongClickBackground: function (e) {
        
    },
    onMouseMove: function (element, e) {
        
    },
    onMouseEnter: function (element, e) {
        
    },
    onMouseLeave: function (element, e) {
        
    },
    setMovingElement: function (v) {
        if (v == this._movingElement) {
            return;
        }
        var oldValue = this._movingElement;
        this._movingElement = v;
        this.firePropertyChange("movingElement", oldValue, v);
        if (this._box._undoManager._enabled) {
            if (v) {
                this._box._undoManager.startBatch();
            } else {
                this._box._undoManager.endBatch();
            }
        }
    },
    setEditingElement: function (v) {
        if (v == this._editingElement) {
            return;
        }
        var oldValue = this._editingElement;
        this._editingElement = v;
        this.firePropertyChange("editingElement", oldValue, v);
        if (this._box._undoManager._enabled) {
            if (v) {
                this._box._undoManager.startBatch();
            } else {
                this._box._undoManager.endBatch();
            }
        }
    },
    dispose: function () {
        twaver.imageUtil.removeEventListener(this.invalidateElementUIs, this);
    }
});

twaver.network.Overview = function (network) {
    twaver.network.Overview.superClass.constructor.apply(this, arguments);
    this._view = $html.createView();
    this._rootDiv = $html.createDiv();
    this._imageCanvas = $html.createCanvas();
    this._imageDiv = $html.createDiv();
    this._maskCanvas = $html.createCanvas();
    this._selectDiv = $html.createDiv();
    this._isNetworkDirty = false;
    this._isMaskDirty = false;

    $html.setVisible(this._selectDiv, false);
    this._view.appendChild(this._rootDiv);
    this._rootDiv.appendChild(this._imageDiv);
    this._rootDiv.appendChild(this._maskCanvas);
    this._rootDiv.appendChild(this._selectDiv);
    this._imageDiv.appendChild(this._imageCanvas);

    this.setNetwork(network);

    if ($ua.isTouchable) {
        if($ua.isMSTouchable){
          new twaver.network.OverviewMSTouchInteraction(this);
        }else{
          new twaver.network.OverviewTouchInteraction(this);
          new twaver.network.OverviewInteraction(this);
        }        
    }else{        
        new twaver.network.OverviewInteraction(this);
    }
};
_twaver.ext('twaver.network.Overview', twaver.controls.ControlBase, {
    __accessor: ['fillColor', 'outlineColor', 'outlineWidth', 'selectColor', 'selectWidth',
            'padding', 'maxPackingWidth', 'maxPackingHeight'],
    __bool: ['animate'],

    _fillColor: $Defaults.OVERVIEW_FILL_COLOR,
    _outlineColor: $Defaults.OVERVIEW_OUTLINE_COLOR,
    _outlineWidth: $Defaults.OVERVIEW_OUTLINE_WIDTH,
    _selectColor: $Defaults.OVERVIEW_SELECT_COLOR,
    _selectWidth: $Defaults.OVERVIEW_SELECT_WIDTH,
    _padding: $Defaults.OVERVIEW_PADDING,
    _animate: $Defaults.OVERVIEW_ANIMATE,
    _maxPackingWidth: $Defaults.OVERVIEW_MAX_PACKING_WIDTH,
    _maxPackingHeight: $Defaults.OVERVIEW_MAX_PACKING_HEIGHT,

    getNetwork: function () {
        return this._network;
    },
    onPropertyChanged: function (e) {
        this._invalidateMask();
    },
    setNetwork: function (network) {
        if (network === this._network) {
            return;
        }
        if (this._network) {
            this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.removeViewListener(this._handleNetworkViewChange, this);
            $html.removeEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this._network = network;
        if (this._network) {
            this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.addViewListener(this._handleNetworkViewChange, this);
            $html.addEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this.invalidate();
    },
    _handleNetworkPropertyChange: function (evt) {
        if (evt.property === 'zoom' || evt.property === 'currentSubNetwork' || evt.property === 'elementBox' || evt.property === 'dataBox') {
            this.invalidate();
        }
    },
    _handleNetworkViewChange: function (evt) {
        if (evt.kind === 'validateEnd') {
            this.invalidate();
        }
    },
    _handleScrollChange: function () {
        this._invalidateMask();
    },
    invalidate: function (delay) {
        if (!this._isNetworkDirty || !this._isMaskDirty) {
            if (!this._isNetworkDirty) {
                this._isNetworkDirty = true;
            }
            if (!this._isMaskDirty) {
                this._isMaskDirty = true;
            }
            _twaver.callLater(this.validate, this, null, delay);
        }
    },
    _invalidateMask: function () {
        if (!this._isMaskDirty) {
            this._isMaskDirty = true;
            _twaver.callLater(this.validate, this, [], 100);
        }
    },
    validate: function () {
        if ((this._isMaskDirty || this._isNetworkDirty) && this._network &&
                ((this._maxPackingWidth > 0 && this._maxPackingHeight > 0) || (this._view.clientWidth > 0 && this._view.clientHeight > 0)) &&
                this._network._view.clientWidth !== 0 && this._network._view.clientHeight !== 0) {
            var isByMaxPackingWidthAndHeight = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
            var rect;
            if (isByMaxPackingWidthAndHeight) {
                rect = { x: 0, y: 0, width: this._maxPackingWidth, height: this._maxPackingHeight };
            } else {
                rect = { x: 0, y: 0, width: this._view.clientWidth, height: this._view.clientHeight };
            }
            $math.grow(rect, -this._padding, -this._padding);

            var zoom = Math.min(rect.width / this._network._view.scrollWidth, rect.height / this._network._view.scrollHeight);
            if (isByMaxPackingWidthAndHeight) {
                $html.setDiv(this._view, { x: 0, y: 0, width: this._imageDiv._viewRect.width, height: this._imageDiv._viewRect.height }, null, 0, null);
                rect.width = this._imageDiv._viewRect.width;
                rect.height = this._imageDiv._viewRect.height;
            }
            var imageWidth = this._network._view.scrollWidth * zoom;
            var imageHeight = this._network._view.scrollHeight * zoom;
            var imageX = rect.x + (rect.width - imageWidth) / 2;
            var imageY = rect.y + (rect.height - imageHeight) / 2;

            if (this._isNetworkDirty) {
                var imageRect = { x: imageX, y: imageY, width: imageWidth, height: imageHeight };
                this._network.toCanvas(imageRect.width, imageRect.height, this._imageCanvas);
                $html.setDiv(this._imageDiv, imageRect, null, 0, null);
                if (this._network.getElementBox) {
                    this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle('background.color') || '';
                }
                this._isNetworkDirty = false;
            }

            if (this._isMaskDirty) {
                var currentRect = { x: this._network._view.scrollLeft * zoom, y: this._network._view.scrollTop * zoom,
                    width: imageWidth * this._network._view.clientWidth / this._network._view.scrollWidth,
                    height: imageHeight * this._network._view.clientHeight / this._network._view.scrollHeight
                };

                var g = $html.setCanvas(this._maskCanvas, imageX, imageY, imageWidth, imageHeight);
                g.lineWidth = 0;
                g.fillStyle = this._fillColor;
                g.beginPath();
                $g.drawVector(g, 'rectangle', null, imageX, imageY, imageWidth, imageHeight);
                g.fill();
                g.clearRect(imageX + currentRect.x, imageY + currentRect.y, currentRect.width, currentRect.height);
                var outlineWidth = this._outlineWidth < 0 ? 0 : this._outlineWidth;
                g.lineWidth = outlineWidth;
                g.strokeStyle = this._outlineColor;
                g.beginPath();
                $g.drawVector(g, 'rectangle', null, imageX + currentRect.x + outlineWidth, imageY + currentRect.y + outlineWidth,
                    currentRect.width - outlineWidth * 2, currentRect.height - outlineWidth * 2);
                if (outlineWidth >= 0) {
                    g.stroke();
                }
                this._isMaskDirty = false;
            }
        } else {
            this._isNetworkDirty = false;
            this._isMaskDirty = false;
        }
    },
    getLogicalPoint: function (e) {
        return $html.getLogicalPoint(this._view, e, 1, this._rootDiv)
    },
    centerNetwork: function (point, animate) {
        var imageRect = this._imageDiv._viewRect;
        if ($math.containsPoint(imageRect, point)) {
            this._network.centerByLogicalPoint(
                        (point.x - imageRect.x) / imageRect.width * this._network._view.scrollWidth / this._network.getZoom(),
                        (point.y - imageRect.y) / imageRect.height * this._network._view.scrollHeight / this._network.getZoom(), animate);
            this._invalidateMask();
        }
    }
});

twaver.network.OverviewTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.network.OverviewTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.zoom = this.network.getZoom();
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if (!this.moved) {
            this.moved = true;
        }
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isSingleTouch(e)) {
            this.overview.centerNetwork(this.endPoint, false);
        } else {
            if (this.distance) {
                var scale = $touch.getDistance(e) / this.distance;
                this.network.setZoom(this.zoom * scale, false);
            }
        }
    },
    handleTouchend: function (e) {
        if (!this.moved) {
            this.endPoint = this.overview.getLogicalPoint(e);
            var isDoubleTouch = this.lastPoint && this.lastTouchStartTime
                && (new Date().getTime() - this.lastTouchStartTime.getTime() <= 300)
                && (Math.abs(this.endPoint.x - this.lastPoint.x) <= 10)
                && (Math.abs(this.endPoint.y - this.lastPoint.y) <= 10);
            if (isDoubleTouch) {
                this.lastPoint = null;
                this.lastTouchStartTime = null;
            } else {
                this.lastPoint = this.endPoint;
                this.lastTouchStartTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('touchmove', this.view, this);
            $html.removeEventListener('touchend', this.view, this);
        }
        this.moved = false;
    }
});

twaver.network.OverviewInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('mousedown', 'handleMousedown', this.view, this);
};
_twaver.ext('twaver.network.OverviewInteraction', Object, {
    handleMousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if (_twaver.isCtrlDown(e)) {
            this.startPoint = this.endPoint;
            $html.setVisible(this.overview._selectDiv, true);
        }
        $html.addEventListener('mousemove', 'handleMousemove', this.view, this);
        $html.addEventListener('mouseup', 'handleMouseup', document, this);
    },
    handleMouseup: function (e) {
        this.endPoint = this.overview.getLogicalPoint(e);
        if ('detail' in e && e.detail === 2) {
            _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
        } else {
            if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
                var rect = this.overview._imageDiv._viewRect;
                var x = this.overview._selectDiv._viewRect.x;
                var y = this.overview._selectDiv._viewRect.y;
                var zoomByWidth = rect.width / this.overview._selectDiv._viewRect.width;
                var zoomByHeight = rect.height / this.overview._selectDiv._viewRect.height;
                var zoom = Math.min(zoomByWidth, zoomByHeight);
                var centerX = this.network._view.scrollWidth / this.network.getZoom() * ((x - rect.x + this.overview._selectDiv._viewRect.width / 2) / rect.width);
                var centerY = this.network._view.scrollHeight / this.network.getZoom() * ((y - rect.y + this.overview._selectDiv._viewRect.height / 2) / rect.height);
                this.network.setZoom(zoom * Math.min(this.network._view.clientWidth / this.network._view.scrollWidth,
                    this.network._view.clientHeight / this.network._view.scrollHeight) * this.network.getZoom(), false);
                _twaver.callLater(this.network.centerByLogicalPoint, this.network, [centerX, centerY, this.overview._animate]);
                $html.setVisible(this.overview._selectDiv, false);
                $html.setDiv(this.overview._selectDiv, { x: 0, y: 0, width: 0, height: 0 }, null, 0, null);
                this.startPoint = null;
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
    },
    handleMousemove: function (e) {
        var newPoint = this.overview.getLogicalPoint(e);
        this.endPoint = newPoint;
        if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
            var x = newPoint.x > this.startPoint.x ? this.startPoint.x : newPoint.x;
            var y = newPoint.x > this.startPoint.x ? this.startPoint.y : newPoint.y;
            if (newPoint.x > this.startPoint.x && newPoint.y < this.startPoint.y) {
                y = newPoint.y;
            }
            if (newPoint.x < this.startPoint.x && newPoint.y > this.startPoint.y) {
                y = this.startPoint.y;
            }
            var imageRect = this.overview._imageDiv._viewRect;
            if (x < imageRect.x) {
                x = imageRect.x;
            }
            if (x > imageRect.x + imageRect.width) {
                x = imageRect.x + imageRect.width;
            }
            if (y < imageRect.y) {
                y = imageRect.y;
            }
            if (y > imageRect.y + imageRect.height) {
                y = imageRect.y + imageRect.height;
            }
            var width = Math.abs(newPoint.x - this.startPoint.x);
            var height = Math.abs(newPoint.y - this.startPoint.y);
            if (x + width > imageRect.x + imageRect.width) {
                width = imageRect.x + imageRect.width - x;
            }
            //height = width * imageRect.height / imageRect.width;
            if (y + height > imageRect.y + imageRect.height) {
                height = imageRect.y + imageRect.height - y;
                //width = height * imageRect.width / imageRect.height;
            }
            $html.setDiv(this.overview._selectDiv, { x: x, y: y, width: width, height: height }, null, this.overview._selectWidth, this.overview._selectColor);
        } else {
            this.overview.centerNetwork(newPoint, false);
        }
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('mousemove', this.view, this);
            $html.removeEventListener('mouseup', this.view, this);
        }
    }
});

twaver.network.OverviewMSTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;

    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.view, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.view, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.view, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.view, this);
};
_twaver.ext('twaver.network.OverviewMSTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);

        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }
        if (!this._pointerMap[e.pointerId] && this.overview.getLogicalPoint(e)) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        if (this._pointerIdArray.length == 1) {
            this._startTouchPoint = this.overview.getLogicalPoint(e);
            this._startTouchTime = new Date();
        }
        else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }
    },
    handleTouchmove: function (e) {
        if (this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;

        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        } else if (this._pointerIdArray.length == 1) {
            if (this._startTouchPoint) {
                var newPoint = this.overview.getLogicalPoint(e);
                if (newPoint == null) {
                    return
                };
                this._startTouchPoint = newPoint;
                this.overview.centerNetwork(this._startTouchPoint, false);
            }
        }
    },
    handleTouchend: function (e) {
        var newEndTouchPoint = this.overview.getLogicalPoint(e);
        if (this._pointerIdArray.length == 1 && newEndTouchPoint) {
            var isDoubleTouch = this._endTouchPoint && this._endTouchTime
                && (new Date().getTime() - this._endTouchTime.getTime() <= 500)
                && $math.getDistance(this._endTouchPoint , newEndTouchPoint) <= 10;
            if (isDoubleTouch) {
                this._endTouchPoint = null;
                this._endTouchTime = null;
            } else {
                this._endTouchPoint = newEndTouchPoint;
                this._endTouchTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this._endTouchPoint, this.overview._animate);
            }
        }

        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.network.ElementUI = function (network, element) {
    this._view = $html.createDiv();
    this._bodyView = $html.createDiv();
    this._view.appendChild(this._bodyView);
    this._network = network;
    this._element = element;
    this._attachments = new $List();
    this._bodyBounds = new $List();
    this.invalidate(true);
};
_twaver.ext('twaver.network.ElementUI', Object, {
    _invalidateFlag: false,
    _invalidateAttachmentsFlag: false,
    getElement: function () {
        return this._element;
    },
    getNetwork: function () {
        return this._network;
    },
    getAttachments: function () {
        return this._attachments;
    },
    getStyle: function (styleProp) {
        return this._element.getStyle(styleProp);
    },
    getFont: function (styleProp) {
        var font = this._element.getStyle(styleProp);
        return font ? font : $Defaults.FONT;
    },
    getDyeColor: function (styleProp) {
        if (this._innerColor) {
            return this._innerColor;
        }
        return this.getStyle(styleProp);
    },
    getInnerColor: function () {
        return this._innerColor;
    },
    getOuterColor: function () {
        return this._outerColor;
    },
    getShadowColor: function () {
        return this._shadowColor;
    },
    getLabelAttachment: function () {
        return this._labelAttachment;
    },
    getAlarmAttachment: function () {
        return this._alarmAttachment;
    },
    getIconsAttachment: function () {
        return this._iconsAttachment;
    },
    getEditAttachment: function () {
        return this._editAttachment;
    },
    getHotSpot: function () {
        if (this._hotSpot) {
            return _twaver.clone(this._hotSpot);
        }
        return { x: 0, y: 0 };
    },
    setHotSpot: function (value) {
        this._hotSpot = value;
    },
    getUnionBodyBounds: function () {
        return _twaver.clone(this._unionBodyBounds);
    },
    getBodyRect: function () {
        if (!this._bodyRect) {
            this._bodyRect = this.createBodyRect();
        }
        return _twaver.clone(this._bodyRect);
    },
    invalidate: function (checkAttachments) {
        if (checkAttachments === undefined) {
            checkAttachments = true;
        }
        if (checkAttachments) {
            this._invalidateAttachmentsFlag = true;
        }
        if (this._invalidateFlag) {
            return;
        }
        this._bodyRect = null;
        this._invalidateFlag = true;
        this._network.invalidateElementVisibility();
    },
    updateMeasure: function () {

    },
    validate: function () {
        if (!this._invalidateFlag) {
            return;
        }
        if (this._invalidateAttachmentsFlag) {
            this._invalidateAttachmentsFlag = false;
            this.checkAttachments();
        }
        this._invalidateFlag = false;

        this._bodyBounds.clear();
        $html.clear(this._bodyView);
        this._innerColor = this._network.getInnerColor(this._element);
        this._outerColor = this._network.getOuterColor(this._element);
        this._shadowColor = this._network.getShadowColor(this._element);
        this._shadowXOffset = this._element.getStyle('shadow.xoffset');
        this._shadowYOffset = this._element.getStyle('shadow.yoffset');
        this._shadowBlur = this._element.getStyle('shadow.blur');

        // update body measure
        this.updateMeasure();
        var wholeAlpha = this._element.getStyle('whole.alpha');
        this._view.style.opacity = wholeAlpha;
        // update attachment measure
        this._attachments.forEach(function (attachment) {
            attachment.updateMeasure();

            var attachmentAlpha = attachment.getAlpha();
            if (attachment.isShowInAttachmentDiv()) {
                attachment._view.style.opacity = attachmentAlpha * wholeAlpha;
            } else {
                attachment._view.style.opacity = attachmentAlpha;
            }
        });

        // update union body bounds
        var unionRect;
        this._bodyBounds.forEach(function (rect) {
            unionRect = $math.unionRect(unionRect, rect);
        });
        this._unionBodyBounds = _twaver.clone(unionRect);

        // update view rect 
        this._attachments.forEach(function (attachment) {
            unionRect = $math.unionRect(unionRect, attachment.getViewRect());
        });
        this._viewRect = unionRect;
    },
    cleanUp: function (names) {
        var count = names.length;
        for (var i = 0; i < count; i++) {
            var name = names[i];
            var comp = this[name];
            if (comp && !comp.parentNode) {
                this[name] = null;
            }
        }
    },
    setVisible: function (value) {
        if (this.isVisible() === value) {
            return;
        }
        $html.setVisible(this._view, value);
        this._attachments.forEach(function (attachment) {
            if (attachment.isShowInAttachmentDiv()) {
                $html.setVisible(attachment._view, value);
            }
        });
        this.invalidate(true);
    },
    isVisible: function () {
        return $html.isVisible(this._view);
    },
    checkAttachments: function () {
        this.checkLabelAttachment();
        this.checkAlarmAttachment();
        this.checkIconsAttachment();
        this.checkEditAttachment();
    },
    checkLabelAttachment: function () {
        var label = this._network.getLabel(this._element);
        if (label != null && label !== "") {
            if (!this._labelAttachment) {
                this._labelAttachment = new twaver.network.LabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._labelAttachment);
            }
        } else {
            if (this._labelAttachment) {
                this.removeAttachment(this._labelAttachment);
                this._labelAttachment = null;
            }
        }
    },
    checkAlarmAttachment: function () {
        var label = this._network.getAlarmLabel(this._element);
        if (label != null && label !== "") {
            if (!this._alarmAttachment) {
                this._alarmAttachment = new twaver.network.AlarmAttachment(this, $Defaults.SHOW_ALARM_IN_ATTACHMENT_DIV);
                this.addAttachment(this._alarmAttachment);
            }
        } else {
            if (this._alarmAttachment) {
                this.removeAttachment(this._alarmAttachment);
                this._alarmAttachment = null;
            }
        }
    },
    checkIconsAttachment: function () {
        var icons = this._network.getIconsNames(this._element);
        if (icons && icons.length > 0) {
            if (!this._iconsAttachment) {
                this._iconsAttachment = new twaver.network.IconsAttachment(this);
                this.addAttachment(this._iconsAttachment);
            }
        } else {
            if (this._iconsAttachment) {
                this.removeAttachment(this._iconsAttachment);
                this._iconsAttachment = null;
            }
        }
    },
    checkEditAttachment: function () {
        if (this.isEditable() &&
					this._network.hasEditInteraction() &&
					this._network.isSelected(this._element) &&
					this._network.isEditable(this._element)) {
            if (!this._editAttachment) {
                this._editAttachment = new twaver.network.EditAttachment(this);
                this.addAttachment(this._editAttachment);
            }
        } else {
            if (this._editAttachment) {
                this.removeAttachment(this._editAttachment);
                this._editAttachment = null;
            }
        }
    },
    isEditable: function () {
        return true;
    },
    handlePropertyChange: function (e) {
        this.invalidate(true);
    },
    handleSelectionChange: function (e) {
        this.invalidate(true);
    },
    dispose: function () {
        this._attachments.forEach(function (attachment) {
            if (attachment.getView().parentNode) {
                attachment.getView().parentNode.removeChild(attachment.getView());
            }
            attachment.dispose();
        });
        this._attachments.clear();
    },
    addAttachment: function (attachment) {
        this._attachments.add(attachment);
        if (attachment.isShowInAttachmentDiv()) {
            this._network.getAttachmentDiv().appendChild(attachment.getView());
        } else {
            this._view.appendChild(attachment.getView());
        }
        this.invalidate(false);
    },
    removeAttachment: function (attachment) {
        this._attachments.remove(attachment);
        if (attachment.getView().parentNode) {
            attachment.getView().parentNode.removeChild(attachment.getView());
        }
        attachment.dispose();
        this.invalidate(false);
    },
    addBodyBounds: function (rect) {
        if (rect) {
            this._bodyBounds.add(rect);
        }
    },
    addComponent: function (component) {
        this._bodyView.appendChild(component);
    },
    getBodyView: function () {
        return this._bodyView;
    },
    getView: function () {
        return this._view;
    },
    getViewRect: function () {
        return _twaver.clone(this._viewRect);
    },
    setShadow: function (part, canvas, rect) {
        var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
        if (shadowable) {
            if (this._shadowXOffset > 0) {
                rect.width += this._shadowXOffset;
            } else {
                rect.x += this._shadowXOffset;
                rect.width += -this._shadowXOffset;
            }
            if (this._shadowYOffset > 0) {
                rect.height += this._shadowYOffset;
            } else {
                rect.y += this._shadowYOffset;
                rect.height += -this._shadowYOffset;
            }
            $math.grow(rect, this._shadowBlur, this._shadowBlur);
        }
        var g = $html.setCanvas(canvas, rect);
        if (shadowable) {
            g.shadowOffsetX = this._shadowXOffset;
            g.shadowOffsetY = this._shadowYOffset;
            g.shadowBlur = this._shadowBlur;
            g.shadowColor = this._shadowColor;
        }
        return g;
    },
    isShadowable: function () {
        if (this._shadowColor &&
            this._network.isSelected(this._element) &&
            this._element.getStyle('select.style') === 'shadow') {
            return true;
        }
        return false;
    },
    hit: function (x, y) {
        return false;
    },
    hitCanvas: function (x, y, names) {
        var count = names.length;
        for (var i = 0; i < count; i++) {
            var name = names[i];
            var canvas = this[name];
            if ($g.hit(canvas, x, y, this._network.getSelectionTolerance())) {
                return true;
            }
        }
        return false;
    },
    hitComponent: function (x, y, names) {
        var count = names.length;
        for (var i = 0; i < count; i++) {
            var name = names[i];
            var component = this[name];
            if (component && $math.containsPoint(component._viewRect, x, y)) {
                return true;
            }
        }
        return false;
    },
    hitTest: function (x, y) {
        if (!this.isVisible() || !$math.containsPoint(this._viewRect, x, y)) {
            return null;
        }
        var i, n = this._attachments.size(), attachment;
        for (i = n - 1; i >= 0; i--) {
            attachment = this._attachments.get(i);
            if (attachment.isShowInAttachmentDiv() && attachment.hit(x, y)) {
                return attachment;
            }
        }
        for (i = n - 1; i >= 0; i--) {
            attachment = this._attachments.get(i);
            if (!attachment.isShowInAttachmentDiv() && attachment.hit(x, y)) {
                return attachment;
            }
        }
        if ($math.containsPoint(this._unionBodyBounds, x, y) && this.hit(x, y)) {
            return this;
        }
        return null;
    },
    intersects: function (rect) {
        return false;
    },
    intersectsComponent: function (rect, names) {
        var count = names.length;
        for (var i = 0; i < count; i++) {
            var name = names[i];
            var component = this[name];
            if (component && $math.intersects(component._viewRect, rect)) {
                return true;
            }
        }
        return false;
    },
    intersectsCanvas: function (rect, names) {
        var count = names.length;
        for (var i = 0; i < count; i++) {
            var name = names[i];
            var canvas = this[name];
            if ($g.intersects(canvas, rect)) {
                return true;
            }
        }
        return false;
    },
    intersectsTest: function (rect) {
        if (!this.isVisible() || !$math.intersects(this._viewRect, rect)) {
            return null;
        }
        var n = this._attachments.size(), i, attachment;
        for (i = n - 1; i >= 0; i--) {
            attachment = this._attachments.get(i);
            if (attachment.isShowInAttachmentDiv() && attachment.intersects(rect)) {
                return attachment;
            }
        }
        for (i = n - 1; i >= 0; i--) {
            attachment = this._attachments.get(i);
            if (!attachment.isShowInAttachmentDiv() && attachment.intersects(rect)) {
                return attachment;
            }
        }
        if ($math.intersects(this._unionBodyBounds, rect) && this.intersects(rect)) {
            return this;
        }
        return null;
    }
});

twaver.network.Attachment = function (elementUI, showInAttachmentDiv) {
    this._view = $html.createDiv();
    this._ui = elementUI;
    this._element = this._ui.getElement();
    this._network = elementUI.getNetwork();
    this._isShowInAttachmentDiv = showInAttachmentDiv === true;
    if (this._isShowInAttachmentDiv) {
        $html.setVisible(this._view, elementUI.isVisible());
    }
};
_twaver.ext('twaver.network.Attachment', Object, {
    getElement: function () {
        return this._element;
    },
    getElementUI: function () {
        return this._ui;
    },
    getNetwork: function () {
        return this._network;
    },
    getStyle: function (styleProp) {
        return this._ui.getStyle(styleProp);
    },
    getFont: function (styleProp) {
        return this._ui.getFont(styleProp);
    },
    isShowInAttachmentDiv: function () {
        return this._isShowInAttachmentDiv;
    },
    getView: function () {
        return this._view;
    },
    getViewRect: function () {
        return _twaver.clone(this._viewRect);
    },
    getAlpha: function () {
        return 1;
    },
    updateMeasure: function () {

    },
    dispose: function () {

    },
    hit: function (x, y) {
        return $math.containsPoint(this._viewRect, x, y);
    },
    intersects: function (rect) {
        return $math.intersects(this._viewRect, rect);
    }
});

twaver.network.BasicAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.BasicAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._roundRect = { x: 0, y: 0, width: 0, height: 0 };
    this._contentRect = { x: 0, y: 0, width: 0, height: 0 };
    this._attachmentCanvas = $html.createCanvas();
    this._view.insertBefore(this._attachmentCanvas, this._view.firstChild);
};
_twaver.ext('twaver.network.BasicAttachment', twaver.network.Attachment, {
    calculateMeasure: function () {
        var contentWidth = this.getContentWidth();
        var contentHeight = this.getContentHeight();
        var cornerRadius = this.getCornerRadius();
        var pointerLength = this.getPointerLength();
        var pointerWidth = this.getPointerWidth();
        var position = this.getPosition();
        var xOffset = this.getXOffset();
        var yOffset = this.getYOffset();

        var roundRect = this._roundRect;
        roundRect.width = contentWidth + cornerRadius * 2;
        roundRect.height = contentHeight;
        var location;

        if (pointerLength > 0) {
            var direction = this.getDirection();
            location = this._network.getPosition(position, this._ui, null, xOffset, yOffset);
            var endPoint;
            if (direction === 'aboveleft') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, roundRect.x + cornerRadius / 2);
                this._pointers = [location,
	     						{ x: location.x, y: location.y - pointerLength },
	     						{ x: endPoint, y: location.y - pointerLength}];
            }
            else if (direction === 'aboveright') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, roundRect.x + roundRect.width - cornerRadius / 2);
                this._pointers = [location,
     							 { x: location.x, y: location.y - pointerLength },
     							 { x: endPoint, y: location.y - pointerLength}];
            }
            else if (direction === 'belowleft') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, roundRect.x + cornerRadius / 2);
                this._pointers = [location,
     							 { x: location.x, y: location.y + pointerLength },
     							 { x: endPoint, y: location.y + pointerLength}];
            }
            else if (direction === 'belowright') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, roundRect.x + roundRect.width - cornerRadius / 2);
                this._pointers = [location,
     							 { x: location.x, y: location.y + pointerLength },
     							 { x: endPoint, y: location.y + pointerLength}];
            }
            else if (direction === 'leftabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.max(location.y - pointerWidth, roundRect.y + cornerRadius / 2);
                this._pointers = [location,
     							 { x: location.x - pointerLength, y: location.y },
     							 { x: location.x - pointerLength, y: endPoint}];
            }
            else if (direction === 'leftbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(location.y + pointerWidth, roundRect.y + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
     							{ x: location.x - pointerLength, y: location.y },
     							{ x: location.x - pointerLength, y: endPoint}];
            }
            else if (direction === 'rightabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.max(location.y - pointerWidth, roundRect.y + cornerRadius / 2);
                this._pointers = [location,
     							{ x: location.x + pointerLength, y: location.y },
     							{ x: location.x + pointerLength, y: endPoint}];
            }
            else if (direction === 'rightbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(location.y + pointerWidth, roundRect.y + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
     								{ x: location.x + pointerLength, y: location.y },
     								{ x: location.x + pointerLength, y: endPoint}];
            }
            else if (direction === 'above') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
     							{ x: location.x - endPoint, y: location.y - pointerLength },
     							{ x: location.x + endPoint, y: location.y - pointerLength}];
            }
            else if (direction === 'below') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
     							{ x: location.x - endPoint, y: location.y + pointerLength },
     							{ x: location.x + endPoint, y: location.y + pointerLength}];
            }
            else if (direction === 'left') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
     							{ x: location.x - pointerLength, y: location.y + endPoint },
     							{ x: location.x - pointerLength, y: location.y - endPoint}];
            }
            else if (direction === 'right') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
     							{ x: location.x + pointerLength, y: location.y + endPoint },
     							{ x: location.x + pointerLength, y: location.y - endPoint}];
            }
            else {
                throw "Can not resolve '" + direction + "' attachment direction";
            }
        }
        else {
            location = this._network.getPosition(position, this._ui, { width: roundRect.width, height: roundRect.height }, xOffset, yOffset);
            roundRect.x = location.x;
            roundRect.y = location.y;
            this._pointers = null;
        }

        this._contentRect.x = roundRect.x + (roundRect.width - contentWidth) / 2;
        this._contentRect.y = roundRect.y + (roundRect.height - contentHeight) / 2;
        this._contentRect.width = contentWidth;
        this._contentRect.height = contentHeight;

        var padding = this.getPadding();
        if (padding != 0) {
            $math.grow(roundRect, padding, padding);
        }
        padding = this.getPaddingLeft();
        if (padding != 0) {
            roundRect.x -= padding;
            roundRect.width += padding;
        }
        padding = this.getPaddingRight();
        if (padding != 0) {
            roundRect.width += padding;
        }
        padding = this.getPaddingTop();
        if (padding != 0) {
            roundRect.y -= padding;
            roundRect.height += padding;
        }
        padding = this.getPaddingBottom();
        if (padding != 0) {
            roundRect.height += padding;
        }
        if (roundRect.width < 0) {
            roundRect.width = roundRect.width;
            roundRect.x -= roundRect.width;
        }
        if (roundRect.height < 0) {
            roundRect.height = -roundRect.height;
            roundRect.y -= roundRect.height;
        }
    },

    updateMeasure: function () {
        twaver.network.BasicAttachment.superClass.updateMeasure.call(this);
        this.calculateMeasure();

        var fill = this.isFill();
        var outlineWidth = this.getOutlineWidth();

        this._viewRect = $math.getRect(this._pointers);
        this._viewRect = $math.unionRect(this._viewRect, this._roundRect);
        if (outlineWidth > 0) {
            $math.grow(this._viewRect, outlineWidth / 2, outlineWidth / 2);
        }
        var g = this._ui.setShadow(this, this._attachmentCanvas, this._viewRect);

        if (outlineWidth > 0 || fill) {
            g.beginPath();
            $g.drawRoundRect(g, this._roundRect.x, this._roundRect.y, this._roundRect.width, this._roundRect.height, this.getCornerRadius());
            //todo make sure drawRoundRect and pointer same direction
            if (this._pointers) {
                g.moveTo(this._pointers[0].x, this._pointers[0].y);
                g.lineTo(this._pointers[1].x, this._pointers[1].y);
                g.lineTo(this._pointers[2].x, this._pointers[2].y);
            }
            g.closePath();

            if (outlineWidth > 0) {
                g.lineWidth = outlineWidth;
                g.strokeStyle = this.getOutlineColor();
                g.lineCap = this.getCap();
                g.lineJoin = this.getJoin();
                g.stroke();
            }
            if (fill) {
                var fillColor = this.getFillColor();
                var gradient = this.getGradient();
                if (gradient) {
                    $g.fill(g, fillColor, gradient, this.getGradientColor(), this._viewRect);
                } else {
                    g.fillStyle = fillColor;
                }
                g.fill();
            }
        }
        return g;
    },
    getRoundRect: function () {
        return _twaver.clone(this._roundRect);
    },
    getContentRect: function () {
        return _twaver.clone(this._contentRect);
    },
    getContent: function () {
        return this._content;
    },
    setContent: function (value) {
        if (this._content === value) {
            return;
        }
        if (this._content) {
            this._view.removeChild(this._content);
        }
        this._content = value;
        if (value) {
            this._view.appendChild(value);
        }
    },
    getContentWidth: function () {
        return $Defaults.ATTACHMENT_CONTENT_WIDTH;
    },
    getContentHeight: function () {
        return $Defaults.ATTACHMENT_CONTENT_HEIGHT;
    },
    getCornerRadius: function () {
        return $Defaults.ATTACHMENT_CORNER_RADIUS;
    },
    getPointerLength: function () {
        return $Defaults.ATTACHMENT_POINTER_LENGTH;
    },
    getPointerWidth: function () {
        return $Defaults.ATTACHMENT_POINTER_WIDTH;
    },
    getPosition: function () {
        return $Defaults.ATTACHMENT_POSITION;
    },
    getXOffset: function () {
        return $Defaults.ATTACHMENT_XOFFSET;
    },
    getYOffset: function () {
        return $Defaults.ATTACHMENT_YOFFSET;
    },
    getPadding: function () {
        return $Defaults.ATTACHMENT_PADDING;
    },
    getPaddingLeft: function () {
        return $Defaults.ATTACHMENT_PADDING_LEFT;
    },
    getPaddingRight: function () {
        return $Defaults.ATTACHMENT_PADDING_RIGHT;
    },
    getPaddingTop: function () {
        return $Defaults.ATTACHMENT_PADDING_TOP;
    },
    getPaddingBottom: function () {
        return $Defaults.ATTACHMENT_PADDING_BOTTOM;
    },
    getDirection: function () {
        return $Defaults.ATTACHMENT_DIRECTION;
    },
    isFill: function () {
        return $Defaults.ATTACHMENT_FILL;
    },
    getFillColor: function () {
        return $Defaults.ATTACHMENT_FILL_COLOR;
    },
    getGradient: function () {
        return $Defaults.ATTACHMENT_GRADIENT;
    },
    getGradientColor: function () {
        return $Defaults.ATTACHMENT_GRADIENT_COLOR;
    },
    getOutlineWidth: function () {
        return $Defaults.ATTACHMENT_OUTLINE_WIDTH;
    },
    getOutlineColor: function () {
        return $Defaults.ATTACHMENT_OUTLINE_COLOR;
    },
    getCap: function () {
        return $Defaults.ATTACHMENT_CAP;
    },
    getJoin: function () {
        return $Defaults.ATTACHMENT_JOIN;
    },
    isShadowable: function () {
        return $Defaults.ATTACHMENT_SHADOWABLE;
    },
    hit: function (x, y) {
        if (!$math.containsPoint(this._viewRect, x, y)) {
            return false;
        }
        if ($math.containsPoint(this._contentRect, x, y)) {
            return true;
        }
        return $g.hit(this._attachmentCanvas, x, y);
    },
    intersects: function (rect) {
        if (!$math.intersects(this._viewRect, rect)) {
            return false;
        }
        if ($math.intersects(this._contentRect, rect)) {
            return true;
        }
        return $g.intersects(this._attachmentCanvas, rect);
    }
});

twaver.network.LabelAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.LabelAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.network.LabelAttachment', twaver.network.BasicAttachment, {
    updateMeasure: function () {
        var font = this.getFont('label.font');
        var text;
        var originalText = this.getLabel();
        var originalTextSize = _twaver.g.getTextSize(font, originalText);
        var originalMaxLength = this.getMaxLength();
        if(originalMaxLength !==0 && originalTextSize.width > originalMaxLength){
            text = _twaver.g.getCollapseTextInLength(font,originalText,originalMaxLength);
            this._textSize = _twaver.g.getTextSize(font, text);
        }else{
            text = originalText;
            this._textSize = originalTextSize;
        }
        var g = twaver.network.LabelAttachment.superClass.updateMeasure.call(this);
        var align = this._element.getStyle("label.align");
		$g.drawText(g, text, this._contentRect, font, this.getStyle('label.color'),align,this.getStyle('label.linespacing'));
    },
    getLabel: function () {
        return this._network.getLabel(this._element);
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('label.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('label.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('label.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('label.position');
    },
    getXOffset: function () {
        return this.getStyle('label.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('label.yoffset');
    },
    getPadding: function () {
        return this.getStyle('label.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('label.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('label.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('label.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('label.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('label.direction');
    },
    isFill: function () {
        return this.getStyle('label.fill');
    },
    getFillColor: function () {
        return this.getStyle('label.fill.color');
    },
    getGradient: function () {
        return this.getStyle('label.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('label.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('label.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('label.outline.color');
    },
    getCap: function () {
        return this.getStyle('label.cap');
    },
    getJoin: function () {
        return this.getStyle('label.join');
    },
    getAlpha: function () {
        return this.getStyle('label.alpha');
    },
    getMaxLength:function(){
        return this.getStyle('label.maxlength');
    },
    isShadowable: function () {
        return this.getStyle('label.shadowable');
    }
});

twaver.network.AlarmAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.AlarmAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.network.AlarmAttachment', twaver.network.BasicAttachment, {
    updateMeasure: function () {
        var font = this.getFont('alarm.font');
        var text = this._network.getAlarmLabel(this._element);
        this._textSize = $g.getTextSize(font, text);
        this._fillColor = this._network.getAlarmFillColor(this._element);
        var g = twaver.network.AlarmAttachment.superClass.updateMeasure.call(this);
        $g.drawText(g, text, this._contentRect, font, this.getStyle('alarm.color'));
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('alarm.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('alarm.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('alarm.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('alarm.position');
    },
    getXOffset: function () {
        return this.getStyle('alarm.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('alarm.yoffset');
    },
    getPadding: function () {
        return this.getStyle('alarm.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('alarm.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('alarm.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('alarm.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('alarm.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('alarm.direction');
    },
    isFill: function () {
        return this._fillColor != null;
    },
    getFillColor: function () {
        return this._fillColor;
    },
    getGradient: function () {
        return this.getStyle('alarm.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('alarm.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('alarm.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('alarm.outline.color');
    },
    getCap: function () {
        return this.getStyle('alarm.cap');
    },
    getJoin: function () {
        return this.getStyle('alarm.join');
    },
    getAlpha: function () {
        return this.getStyle('alarm.alpha');
    },
    isShadowable: function () {
        return this.getStyle('alarm.shadowable');
    }
});

twaver.network.LinkHandlerAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.LinkHandlerAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.network.LinkHandlerAttachment', twaver.network.BasicAttachment, {
    updateMeasure: function () {
        var font = this.getFont('link.handler.font');
        var text = this._network.getLinkHandlerLabel(this._element);
        this._textSize = $g.getTextSize(font, text);
        var g = twaver.network.LabelAttachment.superClass.updateMeasure.call(this);
        $g.drawText(g, text, this._contentRect, font, this.getStyle('link.handler.color'));
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('link.handler.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('link.handler.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('link.handler.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('link.handler.position');
    },
    getXOffset: function () {
        return this.getStyle('link.handler.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('link.handler.yoffset');
    },
    getPadding: function () {
        return this.getStyle('link.handler.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('link.handler.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('link.handler.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('link.handler.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('link.handler.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('link.handler.direction');
    },
    isFill: function () {
        return this.getStyle('link.handler.fill');
    },
    getFillColor: function () {
        return this.getStyle('link.handler.fill.color');
    },
    getGradient: function () {
        return this.getStyle('link.handler.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('link.handler.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('link.handler.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('link.handler.outline.color');
    },
    getCap: function () {
        return this.getStyle('link.handler.cap');
    },
    getJoin: function () {
        return this.getStyle('link.handler.join');
    },
    getAlpha: function () {
        return this.getStyle('link.handler.alpha');
    },
    isShadowable: function () {
        return this.getStyle('link.handler.shadowable');
    }

});

twaver.network.EditAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.EditAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._attachmentDiv = $html.createDiv();
    this._view.appendChild(this._attachmentDiv);
};
_twaver.ext('twaver.network.EditAttachment', twaver.network.Attachment, {
    updateMeasure: function () {
        twaver.network.EditAttachment.superClass.updateMeasure.call(this);
        this._viewRect = null;
        if (this._element instanceof $Node) {
            this._addResizingPoint(this._element);
        }
        if(this._network.isRotatable(this._element) && this._element instanceof $Node && !(this._element instanceof twaver.ShapeNode) && !(this._element instanceof twaver.Grid) && !(this._element instanceof twaver.Group)) {
            this._addRotatePoint(this._element);
        }
        if (this._element instanceof twaver.ShapeNode) {
            this._addResizingPoint(this._element);
            this._addShapeNodePoint(this._element);
        }
        if (this._ui instanceof twaver.network.ShapeLinkUI) {
            this._addShapeLinkPoints(this._ui);
        }
        if (this._ui instanceof twaver.network.LinkUI) {
            this._addLinkControlPoint(this._ui);
        }
    },
    _addRotatePoint: function(node) {
        var size = this._network.getRotatePointSize();
        if (size <= 0) {
            return;
        }
        var rect = node.getOriginalRect();
        if(!this._rotateDiv) {
            var div = $html.createDiv();
            this._attachmentDiv.appendChild(div);
            this._rotateDiv = div;
        }
        var outlineWidth = this._network.getRotatePointOutlineWidth();
        var outlineColor = this._network.getRotatePointOutlineColor();
        var fillColor = this._network.getRotatePointFillColor();
        var size = this._network.getRotatePointSize();
        var offset = size + outlineWidth;
        var width = size * 2;
        var divRect = { x: rect.x + rect.width / 2 - size, y: rect.y - this._network.getRotatePointOffset() - width, width:width, height:width};
        var rotateDivRect;
        if(node.angle == 0) {
            rotateDivRect = divRect;
        } else {
            rotateDivRect = this._getRotateRect(divRect,node.getAngle(),{x:rect.x + rect.width / 2, y:rect.y + rect.height / 2});
        }
        var unionRect = $math.unionRect(node.getRect(),rotateDivRect);
        this._viewRect = $math.unionRect(unionRect, this._viewRect);
        $html.setDiv(this._rotateDiv, divRect, fillColor, outlineWidth, outlineColor);
        this._rotateDiv._viewRect = rotateDivRect;
        $html.setBorderRaidus(this._rotateDiv, width + 'px');
        this._rotateAttachments(this._rotateDiv,width / 2, outlineWidth);
    },
    _addResizingPoint: function (node) {
        var size = this._network.getResizePointSize();
        if(size <= 0) {
            return;
        }
        var rect = node.getOriginalRect();
        var points = new $List([
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.width / 2, y: rect.y },
            { x: rect.x + rect.width, y: rect.y },

            { x: rect.x, y: rect.y + rect.height / 2 },
            { x: rect.x + rect.width, y: rect.y + rect.height / 2 },

            { x: rect.x, y: rect.y + rect.height },
            { x: rect.x + rect.width / 2, y: rect.y + rect.height },
            { x: rect.x + rect.width, y: rect.y + rect.height }
        ]);
        if (!this._resizeDivs) {
            this._resizeDivs = new Array();
            for (var i = 0; i < 8; i++) {
                var div = $html.createDiv();
                this._attachmentDiv.appendChild(div);
                this._resizeDivs[i] = div;
            }
        }
        if(this._resizeDivs) {
            this._resizeRects = new Array();
            for (var i = 0; i < 8; i++) {
                var point = points.get(i);
                var divRect = {x:point.x - size, y:point.y - size, width:size * 2, height:size * 2};
                var rotatedRect;
                if(node.getAngle() == 0) {
                    rotatedRect = divRect;
                } else {
                    rotatedRect = this._getRotateRect(divRect,node.getAngle(),{x:rect.x + rect.width / 2, y:rect.y + rect.height / 2});
                }
                this._resizeRects[i] = rotatedRect;
            }
        }
        var outlineWidth = this._network.getResizePointOutlineWidth();
        var outlineColor = this._network.getResizePointOutlineColor();
        var fillColor = this._network.getResizePointFillColor();

        this._addPoints(node.getRect(), points, outlineWidth, outlineColor, fillColor, true);

    },
    _addPoints: function (rect, points, outlineWidth, outlineColor, fillColor, isResizePoints) {
        var size = isResizePoints ? this._network.getResizePointSize() : this._network.getEditPointSize();
        if (size <= 0) {
            return;
        }
        var offset = size + outlineWidth;
        $math.grow(rect, offset, offset);
        this._viewRect = $math.unionRect(rect, this._viewRect);
        var width = size * 2;
        var rects = new $List();
        var i, n, point, rectangleRect;
        for (i = 0, n = points.size(); i < n; i++) {
            point = points.get(i);
            rectangleRect = { x: point.x - size, y: point.y - size, width: width, height: width};
            rects.add(rectangleRect);
        }
        var divs;
        if (isResizePoints) {
            divs = this._resizeDivs;
        } else {
            if (!this._controlDivs) {
                this._controlDivs = new Array();
            }
            if (this._controlDivs.length < n) {
                for (i = this._controlDivs.length; i < n; i++) {
                    var div = $html.createDiv();
                    this._attachmentDiv.appendChild(div);
                    this._controlDivs[i] = div;
                }
            } else if (this._controlDivs.length > n) {
                for (i = n; i < this._controlDivs.length; i++) {
                    this._attachmentDiv.removeChild(this._controlDivs[i]);
                }
                this._controlDivs.splice(n);
            }
            divs = this._controlDivs;
        }
        for (i = 0, n = rects.size(); i < n; i++) {
            rectangleRect = rects.get(i);
            $html.setDiv(divs[i], rectangleRect, fillColor, outlineWidth, outlineColor);
            $html.setBorderRaidus(divs[i], (isResizePoints ? '0' : width) + 'px');
            this._rotateAttachments(divs[i], width / 2, outlineWidth,points.get(i));
        }
    },
    _rotateAttachments: function(div, size, outlineWidth, point) {
        if(this._element instanceof $Node) {
            var angle = this._element.getAngle();
            if(angle == 0) {
                return;
            }
            var rect = this._element.getOriginalRect();
            var x = (div.style.left).split("px")[0];
            var y = (div.style.top).split("px")[0];
            var translateX = rect.x + rect.width / 2;
            var translateY = rect.y + rect.height / 2;
            if(!point) {
                point = {x: parseFloat(x) + size + outlineWidth, y: parseFloat(y) + size + outlineWidth};
            }
            var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
            var newPoint = matrix.transform(point);
            div.style.webkitTransform = "rotate(" + angle + "deg)";
            div.style.mozTransform = "rotate(" + angle + "deg)";
            div.style.OTransform = "rotate(" + angle + "deg)";
            div.style.msTransform = "rotate(" + angle + "deg)";
            div.style.transform = "rotate(" + angle + "deg)";
            div.style.left = (newPoint.x - size - outlineWidth) + "px";
            div.style.top = (newPoint.y  - size - outlineWidth) + "px";
        }
    },
    _addShapeLinkPoints: function (shapeLinkUI) {
        this._addEditPoints(shapeLinkUI._element.getPoints());
    },
    _addShapeNodePoint: function (shapeNode) {
        this._addEditPoints(shapeNode.getPoints());
    },
    _addLinkControlPoint: function (linkUI) {
        if ($link.isOrthogonalLink(linkUI._element)) {
            var controlPoint = linkUI.getControlPoint();
            if (controlPoint) {
                var points = new $List();
                points.add(controlPoint);
                this._addEditPoints(points);
            }
        }
    },
    _addEditPoints: function (points) {
        var rect = $math.getRect(points);
        if (!rect) {
            return;
        }
        var outlineWidth = this._network.getEditPointOutlineWidth();
        var outlineColor = this._network.getEditPointOutlineColor();
        var fillColor = this._network.getEditPointFillColor();

        this._addPoints(rect, points, outlineWidth, outlineColor, fillColor, false);
    },
    hit: function (x, y) {
        if (!$math.containsPoint(this._viewRect, x, y)) {
            return false;
        }
        var i;
        if (this._resizeDivs) {
            for (i = this._resizeDivs.length - 1; i >= 0; i--) {
                if ($math.containsPoint(this._resizeRects[i], x, y)) {
                    return true;
                }
            }
        }
        if (this._rotateDiv) {
            if ($math.containsPoint(this._rotateDiv._viewRect, x, y)) {
                return true;
            }
        }
        if (this._controlDivs) {
            for (i = this._controlDivs.length - 1; i >= 0; i--) {
                if ($math.containsPoint(this._controlDivs[i]._viewRect, x, y)) {
                    return true;
                }
            }
        }
        return false;
    },
    intersects: function (rect) {
        if (!$math.intersects(this._viewRect, rect)) {
            return false;
        }
        var i;
        if (this._resizeDivs) {
            for (i = this._resizeDivs.length - 1; i >= 0; i--) {
                if ($math.intersects(this._resizeRects[i], rect)) {
                    return true;
                }
            }
        }
        if (this._rotateDiv) {
            if ($math.containsPoint(this._rotateDiv._viewRect, rect)) {
                return true;
            }
        }
        if (this._controlDivs) {
            for (i = this._controlDivs.length - 1; i >= 0; i--) {
                if ($math.intersects(this._controlDivs[i]._viewRect, rect)) {
                    return true;
                }
            }
        }
        if (!$math.intersects(this._viewRect, rect)) {
            return false;
        }
        return false;
    },
    _getRotateRect: function(rect,angle,center) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, center.x, center.y);
        var centerPoint = {x: rect.x + rect.width / 2,y: rect.y + rect.height / 2};
        var point = matrix.transform(centerPoint);
        var points = new twaver.List([
            {x: point.x - rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y + rect.height / 2},
            {x: point.x - rect.width / 2, y: point.y + rect.height / 2}
        ]);
        return $math.getRect(points);
    }
});
twaver.network.IconsAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.IconsAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._iconsCanvas = null;
};
_twaver.ext('twaver.network.IconsAttachment', twaver.network.Attachment, {
    isShadowable: function () {
        return $Defaults.ATTACHMENT_SHADOWABLE;
    },
    updateMeasure: function () {
        twaver.network.IconsAttachment.superClass.updateMeasure.call(this);

        var names = this._network.getIconsNames(this._element);
        if (!names || names.length == 0) {
            return;
        }

        var colors = this._network.getIconsColors(this._element);
        var orientation = this._element.getStyle('icons.orientation');
        var position = this._element.getStyle('icons.position');
        var xoffset = this._element.getStyle('icons.xoffset');
        xoffset = xoffset instanceof Array? xoffset[0] : xoffset;
        var yoffset = this._element.getStyle('icons.yoffset');
        yoffset = yoffset instanceof Array? yoffset[0] : yoffset;
        var xgap = this._element.getStyle('icons.xgap');
        xgap = xgap instanceof Array? xgap[0] : xgap; 
        var ygap = this._element.getStyle('icons.ygap');
        ygap = ygap instanceof Array? ygap[0] : ygap;
        var iconsSize = this._getIconsSize(names, orientation, xgap, ygap);
        if (!iconsSize) {
            return;
        }
        var location = this._network.getPosition(position, this._ui, iconsSize, xoffset, yoffset);
        this._viewRect = { x: location.x, y: location.y, width: iconsSize.width, height: iconsSize.height };
        if (orientation === 'top') {
            location.y += iconsSize.height;
        }
        else if (orientation === 'left') {
            location.x += iconsSize.width;
        }

        if (!this._iconsCanvas) {
            this._iconsCanvas = $html.createCanvas();
            this._view.appendChild(this._iconsCanvas);
        }
        var g = this._ui.setShadow(this, this._iconsCanvas, _twaver.clone(this._viewRect));

        var x = location.x;
        var y = location.y;
        var index = 0;
        for (var name in names) {
            var rect = null;
            var color = null;
            if (colors && colors.length > index) {
                color = colors[index++];
            }
            var imageAsset = _twaver.getImageAsset(names[name]);
            if (imageAsset == null) {
                continue;
            }
            if (orientation === 'right') {
                rect = { x: x, y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                x += rect.width + xgap;
            }
            else if (orientation === 'left') {
                rect = { x: x - imageAsset.getWidth(), y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                x -= rect.width + xgap;
            }
            else if (orientation === 'top') {
                rect = { x: x, y: y - imageAsset.getHeight(), width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                y -= rect.height + ygap;
            }
            else if (orientation === 'bottom') {
                rect = { x: x, y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                y += rect.height + ygap;
            }
            else {
                throw "Can not resolve '" + orientation + "' orientation";
            }
            drawImage(g, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
        }
    },
    _getIconsSize: function (names, orientation, xgap, ygap) {
        var x = 0;
        var y = 0;
        var rect = null;
        var imageAsset = null;
        var unionRect = null;
        for (var name in names) {
            imageAsset = _twaver.getImageAsset(names[name]);
            if (!imageAsset) {
                continue;
            }
            if (orientation === 'right') {
                rect = { x: x, y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                x += rect.width + xgap;
            }
            else if (orientation === 'left') {
                rect = { x: x - imageAsset.getWidth(), y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                x -= rect.width + xgap;
            }
            else if (orientation === 'top') {
                rect = { x: x, y: y - imageAsset.getHeight(), width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                y -= rect.height + ygap;
            }
            else if (orientation === 'bottom') {
                rect = { x: x, y: y, width: imageAsset.getWidth(), height: imageAsset.getHeight() };
                y += rect.height + ygap;
            }
            else {
                throw "Can not resolve '" + orientation + "' orientation";
            }
            if (unionRect == null) {
                unionRect = _twaver.clone(rect);
            } else {
                unionRect = $math.unionRect(unionRect, rect);
            }
        }
        if (unionRect) {
            return { width: Math.abs(unionRect.width), height: Math.abs(unionRect.height) };
        }
        return null;
    }
});

twaver.network.HTMLBasicAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.HTMLBasicAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._roundRect = { x: 0, y: 0, width: 0, height: 0 };
    this._contentRect = { x: 0, y: 0, width: 0, height: 0 };
    this._triangleDiv = twaver.Util.createDiv();
    this._roundDiv = twaver.Util.createDiv();
    this._contentDiv = twaver.Util.createDiv();

    twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
    twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");

    var self = this;
    function toRotatedPoint(x, y, ox, oy, lx, ly, ispositive) {
        if (!ox) {
            ox = this._origin.x;
        }
        if (!oy) {
            oy = this._origin.y;
        }
        if (!lx) {
            lx = this._location.x;
        }
        if (!ly) {
            ly = this._location.y;
        }
        x = x - ox - lx; y = y - oy - ly;
        var point = twaver.Util.transformPoint({ x: ox + lx, y: oy + ly }, (ispositive ? this._radian : -this._radian), x, y).point;
        return point;
    }
    this.hit = function (x, y) {
        if (this._radian && this._origin) {
            var point = toRotatedPoint.call(self, x, y);
            x = point.x, y = point.y;
        }
        return twaver.Util.containsPoint(this._roundRect, x, y) || twaver.Util.containsPoint(this._pointerRect, x, y);
    };
    this.intersects = function (rect) {
        var a = { x: rect.x, y: rect.y }, b = { x: rect.x + rect.width, y: rect.y }, c = { x: rect.x, y: rect.y + rect.height }, d = { x: rect.x + rect.width, y: rect.y + rect.height };
        if (this._radian && this._origin) {
            if (rect.width * rect.height > 50) return false;
            a = toRotatedPoint.call(self, a.x, a.y);
            b = toRotatedPoint.call(self, b.x, b.y);
            c = toRotatedPoint.call(self, c.x, c.y);
            d = toRotatedPoint.call(self, d.x, d.y);
        }
        rect = twaver.Util.getRect([a, b, c, d]);
        return twaver.Util.intersects(this._roundRect, rect) || twaver.Util.intersects(this._pointerRect, rect);
    }
    this.getContentWidth = function () {
        return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
    }
    this.getContentHeight = function () {
        return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
    }

    
    this._view.appendChild(this._roundDiv);
    this._roundDiv.appendChild(this._contentDiv);
};
twaver.Util.ext('twaver.network.HTMLBasicAttachment', twaver.network.BasicAttachment, {
    calculateMeasure: function () {
        var contentWidth = this.getContentWidth();
        var contentHeight = this.getContentHeight();
        var cornerRadius = Math.min(this.getCornerRadius(), contentHeight / 2);
        var pointerLength = this.getPointerLength();
        var pointerWidth = this.getPointerWidth();
        var position = this.getPosition();
        var xOffset = this.getXOffset();
        var yOffset = this.getYOffset();

        this._contentRect.width = contentWidth;
        this._contentRect.height = contentHeight;
        this._contentRect.x = cornerRadius;

        var roundRect = this._roundRect;
        roundRect.width = contentWidth + cornerRadius * 2;
        roundRect.height = contentHeight;
        var location;

        if (pointerLength > 0) {
            var direction = this.getDirection();
            location = this._network.getPosition(position, this._ui, null, xOffset, yOffset);
            var endPoint;
            if (direction === 'aboveleft') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - (roundRect.width - cornerRadius);

                this._pointers = [location,
                                { x: location.x, y: location.y - pointerLength },
                                { x: location.x - Math.min(pointerWidth, contentWidth), y: location.y - pointerLength}];

                var hBorderWidth = pointerLength / 2;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = fillColor + " " + fillColor + " transparent transparent";
                this._triangleDivLocation = this._pointers[2];
            }
            else if (direction === 'aboveright') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - cornerRadius;

                this._pointers = [location,
                                { x: location.x, y: location.y - pointerLength },
                                { x: location.x + Math.min(pointerWidth, contentWidth), y: location.y - pointerLength}];

                var hBorderWidth = pointerLength / 2;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = fillColor + " transparent transparent " + fillColor;
                this._triangleDivLocation = this._pointers[1];
            }
            else if (direction === 'belowleft') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - (roundRect.width - cornerRadius);

                this._pointers = [location,
                                { x: location.x, y: location.y + pointerLength },
                                { x: location.x - Math.min(pointerWidth, contentWidth), y: location.y + pointerLength}];

                var hBorderWidth = pointerLength / 2;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = " transparent " + fillColor + " " + fillColor + " transparent";
                this._triangleDivLocation = { x: this._pointers[2].x, y: location.y }
            }
            else if (direction === 'belowright') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - cornerRadius;

                this._pointers = [location,
                                { x: location.x, y: location.y + pointerLength },
                                { x: location.x + Math.min(pointerWidth, contentWidth), y: location.y + pointerLength}];

                var hBorderWidth = pointerLength / 2;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = "transparent transparent " + fillColor + " " + fillColor;
                this._triangleDivLocation = this._pointers[0];
            }
            else if (direction === 'above') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - roundRect.width / 2;

                this._pointers = [location,
                                { x: location.x - Math.min(pointerWidth, contentWidth) / 2, y: location.y - pointerLength },
                                { x: location.x + Math.min(pointerWidth, contentWidth) / 2, y: location.y - pointerLength}];

                var hBorderWidth = pointerLength;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + "0px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = fillColor + " transparent transparent transparent";
                this._triangleDivLocation = this._pointers[1];
            }
            else if (direction === 'below') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - roundRect.width / 2;

                this._pointers = [location,
                                { x: location.x - Math.min(pointerWidth, contentWidth) / 2, y: location.y + pointerLength },
                                { x: location.x + Math.min(pointerWidth, contentWidth) / 2, y: location.y + pointerLength}];

                var hBorderWidth = pointerLength;
                var vBorderWidth = Math.min(pointerWidth, contentWidth) / 2;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = "0px " + vBorderWidth + "px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = "transparent transparent " + fillColor + " transparent ";
                this._triangleDivLocation = { x: this._pointers[1].x, y: location.y };
            }
            else if (direction === 'left') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x - roundRect.width - pointerLength;

                this._pointers = [location,
                                { x: location.x - pointerLength, y: location.y - Math.min(pointerWidth, contentHeight) / 2 },
                                { x: location.x - pointerLength, y: location.y + Math.min(pointerWidth, contentHeight) / 2}];

                var hBorderWidth = Math.min(pointerWidth, contentHeight) / 2;
                var vBorderWidth = pointerLength;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px 0px " + hBorderWidth + "px " + vBorderWidth + "px";
                this._triangleBorderColorStyle = "transparent transparent  transparent " + fillColor;
                this._triangleDivLocation = this._pointers[1];
            }
            else if (direction === 'right') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x + pointerLength;

                this._pointers = [location,
                                { x: location.x + pointerLength, y: location.y - Math.min(pointerWidth, contentHeight) / 2 },
                                { x: location.x + pointerLength, y: location.y + Math.min(pointerWidth, contentHeight) / 2}];

                var hBorderWidth = Math.min(pointerWidth, contentHeight) / 2;
                var vBorderWidth = pointerLength;
                var fillColor = this.getFillColor();
                this._triangleBorderWidthStyle = hBorderWidth + "px " + vBorderWidth + "px " + hBorderWidth + "px " + "0px";
                this._triangleBorderColorStyle = "transparent " + fillColor + " transparent  transparent ";
                this._triangleDivLocation = { x: location.x, y: this._pointers[1].y };
            }
            else {
                throw "Can not resolve '" + direction + "' attachment direction";
            }
        }
        else {
            location = this._network.getPosition(position, this._ui, { width: roundRect.width, height: roundRect.height }, xOffset, yOffset);
            roundRect.x = location.x;
            roundRect.y = location.y;
            this._pointers = null;
        }
        this._location = location;
    },
    updateMeasure: function () {
        this.calculateMeasure();

        if (this._ui.isShadowable() && this.isShadowable()) {
            twaver.Util.setCSSStyle(this._roundDiv, "text-shadow", this._ui._shadowXOffset + "px " + this._ui._shadowYOffset + "px " + this._ui._shadowBlur + "px " + this._ui._shadowColor);
        } else {
            twaver.Util.removeCSSStyle(this._roundDiv, "text-shadow");
        }

        this._pointerRect = twaver.Util.getRect(this._pointers);
        this._viewRect = twaver.Util.unionRect(this._pointerRect, this._roundRect);

        twaver.Util.setCSSStyle(this._contentDiv, "left", this._contentRect.x + "px");
        twaver.Util.setCSSStyle(this._contentDiv, "top", this._contentRect.y + "px");

        twaver.Util.setCSSStyle(this._roundDiv, "left", this._roundRect.x + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "top", this._roundRect.y + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "width", this._roundRect.width + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "height", this._roundRect.height + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "background", this.isFill() ? this.getFillColor() : null);

        twaver.Util.setCSSStyle(this._roundDiv, "-webkit-border-radius", this.getCornerRadius() + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "-moz-border-radius", this.getCornerRadius() + "px");
        twaver.Util.setCSSStyle(this._roundDiv, "border-radius", this.getCornerRadius() + "px");

        if (this._pointers) {
            twaver.Util.setCSSStyle(this._triangleDiv, "left", this._triangleDivLocation.x + "px");
            twaver.Util.setCSSStyle(this._triangleDiv, "top", this._triangleDivLocation.y + "px");
            twaver.Util.setCSSStyle(this._triangleDiv, "border-width", this._triangleBorderWidthStyle);
            twaver.Util.setCSSStyle(this._triangleDiv, "border-color", this._triangleBorderColorStyle);

            this._view.appendChild(this._triangleDiv);
        } else {
            if (this._triangleDiv.parentNode == this._view)
                this._view.removeChild(this._triangleDiv);
        }

        if (this._element.getStyle('label.rotatable') && this.label) {
            var fromLocation = this._ui.getFromPoint();
            var toLocation = this._ui.getToPoint();

            var points = this._ui.getLinkPoints();
            if (points.size() % 2 == 0) {
                fromLocation = points.get(points.size() / 2 - 1);
                toLocation = points.get(points.size() / 2);
            }

            if (fromLocation.x > toLocation.x) {
                this._radian = twaver.Util.getRadiansBetweenLines(toLocation, fromLocation);
            } else {
                this._radian = twaver.Util.getRadiansBetweenLines(fromLocation, toLocation);
            }
            this._origin = { x: this._contentRect.width / 2, y: 0 };


            var deg = "rotate(" + (twaver.Util.toDegrees(this._radian)) + "deg)";
            var origin = this._origin.x + "px " + this._origin.y + "px";
            if (twaver.Util.isChrome || twaver.Util.isSafari) {
                twaver.Util.setCSSStyle(this._roundDiv, "-webkit-transform", deg);
                twaver.Util.setCSSStyle(this._roundDiv, "-webkit-transform-origin", origin);
            } else if (twaver.Util.isIE) {
                twaver.Util.setCSSStyle(this._roundDiv, "-ms-transform", deg);
                twaver.Util.setCSSStyle(this._roundDiv, "-ms-transform-origin", origin);
            } else {
                twaver.Util.setCSSStyle(this._roundDiv, "transform", deg);
                twaver.Util.setCSSStyle(this._roundDiv, "transform-origin", origin);
            }
        } else {
            twaver.Util.removeCSSStyle(this._roundDiv, "-webkit-transform");
            twaver.Util.removeCSSStyle(this._roundDiv, "-webkit-transform-origin");

            twaver.Util.removeCSSStyle(this._roundDiv, "-ms-transform");
            twaver.Util.removeCSSStyle(this._roundDiv, "-ms-transform-origin");

            twaver.Util.removeCSSStyle(this._roundDiv, "transform");
            twaver.Util.removeCSSStyle(this._roundDiv, "transform-origin");

            delete this._origin;
            delete this._radian;
        }
    }
});
twaver.network.HTMLLabelAttachment = function(elementUI, showInAttachmentDiv) {
    twaver.network.HTMLBasicAttachment.call(this, elementUI, showInAttachmentDiv);
    this.label = true;
}

twaver.Util.ext('twaver.network.HTMLLabelAttachment', twaver.network.LabelAttachment, {
   updateMeasure: function () {
        var font = this.getFont('label.font');
        var text = this.getLabel();
        this._contentDiv.innerHTML = text;
        twaver.Util.setCSSStyle(this._contentDiv, "font", font);
        twaver.network.HTMLBasicAttachment.prototype.updateMeasure.call(this);
        twaver.Util.removeCSSStyle(this._contentDiv, "font");
    },
    calculateMeasure: twaver.network.HTMLBasicAttachment.prototype.calculateMeasure
});
twaver.network.HTMLAlarmAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.network.HTMLBasicAttachment.call(this, elementUI, showInAttachmentDiv);
    this.alarm = true;
};
twaver.Util.ext('twaver.network.HTMLAlarmAttachment', twaver.network.AlarmAttachment, {
    updateMeasure: function () {
        var font = this.getFont('alarm.font');
        this._contentDiv.innerHTML = this._network.getAlarmLabel(this._element);
        twaver.Util.setCSSStyle(this._contentDiv, "font",font);
        this._fillColor = this._network.getAlarmFillColor(this._element);
        twaver.network.HTMLBasicAttachment.prototype.updateMeasure.call(this);
        twaver.Util.removeCSSStyle(this._contentDiv, "font");
    },
    calculateMeasure: twaver.network.HTMLBasicAttachment.prototype.calculateMeasure
});
twaver.network.NodeUI = function (network, element) {
    twaver.network.NodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.NodeUI', twaver.network.ElementUI, {
    createBodyRect: function () {
        return this._element.getRect();
    },
    invalidate: function (checkAttachments) {
        twaver.network.NodeUI.superClass.invalidate.call(this, checkAttachments);
        var links = this._element.getAgentLinks();
        if (links) {
            links.forEach(function (link) {
                this._network.invalidateElementUI(link, false);
            }, this);
        }
    },
    updateMeasure: function () {
        twaver.network.NodeUI.superClass.updateMeasure.call(this);
        var shape = this.getStyle('vector.shape');
        var rect = this.getBodyRect();
        this._hotSpot = $math.getHotSpot(rect.x, rect.y, rect.width, rect.height, shape);
        this.drawBody();
        if (this._outerColor) {
            this.drawOuterBorder();
        }
        if (!this._editAttachment && this.getStyle('select.style') === 'border' && this._network.isSelected(this._element)) {
            this.drawSelectBorder();
        }
        this.cleanUp(['_selectCanvas', '_nodeCanvas', '_nodeImage', '_nodeComponent', '_vectorCanvas', '_outerCanvas']);
        var parent = this._element.getParent();
        if (parent instanceof $Group) {
            this._network.invalidateElementUI(parent, false);
        }
    },
    drawBody: function () {
        var type = this.getStyle('body.type');
        if (type === 'default') {
            this.drawDefaultBody();
        }
        else if (type === 'vector') {
            this.drawVectorBody();
        }
        else if (type === 'default.vector') {
            this.drawVectorBody();
            this.drawDefaultBody();
        }
        else if (type === 'vector.default') {
            this.drawDefaultBody();
            this.drawVectorBody();
        }else {
            this.addBodyBounds({x : this._element.getX(), y : this._element.getY(), width: 0, height: 0});
        }
    },
    drawOuterBorder: function () {
        var node = this._element;
        var lineWidth = node.getStyle('outer.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            $math.addPadding(rect, node, 'outer.padding', 1);
            if (!this._outerCanvas) {
                this._outerCanvas = $html.createCanvas();
            }
            var bounds = _twaver.clone(rect);
            $math.grow(bounds, lineWidth / 2, lineWidth / 2);
            var g = $html.setCanvas(this._outerCanvas, bounds);

            g.lineWidth = lineWidth;
            g.lineCap = node.getStyle('outer.cap');
            g.lineJoin = node.getStyle('outer.join');
            g.strokeStyle = this._outerColor;
            $g.drawVector(g, node.getStyle('outer.shape'), null, rect);
            g.stroke();
            this.addComponent(this._outerCanvas);
            this.addBodyBounds(bounds);
        }
    },
    drawSelectBorder: function () {
        var node = this._element;
        var lineWidth = node.getStyle('select.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            rect = _twaver.clone(rect);
            var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getGraphicsZoom();
            $math.addPadding(rect, node, 'select.padding', 1 / zoom);
            if (!this._selectCanvas) {
                this._selectCanvas = $html.createCanvas();
            }
            $math.grow(rect, lineWidth / 2 / zoom, lineWidth / 2 / zoom);
            var g = $html.setCanvas(this._selectCanvas, bounds);

            g.lineWidth = lineWidth / zoom;
            g.lineCap = node.getStyle('select.cap');
            g.lineJoin = node.getStyle('select.join');
            g.strokeStyle = node.getStyle('select.color');
            $g.drawVector(g, node.getStyle('select.shape'), null, rect);
            g.stroke();
            this.addComponent(this._selectCanvas);
            this.addBodyBounds(bounds);
        }
    },
    drawDefaultBody: function () {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        if (!imageAsset) {
            this.addBodyBounds(rect);
            this._currentImageAsset = null;
            return;
        }
        $math.addPadding(rect, this._element, 'image.padding', 1);

        if (imageAsset.getImage()) {
            if (!this._nodeCanvas) {
                this._nodeCanvas = $html.createCanvas();
            }
            var bounds = _twaver.clone(rect);
            var g = this.setShadow(this, this._nodeCanvas, bounds);
            if(node.getAngle() != 0) {
                rect = node.getOriginalRect();
                twaver.Util.rotateCanvas(g, rect, node.getAngle());
            }
            drawImage(g, node.getImage(), this.getInnerColor(), rect, node, this._network);
            rect = bounds;
            this.addComponent(this._nodeCanvas);
        }
        else if (imageAsset.getSrc()) {
            if (!this._nodeImage) {
                this._nodeImage = $html.createImg();
            }
            $html.setImg(this._nodeImage, imageAsset.getSrc(), rect);
            this.addComponent(this._nodeImage);
        }
        else if (imageAsset.getFunction()) {
            if (this._currentImageAsset !== imageAsset) {
                this._nodeComponent = imageAsset.getFunction()(this, rect);
            } else {
                this._nodeComponent = imageAsset.getFunction()(this, rect, this._nodeComponent);
            }
            this.addComponent(this._nodeComponent);
            this._nodeComponent._viewRect = _twaver.clone(rect);
        }
        else {
            throw "ImageAsset '" + node.getImage() + " ' is empty";
        }
        this.addBodyBounds(rect);
        this._currentImageAsset = imageAsset;
    },
    hit: function (x, y) {
        if (this._network._transparentSelectionEnable) {
            var bodyRect = this.getBodyRect();
            if (_twaver.math.containsPoint(bodyRect, x, y)) {
                return true;
            }
        }
        if (this.hitCanvas(x, y, ['_nodeCanvas', '_outerCanvas', '_vectorCanvas'])) {
            return true;
        }
        return this.hitComponent(x, y, ['_nodeImage', '_nodeComponent']);
    },
    intersects: function (rect) {
        if (this._network._transparentSelectionEnable) {
            var bodyRect = this.getBodyRect();
            if (_twaver.math.intersects(bodyRect, rect)) {
                return true;
            }
        }
        if (this.intersectsCanvas(rect, ['_nodeCanvas', '_outerCanvas', '_vectorCanvas'])) {
            return true;
        }
        return this.intersectsComponent(rect, ['_nodeImage', '_nodeComponent']);
    },
    drawVectorBody: function () {
        if (!this._vectorCanvas) {
            this._vectorCanvas = $html.createCanvas();
        }
        var bounds = $g.drawPath(this, this._vectorCanvas, 'vector', true, this._element.getStyle('vector.outline.pattern'));

        var deep = this.getStyle('vector.deep');
        var g = this._vectorCanvas.getContext('2d');
        var rect = this.getBodyRect();
        var fillColor = this.getStyle('vector.fill.color');
        if (deep !== 0 && fillColor) {
            var angle = this._element.getAngle();
            if(angle != 0) {
                rect = this._element.getOriginalRect();
                twaver.Util.rotateCanvas(g, rect, -angle);
                twaver.Util.rotateCanvas(g, rect, angle);
            }
            if (this.getStyle('vector.shape') === 'rectangle') {
                $g.draw3DRect(g, fillColor, deep, rect);
            }
        }

        this.addBodyBounds(bounds);
        this.addComponent(this._vectorCanvas);
    }
});

twaver.network.LinkUI = function (network, element) {
    twaver.network.LinkUI.superClass.constructor.call(this, network, element);
    this._linkCanvas = $html.createCanvas();
};
_twaver.ext('twaver.network.LinkUI', twaver.network.ElementUI, {
    isEditable: function () {
        if ($link.isOrthogonalLink(this._element) && this.getControlPoint()) {
            return true;
        }
        return false;
    },
    createBodyRect: function () {
        var h = this.getHotSpot();
        if (h) {
            return { x: h.x - 1, y: h.y - 1, width: 2, height: 2 };
        }
        return null;
    },
    hit: function (x, y) {
        return this.hitCanvas(x, y, ['_linkCanvas']);
    },
    intersects: function (rect) {
        return this.intersectsCanvas(rect, ['_linkCanvas']);
    },
    checkAttachments: function () {
        twaver.network.LinkUI.superClass.checkAttachments.call(this);
        this.checkLinkHandlerAttachment();
    },
    checkLinkHandlerAttachment: function () {
        var label = this._network.getLinkHandlerLabel(this._element);
        if (label != null && label !== '') {
            if (!this._linkHandlerAttachment) {
                this._linkHandlerAttachment = new twaver.network.LinkHandlerAttachment(this);
                this.addAttachment(this._linkHandlerAttachment);
            }
        } else {
            if (this._linkHandlerAttachment) {
                this.removeAttachment(this._linkHandlerAttachment);
                this._linkHandlerAttachment = null;
            }
        }
    },
    getLinkHandlerAttachment: function () {
        return this._linkHandlerAttachment;
    },
    getLinkPoints: function () {
        if (!this._linkPoints) {
            this._linkPoints = this.createLinkPoints();
            this._lineLength = $math.calculateLineLength(this._linkPoints);
        }
        return this._linkPoints;
    },
    invalidate: function (checkAttachments) {
        this._linkPoints = null;
        this._fromPoint = null;
        this._toPoint = null;
        twaver.network.LinkUI.superClass.invalidate.call(this, checkAttachments);
    },
    getFromPosition: function (xoffset, yoffset) {
        var point = this.getFromPoint();
        if (point) {
            return { x: point.x + xoffset, y: point.y + yoffset };
        }
        return null;
    },
    getToPosition: function (xoffset, yoffset) {
        var point = this.getToPoint();
        if (point) {
            return { x: point.x + xoffset, y: point.y + yoffset };
        }
        return null;
    },
    getFromPoint: function () {
        if (!this._fromPoint) {
            this._fromPoint = $link.createFromPoint(this);
        }
        return this._fromPoint;
    },
    getToPoint: function () {
        if (!this._toPoint) {
            this._toPoint = $link.createToPoint(this);
        }
        return this._toPoint;
    },
    updateMeasure: function () {
        twaver.network.LinkUI.superClass.updateMeasure.call(this);
        this.drawBody();
    },
    createLinkPoints: function () {
        var fromPoint = this.getFromPoint();
        var toPoint = this.getToPoint();
        var type = this.getStyle('link.type');
        var points = new $List();

        if ($link.isOrthogonalOrFlexionalLink(this._element)) {
            points = $link.orthogonalAndFlexional(this, type);
        } else {
            if (this._element.isLooped()) {
                var nodeUI = this._network.getElementUI(this._element.getFromAgent());
                if (nodeUI != null) {
                    this._hotSpot = $link.fillLoopedPoints(this, nodeUI.getBodyRect(), points);
                }
            } else if (type === 'arc' || type === 'triangle' || type === 'parallel') {
                this._hotSpot = $link.fillBundlePoints(this, type, fromPoint, toPoint, points);
            } else {
                throw "Can not resolve link type '" + type + "'";
            }
        }
        if (this._network._linkPathFunction) {
            var result = this._network._linkPathFunction(this, points);
            result && (points = result);
        }
        return points;
    },
    drawLinePoints: function (g, points, width, color, pattern) {
        g.lineWidth = width;
        g.strokeStyle = color;
        if (this._element.getStyle("link.flow") === true && pattern && pattern.length > 1) {
            var dashedLine = new $DashedLine(g, pattern[0], pattern[1]);
            var offset = this._element.getStyle("link.flow.offset");
            if (this._element.getStyle("link.flow.converse")) {
                if (offset < pattern[0]) {
                    dashedLine.overflow = pattern[0] - offset;
                } else if (offset >= pattern[0] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = pattern[1] - (offset - pattern[0]);
                    if (dashedLine.overflow) { dashedLine.isLine = false };
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    dashedLine.overflow = pattern[0] - offset;
                }
            } else {
                if (offset <= pattern[1]) {
                    dashedLine.overflow = offset;
                    if (offset) dashedLine.isLine = false;
                } else if (offset > pattern[1] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = offset - pattern[1];
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    if (offset) { dashedLine.isLine = false };
                    dashedLine.overflow = offset;
                }
            }

            this._element._styleMap["link.flow.offset"] = offset;
            g.beginPath();
            $g._drawLine(points, g);
            g.stroke();

            g.shadowColor = 'transparent';
            g.beginPath();
            var linkFlowColor = this._element.getStyle("link.flow.color");
            linkFlowColor = linkFlowColor ? linkFlowColor : $Defaults.NETWORK_LINK_FLOW_COLOR;
            g.strokeStyle = linkFlowColor;
            $g._drawLine(points, dashedLine);
            g.stroke();
            g.shadowColor = this._shadowColor;
        } else {
            g.beginPath();
            $g.drawLinePoints(g, points, pattern);
            g.stroke();
        }
    },
    drawBody: function () {
        var points = this.getLinkPoints();
        if (!points || points.size() < 2) {
            return;
        }
        var link = this._element;
        var bounds = $math.getLineRect(points);

        var width = link.getStyle('link.width');
        var grow = width;
        if (this._outerColor) {
            var outerWidth = link.getStyle('outer.width');
            grow += outerWidth * 2;
        }
        var selectBorder = !this._editAttachment && link.getStyle('select.style') === 'border' && this._network.isSelected(this._element);
        if (selectBorder) {
            var selectWidth = link.getStyle('select.width');
            grow += selectWidth * 2;
        }
        $math.grow(bounds, grow / 2, grow / 2);

        if (link.getStyle('arrow.from')) {
            bounds = $math.unionRect(bounds,
                $arrow.getArrowRect(points, true,
                    link.getStyle('arrow.from.shape'),
                    link.getStyle('arrow.from.width'),
                    link.getStyle('arrow.from.height'),
                    link.getStyle('arrow.from.xoffset'),
                    link.getStyle('arrow.from.yoffset')
                ));
        }
        if (link.getStyle('arrow.to')) {
            bounds = $math.unionRect(bounds,
                $arrow.getArrowRect(points, false,
                    link.getStyle('arrow.to.shape'),
                    link.getStyle('arrow.to.width'),
                    link.getStyle('arrow.to.height'),
                    link.getStyle('arrow.to.xoffset'),
                    link.getStyle('arrow.to.yoffset')
                ));
        }

        var g = this.setShadow(this, this._linkCanvas, bounds);
        g.lineCap = link.getStyle('link.cap');
        g.lineJoin = link.getStyle('link.join');
        var pattern = link.getStyle('link.pattern');
        if (selectBorder) {
            this.drawLinePoints(g, points, grow, link.getStyle('select.color'), pattern);
        }
        if (this._outerColor) {
            this.drawLinePoints(g, points, width + outerWidth * 2, this._outerColor, pattern);
        }
        this.drawLinePoints(g, points, width, this._innerColor || link.getStyle('link.color'), pattern);

        this.addBodyBounds(bounds);
        this.addComponent(this._linkCanvas);

        $arrow.drawLinkArrow(this, g, points);
    },
    getControlPoint: function () {
        return $link.getControlPoint(this._element, this);
    },
    setControlPoint: function (point) {
        if (!point) {
            return;
        }
        var linkType = this.getStyle('link.type');
        if (!$link.hasControlPoint(linkType)) {
            return;
        }
        var sourceBounds = $link.getLinkSourceBounds(this);
        var targetBounds = $link.getLinkTargetBounds(this);
        $link.setParamsByControlPoint(point, sourceBounds, targetBounds, linkType, this._element);
    },
    getLineLength: function () {
        return this._lineLength;
    }
});

twaver.network.HTMLLinkUI = function (network, element) {
	twaver.network.HTMLLinkUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.HTMLLinkUI', twaver.network.LinkUI, {
	checkAttachments: function () {
		twaver.network.LinkUI.prototype.checkAttachments.call(this);
	},
	checkLabelAttachment: function () {
		var style = this._element.getStyle('attachment.label.style');
        if(style && style === 'none'){
            twaver.network.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            return;
        }

		var label = this._network.getLabel(this._element);
		if (label != null && label !== "") {
			if (!this._labelAttachment) {
				this._labelAttachment = new twaver.network.HTMLLabelAttachment(this);
				this.addAttachment(this._labelAttachment);
			}
		} else {
			if (this._labelAttachment) {
				this.removeAttachment(this._labelAttachment);
				this._labelAttachment = null;
			}
		}
	},
	checkAlarmAttachment: function () {
		var style = this._element.getStyle('attachment.alarm.style');
        if(style && style === 'none'){
            twaver.network.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

		var label = this._network.getAlarmLabel(this._element);
		if (label != null && label !== "") {
			if (!this._alarmAttachment) {
				this._alarmAttachment = new twaver.network.HTMLAlarmAttachment(this, false);
				this.addAttachment(this._alarmAttachment);
			}
		} else {
			if (this._alarmAttachment) {
				this.removeAttachment(this._alarmAttachment);
				this._alarmAttachment = null;
			}
		}
	}
});

twaver.network.GroupUI = function (network, element) {
    twaver.network.GroupUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.GroupUI', twaver.network.NodeUI, {
    isEditable: function () {
        return !this._element.isExpanded();
    },
    drawBody: function () {
        var bodyRect = this.getBodyRect();
        if (this._shapeRect) {
            this.drawExpandedGroup();
        } else {
            twaver.network.GroupUI.superClass.drawBody.call(this);
        }
    },
    drawExpandedGroup: function () {
        if (!this._nodeCanvas) {
            this._nodeCanvas = $html.createCanvas();
        }
        var bounds = $g.drawPath(this, this._nodeCanvas, 'group', false, this._element.getStyle('vector.outline.pattern'));
        var deep = this.getStyle('group.deep');
        var fillColor = this.getStyle('group.fill.color');
        if (deep !== 0 && fillColor) {
            if (this.getStyle('group.shape') === 'rectangle') {
                $g.draw3DRect(this._nodeCanvas.getContext('2d'), fillColor, deep, this._bodyRect);
            }
        }
        this.addBodyBounds(bounds);
        this.addComponent(this._nodeCanvas);
    },
    getChildrenRects: function () {
        return this._network.getGroupChildrenRects(this._element);
    },
    createBodyRect: function () {
        this._shapeRect = null;
        var group = this._element;
        if (group.isExpanded()) {
            var rects = this.getChildrenRects();
            if (!rects.isEmpty()) {
                var shape = group.getStyle('group.shape');
                var func = $group[shape];
                if (!func) {
                    throw "Can not resolve group shape '" + shape + "'";
                }
                this._shapeRect = func(rects);
            }
        }
        if (this._shapeRect) {
            $math.addPadding(this._shapeRect, group, 'group.padding', 1);
            return this._shapeRect;
        } else {
            return twaver.network.GroupUI.superClass.createBodyRect.call(this);
        }
    }
});

twaver.network.GridUI = function (network, element) {
    twaver.network.GridUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.GridUI', twaver.network.NodeUI, {
    drawDefaultBody: function () {
        if (this._element.getImage()) {
            twaver.network.GridUI.superClass.drawDefaultBody.call(this);
        } else {
            this.drawGridBody();
        }
    },
    drawGridBody: function () {
        var fill = this.getStyle('grid.fill');
        var gridDeep = this.getStyle('grid.deep');
        var cellDeep = this.getStyle('grid.cell.deep');

        if (!fill && gridDeep === 0 && cellDeep === 0) {
            return;
        }
        var bodyRect = this.getBodyRect();
        var fillColor = this.getDyeColor('grid.fill.color');
        if (!this._nodeCanvas) {
            this._nodeCanvas = $html.createCanvas();
        }
        var bounds = _twaver.clone(bodyRect);
        var g = this.setShadow(this, this._nodeCanvas, bounds);
        g.rect(bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
        this.addComponent(this._nodeCanvas);
        // draw body
        if (fill) {
            g.fillStyle = fillColor;
            g.fill();
        }
        // draw border deep
        if (gridDeep != 0) {
            $g.draw3DRect(g, fillColor, gridDeep, bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
        }
        // draw cell deep
        if (cellDeep != 0) {
            var row = this.getStyle('grid.row.count');
            var col = this.getStyle('grid.column.count');
            for (var r = 0; r < row; r++) {
                for (var c = 0; c < col; c++) {
                    var rect = this._element.getCellRect(r, c);
                    if (rect != null) {
                        $g.draw3DRect(g, fillColor, cellDeep, rect.x, rect.y, rect.width, rect.height);
                    }
                }
            }
        }
        this.addBodyBounds(bounds);
    }
});

twaver.network.ShapeNodeUI = function (network, element) {
    twaver.network.ShapeNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.ShapeNodeUI', twaver.network.NodeUI, {
    drawDefaultBody: function () {
        if (this._element._points.size() < 2) {
            this.addBodyBounds({x: this._element.getX(), y: this._element.getY(), width: 0, height: 0});
            return;
        }
        if (!this._nodeCanvas) {
            this._nodeCanvas = $html.createCanvas();
        }

        var bounds = $g.drawPath(this, this._nodeCanvas, 'vector', true, this._element.getStyle('vector.outline.pattern'),
            this._element._points, this._element._segments, this._element.getStyle('shapenode.closed'));
        this.addBodyBounds(bounds);
        this.addComponent(this._nodeCanvas);

        $arrow.drawLinkArrow(this, this._nodeCanvas.getContext('2d'), $math.getPointObject(this._element._points, this._element._segments));
    },
    drawSelectBorder: function () {
        var node = this._element;
        var lineWidth = node.getStyle('select.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            rect = _twaver.clone(rect);
            var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getGraphicsZoom();

            $math.addPadding(rect, node, 'select.padding', 1 / zoom);
            var outlineWidth = node.getStyle('vector.outline.width');
            if (outlineWidth > 0) {
                $math.grow(rect, outlineWidth / 2, outlineWidth / 2);
            }
            if (!this._selectCanvas) {
                this._selectCanvas = $html.createCanvas();
            }

            $math.grow(rect, lineWidth / 2 / zoom, lineWidth / 2 / zoom);
            var g = $html.setCanvas(this._selectCanvas, rect);

            g.lineWidth = lineWidth / zoom;
            g.lineCap = node.getStyle('select.cap');
            g.lineJoin = node.getStyle('select.join');
            g.strokeStyle = node.getStyle('select.color');
            $g.drawVector(g, node.getStyle('select.shape'), null, rect);
            g.stroke();
            this.addComponent(this._selectCanvas);
            this.addBodyBounds(bounds);
        }
    }
});

twaver.network.ShapeLinkUI = function (network, element) {
    twaver.network.ShapeLinkUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.ShapeLinkUI', twaver.network.LinkUI, {
    isEditable: function () {
        return true;
    },
    createLinkPoints: function () {
        var fromPoint = this.getFromPoint();
        var toPoint = this.getToPoint();
        var points = new $List();
        var type = this.getStyle('shapelink.type');

        points.add(fromPoint);
        if (this._element._points != null) {
            points.addAll(this._element._points);
        }
        points.add(toPoint);
        var pointCount = points.size();
        var half = Math.floor(pointCount / 2);
        if (pointCount % 2 === 0) {
            var p1 = points.get(half);
            var p2 = points.get(half - 1);
            this._hotSpot = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        } else {
            this._hotSpot = _twaver.clone(points.get(half));
        }

        var result, i, lastPoint;
        if (type === 'lineto') {
            //Do Nonthing
        } else if (type === 'quadto') {
            result = new $List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    result.add(new $List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'cubicto') {
            result = new $List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 2) {
                    result.add(new $List([points.get(i++), points.get(i++), points.get(i)]));
                } else if (i < pointCount - 1) {
                    result.add(new $List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'orthogonalto') {
            lastPoint = points.get(0);
            result = new $List(lastPoint);
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    var point = _twaver.clone(points.get(i));
                    var x = point.x;
                    var y = point.y;
                    var dx = x - lastPoint.x;
                    var dy = y - lastPoint.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        point.x = x;
                        point.y = lastPoint.y;
                    } else {
                        point.x = lastPoint.x;
                        point.y = y;
                    }
                    lastPoint = point;
                    result.add(lastPoint);
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else {
            throw "Can not resolve shapelink type '" + type + "'";
        }
        return points;
    }
});

twaver.network.RotatableNodeUI = function (network, element) {
    twaver.network.RotatableNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.network.RotatableNodeUI', twaver.network.NodeUI, {
    isEditable: function () {
        return false;
    },
    drawDefaultBody: function () {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        if (!imageAsset) {
            this.addBodyBounds(rect);
            this._currentImageAsset = null;
            return;
        }
        $math.addPadding(rect, this._element, 'image.padding', 1);

        if (imageAsset.getImage()) {
            if (!this._nodeCanvas) {
                this._nodeCanvas = $html.createCanvas();
            }
            var bounds = _twaver.clone(rect);
            var g = this.setShadow(this, this._nodeCanvas, bounds);

            var ow = this._element._getOrignalWidth(),
            	oh = this._element._getOrignalHeight(),
				rotateRect = this._element._getRotateRect();

            g.save();
            g.translate(rect.x - rotateRect.x + ow / 2, rect.y - rotateRect.y + oh / 2);
            g.rotate(this._element._angle * Math.PI / 180);
            var rect = {x: -ow/2, y:  -oh / 2, width: ow, height: oh}
            drawImage(g, imageAsset.getImage(this._innerColor, rect.width, rect.height), this._innerColor, rect, node, this._network);
            g.restore();
            this.addComponent(this._nodeCanvas);
        }
        else if (imageAsset.getSrc()) {
        }
        else if (imageAsset.getFunction()) {
        }
        else {
            throw "ImageAsset '" + node.getImage() + " ' is empty";
        }
        this.addBodyBounds(rect);
        this._currentImageAsset = imageAsset;
    }
});

twaver.network.HTMLNodeUI  = function (network, element) {
    twaver.network.HTMLNodeUI.superClass.constructor.call(this, network, element);
}
twaver.Util.ext('twaver.network.HTMLNodeUI', twaver.network.NodeUI, {
    checkAttachments: function () {
        twaver.network.NodeUI.prototype.checkAttachments.call(this);
    },

    checkLabelAttachment: function () {
        var style = this._element.getStyle('attachment.label.style');
        if(style && style === 'none'){
            twaver.network.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            return;
        }

        var label = this._network.getLabel(this._element);
        if (label != null && label !== "") {
            if (!this._labelAttachment) {
                this._labelAttachment = new twaver.network.HTMLLabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._labelAttachment);
            }
        } else {
            if (this._labelAttachment) {
                this.removeAttachment(this._labelAttachment);
                this._labelAttachment = null;
            }
        }
    },

    checkAlarmAttachment: function () {
        var style = this._element.getStyle('attachment.alarm.style');
        if(style && style === 'none'){
            twaver.network.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

        var label = this._network.getAlarmLabel(this._element);
        if (label != null && label !== "") {
            if (!this._alarmAttachment) {
                this._alarmAttachment = new twaver.network.HTMLAlarmAttachment(this, false);
                this.addAttachment(this._alarmAttachment);
            }
        } else {
            if (this._alarmAttachment) {
                this.removeAttachment(this._alarmAttachment);
                this._alarmAttachment = null;
            }
        }
    },
});
twaver.network.interaction.BaseInteraction = function (network) {
    this.network = network;
};
_twaver.ext('twaver.network.interaction.BaseInteraction', Object, {
    setUp: function () {

    },
    tearDown: function () {

    },
    addListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            var type = arguments[i];
            $html.addEventListener(type, 'handle_' + type, this.network.getView(), this);
        }
    },
    removeListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            $html.removeEventListener(arguments[i], this.network.getView(), this);
        }
    },
    _handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        this._startLogical = this.network.getLogicalPoint(e);
        this._startClient = $html.getClientPoint(e);
        if (this._startLogical) {
            $html.handle_mousedown(this, e);
        }
    },
    _handle_mousemove: function (e) {
        this._endLogical = {
            x: this._startLogical.x + (e.clientX - this._startClient.x) / this.network.getZoom(),
            y: this._startLogical.y + (e.clientY - this._startClient.y) / this.network.getZoom()
        };
    },
    _handle_mouseup: function (e) {
        delete this._startClient;
        delete this._startLogical;
        delete this._endLogical;
    }
});

twaver.network.interaction.SelectInteraction = function (network) {
    twaver.network.interaction.SelectInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.SelectInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
    },
    tearDown: function () {
        this.removeListener('mousedown');
        this.end();
    },
    handle_mousedown: function (e) {
        this._button = e.button;
        if (!this.network.isValidEvent(e) || this.network.isMovingElement() || this.network.isEditingElement()) {
            return;
        }
        if (e.shiftKey) {
            return;
        }
        var element = this.network.getElementAt(e);
        var sm = this.network.getSelectionModel();
        if (element) {
            if (_twaver.isCtrlDown(e)) {
                if (sm.contains(element)) {
                    sm.removeSelection(element);
                } else {
                    sm.appendSelection(element);
                }
            } else {
                if (!sm.contains(element)) {
                    sm.setSelection(element);
                }
            }
        } else {
            if (!_twaver.isCtrlDown(e)) {
                sm.clearSelection();
            }
            this.end(e);
            if (this.network.getLogicalPoint(e) && this.network.isRectSelectEnabled()) {
                this._handle_mousedown(e);
            }
        }
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (this._button !== 0 || this.network.isMovingElement() || this.network.isEditingElement()) {
            this.end(e);
            return;
        }
        this._handle_mousemove(e);
        if (this.mark) {
            this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
        } else {
            this.mark = $html.createDiv();
            this.network.getTopDiv().appendChild(this.mark);
            this.network.setSelectingElement(true);
            this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
        }
        var rect = $math.getRect([this._startLogical, this._endLogical]);
        $html.setDiv(this.mark, rect,
            this.getIntersectMode() ? this.network.getSelectFillColor() : null,
            this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor());

    },
    end: function (e) {
        if (this._startLogical) {
            if (this.mark) {
                if (this._endLogical && this._startLogical.x !== this._endLogical.x && this._startLogical.y !== this._endLogical.y) {
                    var elements = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
                    if (elements && elements.size() > 0) {
                        var sm = this.network.getSelectionModel();
                        var selections = sm.toSelection();
                        elements.forEach(function (element) {
                            if (sm.contains(element)) {
                                selections.remove(element);
                            } else {
                                selections.add(element);
                            }
                        }, this);
                        sm.setSelection(selections);
                    }
                    this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
                }
                var self = this;
                setTimeout(function () {
                    if (self.mark) {
                        self.network.getTopDiv().removeChild(self.mark);
                        self.mark = null;
                    }
                }, 0);
                this.network.setSelectingElement(false);
            }
            this._handle_mouseup(e);
        }
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startLogical.x > this._endLogical.x && this._startLogical.y > this._endLogical.y;
    }
});

twaver.network.interaction.MoveInteraction = function(network, lazyMode) {
	this.lazyMode = lazyMode;
	this.xoffset = 0;
	this.yoffset = 0;
	twaver.network.interaction.MoveInteraction.superClass.constructor.call( this, network);
	this.currentKeyEvent = null;
};
_twaver.ext('twaver.network.interaction.MoveInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'keydown','mouseleave');
    },
    tearDown: function () {
        this.removeListener('mousedown', 'keydown','mouseleave');
        this.end();
    },

    handle_keydown: function (e) {
        this.currentKeyEvent = e;
        this.addListener('keyup');
    },

    handle_keyup: function (e) {
        this.currentKeyEvent = null;
        this.removeListener('keyup');
    },
    handle_mouseleave : function(e) {
        this.end(e);
    },
    isParenting: function () {
        return this._startLogical && this.currentKeyEvent != null
				&& this.currentKeyEvent.keyCode === 80;
    },

    parentProcess: function (e, released) {
        var rect = null;
        if (this.parent != null) {
            rect = this.network.getElementUI(this.parent).getViewRect();
            this.parent = null;
        }
        var self = this;
        e = this.network.getLogicalPoint(e);

        if (!released && this.isParenting()) {
            var hitRect = {};
            hitRect.x = e.x - 1;
            hitRect.y = e.y - 1;
            hitRect.width = 2;
            hitRect.height = 2;

            var elements = this.network
					.getElementsAtRect(hitRect, true);
            if (elements && elements.size() > 0) {
                var size = elements.size();
                for (var i = 0; i < size; i++) {
                    var element = elements.get(i);
                    if (!self.network.getElementBox()
							.getSelectionModel().contains(element)) {
                        self.parent = element;
                        break;
                    }
                }
            }

        }
        if (this.parent != null) {
            rect = this.network.getElementUI(this.parent).getViewRect();
        }
        if (rect != null && !released) {
            if (!this.parentMark) {
                this.parentMark = _twaver.html.createDiv();
                this.network.getTopDiv().appendChild(this.parentMark);
            }
            _twaver.html.setDiv(this.parentMark, rect, this.network
							.isLazyMoveFill() ? this.network
							.getLazyMoveFillColor() : null,
					this.network.getLazyMoveOutlineWidth(),
					this.network.getLazyMoveOutlineColor());
        } else {
            if (this.parentMark) {
                this.network.getTopDiv().removeChild(this.parentMark);
                this.parentMark = null;
            }
        }
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.network.isSelectingElement()
				|| this.network.isEditingElement()) {
            return;
        }
        var element = this.network.getElementAt(e);
        if (!this.network.isMovable(element)) {
            return;
        }
        this.end(e);
        this._handle_mousedown(e);
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (this.network.isSelectingElement()
				|| this.network.isEditingElement()
				|| !this.network.hasMovableSelectedElements()
				|| !this._startLogical) {
            this.end(e);
            return;
        }
        this._handle_mousemove(e);

        this.xoffset = this._endLogical.x - this._startLogical.x;
        this.yoffset = this._endLogical.y - this._startLogical.y;

        if (this.lazyMode) {
            if (this.mark) {
                this.network.fireInteractionEvent({
                    kind: 'lazyMoveBetween',
                    event: e
                });
            } else {
                this.mark = $html.createDiv();

                var rect;
                this.network.getMovableSelectedElements().forEach(
						function (element) {
						    var ui = this.getElementUI(element);
						    if (ui) {
						        rect = $math.unionRect(rect, ui
												.getViewRect());
						    }
						}, this.network);

                this.network.getTopDiv().appendChild(this.mark);
                this.network.setMovingElement(true);

                $html.setDiv(this.mark, rect, this.network
								.isLazyMoveFill() ? this.network
								.getLazyMoveFillColor() : null,
						this.network.getLazyMoveOutlineWidth(),
						this.network.getLazyMoveOutlineColor());

                this.network.fireInteractionEvent({
                    kind: 'lazyMoveStart',
                    event: e
                });
            }
            this.mark.style.left = this.xoffset + this.mark._viewRect.x
					+ "px";
            this.mark.style.top = this.yoffset + this.mark._viewRect.y
					+ "px";
        } else {
            this._startLogical = this._endLogical;
            this._startClient = $html.getClientPoint(e);
            if (this.network.isMovingElement()) {
                this.network.fireInteractionEvent({
                    kind: 'liveMoveBetween',
                    event: e
                });
            } else {
                this.network.setMovingElement(true);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveStart',
                    event: e
                });
            }
            this.network.moveSelectedElements(this.xoffset, this.yoffset);
        }
        this.parentProcess(e, false);
    },
    end: function (e) {
        if (this._startLogical) {
            if (this.lazyMode) {
                if (this.mark) {
                    var self = this;
                    var f = function () {
                        self.network.fireInteractionEvent({
                            kind: 'lazyMoveEnd',
                            event: e
                        });
                        if (self.mark) {
                            self.network.getTopDiv()
									.removeChild(self.mark);
                            self.mark = null;
                            self.network.setMovingElement(false);
                        }
                    };
                    this.network.moveSelectedElements(this.xoffset,
							this.yoffset, this.network
									.isLazyMoveAnimate(), f);
                }
            } else {
                if (this.network.isMovingElement()) {
                    this.network.setMovingElement(false);
                    this.network.fireInteractionEvent({
                        kind: 'liveMoveEnd',
                        event: e
                    });

                }
            }
            if (this.isParenting()) {
                if (this.parent == null) {
                    this.parent = this.network.getCurrentSubNetwork();
                }
                var self = this;
                this.network.getMovableSelectedElements().forEach(
							function (element) {
							    element.setParent(self.parent);
							}, this.network);
            }
            this.parentProcess(e, true)
            this._handle_mouseup(e);
        }
    }
});

twaver.network.interaction.DefaultInteraction = function (network) {
    twaver.network.interaction.DefaultInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.DefaultInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove', 'keydown');
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove', 'keydown');
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if (this.network.isFocusOnClick()) {
            twaver.Util.setFocus(this.network.getView());
        }
        var element = this.network.getElementAt(e);
        if (e.detail === 2) {
            this.handleDoubleClicked(e, element);
        } else {
            this.handleClicked(e, element);
        }
    },
    handleClicked: function (e, element) {
        $network_interaction.handleClicked(this.network, e, element);
    },
    handleDoubleClicked: function (e, element) {
        $network_interaction.handleDoubleClicked(this.network, e, element);
    },
    handle_keydown: function (e) {
        $network_interaction.handleKeyDown(this.network, e);
    },
    handle_mousemove: function (e) {
        var element = this.network.getElementAt(e),
            preElement = this._preElement,
            preImage = _getElementImage(preElement),
            image = _getElementImage(element);
        if (preElement !== element) {
            if (preElement) {
                preImage && preImage.onMouseLeave && preImage.onMouseLeave(preElement, this.network);
                this.network.onMouseLeave(preElement, e);
            }
            if (element) {
                image && image.onMouseEnter && image.onMouseEnter(element, this.network);
                this.network.onMouseEnter(element, e);
            }
        }
        element && image && image.onMouseMove && image.onMouseMove(element, this.network);
        this.network.onMouseMove(element, e);
        this._preElement = element;
    }
});

twaver.network.interaction.PanInteraction = function (network) {
    twaver.network.interaction.PanInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.PanInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
        this._oldCursor = this.network.getView().style.cursor;
    },
    tearDown: function () {
        this.removeListener('mousedown');
    },
    handle_mousedown: function (e) {
        this._startLogical = this.network.getLogicalPoint(e);
        if (this._startLogical) {
            this._handle_mousedown(e);
            this.network.getView().style.cursor = 'pointer';
        }
    },
    handle_mouseup: function (e) {
        this._clear();
    },
    handle_mousemove: function (e) {
        if (!this._startLogical) {
            return;
        }
        this._handle_mousemove(e);
        var xoffset = this._startLogical.x - this._endLogical.x;
        var yoffset = this._startLogical.y - this._endLogical.y;
        var result = this.network.panByOffset(xoffset, yoffset);
        this._startLogical = this._endLogical;
        this._startClient = $html.getClientPoint(e);
    },
    _clear: function (e) {
        if (this._startLogical) {
            this._handle_mouseup(e);
            this.network.getView().style.cursor = this._oldCursor;
        }
    }
});

twaver.network.interaction.EditInteraction = function (network, lazyMode) {
    this.lazyMode = lazyMode;
    this.pointIndex = -1;
    twaver.network.interaction.EditInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.EditInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove');
        this.oldCursor = this.network.getView().style.cursor;
        this.network.setHasEditInteraction(true);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove');
        this.network.getView().style.cursor = this.oldCursor;
        this.network.setHasEditInteraction(false);
        this.clear();
    },
    clear: function () {
        this.network.setEditingElement(false);
        this.network.setRotatingElement(false);
        this.isStart = false;
        this.isStartRotate = false;
        this.node = null;
        this.shapeNode = null;
        this.shapeLink = null;
        this.linkUI = null;
        this.resizingRect = null;
        this.resizeDirection = null;
        this.pointIndex = -1;
        this._removeCursor();
        this.oldCursor = null;
        this.mouseMoved = false;
        this.horizontal = false;
        this.vertical = false;
        if (this.mark) {
            this.network.getTopDiv().removeChild(this.mark);
            this.mark = null;
        }
        if(this.rotateScale) {
            if(this.network.getTopDiv().contains(this.rotateScale)) {
                this.network.getTopDiv().removeChild(this.rotateScale);
                this.rotateScale = null;
            }
        }
    },
    _removeCursor: function () {
        if (this.cursorID) {
            this.network.getView().style.cursor = this.oldCursor || 'default';
            this.cursorID = null;
        }
        this.resizeDirection = null;
        this.isCrossCursor = false;
    },
    _setCrossCursor: function () {
        if (!this.isCrossCursor) {
            this._removeCursor();
            this._setCursor("crosshair");
            this.isCrossCursor = true;
        }
    },
    _setCursor: function (cursorID) {
        this.cursorID = cursorID;
        if (this.network.getView().style.cursor !== this.cursorID) {
            this.network.getView().style.cursor = this.cursorID;
        }
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (_twaver.isAltDown(e) && !this.network.isEditingElement()) {
            var element = this.network.getElementAt(e);
            var point = this.network.getLogicalPoint(e);
            if (element instanceof twaver.ShapeNode) {
                var pointIndex = this.getPointIndex(element.getPoints(), point, true);
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeNode = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            if (element instanceof twaver.ShapeLink) {
                var points = new twaver.List(element.getPoints());
                var shapeLinkUI = this.network.getElementUI(element);
                points.add(shapeLinkUI.getFromPoint(), 0);
                points.add(shapeLinkUI.getToPoint());
                var pointIndex = this.getPointIndex(points, point) - 1;
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeLink = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazeMovePointStart' : 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            return;
        }
        if (!this.network.isEditingElement()  || this.isStart || this.isStartRotate) {
            return;
        }
        if (this.node && this.resizeDirection) {
            this.isStart = true;
            this._handle_mousedown(e);
            this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyResizeStart' : 'liveResizeStart', event: e, element: this.node, resizeDirection: this.resizeDirection });
        } else if (this.shapeNode && this.pointIndex >= 0) {
            if (_twaver.isAltDown(e)) {
                this.shapeNode.removeAt(this.pointIndex);
                this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeNode });
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyMovePointStart' : 'liveMovePointStart', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            }
        } else if (this.shapeLink && this.pointIndex >= 0) {
            if (_twaver.isAltDown(e)) {
                this.shapeLink.removeAt(this.pointIndex);
                this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeLink });
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyMovePointStart' : 'liveMovePointStart', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
            }
        } else if (this.linkUI) {
            this.isStart = true;
            this._handle_mousedown(e);
            this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyMovePointStart' : 'liveMovePointStart', event: e, element: this.linkUI._element });
        } else if(this.node) {
            this.isStartRotate = true;
            this._handle_mousedown(e);
        }
    },
    handle_mouseup: function (e) {
        if (this.isStart) {
            var point = _twaver.clone(this._endLogical);
            if (this.resizingRect) {
                if (this.lazyMode) {
                    if (this.network.isResizeAnimate()) {
                        var self = this;
                        var animate = new twaver.animate.AnimateBounds(this.node, this.resizingRect, function () {
                            self.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: self.node, resizeDirection: self.resizeDirection });
                            self.clear();
                        });
                        twaver.animate.AnimateManager.start(animate);
                    } else {
                        this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                        this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                        this.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                    }
                } else {
                    this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                    this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                    this.network.fireInteractionEvent({ kind: 'liveResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                }
            } else if (this.shapeNode && this.pointIndex >= 0 && point) {
                var oldPoint = this.shapeNode.getPoints().get(this.pointIndex);
                if (this.horizontal) {
                    point.y = oldPoint.y;
                }
                if (this.vertical) {
                    point.x = oldPoint.x;
                }
                this.shapeNode.setPoint(this.pointIndex, point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            } else if (this.shapeLink && this.pointIndex >= 0 && point) {
                var oldPoint = this.shapeLink.getPoints().get(this.pointIndex);
                if (this.horizontal) {
                    point.y = oldPoint.y;
                }
                if (this.vertical) {
                    point.x = oldPoint.x;
                }
                this.shapeLink.setPoint(this.pointIndex, point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
            } else if (this.linkUI && point) {
                this.linkUI.setControlPoint(point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.linkUI._element });
            }
        }

        this._handle_mouseup(e);
        // if (!this.lazyMode) { //networknetwork.setEditInteractions(true)
            this.clear();
        // }
    },
    handle_mousemove: function (e) {
        if(this.isStartRotate) {
            if(this.node) {
                this._handleRotateElement(e,this.node);
                if(this.network.isShowRotateScale()) {
                    this.showRotateScale();
                }
                return;
            }
        }
        if (this.isStart) {
            if (this.shapeNode && this.pointIndex >= 0) {
                this._handleMovingShapeNodePoint(e);
                return;
            }
            if (this.shapeLink && this.pointIndex >= 0) {
                this._handleMovingShapeLinkPoint(e);
                return;
            }
            if (this.node && this.resizeDirection) {
                this._handleResizing(e);
                return;
            }
            if (this.linkUI) {
                this._handleMovingLinkControlPoint(e);
                return;
            }
            return;
        }
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if (this.network.isSelectingElement() || this.network.isMovingElement() || this.network.getSelectionModel().size() === 0) {
            this.clear();
            return;
        }

        var element = this.network.getElementAt(e);
        var elementUI = this.network.getElementUI(element);
        if (!elementUI || !elementUI.getEditAttachment()) {
            this.clear();
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (element instanceof $Node) {
            this.node = element;
            if (this._isEditingShapeNode(point) || this._isResizingNode(point)) {
                this.network.setEditingElement(true);
                return;
            }
            if(this._isRotatingElement(point)) {
                this.network.setRotatingElement(true);
                this.network.setEditingElement(true)
                return;
            }
        } else if (element instanceof twaver.ShapeLink) {
            this.shapeLink = element;
            if (this._isEditingShapeLink(point)) {
                this.network.setEditingElement(true);
                return;
            }
        } else if (elementUI instanceof twaver.network.LinkUI) {
            var size = this.network.getEditPointSize();
            if ($link.isOrthogonalLink(elementUI._element)) {
                this.linkUI = elementUI;
                var controlPoint = this.linkUI.getControlPoint();
                if (controlPoint && this._contains(point, controlPoint, size)) {
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                }
                return;
            }
        }
        this.clear();
    },
    _isRotatingElement: function(point) {
        var size = this.network.getRotatePointSize();
        if (size <= 0) {
            return false;
        }
        var rect = this.node.getOriginalRect();
        var angle = this.node.getAngle();
        return this._isRotating(point, "crosshair", rect, angle)
    },
    _isRotating: function(point,cursor,rect,angle) {
        var size = this.network.getRotatePointSize();
        var p = {x: rect.x + rect.width/2 , y: rect.y - this.network.getRotatePointOffset() - size};
        var rotatep = this._rotatePoint(p, angle, rect);
        var newrect = { x: rotatep.x - size, y: rotatep.y - size , width: size * 2, height: size * 2};
        if($math.containsPoint(newrect, point)) {
            this._removeCursor();
            this._setCursor(cursor);
            return true;
        }
        return false;
    },
    _handleRotateElement: function(e,node) {
        this._handle_mousemove(e);
        var angle = this._calculateAngle(this.network.getLogicalPoint(e),node);
        node.setAngle(angle);
    },
    _calculateAngle: function(p,node) {
        var c = node.getCenterLocation();
        return Math.round(Math.atan2(c.x-p.x,p.y - c.y) * 180 / Math.PI + 180);
    },
    _handleMovingShapeNodePoint: function (e) {
        this._handle_mousemove(e);
        if (!this.mouseMoved && _twaver.isCtrlDown(e)) {
            var offsetX = this._endLogical.x - this._startLogical.x,
            offsetY = this._endLogical.y - this._startLogical.y;
            this.horizontal = Math.abs(offsetX) >= Math.abs(offsetY);
            this.vertical = !this.horizontal;
            this.mouseMoved = true;
        }
        var oldPoint = this.shapeNode.getPoints().get(this.pointIndex),
        newPoint = _twaver.clone(this._endLogical);
        if (this.horizontal) {
            newPoint.y = oldPoint.y;
        }
        if (this.vertical) {
            newPoint.x = oldPoint.x;
        }
        this.shapeNode.setPoint(this.pointIndex, newPoint);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeNode, pointIndex: this.pointIndex });
    },
    _handleMovingShapeLinkPoint: function (e) {
        this._handle_mousemove(e);
        if (!this.mouseMoved && _twaver.isCtrlDown(e)) {
            var offsetX = this._endLogical.x - this._startLogical.x,
            offsetY = this._endLogical.y - this._startLogical.y;
            this.horizontal = Math.abs(offsetX) >= Math.abs(offsetY);
            this.vertical = !this.horizontal;
            this.mouseMoved = true;
        }
        var oldPoint = this.shapeLink.getPoints().get(this.pointIndex),
        newPoint = _twaver.clone(this._endLogical);
        if (this.horizontal) {
            newPoint.y = oldPoint.y;
        }
        if (this.vertical) {
            newPoint.x = oldPoint.x;
        }
        this.shapeLink.setPoint(this.pointIndex, newPoint);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeLink, pointIndex: this.pointIndex });
    },
    _handleMovingLinkControlPoint: function (e) {
        this._handle_mousemove(e);
        this.linkUI.setControlPoint(_twaver.clone(this._endLogical));
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.linkUI._element });
    },
    _handleResizing: function (e) {
        this._handle_mousemove(e);
        var angle = this.node.getAngle();
        var oldLocation = this.node.getLocation();
        var w = this.node.getWidth()/2,h = this.node.getHeight()/2;
        var center = {x : oldLocation.x + w, y : oldLocation.y + h};

        var p1 = {x: (-w),y : (-h)}; // northwest
        var p2 = {x : (-w),y : h}; //southwest
        var p3 = {x : w, y : h};//southeast
        var p4 = {x : w,y :(-h)};//northeast
        var p5 = {x:0,y:-h};//north
        var p6 = {x:w,y:0};//east
        var p7 = {x:0,y:h};//south
        var p8 ={x:-w,y:0};//west


        if (this.resizeDirection === 'northwest') {
            this._transformPoint(p3,center,angle);
            p1.x = this._endLogical.x;
            p1.y = this._endLogical.y;

            center.x = (p1.x + p3.x) / 2;
            center.y = (p1.y + p3.y) / 2;

            this._reversPoint(p1,center,angle);
            this._reversPoint(p3,center,angle);

            this.resizingRect = {x:p1.x,y:p1.y,width:p3.x-p1.x,height:p3.y - p1.y};
        }
        if (this.resizeDirection === 'north') {
            var p= {x:this._endLogical.x, y:this._endLogical.y};

            this._reversPoint(p,center,angle);
            p5.y = p.y - center.y;
            this._transformPoint(p5,center,angle);
            this._transformPoint(p7,center,angle);


            center.x = (p5.x + p7.x) / 2;
            center.y = (p5.y + p7.y) / 2;

            this._reversPoint(p5,center,angle);
            this._reversPoint(p7,center,angle);

//            this.node.setLocation(center.x - this.node.getWidth() / 2,center.y - this.node.getHeight()/ 2);
//            this.node.setSize(this.node.getWidth(), p7.y - p5.y);
this.resizingRect = {x:center.x - this.node.getWidth()/2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
}
if (this.resizeDirection === 'northeast') {
    this._transformPoint(p2,center,angle);
    p4.x = this._endLogical.x;
    p4.y = this._endLogical.y;

    center.x = (p2.x + p4.x) / 2;
    center.y = (p2.y + p4.y) / 2;

    this._reversPoint(p2,center,angle);
    this._reversPoint(p4,center,angle);

    this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
}
if (this.resizeDirection === 'west') {
    var p= {x:this._endLogical.x, y:this._endLogical.y};

    this._reversPoint(p,center,angle);
    p8.x = p.x - center.x;
    this._transformPoint(p6,center,angle);
    this._transformPoint(p8,center,angle);


    center.x = (p6.x + p8.x) / 2;
    center.y = (p6.y + p8.y) / 2;

    this._reversPoint(p6,center,angle);
    this._reversPoint(p8,center,angle);


    this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
}
if (this.resizeDirection === 'east') {
    var p= {x:this._endLogical.x, y:this._endLogical.y};

    this._reversPoint(p,center,angle);
    p6.x = p.x - center.x;
    this._transformPoint(p6,center,angle);
    this._transformPoint(p8,center,angle);


    center.x = (p6.x + p8.x) / 2;
    center.y = (p6.y + p8.y) / 2;

    this._reversPoint(p6,center,angle);
    this._reversPoint(p8,center,angle);


    this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
}
if (this.resizeDirection === 'southwest') {
    this._transformPoint(p4,center,angle);
    p2.x = this._endLogical.x;
    p2.y = this._endLogical.y;

    center.x = (p2.x + p4.x) / 2;
    center.y = (p2.y + p4.y) / 2;

    this._reversPoint(p2,center,angle);
    this._reversPoint(p4,center,angle);

    this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
}
if (this.resizeDirection === 'south') {
    var p= {x:this._endLogical.x, y:this._endLogical.y};

    this._reversPoint(p,center,angle);
    p7.y = p.y - center.y;
    this._transformPoint(p5,center,angle);
    this._transformPoint(p7,center,angle);


    center.x = (p5.x + p7.x) / 2;
    center.y = (p5.y + p7.y) / 2;

    this._reversPoint(p5,center,angle);
    this._reversPoint(p7,center,angle);


    this.resizingRect = {x:center.x - this.node.getWidth() / 2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
}
if (this.resizeDirection === 'southeast') {
    this._transformPoint(p1,center,angle);
    p3.x = this._endLogical.x;
    p3.y = this._endLogical.y;

    center.x = (p1.x + p3.x) / 2;
    center.y = (p1.y + p3.y) / 2;

    this._reversPoint(p1,center,angle);
    this._reversPoint(p3,center,angle);

    this.resizingRect = {x:p1.x,y:p1.y,width:p3.x - p1.x,height:p3.y - p1.y};
}

if (this.lazyMode) {
    if (!this.mark) {
        this.mark = $html.createDiv();
        this.mark.style.webkitTransform = "rotate(" + angle + "deg)";
        this.mark.style.mozTransform = "rotate(" + angle + "deg)";
        this.mark.style.OTransform = "rotate(" + angle + "deg)";
        this.mark.style.msTransform = "rotate(" + angle + "deg)";
        this.mark.style.transform = "rotate(" + angle + "deg)";
        this.network.getTopDiv().appendChild(this.mark);
    }
    $html.setDiv(this.mark, this.resizingRect, null, this.network.getResizeLineWidth(), this.network.getResizeLineColor());
    this.network.fireInteractionEvent({ kind: 'lazyResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
} else {
    this.node.setSize(this.resizingRect.width, this.resizingRect.height);
    this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
    this.network.fireInteractionEvent({ kind: 'liveResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
}
},
_isEditingShapeNode: function (point) {
    var size = this.network.getEditPointSize();
    if (this.node instanceof twaver.ShapeNode) {
        this.shapeNode = this.node;
        var points = this.shapeNode.getPoints();
        for (var i = 0, n = points.size(); i < n; i++) {
            var p = points.get(i);
            if (this._contains(point, p, size)) {
                this._setCrossCursor();
                this.pointIndex = i;
                return true;
            }
        }
    }
    this.pointIndex = -1;
    return false;
},
_isEditingShapeLink: function (point) {
    var points = this.shapeLink.getPoints();
    var size = this.network.getEditPointSize();
    for (var i = 0, n = points.size(); i < n; i++) {
        var p = points.get(i);
        if (this._contains(point, p, size)) {
            this._setCrossCursor();
            this.pointIndex = i;
            return true;
        }
    }
    this.pointIndex = -1;
    return false;
},
_isResizingNode: function (point) {
    var size = this.network.getResizePointSize();
    if (size <= 0) {
        return false;
    }
    var rect = this.node.getOriginalRect();
    var angle = this.node.getAngle();
    var p = {x: rect.x, y:rect.y};
    var rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point, rotatep.x, rotatep.y, 'northwest', 'nwse-resize')) {
        return true;
    }
    p = {x: rect.x + rect.width / 2, y: rect.y};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point, rotatep.x ,rotatep.y, 'north', 'ns-resize')) {
        return true;
    }
    p = {x: rect.x + rect.width, y:rect.y};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point,rotatep.x ,rotatep.y, 'northeast', 'nesw-resize')) {
        return true;
    }
    p = {x: rect.x, y:rect.y + rect.height / 2};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point, rotatep.x ,rotatep.y, 'west', 'ew-resize')) {
        return true;
    }
    p = {x: rect.x + rect.width, y: rect.y + rect.height / 2};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point,  rotatep.x ,rotatep.y, 'east', 'ew-resize')) {
        return true;
    }
    p = {x: rect.x, y: rect.y + rect.height};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point,rotatep.x ,rotatep.y, 'southwest', 'nesw-resize')) {
        return true;
    }
    p = {x: rect.x + rect.width / 2, y: rect.y + rect.height};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point, rotatep.x ,rotatep.y, 'south', 'ns-resize')) {
        return true;
    }
    p = {x: rect.x + rect.width, y:rect.y + rect.height};
    rotatep = this._rotatePoint(p,angle,rect);
    if (this._isResizing(point, rotatep.x ,rotatep.y, 'southeast', 'nwse-resize')) {
        return true;
    }
    return false;
},
_rotatePoint: function(point,angle,rect) {
    var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
    var newPoint = matrix.transform(point);
    return newPoint;
},
_isResizing: function (point, x, y, direction, cursor) {
    var size = this.network.getResizePointSize();
    if (this._contains(point, { x: x, y: y }, size)) {
        if (this.resizeDirection !== direction) {
            this._removeCursor();
            cursor = this._changeCursorWithAngle(direction, this.node.getAngle());
            this._setCursor(cursor);
            this.resizeDirection = direction;
        }
        return true;
    }
    return false;
},
_getRect: function (x1, y1, x2, y2) {
    var x = x1 < x2 ? x1 : x2;
    var y = y1 < y2 ? y1 : y2;
    var w = Math.abs(x1 - x2);
    var h = Math.abs(y1 - y2);
    return { x: x, y: y, width: w, height: h };
},
_contains: function (point, center, size) {
    var rect = { x: center.x - size, y: center.y - size, width: size * 2, height: size * 2 };
    return $math.containsPoint(rect, point);
},
getPointIndex: function (points, point, closed) {
  if(points.size() < 2){
     return 0;
 }
 var p1 = points.get(0), p2;
 for(var i=1; i<points.size(); i++){
     p2 = points.get(i);
     if(this.isPointOnLine(point, p1, p2, 6)){
        return i;
    }
    p1 = p2;
}
p1 = points.get(0);
if(closed && this.isPointOnLine(point, p1, p2, 6)){
 return points.size();
}
return 0;
},
showRotateScale: function() {
    if(!this.rotateScale) {
        this.rotateScale = _twaver.html.createCanvas();
    }
    var rmpList = new twaver.List(),
    width = this.network.getRotateScaleWidth(),
    height = this.network.getRotateScaleHeight(),
    size = this.network.getRotatePointSize(),
    angle = this.node.getAngle(),
    rect = this.node.getOriginalRect(),
    point = {x: rect.x + rect.width / 2, y: rect.y - this.network.getRotatePointOffset() - size},
    rotatePoint = this._rotatePoint(point, angle, rect),
    rscaleRect,
    font = "13px Arial",
    text = angle + '\u00B0',
    p1,p2,p3,p4;
    if(this.node.getAngle() >= 0 && this.node.getAngle() <= 180) {
        p1 = {x: rotatePoint.x + size, y: rotatePoint.y};
        p2 = {x: p1.x + width, y: p1.y};
        p3 = {x: p2.x, y: p2.y -  height};
        p4 = {x: p1.x, y: p3.y};
    } else if (this.node.getAngle() > 180 && this.node.getAngle() <= 360) {
        p1 = {x: rotatePoint.x - size, y: rotatePoint.y};
        p2 = {x: p1.x - width, y: p1.y};
        p3 = {x: p2.x, y: p2.y - height};
        p4 = {x: p1.x, y: p3.y};
    }
    var rscalePointsList = new twaver.List([p1,p2,p3,p4]),
    rscaleRect = _twaver.math.getRect(rscalePointsList);
    var g = _twaver.html.setCanvas(this.rotateScale, rscaleRect);
    g.fillStyle = this.network.getRotateScaleFillColor();
    g.fillRect(rscaleRect.x, rscaleRect.y, rscaleRect.width, rscaleRect.height);
    g.fillStyle = this.network.getRotateScaleFontColor();
    g.textBaseline="middle";
    g.textAlign = "center";
    g.font = font;
    g.fillText(text, rscaleRect.x + rscaleRect.width / 2, rscaleRect.y + rscaleRect.height/2);

    this.network.getTopDiv().appendChild(this.rotateScale);

},
isPointOnLine: function (point, point1, point2, width) {
  if(width < 0){
     width = 0;
 }
 var distance = this.getDistanceFromPointToLine(point, point1, point2);
 return distance <= width &&
 (point.x >= Math.min(point1.x, point2.x) - width) &&
 (point.x <= Math.max(point1.x, point2.x) + width) &&
 (point.y >= Math.min(point1.y, point2.y) - width) &&
 (point.y <= Math.max(point1.y, point2.y) + width);
},
getDistanceFromPointToLine: function (point, point1, point2) {
  if (point1.x === point2.x) {
     return Math.abs(point.x - point1.x);
 }
 var lineK = (point2.y - point1.y) / (point2.x - point1.x);
 var lineC = (point2.x * point1.y - point1.x * point2.y) / (point2.x - point1.x);
 return Math.abs(lineK * point.x - point.y + lineC) / (Math.sqrt(lineK * lineK + 1));
},
_transformPoint : function(p,center,angle){
    var cos = Math.cos(angle * Math.PI / 180);
    var sin = Math.sin(angle * Math.PI / 180);
    var x = p.x;
    var y = p.y;

    var newX = x * cos - y *sin;
    var newY = x * sin + y *cos;

    p.x = newX + center.x;
    p.y = newY + center.y;
},

_reversPoint : function(p,center,angle){
    angle *= -1;
    var cos = Math.cos(angle * Math.PI / 180);
    var sin = Math.sin(angle * Math.PI / 180);
    var x = p.x - center.x;
    var y = p.y - center.y;

    var newX = x * cos - y *sin;
    var newY = x * sin + y *cos;

    p.x = newX + center.x;
    p.y = newY + center.y;
},
_changeCursorWithAngle: function(direction, angle) {
    var flag,cursorArray = ['auto','nwse-resize','ns-resize','nesw-resize','ew-resize','nwse-resize','ns-resize','nesw-resize','ew-resize'];
    switch(direction)
    {
        case 'northwest':
        flag = 1;
        break;
        case 'north':
        flag = 2
        break;
        case 'northeast':
        flag = 3
        break;
        case 'east':
        flag = 4;
        break;
        case 'southeast':
        flag = 5;
        break;
        case 'south':
        flag = 6;
        break;
        case 'southwest':
        flag = 7;
        break;
        case 'west':
        flag = 8;
        break;
        default:
        flag = 0;
    }
    if(angle >= 360 || angle <= -360) {
        angle = angle % 360;
    }
    if(angle > 45 / 2 && angle <= 135 / 2) {
        flag = flag + 1;
    }
    if(angle < -45/2 && angle >= -135/2) {
        flag = flag - 1;
    }
    if(angle > 135 / 2 && angle <= 225 / 2) {
        flag = flag + 2;
    }
    if(angle < -135 / 2 && angle >= -225 / 2) {
        flag = flag - 2;
    }
    if(angle > 225 / 2 && angle <= 315 / 2) {
        flag = flag + 3;
    }
    if(angle < -225 / 2 && angle >= -315 / 2) {
        flag = flag - 3;
    }
    if(angle > 315 / 2 && angle <= 405 / 2) {
        flag = flag + 4;
    }
    if(angle < -315 / 2 && angle >= -405 / 2) {
        flag = flag - 4;
    }
    if(angle > 405 / 2 && angle <= 495 / 2) {
        flag = flag + 5;
    }
    if(angle < -405 / 2 && angle >= -495 / 2) {
        flag = flag - 5;
    }
    if(angle > 495 / 2 && angle <= 585 / 2) {
        flag = flag + 6;
    }
    if(angle < -495 / 2 && angle >= -585 / 2) {
        flag = flag - 6;
    }
    if(angle > 585 / 2 && angle <= 675 / 2) {
        flag = flag + 7;
    }
    if(angle < -585 / 2 && angle >= -675 / 2) {
        flag = flag - 7;
    }
    if(flag > 8) {
        flag = flag - 8;
    }
    if(flag <= 0) {
        flag = flag + 8;
    }
    return cursorArray[flag];
}
});

twaver.network.interaction.MoveLinkInteraction = function(network, lazyMode) {
	twaver.network.interaction.MoveLinkInteraction.superClass.constructor.call(this, network);
	//this.lazyMode = lazyMode;
	this.xoffset = 0;
	this.yoffset = 0;
};
_twaver.ext('twaver.network.interaction.MoveLinkInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
        this.oldCursor = this.network.getView().style.cursor;
    },
    tearDown: function () {
        this.removeListener('mousedown'/*, 'mousemove'*/);
        this.network.getView().style.cursor = this.oldCursor;
        this.end();
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.network.isSelectingElement() || this.network.isEditingElement()) {
            return;
        }
        var element = this.network.getElementAt(e);
        if (!(element instanceof twaver.Link)) {
            return;
        }
        this.element = element;
        this.end(e);
        this._handle_mousedown(e);
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (!this._startLogical
                || this.network.isSelectingElement()
				|| this.network.isEditingElement()) {
            this.end(e);
            return;
        }
        this._handle_mousemove(e);

        this.xoffset = this._endLogical.x - this._startLogical.x;
        this.yoffset = this._endLogical.y - this._startLogical.y;

        if (this.lazyMode) {
            if (this.mark) {
                this.network.fireInteractionEvent({
                    kind: 'lazyMoveBetween',
                    event: e,
                    element: this.element
                });
            } else {
                this.mark = $html.createCanvas();

                var rect;
                this.network.getMovableSelectedElements().forEach(
						function (element) {
						    var ui = this.getElementUI(element);
						    if (ui) {
						        rect = $math.unionRect(rect, ui.getViewRect());
						    }
						}, this.network);

                this.network.getTopDiv().appendChild(this.mark);
                this.network.setMovingElement(true);

                $html.setDiv(this.mark, rect, this.network
								.isLazyMoveFill() ? this.network
								.getLazyMoveFillColor() : null,
						this.network.getLazyMoveOutlineWidth(),
						this.network.getLazyMoveOutlineColor());

                this.network.fireInteractionEvent({
                    kind: 'lazyMoveStart',
                    event: e,
                    element: this.element
                });
            }
            this.mark.style.left = this.xoffset + this.mark._viewRect.x + "px";
            this.mark.style.top = this.yoffset + this.mark._viewRect.y + "px";
        } else {
            var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
            twaver.Util.moveElements(elements, this.xoffset, this.yoffset);
            this._startLogical = this._endLogical;
            this._startClient = $html.getClientPoint(e);
            if (this.network.isMovingElement()) {
                this.network.fireInteractionEvent({
                    kind: 'liveMoveBetween',
                    event: e,
                    element: this.element
                });
            } else {
                this.network.setMovingElement(true);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveStart',
                    event: e,
                    element: this.element
                });
            }
        }
    },
    end: function (e) {
        if (this._startLogical) {
            if (this.lazyMode) {
                if (this.mark) {
                    var self = this;
                    var f = function () {
                        self.network.fireInteractionEvent({
                            kind: 'lazyMoveEnd',
                            event: e,
                            element: this.element
                        });
                        if (self.mark) {
                            self.network.getTopDiv().removeChild(self.mark);
                            self.mark = null;
                            self.network.setMovingElement(false);
                        }
                    };
                    var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
                    twaver.Util.moveElements(elements, this.xoffset, this.yoffset, this.network.isLazyMoveAnimate(), f);
                }
            } else {
                if (this.network.isMovingElement()) {
                    this.network.setMovingElement(false);
                    this.network.fireInteractionEvent({
                        kind: 'liveMoveEnd',
                        event: e,
                        element: this.element
                    });

                }
            }
            this._handle_mouseup(e);
        delete this.element;
        }
    }
});

twaver.network.interaction.CreateElementInteraction = function (network, typeOrElementFunction) {
    if (!typeOrElementFunction) {
        typeOrElementFunction = $Node;
    }
    if (twaver.Util.isTypeOf(typeOrElementFunction, $Node)) {
        this.elementFunction = function (point) {
            var element = new typeOrElementFunction();
            if (element instanceof $Node) {
                element.setCenterLocation(point);
            }
            return element;
        };
    } else {
        this.elementFunction = typeOrElementFunction;
    }
    twaver.network.interaction.CreateElementInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.CreateElementInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
    },
    tearDown: function () {
        this.removeListener('mousedown');
    },
    handle_mousedown: function (e) {
        var point = this.network.getLogicalPoint(e);
        if (point) {
            var element = this.elementFunction(point);
            if (element) {
                this.network.addElementByInteraction(element);
            }
        }
    }
});

twaver.network.interaction.CreateLinkInteraction = function (network, typeOrLinkFunction) {
    if (!typeOrLinkFunction) {
        typeOrLinkFunction = twaver.Link;
    }
    if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.Link)) {
        this.linkFunction = function (fromNode, toNode) {
            var link = new typeOrLinkFunction();
            if (link instanceof twaver.Link) {
                link.setFromNode(fromNode);
                link.setToNode(toNode);
            }
            return link;
        };
    } else {
        this.linkFunction = typeOrLinkFunction;
    }
    twaver.network.interaction.CreateLinkInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.CreateLinkInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove');
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove');
        this.clear();
    },
    clear: function () {
        var self = this;
        setTimeout(function () {
            if (self._fromRectangle) {
                self.network.getTopDiv().removeChild(self._fromRectangle);
                self._fromRectangle = null;
            }
            if (self._currentRectangle) {
                self.network.getTopDiv().removeChild(self._currentRectangle);
                self._currentRectangle = null;
            }
            if (self._line) {
                self.network.getTopDiv().removeChild(self._line);
                self._line = null;
            }
        });
        this.currentPoint = null;
        this.currentNode = null;
        this.fromNode = null;
        this.toNode = null;
    },
    createLink: function () {
        return this.linkFunction(this.fromNode, this.toNode);
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if (this.fromNode) {
            this.toNode = this.currentNode;
            if (this.toNode) {
                var link = this.createLink();
                if (link) {
                    this.network.addElementByInteraction(link);
                }
            }
            this.clear();
        } else {
            this.fromNode = this.currentNode;
            this.currentNode = null;
            this.currentPoint = null;
            this.updateMark();
        }
    },
    handle_mousemove: function (e) {
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        if (this.network.isMovingElement() || this.network.isEditingElement()) {
            this.clear();
            return;
        }
        var node = null;
        if (this.fromNode) {
            this.currentNode = this.getToNode(e);
            this.currentPoint = point;
            this.updateMark();
        } else {
            node = this.getFromNode(e);
            if (this.currentNode !== node) {
                this.currentNode = node;
                this.updateMark();
            }
        }
    },
    getFromNode: function (e) {
        return this.getNode(e);
    },
    getToNode: function (e) {
        return this.getNode(e);
    },
    getNode: function (e) {
        var node = this.network.getElementAt(e);
        if (node instanceof $Node && this.network.isLinkable(node)) {
            return node;
        }
        return null;
    },
    updateMark: function () {
        var ui;
        if (this.fromNode && !this._fromRectangle && this._currentRectangle) {
            this._fromRectangle = this._currentRectangle;
            this._currentRectangle = null;
        }
        if (!this.fromNode && this._fromRectangle) {
            this.network.getTopDiv().removeChild(this._fromRectangle);
            this._fromRectangle = null;
        }

        if (this.currentNode && !this._currentRectangle) {
            ui = this.network.getElementUI(this.currentNode);
            this._currentRectangle = $html.createDiv();
            this.network.getTopDiv().appendChild(this._currentRectangle);
            $html.setDiv(this._currentRectangle, ui._viewRect, null,
                this.network.getEditLineWidth(), this.network.getEditLineColor());
        }
        if (!this.currentNode && this._currentRectangle) {
            this.network.getTopDiv().removeChild(this._currentRectangle);
            this._currentRectangle = null;
        }

        this.updateLine();
    },
    updateLine: function () {
        if (this.currentPoint) {
            var center = this.fromNode.getCenterLocation();
            var x1 = center.x, y1 = center.y;
            var x2 = this.currentPoint.x, y2 = this.currentPoint.y;
            if (!this._line) {
                this._line = $html.createCanvas();
                this.network.getTopDiv().appendChild(this._line);
            }
            var g = $html.setCanvas(this._line, Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));
            g.lineWidth = this.network.getEditLineWidth();
            g.strokeStyle = this.network.getEditLineColor();
            g.beginPath();
            g.moveTo(x1, y1);
            g.lineTo(x2, y2);
            g.stroke();
        } else {
            if (this._line) {
                this.network.getTopDiv().removeChild(this._line);
                this._line = null;
            }
        }
    }
});

twaver.network.interaction.CreateShapeNodeInteraction = function (network, typeOrShapeNodeFunction) {
    if (!typeOrShapeNodeFunction) {
        typeOrShapeNodeFunction = twaver.ShapeNode;
    }
    if (twaver.Util.isTypeOf(typeOrShapeNodeFunction, twaver.ShapeNode)) {
        this.shapeNodeFunction = function (points) {
            var shapeNode = new typeOrShapeNodeFunction();
            if (shapeNode instanceof twaver.ShapeNode) {
                if (points) {
                    shapeNode.setPoints(points);
                }
            }
            return shapeNode;
        };
    } else {
        this.shapeNodeFunction = typeOrShapeNodeFunction;
    }
    twaver.network.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, network);
    this.timeStamp = -1;
};
_twaver.ext('twaver.network.interaction.CreateShapeNodeInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove');
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove');
        this.clear();
    },
    clear: function () {
        this.network.setEditingElement(false);
        this.points = null;
        this.currentPoint = null;
        this.lastPoint = null;
        this.horizontal = false;
        this.vertical = false;
        if (this.mark) {
            this.network.getTopDiv().removeChild(this.mark);
            this.mark = null;
        }
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        if (e.detail === 2 || e.timeStamp - this.timeStamp < 300) {
            if (this.points) {
                var shapeNode = this.shapeNodeFunction(this.points);
                this.network.addElementByInteraction(shapeNode);
                this.clear();
                var self = this;
                setTimeout(function () { self.network.setEditingElement(false); }, 0);
            }
        } else {
            if (!this.network.isEditingElement()) {
                this.network.setEditingElement(true);
            }
            if (!this.points) {
                this.points = new $List();
            }
            if (this.points.size() > 0) {
                var lastPoint = this.points.get(this.points.size() - 1);
                if (lastPoint.x === point.x && lastPoint.y === point.y) {
                    return;
                }
            }
            this._handle_mousedown(e);
            if (this.points.size() > 0 && _twaver.isCtrlDown(e)) {
                if (this.horizontal) {
                    point.y = lastPoint.y;
                }
                if (this.vertical) {
                    point.x = lastPoint.x;
                }
                this.horizontal = false;
                this.vertical = false;
            }
            this.lastPoint = point;
            this.points.add(point);
            this.updateMark();
        }
        this.timeStamp = e.timeStamp;
    },
    handle_mousemove: function (e) {
        if (this.points) {
            this.currentPoint = this.network.getLogicalPoint(e);
            if (_twaver.isCtrlDown(e)) {
                var offsetX = this.currentPoint.x - this.lastPoint.x,
                    offsetY = this.currentPoint.y - this.lastPoint.y;
                this.horizontal = Math.abs(offsetX) >= Math.abs(offsetY);
                this.vertical = !this.horizontal;
            } else {
                this.horizontal = false;
                this.vertical = false;
            }
            if (this.horizontal) {
                this.currentPoint.y = this.lastPoint.y;
            }
            if (this.vertical) {
                this.currentPoint.x = this.lastPoint.x;
            }
            this.updateMark();
        }
    },
    updateMark: function (e) {
        if (this.points && this.points.size() > 0) {
            if (this.currentPoint) {
                if (!this.mark) {
                    this.mark = $html.createCanvas();
                    this.network.getTopDiv().appendChild(this.mark);
                }
                var newPoints = new $List(this.points);
                newPoints.add(this.currentPoint);
                var rect = $math.getRect(newPoints);
                var lineWidth = this.network.getEditLineWidth();
                _twaver.math.grow(rect, lineWidth, lineWidth);
                var g = $html.setCanvas(this.mark, rect);
                g.lineWidth = lineWidth;
                g.strokeStyle = this.network.getEditLineColor();
                g.beginPath();
                $g.drawLinePoints(g, newPoints);
                g.stroke();
            }
        }
    }
});

twaver.network.interaction.CreateShapeLinkInteraction = function (network, typeOrLinkFunction) {
    twaver.network.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, network);
    if (!typeOrLinkFunction) {
        typeOrLinkFunction = twaver.ShapeLink;
    }
    if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.ShapeLink)) {
        this.linkFunction = function (fromNode, toNode, points) {
            var link = new typeOrLinkFunction();
            if (link instanceof twaver.ShapeLink) {
                link.setFromNode(fromNode);
                link.setToNode(toNode);
                if (points) {
                    link.setPoints(points);
                }
            }
            return link;
        };
    } else {
        this.linkFunction = typeOrLinkFunction;
    }
};
_twaver.ext('twaver.network.interaction.CreateShapeLinkInteraction', twaver.network.interaction.CreateLinkInteraction, {
    clear: function () {
        this.network.setEditingElement(false);
        this.points = null;
        if (this.polyline) {
            this.network.getTopDiv().removeChild(this.polyline);
            this.polyline = null;
        }
        twaver.network.interaction.CreateShapeLinkInteraction.superClass.clear.call(this);
    },
    createLink: function () {
        return this.linkFunction(this.fromNode, this.toNode, this.points);
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        if (this.fromNode) {
            this.toNode = this.currentNode;
            if (this.toNode) {
                var shapeLink = this.createLink();
                if (shapeLink) {
                    this.network.addElementByInteraction(shapeLink);
                }
                this.clear();
            } else {
                if (!this.points) {
                    this.points = new $List();
                }
                if (this.points.size() > 0) {
                    var lastPoint = this.points.get(this.points.size() - 1);
                    if (lastPoint.x === point.x && lastPoint.y === point.y) {
                        return;
                    }
                }
                this.points.add(point);
                this.updateMark();
            }
        } else {
            this.fromNode = this.currentNode;
            if (this.fromNode) {
                if (!this.polyline) {
                    this.polyline = $html.createCanvas();
                    this.network.getTopDiv().appendChild(this.polyline);
                }
            }
            this.points = null;
            this.currentNode = null;
            this.currentPoint = null;
            this.updateMark();
        }
    },
    updateLine: function () {
        if (this.currentPoint) {
            if (this.polyline) {
                var newPoints = new $List(this.points);
                newPoints.add(this.fromNode.getCenterLocation(), 0);
                newPoints.add(this.currentPoint);
                var rect = $math.getRect(newPoints);
                var g = $html.setCanvas(this.polyline, rect);
                g.lineWidth = this.network.getEditLineWidth();
                g.strokeStyle = this.network.getEditLineColor();
                g.beginPath();
                $g.drawLinePoints(g, newPoints);
                g.stroke();
            }
        }
    }
});

twaver.network.interaction.CreateOrthogonalLinkInteraction = function (network, typeOrLinkFunction, linkType, isByControlPoint, splitPercent, isSplitByPercent) {
    twaver.network.interaction.CreateOrthogonalLinkInteraction.superClass.constructor.call(this, network, typeOrLinkFunction);
    this.linkType = linkType || 'orthogonal';
    this.isByControlPoint = isByControlPoint;
    this.splitPercent = splitPercent;
    this.isSplitByPercent = isSplitByPercent;

    this.link = new twaver.Link();
    this.link.setStyle('link.type', this.linkType);
    this.link.setStyle('link.split.by.percent', this.isSplitByPercent);
    if ($link.isFlexionalTypeLink(this.linkType) || $link.isExtendTypeLink(this.linkType)) {
        if (this.splitPercent < 0) {
            this.splitPercent = twaver.Styles.getStyle('link.extend');
        }
        this.link.setStyle('link.extend', this.splitPercent);
    } else if ($link.isSplitTypeLink(this.linkType)) {
        if (this.splitPercent < 0) {
            this.splitPercent = twaver.Styles.getStyle(this.isSplitByPercent ? 'link.split.percent' : 'link.split.value');
        }
        if (this.isSplitByPercent) {
            this.link.setStyle('link.split.percent', this.splitPercent);
        } else {
            this.link.setStyle('link.split.value', this.splitPercent);
        }
    }
};
_twaver.ext('twaver.network.interaction.CreateOrthogonalLinkInteraction', twaver.network.interaction.CreateLinkInteraction, {
    clear: function () {
        if (this.path) {
            this.network.getTopDiv().removeChild(this.path);
            this.path = null;
        }
        twaver.network.interaction.CreateOrthogonalLinkInteraction.superClass.clear.call(this);
    },
    createLink: function () {
        var link = twaver.network.interaction.CreateOrthogonalLinkInteraction.superClass.createLink.call(this);
        link.setStyle('link.type', this.linkType);
        link.setStyle('link.split.by.percent', this.isSplitByPercent);
        if (this.isByControlPoint) {
            var controlPoint = $link.getControlPoint(link);
            if (controlPoint) {
                link.SetStyle('link.control.point', controlPoint);
                return link;
            }
        } else {
            if ($link.isFlexionalTypeLink(this.linkType) || $link.isExtendTypeLink(this.linkType)) {
                if (this.splitPercent < 0) {
                    this.splitPercent = twaver.Styles.getStyle('link.extend');
                }
                link.setStyle('link.extend', this.splitPercent);
            } else if ($link.isSplitTypeLink(this.linkType)) {
                if (this.splitPercent < 0) {
                    this.splitPercent = twaver.Styles.getStyle(this.isSplitByPercent ? 'link.split.percent' : 'link.split.value');
                }
                if (this.isSplitByPercent) {
                    link.setStyle('link.split.percent', this.splitPercent);
                } else {
                    link.setStyle('link.split.value', this.splitPercent);
                }
            }
        }
        return link;
    },
    updateLine: function () {
        if (this.currentPoint) {
            if (!this.fromNode || this.currentNode === this.fromNode) {
                return;
            }

            var sourceBounds;
            var fromNodeUI = this.network.getElementUI(this.fromNode);
            if (!fromNodeUI) {
                return;
            }
            sourceBounds = fromNodeUI.getBodyRect();
            if (sourceBounds == null) {
                return;
            }

            var targetBounds;
            if (this.currentNode && this.currentNode !== this.fromNode) {
                var currentNodeUI = this.network.getElementUI(this.currentNode);
                if (!currentNodeUI) {
                    return;
                }
                targetBounds = currentNodeUI.getBodyRect();
            } else {
                targetBounds = { x: this.currentPoint.x, y: this.currentPoint.y, width: 1, height: 1 };
            }
            if (!targetBounds) {
                return;
            }
            var points = $link.calculateOrthogonalAndFlexionalLinkPoints(this.linkType, sourceBounds, targetBounds, this.link);
            $link.drawCorner(points, this.link);

            if (points.size() < 2) {
                return;
            }

            if (!this.line) {
                this.line = $html.createCanvas();
                this.network.getTopDiv().appendChild(this.line);
            }
            var g = $html.setCanvas(this.line, $math.getLineRect(points));
            g.lineWidth = this.network.getEditLineWidth();
            g.strokeStyle = this.network.getEditLineColor();
            g.beginPath();
            $g.drawLinePoints(g, points);
            g.stroke();
        } else {
            if (this.line) {
                this.network.getTopDiv().removeChild(this.line);
                this.line = null;
            }
        }
    }
});

twaver.network.interaction.MagnifyInteraction = function(network, zoom, xRadius, yRadius, shape) {
	twaver.network.interaction.MagnifyInteraction.superClass.constructor.call(this, network);
	this.zoom = zoom || 2;
	this.xRadius = xRadius || 100;
	this.yRadius = yRadius || 100;
	this.shape = shape || 'circle';
	this.borderColor = 'black';
	this.borderWidth = 1;
	this.backgroundColor = 'white';
	this.markCanvas = $html.createCanvas();
	this.markCanvas._isIgnored = true;
};
_twaver.ext('twaver.network.interaction.MagnifyInteraction', twaver.network.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousemove');
	},
	tearDown : function() {
		this.removeListener('mousemove');
		this._clear();
	},
	handle_mousemove : function(e) {
		var point = this.network.getLogicalPoint(e);
		if (!point) {
			return;
		}
		if (!this.lastPoint) {
			this.network.getView().appendChild(this.markCanvas);
		}
		this.lastPoint = point;
		this.updateMark();
	},
	updateMark : function() {
		var zoom = this.network._zoom,
		    scale = this.zoom * zoom,
		    x = this.lastPoint.x * zoom - this.xRadius,
		    y = this.lastPoint.y * zoom - this.yRadius,
		    width = this.xRadius * 2,
		    height = this.yRadius * 2,
		    rect = {
    		    x: this.lastPoint.x - this.xRadius / scale,
    		    y: this.lastPoint.y - this.yRadius / scale,
    		    width: width / scale,
    		    height: height / scale
    		},
    		borderWidth = this.borderWidth,
    		canvas = $html.createCanvas(),
    		g;
		
		canvas.width = width;
		canvas.height = height;
		this.network.toCanvasByRegion(rect, scale, canvas);
    	
		$html.setCanvas(this.markCanvas, x, y, width, height);
		g = this.markCanvas.getContext('2d');
    	g.save();
		g.beginPath();
		$g.drawVector(g, this.shape, null, x, y, width, height);
		g.clip();
		// background
        g.fillStyle = this.backgroundColor;
        g.beginPath();
    	g.rect(x, y, width, height);
    	g.fill();
    	// image
    	g.drawImage(canvas, x, y);
    	g.restore();
    	// border
		g.beginPath();
		g.lineWidth = borderWidth;
		$g.drawVector(g, this.shape, null, x + borderWidth / 2, y + borderWidth / 2, width - borderWidth, height - borderWidth);
		g.strokeStyle = this.borderColor;
		g.stroke();
	},
	_clear : function(e) {
		if (this.lastPoint) {
			this.network.getView().removeChild(this.markCanvas);
			this.lastPoint = null;
		}
	},
	getZoom: function () {
	    return this.zoom;
	},
	setZoom: function (value) {
	    this.zoom = value;
	    this.updateMark();
	},
	getShape: function () {
	    return this.shape;
	},
	setShape: function (value) {
	    this.shape = value;
	    this.updateMark();
	},
	getXRadius: function () {
	    return this.xRadius;
	},
	setXRadius: function (value) {
	    this.xRadius = value;
	    this.updateMark();
	},
	getYRadius: function () {
	    return this.yRadius;
	},
	setYRadius: function (value) {
	    this.yRadius = value;
	    this.updateMark();
	},
	getBorderColor: function () {
	    return this.borderColor;
	},
	setBorderColor: function (value) {
	    this.borderColor = value;
	    this.updateMark();
	},
	getBorderWidth: function () {
	    return this.borderWidth;
	},
	setBorderWidth: function (value) {
	    this.borderWidth = value;
	    this.updateMark();
	},
	getBackgroundColor: function () {
	    return this.backgroundColor;
	},
	setBackgroundColor: function (value) {
	    this.backgroundColor = value;
	    this.updateMark();
	}
});

twaver.network.interaction.TouchInteraction = function (network) {
    twaver.network.interaction.TouchInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.network.interaction.TouchInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener('touchstart', 'handleTouchstart', view, this);
        $html.addEventListener('touchmove', 'handleTouchmove', view, this);
        $html.addEventListener('touchend', 'handleTouchend', view, this);
        $html.addEventListener('touchcancel', 'handleTouchend', view, this);
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener('touchstart', view, this);
        $html.removeEventListener('touchmove', view, this);
        $html.removeEventListener('touchend', view, this);
        $html.removeEventListener('touchcancel', view, this);
    },
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (e.touches && e.touches.length == 1) {
            var point = this.network.getLogicalPoint(e);
            var element = this.network.getElementAt(point);
            this._startTouchTime = new Date();
            this._startTouchPoint = point;
            var self = this;
            if (element) {
                this._haveElementUnderTouch = true;
                this._startTouchElement = element;
            } else {
                this._haveElementUnderTouch = false;
                this._startTouchElement = null;
            }
            this.timer = setTimeout(function(){
                $network_interaction.handleLongClicked(self.network,e,element);
            },1000);
        } else if (e.touches && e.touches.length == 2) {
            this._distance = $touch.getDistance(e);
            this._zoom = this.network.getZoom();
            this._startTouchPoint = {x:e.touches[0].clientX,y: e.touches[0].clientY};
        }
        this._touchCount = e.touches.length;
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);

        if (this._touchCount == 2 && e.touches && e.touches.length == 2) {
            if(this.timer) {
                clearTimeout(this.timer);
            }
            if(Math.abs(this._distance - $touch.getDistance(e)) >= $Defaults.TOUCH_ZOOM_THRESHOLD || this._zoomFlag) {
                this._zoomFlag = true;
                var scale = $touch.getDistance(e) / this._distance;
                this.network.setTouchZoom(this._zoom*scale,false);
            }else{
                var t0 = e.touches[0];
                //pan
                var xoffset = this._startTouchPoint.x - t0.clientX;
                var yoffset = this._startTouchPoint.y - t0.clientY;
                var result = this.network.panByOffset(xoffset, yoffset);
                this._startTouchPoint.x -= (xoffset - result.x);
                this._startTouchPoint.y -= (yoffset - result.y);
            }
        } else if (this._touchCount == 1 && e.touches && e.touches.length == 1) {
            if (this._haveElementUnderTouch || !this.network.isRectSelectEnabled()) {
                var newPoint = this.network.getLogicalPoint(e);
                var element = this.network.getElementAt(newPoint);

                if (this.network.isMovingElement() || (this._startTouchElement != null && this._startTouchElement == element && this.network.getMovableSelectedElements().contains(element))) {
                    //drag element
                    var xoffset = newPoint.x - this._startTouchPoint.x;
                    var yoffset = newPoint.y - this._startTouchPoint.y;
                    if(Math.abs(xoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD || Math.abs(yoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD) {
                        this._startTouchPoint = newPoint;
                        this.network.moveSelectedElements(xoffset, yoffset);
                        if (this.network.isMovingElement()) {
                            this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                        } else {
                            this.network.setMovingElement(true);
                            this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                            if(this.timer) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                } else {
                    var xoffset = newPoint.x - this._startTouchPoint.x;
                    var yoffset = newPoint.y - this._startTouchPoint.y;
                    if(Math.abs(xoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD || Math.abs(yoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD) {
                        if (this.timer) {
                            clearTimeout(this.timer);
                        }
                    }
//                    //pan
//                    var xoffset = this._startTouchPoint.x - newPoint.x;
//                    var yoffset = this._startTouchPoint.y - newPoint.y;
//                    var result = this.network.panByOffset(xoffset, yoffset);
//                    this._startTouchPoint.x -= (xoffset - result.x);
//                    this._startTouchPoint.y -= (yoffset - result.y);
                }
            } else {
                //rect select
                this._moveTouchPoint = this.network.getLogicalPoint(e);
                var xoffset =  this._moveTouchPoint.x - this._startTouchPoint.x;
                var yoffset =  this._moveTouchPoint.y - this._startTouchPoint.y;
                if(Math.abs(xoffset) >= $Defaults.TOUCH_RECT_SELECT_THRESHOLD  && Math.abs(yoffset) >= $Defaults.TOUCH_RECT_SELECT_THRESHOLD) {
                    if (this.mark) {
                        this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
                    } else {
                        this.mark = $html.createDiv();
                        this.network.getTopDiv().appendChild(this.mark);
                        this.network.setSelectingElement(true);
                        this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
                        if (this.timer) {
                            clearTimeout(this.timer);
                        }
                    }

                    var rect = $math.getRect([this._startTouchPoint, this._moveTouchPoint]);
                    $html.setDiv(this.mark, rect,
                        this.getIntersectMode() ? this.network.getSelectFillColor() : null,
                        this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor());
                }
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);

        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        } else if (this.network.isSelectingElement()) {
            var elements = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
            if (elements && elements.size() > 0) {
                var sm = this.network.getSelectionModel();
                var selections = sm.toSelection();
                elements.forEach(function (element) {
                    if (sm.contains(element)) {
                        selections.remove(element);
                    } else {
                        selections.add(element);
                    }
                }, this);
                sm.setSelection(selections);
            }
            this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            this.network.getTopDiv().removeChild(this.mark);
            this.mark = null;
            this.network.setSelectingElement(false);
            if(this.timer) {
                clearTimeout(this.timer);
            }
        } else if (this._startTouchPoint) {
            //set this.zoomFlag = false;
            this._zoomFlag = false;
            //handle click&double click
            var endTouchTime = new Date();
            var endTouchPoint = this.network.getLogicalPoint(e);
            var element = this.network.getElementAt(this._startTouchPoint);
            if (this._startTouchPoint && endTouchPoint && (endTouchTime.getTime() - this._startTouchTime.getTime()) <= 500
                && $math.getDistance(this._startTouchPoint, endTouchPoint) <= 20) {
                if (element) {
                    if (!this.network.getSelectionModel().contains(element)) {
                        this.network.getSelectionModel().setSelection(element);
                    }
                } else {
                    this.network.getSelectionModel().clearSelection();
                }

                $network_interaction.handleClicked(this.network, e, element);
                if(this.timer) {
                    clearTimeout(this.timer);
                }
                if (this._endTouchTime
                    && (endTouchTime.getTime() - this._endTouchTime.getTime()) <= 500
                    && $math.getDistance(this._endTouchPoint, endTouchPoint) <= 20) {
                    delete this._endTouchTime;
                    delete this._endTouchPoint;
                    $network_interaction.handleDoubleClicked(this.network, e, element);
                    if(this.timer) {
                        clearTimeout(this.timer);
                    }
                } else {
                    this._endTouchTime = endTouchTime;
                    this._endTouchPoint = endTouchPoint;
                }

            }
        }
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
    }

});
twaver.network.interaction.MSTouchInteraction = function (network) {
    twaver.network.interaction.MSTouchInteraction.superClass.constructor.call(this, network);
    this._pointerMap = {};
    this._pointerIdArray = [];
};
_twaver.ext('twaver.network.interaction.MSTouchInteraction', twaver.network.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener("MSPointerDown", "handleTouchstart", view, this)
        $html.addEventListener("MSPointerMove", "handleTouchmove", view, this)
        $html.addEventListener("MSPointerUp", "handleTouchend", view, this)
        $html.addEventListener("MSPointerCancel", "handleTouchend", view, this)
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener("MSPointerDown", view, this)
        $html.removeEventListener("MSPointerMove", view, this)
        $html.removeEventListener("MSPointerUp", view, this)
        $html.removeEventListener("MSPointerCancel", view, this)
    },
    handleTouchstart: function (e) {
        if (this.network.isFocusOnClick()) {
            twaver.Util.setFocus(this.network._view);
        }

        if (this.network.isSelectingElement() && e.pointerType == e.MSPOINTER_TYPE_MOUSE) {
            //view
            return;
        }

        var currentTouchPoint = this.network.getLogicalPoint(e);
        var currentTouchTime = new Date();


        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this.handle_mouseup(e);
        }

        if (!this._pointerMap[e.pointerId]) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }
        if (this._pointerIdArray.length == 1) {
            var element = this.network.getElementAt(currentTouchPoint);
            this._startTouchElement = element;
            this._startClientPoint = { x: e.clientX, y: e.clientY }

            $network_interaction.handleClicked(this.network, e, element); //click
            if (this._startTouchTime
                && this._startTouchPoint
                && currentTouchTime.getTime() - this._startTouchTime.getTime() <= 500
                && $math.getDistance(this._startTouchPoint, currentTouchPoint) <= 20) {
                $network_interaction.handleDoubleClicked(this.network, e, element); //double click
                this._doubleClick = true;
            } else {
                $html.handle_mousedown(this, e);
                this._startTouchPoint = currentTouchPoint;
                this._startTouchTime = currentTouchTime;
            }
            var sm = this.network.getSelectionModel();
            if (element) {
                if (_twaver.isCtrlDown(e)) {
                    if (sm.contains(element)) {
                        sm.removeSelection(element);
                    } else {
                        sm.appendSelection(element);
                    }
                } else {
                    if (!sm.contains(element)) {
                        sm.setSelection(element);
                    }
                }
            } else {
                if (!_twaver.isCtrlDown(e)) {
                    sm.clearSelection();
                }
            }
        } else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }

    },
    handleTouchmove: function (e) {
        if (this._startTouchPoint == null || this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        }
    },
    handleTouchend: function (e) {
        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        }
        if (this.network.isSelectingElement()) {
            var elements = this.network.getElementsAtRect(this.mark._viewRect, this.getIntersectMode(), this.network.getRectSelectFilter());
            if (elements && elements.size() > 0) {
                var sm = this.network.getSelectionModel();
                var selections = sm.toSelection();
                elements.forEach(function (element) {
                    if (sm.contains(element)) {
                        selections.remove(element);
                    } else {
                        selections.add(element);
                    }
                }, this);
                sm.setSelection(selections);
            }
            this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            this.network.getTopDiv().removeChild(this.mark);
            this.mark = null;
            this.network.setSelectingElement(false);
        }
        if (this._doubleClick) {
            delete this._doubleClick;
            delete this._startTouchPoint;
            delete this._startTouchTime;
        }
        var index = -1;
        for (var i = 0; i < this._pointerIdArray.length; i++) {
            if (this._pointerIdArray[i] == e.pointerId) {
                index = i;
                break;
            }
        }
        if (index >= 0) this._pointerIdArray.splice(index, 1);
        delete this._pointerMap[e.pointerId];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
    },
    handle_mousemove: function (e) {
        if (this._startTouchPoint && this._pointerIdArray.length == 1) {
            this._moveTouchPoint = {
                x: this._startTouchPoint.x + (e.clientX - this._startClientPoint.x) / this.network.getZoom(),
                y: this._startTouchPoint.y + (e.clientY - this._startClientPoint.y) / this.network.getZoom()
            };
            if ($math.getDistance(this._startTouchPoint, this._moveTouchPoint) < 3) return;
            if (this._startTouchElement == null && this.network.isRectSelectEnabled()) {
                if (this.mark) {
                    this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
                } else {
                    this.mark = $html.createDiv();
                    this.network.getTopDiv().appendChild(this.mark);
                    this.network.setSelectingElement(true);
                    this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
                }
                var rect = $math.getRect([this._startTouchPoint, this._moveTouchPoint]);
                $html.setDiv(this.mark, rect,
                this.getIntersectMode() ? this.network.getSelectFillColor() : null,
                this.network.getSelectOutlineWidth(), this.network.getSelectOutlineColor());
            } else {
                var element = this.network.getElementAt(this._moveTouchPoint);
                var xoffset = this._moveTouchPoint.x - this._startTouchPoint.x;
                var yoffset = this._moveTouchPoint.y - this._startTouchPoint.y;
                if (this._startTouchElement == null && !this.network.isRectSelectEnabled()) {
                    var result = this.network.panByOffset(-xoffset, -yoffset);
                } else if (this.network.isMovingElement() || (this._startTouchElement != null && element == this._startTouchElement && this.network.getMovableSelectedElements().contains(element))) {
                    this.network.moveSelectedElements(xoffset, yoffset);
                    if (this.network.isMovingElement()) {
                        this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                    } else {
                        this.network.setMovingElement(true);
                        this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                    }
                }
                this._startClientPoint.x = e.clientX;
                this._startClientPoint.y = e.clientY;
            }
        }
    },
    handle_mouseup: function (e) {
        this.handleTouchend(e);
        this._pointerIdArray = [];
        this._pointerMap = {};
    }
});
var $CanvasUtil = {
    _hitCanvas: null,
    getHitCanvas: function (w, h) {
        if (this._hitCanvas == null) {
            this._hitCanvas = $html.createCanvas();
        }
        if (arguments.length == 0) {
            w = 2;
            h = 2;
        }
        this._hitCanvas.setAttribute("width", '' + w - 1);
        this._hitCanvas.setAttribute("height", '' + h - 1);
        this._hitCanvas.setAttribute("width", '' + w);
        this._hitCanvas.setAttribute("height", '' + h);
        var ctx = this.getCtx(this._hitCanvas);
        ctx.clearRect(0, 0, w, h);
        return this._hitCanvas;
    },
    disposeHitCanvas: function () {
        this._hitCanvas = null;
    },
    getCtx: function (cvs) {
        return cvs.getContext("2d");
    },
    render: function (ctx, fillStyle, strokeStyle) {
        if (fillStyle != undefined) {
            ctx.fillStyle = fillStyle;
            ctx.fill();
        }
        if (strokeStyle != undefined) {
            ctx.strokeStyle = strokeStyle;
            ctx.stroke();
        }
    },
    text: function (ctx, text, x, y, fillStyle, strokeStyle) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (fillStyle != null) {
            ctx.fillStyle = fillStyle;
            ctx.fillText(text, x, y);
        }
        if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.strokeText(text, x, y);
        }
    },
    circle: function (ctx, cx, cy, r, fillStyle, strokeStyle) {
        ctx.arc(cx, cy, r, 0, 2 * Math.PI, true);
        ctx.closePath();
        this.render(ctx, fillStyle, strokeStyle);
    },
    rect: function (ctx, x, y, width, height, fillStyle, strokeStyle) {
        ctx.rect(x, y, width, height);
        ctx.closePath();
        this.render(ctx, fillStyle, strokeStyle);
    },
    OUT_LEFT: 1,
    OUT_TOP: 2,
    OUT_RIGHT: 4,
    OUT_BOTTOM: 8,

    outcode: function (pX, pY, rectX, rectY, rectWidth, rectHeight) {
        var out = 0;
        if (rectWidth <= 0) {
            out |= this.OUT_LEFT | this.OUT_RIGHT;
        } else if (pX < rectX) {
            out |= this.OUT_LEFT;
        } else if (pX > rectX + rectWidth) {
            out |= this.OUT_RIGHT;
        }
        if (rectHeight <= 0) {
            out |= this.OUT_TOP | this.OUT_BOTTOM;
        } else if (pY < rectY) {
            out |= this.OUT_TOP;
        } else if (pY > rectY + rectHeight) {
            out |= this.OUT_BOTTOM;
        }
        return out;
    },

    intersectsLine: function (lineX1, lineY1, lineX2, lineY2, rectX, rectY, rectWidth, rectHeight) {
        var out1, out2;
        if ((out2 = this.outcode(lineX2, lineY2, rectX, rectY, rectWidth, rectHeight)) == 0) {
            return true;
        }
        while ((out1 = this.outcode(lineX1, lineY1, rectX, rectY, rectWidth, rectHeight)) != 0) {
            if ((out1 & out2) != 0) {
                return false;
            }
            if ((out1 & (this.OUT_LEFT | this.OUT_RIGHT)) != 0) {
                var x = rectX;
                if ((out1 & this.OUT_RIGHT) != 0) {
                    x += rectWidth;
                }
                lineY1 = lineY1 + (x - lineX1) * (lineY2 - lineY1) / (lineX2 - lineX1);
                lineX1 = x;
            } else {
                var y = rectY;
                if ((out1 & this.OUT_BOTTOM) != 0) {
                    y += rectHeight;
                }
                lineX1 = lineX1 + (y - lineY1) * (lineX2 - lineX1) / (lineY2 - lineY1);
                lineY1 = y;
            }
        }
        return true;
    }
}


twaver.canvas = {};
twaver.canvas.interaction = {};
twaver.canvas.Network = function (elementBox) {
    twaver.canvas.Network.superClass.constructor.apply(this, arguments);

    /* 
    network hierarchy:
    -> view		   
    -> rootCanvas
    -> topcanvas
    */
    this._rootCanvas = $html.createCanvas();
    this._topCanvas = $html.createCanvas();

    //real size
    this.realWidth = 0;
    this.realHeight = 0;
    this._unionBounds = {
        x : 0, y : 0, width : 0,height : 0
    };
    this._zoom = 1;

    this._elementUIMap = {};

    this._visibleMap = {};

    this.viewRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };

    this.hScrollBarVisible = false;
    this.vScrollBarVisible = false;

    this.markerList = new twaver.List();
    this._topAttachmentList = new twaver.List();

    //this._dirtyRects = new twaver.List();
    this.setElementBox(elementBox ? elementBox : new twaver.ElementBox());

    if (!isNodejs) {
        this._view = $html.createView('hidden');
        this._view.appendChild(this._rootCanvas);
        this._view.appendChild(this._topCanvas);
        
        if($ua.isTouchable){
            if($ua.isMSTouchable){
                this.setMSTouchInteractions();
            }else{
                this.setTouchInteractions();
            }
        }else{
            this.setDefaultInteractions(false);
        }
        this.setToolTipEnabled(twaver.Defaults.NETWORK_TOOLTIP_ENABLED);
    }

    var self = this;
    this._flowLink = function () {
        if (self.isMovingElement() || self.isSelectingElement() || self.isEditingElement() || self._box._layoutMovingElements) {
            return;
        }
        if (!self._flowLinkQuickFinder) {
            self._flowLinkQuickFinder = new twaver.QuickFinder(self._box, "link.flow", "style");
        }
        var links = self._flowLinkQuickFinder.find(true);

        links.forEach(function (link) {
            link._styleMap["link.flow.offset"] = self.getLinkFlowOffset(link);
            var ui = self.getElementUI(link);
            //ui.drawBody();
            ui.invalidate(false);
        });
    };
    twaver.imageUtil.addEventListener(this.invalidateElementUIs, this);
};
_twaver.ext('twaver.canvas.Network', twaver.controls.View, {

    __accessor: ['selectMode', 'makeVisibleOnSelected', 'movableFunction',
    'editPointSize', 'editPointFillColor',
    'scrollBarWidth',
    'editPointOutlineWidth', 'editPointOutlineColor', 'editLineColor',
    'editLineWidth','resizePointSize', 'resizePointFillColor', 'resizePointOutlineWidth',
    'resizePointOutlineColor', 'resizeLineColor', 'resizeLineWidth',
    'rotatePointSize','rotatePointFillColor','rotatePointOffset',
    'rotatePointOutlineWidth','rotatePointOutlineColor', 'rotateScaleFillColor', 'rotateScaleFontColor', 'rotateScaleWidth', 'rotateScaleHeight',
    'selectOutlineColor', 'selectOutlineWidth', 'selectFillColor',
    'lazyMoveOutlineColor', 'lazyMoveOutlineWidth', 'lazyMoveFillColor',
    'rectSelectFilter', 'paddingRight', 'paddingBottom','selectionTolerance'],

    __bool: ['doubleClickToUpSubNetwork', 'doubleClickToSubNetwork', 'doubleClickToEmptySubNetwork',
    'doubleClickToLinkBundle', 'doubleClickToGroupExpand',
    'scrollBarVisible', 'limitViewInCanvas', 'autoValidateCanvasSize',
    'subNetworkAnimate', 'lazyMoveAnimate', 'resizeAnimate',
    'noAgentLinkVisible', 'keyboardRemoveEnabled', 'keyboardSelectEnabled',
    'sendToTopOnSelected', 'lazyMoveFill', 'editingElement', 'rotatingElement','movingElement',
    'selectingElement', 'rectSelectEnabled', 'limitElementInPositiveLocation', 'showRotateScale', 'transparentSelectionEnable','debug','showShadowInEdit'],

    _currentSubNetwork: null,
    _subNetworkAnimate: twaver.Defaults.NETWORK_SUBNETWORK_ANIMATE,
    _scrollBarWidth: 10, //need twaver.Defaults.NETWORK_CANVAS_SCROLLBAR_WIDTH

    _scrollBarVisible: true, //need twaver.Defaults.NETWORK_CANVAS_SCROLLBAR_VISIBLE
    _limitViewInCanvas: true, //need twaver.Defaults.NETWORK_CANVAS_LIMIT_VIEW_IN_CANVAS
    _autoValidateCanvasSize: true, //need twaver.Defaults.NETWORK_CANVAS_AUTO_VALIDATE_CANVAS_SIZE

    _makeVisibleOnSelected: twaver.Defaults.NETWORK_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: twaver.Defaults.NETWORK_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: twaver.Defaults.NETWORK_KEYBOARD_SELECT_ENABLED,
    _rectSelectEnabled: $Defaults.NETWORK_RECT_SELECT_ENABLED,
    _rectSelectFilter: null,
    _elementUIFunction: twaver.Defaults.CANVASUI_FUNCTION,

    _doubleClickToUpSubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
    _doubleClickToSubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
    _doubleClickToEmptySubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
    _doubleClickToLinkBundle: twaver.Defaults.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
    _doubleClickToGroupExpand: twaver.Defaults.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,

    _selectOutlineColor: twaver.Defaults.NETWORK_SELECT_OUTLINE_COLOR,
    _selectOutlineWidth: twaver.Defaults.NETWORK_SELECT_OUTLINE_WIDTH,
    _selectFillColor: twaver.Defaults.NETWORK_SELECT_FILL_COLOR,
    _sendToTopOnSelected: twaver.Defaults.NETWORK_SENDTOTOP_ON_SELECTED,

    _lazyMoveOutlineColor: twaver.Defaults.NETWORK_LAZYMOVE_OUTLINE_COLOR,
    _lazyMoveOutlineWidth: twaver.Defaults.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
    _lazyMoveFillColor: twaver.Defaults.NETWORK_LAZYMOVE_FILL_COLOR,
    _lazyMoveFill: twaver.Defaults.NETWORK_LAZYMOVE_FILL,
    _lazyMoveAnimate: twaver.Defaults.NETWORK_LAZYMOVE_ANIMATE,

    _resizePointSize: twaver.Defaults.NETWORK_RESIZE_POINT_SIZE,
    _resizePointFillColor: twaver.Defaults.NETWORK_RESIZE_POINT_FILL_COLOR,
    _resizePointOutlineColor: twaver.Defaults.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
    _resizePointOutlineWidth: twaver.Defaults.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
    _resizeLineColor: twaver.Defaults.NETWORK_RESIZE_LINE_COLOR,
    _resizeLineWidth: twaver.Defaults.NETWORK_RESIZE_LINE_WIDTH,
    _resizeAnimate: twaver.Defaults.NETWORK_RESIZE_ANIMATE,

    _editPointSize: twaver.Defaults.NETWORK_EDIT_POINT_SIZE,
    _editPointFillColor: twaver.Defaults.NETWORK_EDIT_POINT_FILL_COLOR,
    _editPointOutlineColor: twaver.Defaults.NETWORK_EDIT_POINT_OUTLINE_COLOR,
    _editPointOutlineWidth: twaver.Defaults.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
    _editLineColor: twaver.Defaults.NETWORK_EDIT_LINE_COLOR,
    _editLineWidth: twaver.Defaults.NETWORK_EDIT_LINE_WIDTH,

    _rotatePointSize: twaver.Defaults.NETWORK_ROTATE_POINT_SIZE,
    _rotatePointFillColor: twaver.Defaults.NETWORK_ROTATE_POINT_FILL_COLOR,
    _rotatePointOffset: twaver.Defaults.NETWORK_ROTATE_POINT_OFFSET,
    _rotatePointOutlineWidth: twaver.Defaults.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
    _rotatePointOutlineColor: twaver.Defaults.NETWORK_ROTATE_POINT_OUTLINE_COLOR,

    _rotateScaleWidth: $Defaults.NETWORK_ROTATE_SCALE_WIDTH,
    _rotateScaleHeight: $Defaults.NETWORK_ROTATE_SCALE_HEIGHT,
    _rotateScaleFillColor: $Defaults.NETWORK_ROTATE_SCALE_FILL_COLOR,
    _rotateScaleFontColor: $Defaults.NETWORK_ROTATE_SCALE_FONT_COLOR,

    _limitElementInPositiveLocation: $Defaults.NETWORK_LIMIT_ELEMENT_INPOSITIVE_LOCATION,

    _linkFlowInterval: $Defaults.NETWORK_LINK_FLOW_INTERVAL,
    _selectionTolerance: $Defaults.NETWORK_SELECTION_TOLERANCE,


    _invalidateElementVisibility: false,
    _invalidateViewRectFlag: false,
    _repaintTopFlag: false,
    _invalidateCanvasSizeFlag: false,

    _isEditingElement: false,
    _isRotatingElement: false,
    _isMovingElement: false,
    _isSelectingElement: false,
    _hasEditInteraction: false,
    _showRotateScale: true,
    
    _paddingRight: 0,
    _paddingBottom: 0,
    _transparentSelectionEnable:twaver.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,
    _debug: false,
    _showShadowInEdit:false,

    adjustBounds: function (rect) {
        if (isNodejs) {
            this._rootCanvas = new Canvas(rect.width, rect.height);
            this._topCanvas = new Canvas(rect.width, rect.height);
            this.setViewRect(rect.x, rect.y, rect.width, rect.height);
        } else {
            var b = false;
            var style = this._view.style;
            if (style.left == rect.x + 'px' &&
                style.top == rect.y + 'px' &&
                style.width == rect.width + 'px' &&
                style.height == rect.height + 'px') {
                b = true;
        }
        twaver.canvas.Network.superClass.adjustBounds.apply(this, arguments);
        if (b == true) {
            return;
        }
        var w = this._view.offsetWidth;
        var h = this._view.offsetHeight;
        
        this._rootCanvas.setAttribute("width", w);
        this._rootCanvas.setAttribute("height", h);
        this._topCanvas.setAttribute("width", w);
        this._topCanvas.setAttribute("height", h);
        
        this.setViewRect(this.viewRect.x, this.viewRect.y, w, h);
    }
    if (typeof twaver.gis == 'undefined') {
        twaver.Util.makeHighRes(this._rootCanvas);
        twaver.Util.makeHighRes(this._topCanvas);
    }
    this.invalidateElementVisibility();
},

getLabel: function (element) {
    return element.getStyle('network.label') || element.getName();
},
getBackgroundImage : function(){
 return this._backgroundImage;
},

setBackgroundImage : function(backgroundImage) {
    if (this._backgroundImage != backgroundImage) {
        var oldValue = this._backgroundImage;
        this._backgroundImage = backgroundImage;

        var image = this._backgroundImage;
        if (image && !image._viewRect) {
            if (image.width > 0) {
                image._viewRect = {
                    x : 0,
                    y : 0,
                    width : image.width,
                    height : image.height
                };
                this.validateCanvasSize();
                this.firePropertyChange("backgroundImage", oldValue, image);
            } else {
                var self = this;
                image.onload = function() {
                    image._viewRect = {
                        x : 0,
                        y : 0,
                        width : image.width,
                        height : image.height
                    };
                    self.validateCanvasSize();
                    self.firePropertyChange("backgroundImage", oldValue, image);
                    image.onload = null;
                };
            }

        } else {
            this.firePropertyChange("backgroundImage", oldValue, image);
            this.validateCanvasSize();
        }
        

    }
},
getRootCanvas: function () {
    return this._rootCanvas;
},
getTopCanvas: function () {
    return this._topCanvas;
},
validateImpl: function () {
 !isNodejs && __l.twm(this);
 if (this._invalidateElementVisibility == true) {
    this._invalidateElementVisibility = false;
            //validate ui
            var list = this.getElementBox().getDatas()._as;
            var size = list.length;
            var visibleMap = {};
            var i, n, ui, visibleFunction = this._visibleFunction, defaultLayer = this._box._layerBox.size() === 1 ? this._box._layerBox._defaultLayer : null;
            for (i = 0; i < size; i++) {
                n = list[i];
                visibleMap[n._id] = this.isVisible(n, visibleFunction, defaultLayer);
            }
            if (this._visibleMap) {
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (visibleMap[n._id] !== this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui) {
                            ui.invalidate();
                        }
                    }
                }
            }
            for (i = 0; i < size; i++) {
                n = list[i];
                ui = this._elementUIMap[n._id];
                if (ui) {
                    ui.validate();
                }
            }
            this._visibleMap = visibleMap;
            this.paintRoot();
        }
        this.validateCanvasSize();
        if (this._repaintTopFlag == true) {
            this._repaintTopFlag = false;
            this.paintTopCanvas();
        }
    },
    isLinkFlowEnabled: function () {
        return this._linkFlowEnabled ? true : false;
    },
    setLinkFlowEnabled: function (value) {
        if (value) {
            if (!this._linkFlowEnabled) {
                this._linkFlowEnabled = true;
                this.firePropertyChange('linkFlowEnabled', false, true);
            }
            clearInterval(this._linkFlowTimerId);
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        } else {
            if (this._linkFlowEnabled) {
                this._linkFlowEnabled = false;
                this.firePropertyChange('linkFlowEnabled', true, false);
            }
            clearInterval(this._linkFlowTimerId);
            delete this._linkFlowTimerId;
        }
    },
    getLinkFlowInterval: function () {
        return this._linkFlowInterval;
    },
    setLinkFlowInterval: function (value) {
        var oldValue = this._linkFlowInterval;
        this._linkFlowInterval = value;
        this.firePropertyChange('linkFlowInterval', oldValue, value);

        clearInterval(this._linkFlowTimerId);
        if (this.isLinkFlowEnabled()) {
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        }
    },
    getElementBox: function () {
        return this._box;
    },
    setElementBox: function (elementBox) {
        if (!elementBox) {
            throw "ElementBox can not be null";
        }
        if (this._box === elementBox) {
            return;
        }
        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataBoxChangeListener(this.handleElementBoxChange, this);
            oldValue.removeDataPropertyChangeListener(this.handleElementPropertyChange, this);
            oldValue.removePropertyChangeListener(this.handleElementBoxPropertyChange, this);
            oldValue.removeIndexChangeListener(this.handleIndexChange, this);
            oldValue.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this);
            oldValue.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this);
            oldValue.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = elementBox;
        this._box.addDataBoxChangeListener(this.handleElementBoxChange, this);
        this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this);
        this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this);
        this._box.addIndexChangeListener(this.handleIndexChange, this);
        this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this);
        this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this);
        this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this);
        if (this._flowLinkQuickFinder) {
            this._flowLinkQuickFinder.dispose();
            this._flowLinkQuickFinder = new twaver.QuickFinder(this._box, "link.flow", "style");
        }

        if (this._selectionModel) {
            this._selectionModel._setDataBox(elementBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }
        this._elementUIMap = {};
        this._box.forEach(this.createElementUI, this);
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this.firePropertyChange("elementBox", oldValue, this._box);
    },
    // handle event change.
    handleElementBoxChange: function (e) {
        var element = e.data;
        if (e.kind === 'add') {
            this.createElementUI(element);
            this.invalidateBundleLink(element);
        } else if (e.kind === "remove") {
            var ui = this.getElementUI(element);
            if (ui) {
                ui.dispose();
                delete this._elementUIMap[element.getId()];
                //this._dirtyRects.add(ui._viewRect);
            }
            if (element === this._currentSubNetwork && this._currentSubNetwork != null) {
                this._setCurrentSubNetwork(null);
            }
        } else if (e.kind === 'clear') {
            for(var p in this._elementUIMap){  
              this._elementUIMap[p] && this._elementUIMap[p].dispose && this._elementUIMap[p].dispose();
          } 
          this._elementUIMap = {};
          if (this._currentSubNetwork != null) {
            this._setCurrentSubNetwork(null);
        }
    }
    this.invalidateElementVisibility();
    this.invalidateCanvasSize();
},
handleElementPropertyChange: function (e) {
    var element = e.source;
    var ui = this.getElementUI(element);
    if (ui) {
        ui.handlePropertyChange(e);
    }
    this.invalidateBundleLink(element);
    this.invalidateElementVisibility();
    this.invalidateCanvasSize();
},
handleElementBoxPropertyChange: function () {
    this.invalidateElementVisibility();
},
handleIndexChange: function (c) {
    this.invalidateElementVisibility();
},
handleLayerBoxChange: function () {
    this.invalidateElementVisibility();
},
handleLayerPropertyChange: function (e) {
    if (e.property === "editable") {
        this.invalidateSelectedElementUIs(true);
    }
    this.invalidateElementVisibility();
},
handleLayerHierarchyChange: function () {
    this.invalidateElementVisibility();
},
handleSelectionChange: function (e) {
    e.datas.forEach(function (element) {
        var ui = this.getElementUI(element);
        if (ui) {
            ui.handleSelectionChange(e);
        }
    }, this);

    var element = this.getSelectionModel().getLastData();
    if (element) {
        if (e.kind === 'append' || e.kind === 'set') {
            if (this.isMakeVisibleOnSelected()) {
                this.makeVisible(element);
            }
            if (this.isSendToTopOnSelected()) {
                this.sendToTop(element);
            }
        }
    }
    this.invalidateElementVisibility();
},
sendToTop: function (element) {
    if (!this._box.contains(element)) {
        return;
    }
    var parent = element;
    while (parent._parent && this.isVisible(parent._parent)) {
        parent = parent._parent;
        if (!parent) {
            break;
        }
    }
    if (parent !== element) {
        this._box.adjustElementIndex(parent);
    }
    this._box.adjustElementIndex(element);
},
getScopeRect: function(type) {
    var zoom = this._zoom;
    if(type === 'viewsize') {
        return {x:this._unionBounds.x - this.viewRect.x,y:this._unionBounds.y - this.viewRect.y, width:this._unionBounds.width, height:this._unionBounds.height};
    }else if(type === 'viewport') {
        if (this.viewRect) {
            return _twaver.cloneRect(this.viewRect);
        }
    }else if(type === 'rootcanvas'){
        return {
            x:this.viewRect.x, 
            y: this.viewRect.y, 
            width: (Math.abs(this.viewRect.x - this._unionBounds.x) + this._unionBounds.width) * zoom, 
            height:(Math.abs(this.viewRect.y - this._unionBounds.y) + this._unionBounds.height) * zoom};
        }
        return {x:0, y:0, width:0, height:0};
    },
    //view&&real size
    getViewRect: function () {
        if (this.viewRect) {
            return _twaver.clone(this.viewRect);
        }
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    },
    getCanvasSize: function () {
        return {
            width: this.realWidth,
            height: this.realHeight
        };
    },
    getUnionBounds : function(){
        return this._unionBounds;
    },
    //    setCanvasSize:function(w,h){
    //        this.realWidth =   w*this.getZoom(),
    //        this.realHeight=  h*this.getZoom()
    //    },
    setViewOffSet: function (xoff, yoff) {
        var x = this.viewRect.x;
        var y = this.viewRect.y;
        var w = this.viewRect.width;
        var h = this.viewRect.height;
        this.setViewRect(x + xoff, y + yoff, w, h);
    },
    setViewRect: function (x, y, w, h) {
        if (this.isLimitViewInCanvas() == true) {
            if (x < 0) {
                x = 0;
            }
            if (w > this.realWidth) {
                x = 0;
            } else {
                if (x + w > this.realWidth) {
                    x = this.realWidth - w;
                }
            }
            if (y < 0) {
                y = 0;
            }
            if (h > this.realHeight) {
                y = 0;
            } else {
                if (y + h > this.realHeight) {
                    y = this.realHeight - h;
                }
            }
        }
        var old = this.viewRect;
        if (this.viewRect != null) {
            if (x == this.viewRect.x && y == this.viewRect.y && w == this.viewRect.width && h == this.viewRect.height) {
                return;
            }
        }
        this.viewRect = {
            x: x,
            y: y,
            width: w,
            height: h
        };
        this.firePropertyChange("viewRect", old, this.viewRect);
        this.invalidateElementVisibility();
    },
    //scroll bar 
    isHScrollBarVisible: function () {
        return this.hScrollBarVisible;
    },
    setHScrollBarVisible: function (v) {
        this.hScrollBarVisible = v;
    },
    isVScrollBarVisible: function () {
        return this.vScrollBarVisible;
    },
    setVScrollBarVisible: function (v) {
        this.vScrollBarVisible = v;
    },
    dispose: function() {
        twaver.imageUtil.removeEventListener(this.invalidateElementUIs, this);
        for (var o in this._elementUIMap) {
            var ui = this._elementUIMap[o];
            if(ui.curInterval) {
                clearTimeout(ui.curInterval);
            }
        }
        this.setInteractions(null);
    },
    //handle validate
    invalidateElementVisibility: function () {
        if (!this._invalidateElementVisibility) {
            this._invalidateElementVisibility = true;
            this.invalidate();
        }
    },
    repaintTopCanvas: function () {
        if (!this._repaintTopFlag) {
            this._repaintTopFlag = true;
            this.invalidate();
        }
    },
    invalidateCanvasSize: function (delay) {
        if (!this._invalidateCanvasSizeFlag) {
            this._invalidateCanvasSizeFlag = true;
            this.invalidate();
        }
        /*
        if (delay == null) {
        delay = 300;
        }
        if (this._invalidateCanvasSizeFlag == false) {
        this._invalidateCanvasSizeFlag = true;
        _twaver.callLater(this.validateCanvasSize, this, null, delay);
        }
        */
    },
    validateCanvasSize: function () {
        if (this._invalidateCanvasSizeFlag == false) {
            return;
        }
        this._invalidateCanvasSizeFlag = false
        this._validateCanvasSize();
    },
    _validateCanvasSize: function () {
        if (this.isMovingElement()) {
            return;
        }
        if (this.isAutoValidateCanvasSize() == false) {
            this.realWidth = 0;
            this.realHeight = 0;
            this._unionBounds = {
                x : 0, y : 0,width : 0,height : 0
            };
            return;
        }
        var list = this.getElementBox().getDatas();
        var size = list.size();
        if (size > 0) {
            var r = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            for (var i = 0; i < size; i++) {
                var n = list.get(i);
                if (this._visibleMap[n._id]) {
                    var ui = this._elementUIMap[n._id];
                    if (ui) {
                        r = $math.unionRect(r, ui._viewRect);
                    }
                }
            }
            
            
            var img = this.getBackgroundImage();
            if (img) {
                r = $math.unionRect(r, img._viewRect);
            }

            // if (r.x < 0) {
            //     r.width += r.x;
            //     r.x = 0;
            // }
            // if (r.y < 0) {
            //     r.height += r.y;
            //     r.y = 0;
            // }
            if (this.realWidth == (r.x + r.width) * this.getZoom() && this.realHeight == (r.y + r.height) * this.getZoom()) {
                return;
            }
            var zoom = this.getZoom();
            this.realWidth = (r.x + r.width) * zoom + this._paddingRight;
            this.realHeight = (r.y + r.height) * zoom + this._paddingBottom;
            
            this._unionBounds = {
                x : r.x * zoom, y : r.y * zoom ,width : r.width * zoom + this._paddingRight,height : r.height * zoom + this._paddingRight
            };
            
        } else {
            this.realWidth = 0;
            this.realHeight = 0;
            this._unionBounds = {
                x : 0, y : 0,width : 0,height : 0
            };
        }
        this.setViewRect(this.viewRect.x, this.viewRect.y, this.viewRect.width, this.viewRect.height);
        this.firePropertyChange("canvasSizeChange", null, this.viewRect);
        ////////////////////fire event/////////////////////////////
    },
    //element ui
    getElementUI: function (data) {
        if (data == null) {
            return null;
        }
        return this._elementUIMap[data._id];
    },
    createElementUI: function (data) {
        var ui = this._elementUIMap[data.getId()];
        if (!ui) {
            ui = this._elementUIFunction(this, data);
            if (ui) {
                this._elementUIMap[data.getId()] = ui;
            }
        }
    },
    getElementUIFunction: function () {
        return this._elementUIFunction;
    },
    setElementUIFunction: function (value) {
        if (!value) {
            throw "ElementUIFunction can not be null";
        }
        if (this._elementUIFunction === value) {
            return;
        }
        var oldValue = this._elementUIFunction;
        this._elementUIFunction = value;
        this.firePropertyChange("elementUIFunction", oldValue, value);

        if (!this._box.isEmpty()) {
            this._elementUIMap = {};
            this._box.forEach(this.createElementUI, this);
            this.invalidateElementVisibility();
            this.invalidateCanvasSize();
        }
    },
    invalidateElementUI: function (element, checkAttachments) {
        var ui = this.getElementUI(element);
        if (ui) {
            ui.invalidate(checkAttachments);
        }
    },
    invalidateElementUIs: function (checkAttachments) {
        for (var o in this._elementUIMap) {
            var ui = this._elementUIMap[o];
            ui.invalidate(checkAttachments);
        }
    },
    invalidateSelectedElementUIs: function (checkAttachments) {
        this.getSelectionModel().getSelection().forEach(function (element) {
            this.invalidateElementUI(element, checkAttachments);
        }, this);
    },
    invalidateBundleLink: function (element) {
        if (element instanceof twaver.Link && element._bundleLinks) {
            var elementUIMap = this._elementUIMap;
            element._bundleLinks.forEachSiblingLink(function (link) {
                if (link !== element) {
                    var ui = elementUIMap[link._id];
                    if (ui) {
                        ui.invalidate(false);
                    }
                }
            }, this);
        }
    },

    //paint
    paintRoot: function () {
        var ctx = this._rootCanvas.getContext("2d");
        ctx.clearRect(0, 0, this._rootCanvas.width, this._rootCanvas.height);
        this.visibleList = new twaver.List();
        this._topAttachmentList = new twaver.List();
        if (this.getElementBox() == null) {
            return;
        }
        $backgroundUI.draw(ctx, this);
        var list = this.getElementBox().getDatas()._as;
        var size = list.length;
        ctx.save();
        ctx.scale(this.getZoom(), this.getZoom());
        ctx.translate(-this.viewRect.x / this.getZoom(), -this.viewRect.y / this.getZoom());
        this.paintBottom(ctx);
        var v = {
            x: this.viewRect.x / this.getZoom(),
            y: this.viewRect.y / this.getZoom(),
            width: this.viewRect.width / this.getZoom(),
            height: this.viewRect.height / this.getZoom()
        };
        
        var img = this.getBackgroundImage();
        var backgroundRect = this.getBackgroundImageRect();
        if(img instanceof Image){
         if(backgroundRect){
            ctx.drawImage(img,backgroundRect.x,backgroundRect.y,backgroundRect.width,backgroundRect.height);
        }else {
        	ctx.drawImage(img, 0,0 ,img.width,img.height);
        }
        img._viewRect = {
          x : 0 ,
          y : 0 ,
          width : img.width,
          height : img.height
      };
  }
  if(typeof img == "string") {
   var imageAsset =  _twaver.getImageAsset(img);

   var rect = {x: 0, y: 0, width: imageAsset.getWidth(), height: imageAsset.getHeight()};
   drawImage(ctx, img, null, rect, null, this);
}

var layerBox = this._box._layerBox,
i, n, ui, att;

if (layerBox.size() === 1) {
    for (i = 0; i < size; i++) {
        n = list[i];
        if (this._visibleMap[n._id]) {
            ui = this._elementUIMap[n._id];
            if (ui != null && this._isInView(ui, v)) {
                ui.paint(ctx);
                ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                this.visibleList.add(n);
            }else{
                ui.setAttachmentVisible && ui.setAttachmentVisible(false);
            }
        }
    }
} else {
    layerBox.forEachByDepthFirst(function (layer) {
        for (i = 0; i < size; i++) {
            n = list[i];
            if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                ui = this._elementUIMap[n._id];
                if (ui != null && this._isInView(ui, v)) {
                    ui.paint(ctx);
                    ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                    this.visibleList.add(n);
                }else{
                    ui.setAttachmentVisible && ui.setAttachmentVisible(false);
                }
            }
        }
    }, null, this);
}
size = this._topAttachmentList.size();
for (i = 0; i < size; i++) {
    att = this._topAttachmentList.get(i);
    att.getElementUI().paintAttachment(ctx, att);
}

        // paint license compoent
        if(this._xyz){
        	var ld = this._xyz;
        	var mark = ld.markText;
        	var t = ld.type;
        	var expired = ld.expired;
        	var text = ld.innerHTML;
        	var x = 0;
        	var y = 0;
        	var size;
        	var scale = 1;
        	var r = this.viewRect;
            ctx.translate(this.viewRect.x / this.getZoom(), this.viewRect.y / this.getZoom());
            ctx.scale(1/this.getZoom(), 1/ this.getZoom());
            var zoom = this.getZoom();
            if ((mark != undefined && mark != null && mark != '') || t == '2') {
                ctx.font = '15px Arial sans-serif';
                size = _twaver.g.getTextSize(ctx.font,text);
                ctx.fillStyle = 'red';
                x =  r.width - size.width;
                y =  r.height -20;
            }else{
                ctx.font = '10px Arial sans-serif';
                size = _twaver.g.getTextSize(ctx.font,text); 
                x =  r.width / 2 - size.width / 2;
                y =  r.height / 2;
            }
            ctx.fillText(text,x,y);
            
        }
        
        
        
        ctx.restore();
    },
    paintBottom: function (ctx) {
    },
    _isInView: function (ui, realRect) {
        return $math.intersects(realRect, ui._viewRect);
    },
    paintTopCanvas: function () {
        var ctx = this._topCanvas.getContext("2d");
        ctx.clearRect(0, 0, this._topCanvas.width, this._topCanvas.height);
        this.paintMarker(ctx);
    },
    paintMarker: function (ctx) {
        var size = this.markerList.size();
        for (var i = 0; i < size; i++) {
            var marker = this.markerList.get(i);
            marker.paint(ctx);
        }
    },
    getLayerByElement: function (element) {
        return this._box.getLayerBox().getLayerByElement(element);
    },
    //location 
    getLogicalPoint: function (e) {
        var point;
        if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
            var bound = this._view.getBoundingClientRect();
            var touch = e.changedTouches[0];
            var scrollLeft = $ua.isAndroid ? 0 : $touch.scrollLeft();
            var scrollTop = $ua.isAndroid ? 0 : $touch.scrollTop();
            point = { x: (touch.clientX + this.viewRect.x - bound.left - scrollLeft) / this._zoom,
                y: (touch.clientY + this.viewRect.y - bound.top - scrollTop) / this._zoom
            };
            return point;
        }

        if ($ua.isFirefox) {
            point = {
                x: (e.layerX + this.viewRect.x) / this.getZoom(),
                y: (e.layerY + this.viewRect.y) / this.getZoom()
            };
        } else {
            point = {
                x: (e.offsetX + this.viewRect.x) / this.getZoom(),
                y: (e.offsetY + this.viewRect.y) / this.getZoom()
            };
        }
        return point;
    },
    getElementAt: function (e, selectable) {
        if (this.visibleList == null) {
            return null;
        }
        if (arguments.length === 1) {
            selectable = true;
        }
        var point, element;
        if (e.target) {
            point = this.getLogicalPoint(e);
        } else if(e.event) {
            if(e.event.target) {
                point = this.getLogicalPoint(e.event);
            }
        } else {
            point = e;
        }

        if (this._topAttachmentList != null) {
            var tsize = this._topAttachmentList.size();
            for (var j = tsize - 1; j >= 0; j--) {
                var att = this._topAttachmentList.get(j);
                element = att.getElement();
                if ((!selectable || this.isSelectable(element)) && att.hit(point.x, point.y)) {
                    return element;
                }
            }
        }
        if (this.visibleList != null) {
            var size = this.visibleList.size();
            for (var i = size - 1; i >= 0; i--) {
                var n = this.visibleList.get(i);
                var ui = this.getElementUI(n);
                if ((!selectable || this.isSelectable(n)) && ui && ui.hit(point.x, point.y)) {
                    return n;
                }
            }
        }
        return null;
    },
    hitTest: function (e) {
        var element = this.getElementAt(e);
        if (!element) {
            return null;
        }
        var elementUI = this.getElementUI(element);
        if (!elementUI) {
            return null;
        }
        var point;
        if (e.target) {
            point = this.getLogicalPoint(e);
        } else {
            point = e;
        }
        return elementUI.hitTest(point.x, point.y);
    },
    getElementsAtRect: function (rect, intersectMode, filter, selectable) {
        var list = new twaver.List();
        if (this.visibleList == null) {
            return list;
        }
        selectable = selectable === undefined ? true : selectable;
        var size = this.visibleList.size();
        for (var i = size - 1; i >= 0; i--) {
            var n = this.visibleList.get(i);
            var ui = this.getElementUI(n);
            if (ui && (!filter || filter(ui._element)) && ((selectable && this.isSelectable(ui._element)) || !selectable)) {
                if (intersectMode) {
                    if (ui.intersects(rect)) {
                        list.add(n);
                    }
                } else {
                    if ($math.contains(rect, ui.getViewRect())) {
                        list.add(n);
                    }
                }
            }
        }
        return list;
    },
    getPosition: function (position, obj, tarSize, xoffset, yoffset) {
        var point;
        var ui = obj instanceof twaver.canvas.ElementUI ? obj : this.getElementUI(obj);
        if (ui) {
            if (position === 'from' || position === 'to') {
                if (ui.getFromPosition) {
                    point = position === 'from' ? ui.getFromPosition(xoffset, yoffset) : ui.getToPosition(xoffset, yoffset);
                    if (point) {
                        if(!tarSize){
                            return point;
                        }
                        return {
                            x: point.x - tarSize.width / 2,
                            y: point.y - tarSize.height / 2
                        };
                    }
                }
            } else if (position === 'hotspot') {
                point = ui.getHotSpot();
            } else {
                point = $position.get(position, ui.getBodyRect(), tarSize);
            }
        }
        if (!point && obj.getRect) {
            point = $position.get(position, obj.getRect(), tarSize);
        }
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        throw "position '" + position + "' object '" + obj + "'";
    },
    isValidEvent: function (e) {
        if (!e) {
            return false;
        }
        var x;
        var y;
        if (e.currentTarget === this._view) {
            if ($ua.isFirefox) {
                x = e.layerX;
                y = e.layerY;
            } else {
                x = e.offsetX;
                y = e.offsetY;
            }
            if (this.isHScrollBarVisible() == true) {
                if (y >= this.viewRect.height - this.getScrollBarWidth()) {
                    return false;
                }
            }
            if (this.isVScrollBarVisible() == true) {
                if (x >= this.viewRect.width - this.getScrollBarWidth()) {
                    return false;
                }
            }
        }
        return true;
    },
    //marker
    addMarker: function (marker) {
        this.markerList.add(marker);
        this.repaintTopCanvas();
    },
    removeMarker: function (marker) {
        this.markerList.remove(marker);
        this.repaintTopCanvas();
    },
    clearMarker: function () {
        this.markerList.clear();
        this.repaintTopCanvas();
    },
    //move
    isMovable: function (element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (element instanceof twaver.Link) {
            return false;
        }
        if (this._movableFunction && !this._movableFunction(element)) {
            return false;
        }
        return this.getLayerByElement(element).isMovable();
    },
    hasMovableSelectedElements: function () {
        var selection = this.getSelectionModel().getSelection();
        for (var i = 0; i < selection.size(); i++) {
            var element = selection.get(i);
            if (this.isMovable(element)) {
                return true;
            }
        }
        return false;
    },
    getMovableSelectedElements: function () {
        return this.getSelectionModel().toSelection(function (element) {
            return this.isMovable(element);
        }, this);
    },
    moveSelectedElements: function (xoffset, yoffset, animate, finishFunction) {
        if (xoffset === 0 && yoffset === 0) {
            return;
        }
        var bound = this.getMovableSelectedElementsRect();
        if (bound == null) {
            return;
        }
        if (this._limitElementInPositiveLocation) {
            if (bound.x + xoffset < 0) {
                xoffset = -bound.x;
            }
            if (bound.y + yoffset < 0) {
                yoffset = -bound.y;
            }
        }
        twaver.Util.moveElements(this.getMovableSelectedElements(), xoffset, yoffset, animate, finishFunction, this);
    },
    getMovableSelectedElementsRect: function () {
        var elements = this.getMovableSelectedElements();
        if (elements.size() === 0) {
            return null;
        }
        var unionRect = null;
        for (var i = 0, n = elements.size(); i < n; i++) {
            var element = elements.get(i);
            if (element instanceof $Node) {
                var ui = this.getElementUI(element);
                if (ui) {
                    unionRect = $math.unionRect(unionRect, ui.getViewRect());
                }
            }
        }
        return unionRect;
    },

    isVisible: function (element, visibleFunction, defaultLayer) {
        if (!this._box.contains(element)) {
            return false;
        }
        if(!element.isVisible()) {
            return false;
        }
        if (arguments.length !== 3) {
            visibleFunction = this._visibleFunction;
        }
        if (visibleFunction && !visibleFunction(element)) {
            return false;
        }
        if (!(defaultLayer || this._box._layerBox.getLayerByElement(element))._visible) {
            return false;
        }
        if ($element.getSubNetwork(element) !== this._currentSubNetwork) {
            return false;
        }
        if (element instanceof twaver.Link) {
            if (!this._noAgentLinkVisible) {
                if (!element._fromAgent || !element._toAgent) {
                    return false;
                }
                if (!this.isVisible(element._fromAgent, visibleFunction, defaultLayer) || !this.isVisible(element._toAgent, visibleFunction, defaultLayer)) {
                    return false;
                }
            }
            if (element.getBundleIndex() > 0 && element.getBundleCount() > 1 && !element.getStyle("link.bundle.expanded")) {
                return false;
            }
        } else {
            var parent = element._parent;
            while (parent && !parent.ISubNetwork) {
                if (parent instanceof twaver.Group) {
                    if (!parent.isExpanded() || !this.isVisible(parent, visibleFunction, defaultLayer)) {
                        return false;
                    }
                }
                parent = parent._parent;
            }
        }
        if (element.IDummy) {
            return false;
        }
        return true;
    },
    getVisibleFunction: function () {
        return this._visibleFunction;
    },
    setVisibleFunction: function (value) {
        var oldValue = this._visibleFunction;
        this._visibleFunction = value;
        this.firePropertyChange("visibleFunction", oldValue, value);
        this.invalidateElementVisibility();
    },
    isEditable: function (element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (this._editableFunction && !this._editableFunction(element)) {
            return false;
        }
        return this.getLayerByElement(element).isEditable();
    },
    getEditableFunction: function () {
        return this._editableFunction;
    },
    setEditableFunction: function (value) {
        var oldValue = this._editableFunction;
        this._editableFunction = value;
        this.firePropertyChange("editableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    isRotatable: function (element) {
        if (this._rotatableFunction && !this._rotatableFunction(element)) {
            return false;
        }
        return true;
    },
    getRotatableFunction: function () {
        return this._rotatableFunction;
    },
    setRotatableFunction: function (value) {
        var oldValue = this._rotatableFunction;
        this._rotatableFunction = value;
        this.firePropertyChange("rotatableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    isLinkable: function (node) {
        return (this._linkableFunction == null || this._linkableFunction(node));
    },
    getLinkableFunction: function () {
        return this._linkableFunction;
    },
    setLinkableFunction: function (value) {
        var oldValue = this._linkableFunction;
        this._linkableFunction = value;
        this.firePropertyChange("linkableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    onShareSelectionModelChanged: function () {
        this.invalidateElementUIs();
    },
    //paint attribute
    getShadowColor: function (element) {
        var color = element.getStyle('shadow.color');
        if (!color && this.isSelected(element) && element.getStyle('select.style') === 'shadow') {
            return element.getStyle('select.color')
        }
        return color;
    },
    getSelectColor: function (element) {
        return element.getStyle('select.color');
    },
    getAlarmLabel: function (element) {
        var severity = element.getAlarmState().getHighestNewAlarmSeverity();
        if (severity) {
            var label = element.getAlarmState().getNewAlarmCount(severity) + severity.nickName;
            if (element.getAlarmState().hasLessSevereNewAlarms()) {
                label += "+";
            }
            return label;
        }
        return null;
    },
    getLinkHandlerLabel: function (link) {
        if (link.isBundleAgent()) {
            return "+(" + link.getBundleCount() + ")";
        }
        return null;
    },

    //interaction 
    setInteractions: function (interactions) {
        var oldValue = this._interactions;
        if (oldValue) {
            oldValue.forEach(function (handler) {
                handler.tearDown();
            });
        }
        this._interactions = interactions;
        if (interactions) {
            interactions.forEach(function (handler) {
                handler.setUp();
            });
        }
        this.invalidateSelectedElementUIs(true);
        this.firePropertyChange("interactions", oldValue, interactions);
    },
    getInteractions: function () {
        return this._interactions;
    },
    setDefaultInteractions: function (lazyMode, moveLink) {
        var interactions = [
        new twaver.canvas.interaction.DefaultInteraction(this),
        new twaver.canvas.interaction.SelectInteraction(this),
        new twaver.canvas.interaction.MoveInteraction(this, lazyMode),
        new twaver.canvas.interaction.ScrollInteraction(this)
        ];

        if(moveLink) {
            interactions.push(new twaver.canvas.interaction.MoveLinkInteraction(this, lazyMode));
        }
        this.setInteractions(interactions);
    },
    setTouchInteractions: function () {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.SelectInteraction(this),
            new twaver.canvas.interaction.MoveInteraction(this, false),
            new twaver.canvas.interaction.ScrollInteraction(this),
            new twaver.canvas.interaction.TouchInteraction(this)
            ]);
    },
    setMSTouchInteractions: function () {
        this.setInteractions([
            new twaver.canvas.interaction.ScrollInteraction(this),
            new twaver.canvas.interaction.MSTouchInteraction(this)

            ]);
    },
    setEditInteractions: function (lazyMode) {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.SelectInteraction(this),
            new twaver.canvas.interaction.EditInteraction(this, lazyMode),
            new twaver.canvas.interaction.MoveInteraction(this, lazyMode),
            new twaver.canvas.interaction.ScrollInteraction(this)
            ]);
    },
    setCreateElementInteractions: function (type) {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.CreateElementInteraction(this, type)
            ]);
    },
    setCreateLinkInteractions: function (type) {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.CreateLinkInteraction(this, type),
            new twaver.canvas.interaction.ScrollInteraction(this)
            ]);
    },
    setCreateShapeLinkInteractions: function (type) {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.CreateShapeLinkInteraction(this, type),
            new twaver.canvas.interaction.ScrollInteraction(this)
            ]);
    },
    setCreateShapeNodeInteractions: function (type) {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.CreateShapeNodeInteraction(this, type),
            new twaver.canvas.interaction.ScrollInteraction(this)
            ]);
    },
    setPanInteractions: function () {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.PanInteraction(this),
            new twaver.canvas.interaction.ScrollInteraction(this)
            ]);
    },
    setMagnifyInteractions: function () {
        this.setInteractions([
            new twaver.canvas.interaction.DefaultInteraction(this),
            new twaver.canvas.interaction.SelectInteraction(this),
            new twaver.canvas.interaction.MoveInteraction(this),
            new twaver.canvas.interaction.ScrollInteraction(this),
            new twaver.canvas.interaction.MagnifyInteraction(this)
            ]);
    },
    hasEditInteraction: function () {
        return this._hasEditInteraction;
    },
    setHasEditInteraction: function (value) {
        var oldValue = this._hasEditInteraction;
        this._hasEditInteraction = value;
        this.firePropertyChange("hasEditInteraction", oldValue, value);
    },
    addElementByInteraction: function (element) {
        if (!element.getParent()) {
            element.setParent(this._currentSubNetwork);
        }
        this._box.add(element);
        this.getSelectionModel().setSelection(element);
        this.fireInteractionEvent({ kind: 'createElement', element: element });
    },
    //tooltip
    getToolTip: function (element) {
        if (element) {
            var tooltip = element.getToolTip();
            if (tooltip) {
                return tooltip;
            }
            return element.getName();
        }
        return null;
    },
    isToolTipEnabled: function () {
        return this._toolTipEnabled ? true : false;
    },
    setToolTipEnabled: function (value) {
        this._toolTipEnabled = value;
        if (value) {
            if (!this._toolTipListener) {
                var self = this;
                this._toolTipListener = function (e) {
                    if (self.isMovingElement()) {
                        $popup.hideToolTip();
                        return;
                    }
                    var element = self.getElementAt(e);
                    if (self._preElement === element) {
                        return;
                    }
                    self._preElement = element;
                    if (element) {
                        var toolTip = self.getToolTip(element);
                        $popup.showToolTip({ x: e.pageX, y: e.pageY }, toolTip);
                        var toolTipDiv = $popup.getToolTipDiv();

                        var toolTipDiv = $popup.getToolTipDiv();
                        if (toolTipDiv.children.length > 0) {
                            var viewBounds = self._view.getBoundingClientRect();
                            var toolTipBounds = toolTipDiv.getBoundingClientRect();
                            if (toolTipBounds.width + toolTipBounds.left > viewBounds.width + viewBounds.left) {
                                toolTipDiv.style.left = (viewBounds.width + viewBounds.left - toolTipBounds.width + (document.documentElement.scrollLeft || document.body.scrollLeft)) + "px";
                            }
                            if (toolTipBounds.height + toolTipBounds.top > viewBounds.height + viewBounds.top) {
                                toolTipDiv.style.top = (viewBounds.height + viewBounds.top - toolTipBounds.height + (document.documentElement.scrollTop || document.body.scrollTop)) + "px";
                            }
                        }
                        return;
                    }
                    $popup.hideToolTip();
                };
                this._view.addEventListener('mousemove', this._toolTipListener, false);
                this.firePropertyChange('toolTipEnabled', false, true);
            }
        } else {
            if (this._toolTipListener) {
                $popup.hideToolTip();
                this._view.removeEventListener('mousemove', this._toolTipListener, false);
                delete this._toolTipListener;
                this.firePropertyChange('toolTipEnabled', true, false);
            }
        }
    },
    //zoom
    setZoom: function (z) {
    	z = this.checkZoom(z);
        var old = this._zoom;
        if (this._zoom == z) {
            return;
        }
        var center = {
            x: (this.viewRect.x + this.viewRect.width / 2) / this.getZoom() * z,
            y: (this.viewRect.y + this.viewRect.height / 2) / this.getZoom() * z
        };
        this._zoom = z;
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this.validateCanvasSize();
        this.setViewRect(center.x - this.viewRect.width / 2, center.y - this.viewRect.height / 2, this.viewRect.width, this.viewRect.height);
        this.firePropertyChange("zoom", old, this._zoom);
    },
    getZoom: function () {
        return this._zoom;
    },
    //setTouchZoom
    setTouchZoom: function(z){
        this.setZoom(z, false);
    },
    zoomOverview: function (animate) {
        if (this.realWidth <= 0 || this.realHeight <= 0) {
            return;
        }
        var rw = this.realWidth / this.getZoom();
        var rh = this.realHeight / this.getZoom();
        var wzoom = this.viewRect.width / rw;
        var hzoom = this.viewRect.height / rh;
        var min = Math.min(wzoom, hzoom);
        this.setZoom(min);
    },
    zoomReset: function () {
        this.setZoom(1);
    },
    zoomIn: function () {
        this.setZoom(this.getZoom() * 1.2);
    },
    zoomOut: function () {
        this.setZoom(this.getZoom() / 1.2);
    },
    //subnetwork
    upSubNetwork: function (animate, finishFunction) {
        if (this._currentSubNetwork) {
            this.setCurrentSubNetwork($element.getSubNetwork(this._currentSubNetwork), animate, finishFunction);
        }
    },
    getCurrentSubNetwork: function () {
        return this._currentSubNetwork;
    },
    setCurrentSubNetwork: function (currentSubNetwork, animate, finishFunction) {
        twaver.animate.AnimateManager.endAnimate();
        if (animate) {
            if (this._currentSubNetwork === currentSubNetwork) {
                return;
            }
            if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
                throw currentSubNetwork + " is not contained in this network's elementBox";
            }
            var animateSubNetwork = new twaver.animate.AnimateSubNetwork(this, currentSubNetwork, finishFunction);
            twaver.animate.AnimateManager.start(animateSubNetwork);
        } else {
            this._setCurrentSubNetwork(currentSubNetwork);
            if (finishFunction) {
                finishFunction();
            }
        }
    },
    _setCurrentSubNetwork: function (currentSubNetwork) {
        if (this._currentSubNetwork === currentSubNetwork) {
            return;
        }
        if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
            throw currentSubNetwork + " is not contained in this network's elementBox";
        }
        var oldValue = this._currentSubNetwork;
        this._currentSubNetwork = currentSubNetwork;
        this.firePropertyChange("currentSubNetwork", oldValue, currentSubNetwork);
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
    },
    makeVisible: function (element) {
        var ui = this.getElementUI(element);
        if (!ui) {
            return;
        }
        var subNetwork = $element.getSubNetwork(element);
        if (subNetwork !== this._currentSubNetwork) {
            var self = this;
            this.setCurrentSubNetwork(subNetwork, this.isSubNetworkAnimate(), function () {
                _twaver.callLater(self.makeVisible, self, [element]);
            });
            return;
        }
        var e = element;
        while ((e = e.getParent()) && e !== subNetwork) {
            if (e instanceof twaver.Group) {
                e.setExpanded(true);
            }
        }
        var bounds = ui.getViewRect();
        if (!bounds) {
            return;
        }
        var vr = {
            x: bounds.x * this.getZoom(),
            y: bounds.y * this.getZoom(),
            width: bounds.width * this.getZoom(),
            height: bounds.height * this.getZoom()
        };

        if (!$math.intersects(this.viewRect, vr)) {
            if (this.isVisible(element)) {
                _twaver.callLater(this.centerByLogicalPoint, this, [vr.x + vr.width / 2, vr.y + vr.height / 2]);
            }
        }
    },
    centerByLogicalPoint: function (x, y, animate) {
        var xoff = x - this.viewRect.width / 2;
        var yoff = y - this.viewRect.height / 2;
        this.setViewRect(xoff, yoff, this.viewRect.width, this.viewRect.height);
    },
    panByOffset: function (xoff, yoff) {
        this.setViewOffSet(xoff, yoff);
    },
    getIconsNames: function (element) {
        return element.getStyle('icons.names');
    },
    getIconsColors: function (element) {
        return element.getStyle('icons.colors');
    },
    getLinkFlowStepping: function (link) {
        var stepping = parseInt(link.getStyle("link.flow.stepping"));
        if (!stepping) {
            stepping = $Defaults.NETWORK_LINK_FLOW_STEPPING;
        }
        return stepping;
    },
    getLinkFlowOffset: function (link) {
        var currentOffset = link.getStyle("link.flow.offset");
        if (isNaN(currentOffset)) {
            currentOffset = 0;
        }
        return currentOffset + this.getLinkFlowStepping(link);
    },
    toCanvas: function (w, h, c, zoom, dx, dy) {
        if (!c) {
            c = $html.createCanvas();
        }
        c.setAttribute('width', w);
        c.setAttribute('height', h);
        if (c._viewRect) {
            c._viewRect.width = w;
            c._viewRect.height = h;
        } else {
            c._viewRect = { x: 0, y: 0, width: w, height: h };
        }

        var ctx = c.getContext('2d');
        ctx.translate(-dx, -dy);
        ctx.clearRect(0, 0, w, h);
        $backgroundUI.draw(ctx, this);

        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }
        var sx = w / this.realWidth * this.getZoom();
        var sy = h / this.realHeight * this.getZoom();
        // ctx.scale(sx, sy);
        ctx.scale(zoom, zoom);

        var list = this.getElementBox().getDatas()._as;
        var size = list.length;
        this._topAttachmentList = new twaver.List();
        var layerBox = this.getElementBox().getLayerBox(),
        layers = layerBox.getRoots(),
        layerSize = layers.size(),
        j, layer, i, n, ui, att;

        if (layerSize === 1) {
            for (i = 0; i < size; i++) {
                n = list[i];
                if (this._visibleMap[n._id]) {
                    ui = this._elementUIMap[n._id];
                    if (ui != null) {
                        ui.paint(ctx);
                    }
                }
            }
        } else {
            for (j = 0; j < layerSize; j++) {
                layer = layers.get(j);
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui != null) {
                            ui.paint(ctx);
                        }
                    }
                }
            }
        }
        size = this._topAttachmentList.size();
        for (i = 0; i < size; i++) {
            att = this._topAttachmentList.get(i);
            att.getElementUI().paintAttachment(ctx, att);
        }
        return c;
    },
    toCanvasByRegion: function (rect, scale, c) {
        if (!c) {
            c = $html.createCanvas();
        }
        var width = rect.width * scale;
        var height = rect.height * scale;
        c.setAttribute('width', width);
        c.setAttribute('height', height);
        if (c._viewRect) {
            c._viewRect.width = width;
            c._viewRect.height = height;
        } else {
            c._viewRect = { x: 0, y: 0, width: width, height: height };
        }
        var ctx = c.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        $backgroundUI.draw(ctx, this);
        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }

        ctx.save();
        ctx.scale(scale, scale);
        ctx.beginPath();

        ctx.translate(-rect.x, -rect.y);

        var list = this.getElementBox().getDatas()._as;
        var size = list.length;

        this._topAttachmentList = new twaver.List();
        
        var img = this.getBackgroundImage();
        if (img && img._viewRect && $math.intersects(rect, img._viewRect)) {
           var rect = $math.intersection(rect,img._viewRect);
           var r = img._viewRect;
           try {
            ctx.drawImage(img, r.x,r.y,r.width,r.height);
        } catch (e) {
        }
    }

    var layerBox = this.getElementBox().getLayerBox(),
    layers = layerBox.getRoots(),
    layerSize = layers.size(),
    j, layer, i, n, ui, att;
    if (layerSize === 1) {
        for (i = 0; i < size; i++) {
            n = list[i];
            if (this._visibleMap[n._id]) {
                ui = this._elementUIMap[n._id];
                if (ui != null && $math.intersects(rect, ui._viewRect)) {
                    ui.paint(ctx);
                }
            }
        }
    } else {
        for (j = 0; j < layerSize; j++) {
            layer = layers.get(j);
            for (i = 0; i < size; i++) {
                n = list[i];
                if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                    ui = this._elementUIMap[n._id];
                    if (ui != null && $math.intersects(rect, ui._viewRect)) {
                        ui.paint(ctx);
                    }
                }
            }
        }
    }
    size = this._topAttachmentList.size();
    for (i = 0; i < size; i++) {
        att = this._topAttachmentList.get(i);
        att.getElementUI().paintAttachment(ctx, att);
    }
    ctx.restore();
    return c;
},
getGroupChildrenRects: function (group) {
    var list = new $List();
    group.getChildren().forEach(function (child) {
        if (child instanceof $Node) {
            var ui = this.getElementUI(child);
            if (ui) {
                var rect = ui.getViewRect();
                if (rect) {
                    list.add(rect);
                }
            }
        }
    }, this);
    return list;
},
getBackgroundImageRect: function(){
    return null;
},
getLinkPathFunction: function () {
    return this._linkPathFunction;
},
setLinkPathFunction: function (value) {
    var oldValue = this._linkPathFunction;
    this._linkPathFunction = value;
    this.firePropertyChange("linkPathFunction", oldValue, value);
    this.invalidateElementUIs();
},
onClickElement: function (element, e) {

},
onClickBackground: function (e) {

},
onDoubleClickElement: function (element, e) {

},
onDoubleClickBackground: function (e) {

},
onLongClickElement: function (element, e) {

},
onLongClickBackground: function (e) {

},
onMouseMove: function (element, e) {

},
onMouseEnter: function (element, e) {

},
onMouseLeave: function (element, e) {

},
setMovingElement: function (v) {
    if (v == this._movingElement) {
        return;
    }
    var oldValue = this._movingElement;
    this._movingElement = v;
    this.firePropertyChange("movingElement", oldValue, v);
    if (this._box._undoManager._enabled) {
        if (v) {
            this._box._undoManager.startBatch();
        } else {
            this._box._undoManager.endBatch();
        }
    }
},
setEditingElement: function (v) {
    if (v == this._editingElement) {
        return;
    }
    var oldValue = this._editingElement;
    this._editingElement = v;
    this.firePropertyChange("editingElement", oldValue, v);
    if (this._box._undoManager._enabled) {
        if (v) {
            this._box._undoManager.startBatch();
        } else {
            this._box._undoManager.endBatch();
        }
    }
}
});
twaver.canvas.Overview = function (network) {
    twaver.canvas.Overview.superClass.constructor.apply(this, network);
    this._view = $html.createView();
    this._rootDiv = $html.createDiv();
    this._imageCanvas = $html.createCanvas();
    this._imageDiv = $html.createDiv();
    this._maskCanvas = $html.createCanvas();
    this._selectDiv = $html.createDiv();
    this._isNetworkDirty = false;
    this._isMaskDirty = false;

    $html.setVisible(this._selectDiv, false);
    this._view.appendChild(this._rootDiv);
    this._rootDiv.appendChild(this._imageDiv);
    this._rootDiv.appendChild(this._maskCanvas);
    this._rootDiv.appendChild(this._selectDiv);
    this._imageDiv.appendChild(this._imageCanvas);

    this._exportImageCanvas = $html.createCanvas();
    this._imageCtx = this._imageCanvas.getContext('2d');

    this.setNetwork(network);
    if ($ua.isTouchable) {
        if($ua.isMSTouchable){
          new twaver.canvas.OverviewMSTouchInteraction(this);
      }else{
          new twaver.canvas.OverviewTouchInteraction(this);
          new twaver.canvas.OverviewInteraction(this);
      }        
  }else{        
    new twaver.canvas.OverviewInteraction(this);
}
};
_twaver.ext('twaver.canvas.Overview', twaver.controls.ControlBase, {
    __accessor: ['fillColor', 'outlineColor', 'outlineWidth', 'selectColor', 'selectWidth',
    'padding', 'maxPackingWidth', 'maxPackingHeight'],
    __bool: ['animate'],

    _fillColor: $Defaults.OVERVIEW_FILL_COLOR,
    _outlineColor: $Defaults.OVERVIEW_OUTLINE_COLOR,
    _outlineWidth: $Defaults.OVERVIEW_OUTLINE_WIDTH,
    _selectColor: $Defaults.OVERVIEW_SELECT_COLOR,
    _selectWidth: $Defaults.OVERVIEW_SELECT_WIDTH,
    _padding: $Defaults.OVERVIEW_PADDING,
    _animate: $Defaults.OVERVIEW_ANIMATE,
    _maxPackingWidth: $Defaults.OVERVIEW_MAX_PACKING_WIDTH,
    _maxPackingHeight: $Defaults.OVERVIEW_MAX_PACKING_HEIGHT,

    getNetwork: function () {
        return this._network;
    },
    onPropertyChanged: function (e) {
        this._invalidateMask();
    },
    setNetwork: function (network) {
        if (network === this._network) {
            return;
        }
        if (this._network) {
            this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.removeViewListener(this._handleNetworkViewChange, this);
            $html.removeEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this._network = network;
        if (this._network) {
            this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.addViewListener(this._handleNetworkViewChange, this);
            $html.addEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this.invalidate();
    },
    _handleNetworkPropertyChange: function (evt) {
        if (evt.property === 'zoom' || evt.property === 'currentSubNetwork' || evt.property === 'elementBox' || evt.property === 'dataBox' || evt.property === "canvasSizeChange") {
            this.invalidate();
        }
    },
    _handleNetworkViewChange: function (evt) {
        if (evt.kind === 'validateEnd') {
            this.invalidate();
        }
    },
    _handleScrollChange: function () {
        this._invalidateMask();
    },
    invalidate: function (delay) {
        if (!this._isNetworkDirty || !this._isMaskDirty) {
            if (!this._isNetworkDirty) {
                this._isNetworkDirty = true;
            }
            if (!this._isMaskDirty) {
                this._isMaskDirty = true;
            }
            _twaver.callLater(this.validate, this, null, delay);
        }
    },
    _invalidateMask: function () {
        if (!this._isMaskDirty) {
            this._isMaskDirty = true;
            _twaver.callLater(this.validate, this, [], 100);
        }
    },
    validate: function () {
      if ((this._isMaskDirty || this._isNetworkDirty) && this._network &&
        ((this._maxPackingWidth > 0 && this._maxPackingHeight > 0) || (this._view.clientWidth > 0 && this._view.clientHeight > 0)) &&
        this._network.getViewRect().width !== 0 && this._network.getViewRect().height !== 0 && !this._network._invalidate) {
        var isByMaxPackingWidthAndHeight = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
    var rect;
    if (isByMaxPackingWidthAndHeight) {
        rect = { x: 0, y: 0, width: this._maxPackingWidth, height: this._maxPackingHeight };
    } else {
        rect = { x: 0, y: 0, width: this._view.clientWidth, height: this._view.clientHeight };
    }
    $math.grow(rect, -this._padding, -this._padding);

    if (isByMaxPackingWidthAndHeight) {
        $html.setDiv(this._view, { x: 0, y: 0, width: this._imageDiv._viewRect.width, height: this._imageDiv._viewRect.height }, null, 0, null);
        rect.width = this._imageDiv._viewRect.width;
        rect.height = this._imageDiv._viewRect.height;
    }
    var gzoom = this._network.getZoom();
    var unionBounds = this._network._unionBounds;
    unionBounds = $math.unionRect(unionBounds,{x:0 ,y:0 ,width: unionBounds.x ,height: unionBounds.y});
    unionBounds = {x:unionBounds.x/gzoom, y:unionBounds.y/gzoom, width:unionBounds.width/gzoom,height:unionBounds.height/gzoom};
    var viewPort  = {
        x : this._network.viewRect.x/gzoom,
        y : this._network.viewRect.y/gzoom,
        width : this._network.viewRect.width/gzoom,
        height:this._network.viewRect.height/gzoom,
    };
    var viewSize = $math.unionRect(unionBounds,viewPort);
    var zoom = Math.min(rect.width / viewSize.width, rect.height / viewSize.height);
    var imageWidth = viewSize.width * zoom;
    var imageHeight = viewSize.height * zoom;

    var imageRectWidth = viewSize.width * zoom;
    var imageRectHeight = viewSize.height * zoom;

    var imageX = rect.x + (rect.width - imageRectWidth) / 2 ;
    var imageY = rect.y + (rect.height - imageRectHeight) / 2;

    if (this._isNetworkDirty) {
        var imageRect = { x: imageX, y: imageY, width: imageRectWidth, height: imageRectHeight };
        this._network.toCanvas(imageWidth, imageHeight, this._exportImageCanvas, zoom ,viewSize.x * zoom, viewSize.y * zoom);
        this._imageCanvas.setAttribute('width', imageRectWidth);
        this._imageCanvas.setAttribute('height', imageRectHeight);
        this._imageCtx.drawImage(this._exportImageCanvas,0,0,imageWidth,imageHeight);
        $html.setDiv(this._imageDiv, imageRect, null, 0, null);
        if (this._network.getElementBox) {
            this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle('background.color') || '';
        }
        this._isNetworkDirty = false;
    }

    if (this._isMaskDirty) {
        var currentRect = {x : (viewPort.x - viewSize.x) * zoom, y : (viewPort.y - viewSize.y) * zoom,width : viewPort.width * zoom,height : viewPort.height * zoom};
        var g = $html.setCanvas(this._maskCanvas, imageX, imageY, imageRectWidth, imageRectHeight);
        g.lineWidth = 0;
        g.fillStyle = this._fillColor;
        $g.drawVector(g, 'rectangle', null, imageX, imageY, imageRectWidth, imageRectHeight);
        g.closePath();
        g.fill();
        g.stroke();
        g.clearRect(imageX + currentRect.x, imageY + currentRect.y, currentRect.width, currentRect.height);
        g.lineWidth = this._outlineWidth;
        g.strokeStyle = this._outlineColor;
        var w = currentRect.width - this._outlineWidth * 2, h = currentRect.height - this._outlineWidth * 2;
        w = Math.min(w,imageRectWidth - 2 - currentRect.x - this._outlineWidth);
        h = Math.min(h,imageRectHeight - 2 -currentRect.y - this._outlineWidth);
        $g.drawVector(g, 'rectangle', null, imageX + currentRect.x + this._outlineWidth, imageY + currentRect.y + this._outlineWidth,w, h);
        g.closePath();
        g.stroke();
        this._isMaskDirty = false;
    }
} else {
    this._isNetworkDirty = false;
    this._isMaskDirty = false;
}
},
getLogicalPoint: function (e) {
    return $html.getLogicalPoint(this._view, e, 1, this._rootDiv);
},
centerNetwork: function (point, animate) {
    var imageRect = this._imageDiv._viewRect;
    if ($math.containsPoint(imageRect, point)) {
        this._network.centerByLogicalPoint(
            (point.x - imageRect.x) / imageRect.width * this._network.getCanvasSize().width,
            (point.y - imageRect.y) / imageRect.height * this._network.getCanvasSize().height, animate);
        this._invalidateMask();
    }
}
});

twaver.canvas.OverviewTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.canvas.OverviewTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.zoom = this.network.getZoom();
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        if (!this.moved) {
            this.moved = true;
        }
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isSingleTouch(e)) {
            this.overview.centerNetwork(this.endPoint, false);
        } else {
            if (this.distance) {
                var scale = $touch.getDistance(e) / this.distance;
                this.network.setZoom(this.zoom * scale, false);
            }
        }
    },
    handleTouchend: function (e) {
        if (!this.moved) {
            this.endPoint = this.overview.getLogicalPoint(e);
            var isDoubleTouch = this.lastPoint && this.lastTouchStartTime
                && (new Date().getTime() - this.lastTouchStartTime.getTime() <= 300)
                && (Math.abs(this.endPoint.x - this.lastPoint.x) <= 10)
                && (Math.abs(this.endPoint.y - this.lastPoint.y) <= 10);
            if (isDoubleTouch) {
                this.lastPoint = null;
                this.lastTouchStartTime = null;
            } else {
                this.lastPoint = this.endPoint;
                this.lastTouchStartTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
        
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('touchmove', this.view, this);
            $html.removeEventListener('touchend', this.view, this);
        }
        this.moved = false;
    }
});

twaver.canvas.OverviewMSTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;

    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.view, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.view, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.view, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.view, this);
};
_twaver.ext('twaver.canvas.OverviewMSTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);

        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }
        if (!this._pointerMap[e.pointerId] && this.overview.getLogicalPoint(e)) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        if (this._pointerIdArray.length == 1) {
            this._startTouchPoint = this.overview.getLogicalPoint(e);
            this._startTouchTime = new Date();
        }
        else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }
    },
    handleTouchmove: function (e) {
        if (this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;

        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        } else if (this._pointerIdArray.length == 1) {
            if (this._startTouchPoint) {
                var newPoint = this.overview.getLogicalPoint(e);
                if (newPoint == null) {
                    return
                };
                this._startTouchPoint = newPoint;
                this.overview.centerNetwork(this._startTouchPoint, false);
            }
        }
    },
    handleTouchend: function (e) {
        var newEndTouchPoint = this.overview.getLogicalPoint(e);
        if (this._pointerIdArray.length == 1 && newEndTouchPoint) {
            var isDoubleTouch = this._endTouchPoint && this._endTouchTime
                && (new Date().getTime() - this._endTouchTime.getTime() <= 500)
                && $math.getDistance(this._endTouchPoint , newEndTouchPoint) <= 10;
            if (isDoubleTouch) {
                this._endTouchPoint = null;
                this._endTouchTime = null;
            } else {
                this._endTouchPoint = newEndTouchPoint;
                this._endTouchTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this._endTouchPoint, this.overview._animate);
            }
        }

        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.canvas.OverviewInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('mousedown', 'handleMousedown', this.view, this);
};
_twaver.ext('twaver.canvas.OverviewInteraction', Object, {
    handleMousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if (_twaver.isCtrlDown(e)) {
            this.startPoint = this.endPoint;
            $html.setVisible(this.overview._selectDiv, true);
        }
        $html.addEventListener('mousemove', 'handleMousemove', this.view, this);
        $html.addEventListener('mouseup', 'handleMouseup', document, this);
    },
    handleMouseup: function (e) {
        this.endPoint = this.overview.getLogicalPoint(e);
        if ('detail' in e && e.detail === 2) {
            _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
        } else {
            if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
                var rect = this.overview._imageDiv._viewRect;
                var x = this.overview._selectDiv._viewRect.x;
                var y = this.overview._selectDiv._viewRect.y;
                var zoomByWidth = rect.width / this.overview._selectDiv._viewRect.width;
                var zoomByHeight = rect.height / this.overview._selectDiv._viewRect.height;
                var zoom = Math.min(zoomByWidth, zoomByHeight);

                this.network.setZoom(zoom * Math.min(this.network.getViewRect().width / this.network.getCanvasSize().width,
                    this.network.getViewRect().height / this.network.getCanvasSize().height) * this.network.getZoom(), false);

                var centerX = this.network.getCanvasSize().width * ((x - rect.x + this.overview._selectDiv._viewRect.width / 2) / rect.width);
                var centerY = this.network.getCanvasSize().height * ((y - rect.y + this.overview._selectDiv._viewRect.height / 2) / rect.height);

                _twaver.callLater(this.network.centerByLogicalPoint, this.network, [centerX, centerY, this.overview._animate]);
                $html.setVisible(this.overview._selectDiv, false);
                $html.setDiv(this.overview._selectDiv, { x: 0, y: 0, width: 0, height: 0 }, null, 0, null);
                this.startPoint = null;
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
    },
    handleMousemove: function (e) {
        var newPoint = this.overview.getLogicalPoint(e);
        this.endPoint = newPoint;
        if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
            var x = newPoint.x > this.startPoint.x ? this.startPoint.x : newPoint.x;
            var y = newPoint.x > this.startPoint.x ? this.startPoint.y : newPoint.y;
            if (newPoint.x > this.startPoint.x && newPoint.y < this.startPoint.y) {
                y = newPoint.y;
            }
            if (newPoint.x < this.startPoint.x && newPoint.y > this.startPoint.y) {
                y = this.startPoint.y;
            }
            var imageRect = this.overview._imageDiv._viewRect;
            if (x < imageRect.x) {
                x = imageRect.x;
            }
            if (x > imageRect.x + imageRect.width) {
                x = imageRect.x + imageRect.width;
            }
            if (y < imageRect.y) {
                y = imageRect.y;
            }
            if (y > imageRect.y + imageRect.height) {
                y = imageRect.y + imageRect.height;
            }
            var width = Math.abs(newPoint.x - this.startPoint.x);
            var height = Math.abs(newPoint.y - this.startPoint.y);
            if (x + width > imageRect.x + imageRect.width) {
                width = imageRect.x + imageRect.width - x;
            }
            //height = width * imageRect.height / imageRect.width;
            if (y + height > imageRect.y + imageRect.height) {
                height = imageRect.y + imageRect.height - y;
                //width = height * imageRect.width / imageRect.height;
            }
            $html.setDiv(this.overview._selectDiv, { x: x, y: y, width: width, height: height }, null, this.overview._selectWidth, this.overview._selectColor);
        } else {
            this.overview.centerNetwork(newPoint, false);
        }
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('mousemove', this.view, this);
            $html.removeEventListener('mouseup', this.view, this);
        }
    }
});
twaver.canvas.ElementUI = function (network, element) {
    this._network = network;
    this._element = element;

    this._attachments = new twaver.List();
    this._bodyBounds = new twaver.List();
    this._hitTest = false;
    this._hitTest = false;
    this._intersectTest = false;
    this.invalidate(true);
}
_twaver.ext('twaver.canvas.ElementUI', Object, {
    getElement: function () {
        return this._element;
    },
    getNetwork: function () {
        return this._network;
    },
    handlePropertyChange: function (e) {
        this.invalidate(true);
    },
    handleSelectionChange: function (e) {
        this.invalidate(true);
    },
    //validate
    invalidate: function (checkAttachments) {
        if (checkAttachments === undefined) {
            checkAttachments = true;
        }
        if (checkAttachments) {
            this._invalidateAttachmentsFlag = true;
        }
        if (this._invalidateFlag) {
            return;
        }
        this._hotSpot = null;
        this._bodyRect = null;
        this._invalidateFlag = true;
        this._network.invalidateElementVisibility();
    },
    //update the style attribute.
    updateStyle: function () {
        this._innerColor = this._network.getInnerColor(this._element);
        this._outerColor = this._network.getOuterColor(this._element);
        this._shadowColor = this._network.getShadowColor(this._element);
        this._shadowXOffset = this._element.getStyle('shadow.xoffset');
        this._shadowYOffset = this._element.getStyle('shadow.yoffset');
        this._shadowBlur = this._element.getStyle('shadow.blur');
        this._wholeAlpha = this._element.getStyle('whole.alpha');
    },
    validate: function () {
        if (this._invalidateFlag == false) {
            return;
        }
        this._bodyBounds.clear();
        if (this._invalidateAttachmentsFlag) {
            this._invalidateAttachmentsFlag = false;
            this.checkAttachments();
        }
        this._invalidateFlag = false;

        this.updateStyle();
        //calc body bounds
        this.validateImpl();

        this._attachments.forEach(function (attachment) {
            attachment.validate();
        });

        var unionRect;
        this._bodyBounds.forEach(function (rect) {
            unionRect = $math.unionRect(unionRect, rect);
        });
        //body sizeinclude border and select 
        this._unionBodyBounds = _twaver.clone(unionRect);

        // update view rect 
        this._attachments.forEach(function (attachment) {
            unionRect = $math.unionRect(unionRect, attachment.getViewRect());
        });
        //the whole size of the ui
        this._viewRect = unionRect;
    },
    validateImpl: function () {

    },
    setShadow: function (part, ctx) {
        var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
        if (ctx.shadowOffsetX === this._shadowXOffset && ctx.shadowOffsetY === this._shadowYOffset && ctx.shadowBlur === this._shadowBlur) {
            return ctx;
        }
        if (shadowable || this._network._showShadowInEdit) {
            ctx.shadowOffsetX = this._shadowXOffset;
            ctx.shadowOffsetY = this._shadowYOffset;
            ctx.shadowBlur = this._shadowBlur;
            ctx.shadowColor = this._shadowColor;
        }
        return ctx;
    },
    clearShadow: function (ctx) {
        if (ctx.shadowOffsetX != 0 || ctx.shadowOffsetY != 0 || ctx.shadowBlur != 0) {
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            ctx.shadowBlur = 0;
        }
    },
    //append shadow bound
    appendShadowBound: function (part, rect) {
        var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
        if (shadowable) {
            if (this._shadowXOffset > 0) {
                rect.width += this._shadowXOffset;
            } else {
                rect.x += this._shadowXOffset;
                rect.width += -this._shadowXOffset;
            }
            if (this._shadowYOffset > 0) {
                rect.height += this._shadowYOffset;
            } else {
                rect.y += this._shadowYOffset;
                rect.height += -this._shadowYOffset;
            }
            $math.grow(rect, this._shadowBlur, this._shadowBlur);
        }
        return rect;
    },
    isShadowable: function () {
        if (this._shadowColor && this._network.isSelected(this._element) && this._element.getStyle('select.style') === 'shadow') {
            return true;
        }
        return false;
    },

    //attachment
    addAttachment: function (attachment) {
        this._attachments.add(attachment);
        //this.invalidate(false);
    },
    removeAttachment: function (attachment) {
        this._attachments.remove(attachment);
        //this.invalidate(false);
    },
    getAttachments: function () {
        return this._attachments;
    },
    checkAttachments: function () {
        this.checkLabelAttachment();
        this.checkAlarmAttachment();
        this.checkIconsAttachment();
        this.checkEditAttachment();
    },

    checkLabelAttachment: function () {
        var label = this._network.getLabel(this._element);
        if (label != null && label !== "") {
            if (!this._labelAttachment) {
                this._labelAttachment = new twaver.canvas.LabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._labelAttachment);
            }
        } else {
            if (this._labelAttachment) {
                this.removeAttachment(this._labelAttachment);
                this._labelAttachment = null;
            }
        }
    },
    checkAlarmAttachment: function () {
        var label = this._network.getAlarmLabel(this._element);
        if (label != null && label !== "") {
            if (!this._alarmAttachment) {
                this._alarmAttachment = new twaver.canvas.AlarmAttachment(this, $Defaults.SHOW_ALARM_IN_ATTACHMENT_DIV);
                this.addAttachment(this._alarmAttachment);
            }
        } else {
            if (this._alarmAttachment) {
                this.removeAttachment(this._alarmAttachment);
                this._alarmAttachment = null;
            }
        }
    },
    checkIconsAttachment: function () {
        var icons = this._network.getIconsNames(this._element);
        if (icons && icons.length > 0) {
            if (!this._iconsAttachment) {
                this._iconsAttachment = new twaver.canvas.IconsAttachment(this);
                this.addAttachment(this._iconsAttachment);
            }
        } else {
            if (this._iconsAttachment) {
                this.removeAttachment(this._iconsAttachment);
                this._iconsAttachment = null;
            }
        }
    },
    checkEditAttachment: function () {
        if (this._network.hasEditInteraction() && this._network.isSelected(this._element) && this._network.isEditable(this._element) && this.isEditable()) {
            if (!this._editAttachment) {
                this._editAttachment = new twaver.canvas.EditAttachment(this);
                this.addAttachment(this._editAttachment);
            }
        } else {
            if (this._editAttachment) {
                this.removeAttachment(this._editAttachment);
                this._editAttachment = null;
            }
        }
    },
    getLabelAttachment: function () {
        return this._labelAttachment;
    },
    getAlarmAttachment: function () {
        return this._alarmAttachment;
    },
    getIconsAttachment: function () {
        return this._iconsAttachment;
    },
    getEditAttachment: function () {
        return this._editAttachment;
    },
    isEditable: function () {
        return true;
    },
    getInnerColor: function () {
        return this._innerColor;
    },
    getOuterColor: function () {
        return this._outerColor;
    },
    getShadowColor: function () {
        return this._shadowColor;
    },
    getDyeColor: function (styleProp) {
        if (this._innerColor) {
            return this._innerColor;
        }
        return this.getStyle(styleProp);
    },
    getStyle: function (styleProp) {
        return this._element.getStyle(styleProp);
    },
    getFont: function (styleProp) {
        var font = this._element.getStyle(styleProp);
        return font ? font : twaver.Defaults.FONT;
    },
    //paint 
    paint: function (ctx) {
        ctx.save();
        ctx.globalAlpha = this._wholeAlpha;
        ctx.beginPath();
        this.paintBody(ctx);
        this.clearShadow(ctx);
        ctx.closePath();
        ctx.beginPath();
        this.paintAttachments(ctx);
        ctx.closePath();
        ctx.restore();
    },
    paintBody: function (ctx) {

    },
    paintAttachments: function (ctx) {
        ctx.beginPath();
        var size = this._attachments.size();
        for (var i = 0; i < size; i++) {
            var att = this._attachments.get(i);
            if (this._hitTest == true) {
                if (att.isShowOnTop() == false) {
                    this.paintAttachment(ctx, att);
                }
            }
            if (this._intersectTest == true) {
                this.paintAttachment(ctx, att);
            }
            if (this._hitTest == false && this._intersectTest == false) {
                if (att.isShowOnTop()) {
                    this._network._topAttachmentList.add(att);
                } else {
                    this.paintAttachment(ctx, att);
                }
            }
        }
    },
    paintAttachment: function (ctx, att) {
        ctx.beginPath();
        att.paint(ctx);
        this.clearShadow(ctx);
    },
    /*
    * Get the bounds of the whole ui
    */
    getViewRect: function () {
        return _twaver.clone(this._viewRect);
    },
    getUnionBodyBounds: function () {
        return _twaver.clone(this._unionBodyBounds);
    },
    addBodyBounds: function (rect) {
        if (rect) {
            this._bodyBounds.add(rect);
        }
    },
    getBodyRect: function () {
        if (!this._bodyRect) {
            this._bodyRect = this.createBodyRect();
        }
        return _twaver.clone(this._bodyRect);
    },

    //hot spot
    getHotSpot: function () {
        if (this._hotSpot) {
            return _twaver.clone(this._hotSpot);
        }
        return {
            x: 0,
            y: 0
        };
    },
    setHotSpot: function (value) {
        this._hotSpot = value;
    },
    //hit interaction--getElementAt(e)
    hit: function (x, y) {
        return false;
    },
    //rect select--getELementsAtRect(rect);
    intersects: function (r) {
        if ($math.contains(r, this.getViewRect())) {
            return true;
        }
        return false;
    },
    /*
    * 1 true
    * -1 false
    * 0 exceptipn
    */
    hitCanvasRectAtBody: function (rect) {
        var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
        var ctx = $CanvasUtil.getCtx(cvs);
        ctx.save();
        ctx.translate(-rect.x, -rect.y);
        if(this._element.getImage) {
            var imageAsset = _twaver.getImageAsset(this._element.getImage());
            if(imageAsset && imageAsset.getImage() instanceof _gif) {
                return 1;
            }
        }
        this.paintBody(ctx);
        try {
            var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
            var pixs = imageData.data;
            for (var c = 0; c < imageData.width; c++) {
                for (var r = 0; r < imageData.height; r++) {
                    var index = 4 * (r * imageData.width + c);
                    var a = pixs[index + 3];
                    if (a !== 0) {
                        ctx.restore();
                        return 1;
                    }
                }
            }
        } catch (e) {
            $CanvasUtil.disposeHitCanvas();
            if ($math.contains(this.getUnionBodyBounds(), rect)) {
                return 0;
            }
        }
        ctx.restore();
        return -1;
    },
    hitCanvasRectAtAttachments: function (rect) {
        var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
        var ctx = $CanvasUtil.getCtx(cvs);
        ctx.save();
        ctx.translate(-rect.x, -rect.y);
        this.paintAttachments(ctx);
        try {
            var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
            var pixs = imageData.data;
            for (var c = 0; c < imageData.width; c++) {
                for (var r = 0; r < imageData.height; r++) {
                    var index = 4 * (r * imageData.width + c);
                    var a = pixs[index + 3];
                    if (a !== 0) {
                        ctx.restore();
                        return 1;
                    }
                }
            }
        } catch (e) {
            $CanvasUtil.disposeHitCanvas();
        }
        ctx.restore();
        return -1;
    },
    hitCanvasRect: function (r) {
        this._intersectTest = true;
        if (this._hitTest == true) {
            this._intersectTest = false;
        }
        var rect = $math.intersection(r, this._viewRect);
        var bh = this.hitCanvasRectAtBody(rect);
        if (bh == 1) {
            this._intersectTest = false;
            return true;
        }
        var ah = this.hitCanvasRectAtAttachments(rect);
        if (ah == 1) {
            this._intersectTest = false;
            return true;
        }
        this._intersectTest = false;
        return bh == 0;
    },
    hitCanvasPoint: function (x, y) {
        var targetRect = { x: x, y: y, width: 0, height: 0 };
        var tolerance = this._network.getSelectionTolerance();
        if (tolerance && tolerance > 0) {        
          $math.grow(targetRect, tolerance, tolerance);
        }
        if (!$math.intersects(this._viewRect, targetRect)) {
            return false;
        }
        this._hitTest = true;
        var h = this.hitCanvasRect(targetRect);
        this._hitTest = false;
        return h;
    },
    hitTest: function (x, y) {
        var targetRect = { x: x, y: y, width: 0, height: 0 };
        var tolerance = this._network.getSelectionTolerance();
        if (tolerance && tolerance > 0) {        
            $math.grow(targetRect, tolerance, tolerance);
        }
        if (!$math.intersects(this._viewRect, targetRect)) {
            return null;
        }
        var rect = $math.intersection(targetRect, this._viewRect);
        var bh = this.hitCanvasRectAtBody(rect);
        if (bh == 1) {
            return this;
        }

        var size = this._attachments.size();
        for (var i = 0; i < size; i++) {
            var att = this._attachments.get(i);
            if (att.hit(x, y)) {
                return att;
            }
        }
        if (bh == 0) {
            return this;
        }
        return null;
    },
    dispose: function () {
        this._attachments.forEach(function (attachment) {
            attachment.dispose();
        });
        this._attachments.clear();
    },
});


twaver.canvas.NodeUI = function (network, element) {
    twaver.canvas.NodeUI.superClass.constructor.call(this, network, element);
}
_twaver.ext('twaver.canvas.NodeUI', twaver.canvas.ElementUI, {
    invalidate: function (checkAttachments) {
        twaver.canvas.NodeUI.superClass.invalidate.call(this, checkAttachments);
        if(this.curInterval) {
            clearInterval(this.curInterval);
        }
        var links = this._element.getAgentLinks();
        if (links) {
            links.forEach(function (link) {
                this._network.invalidateElementUI(link, false);
            }, this);
        }
        var parent = this._element.getParent();
        if (parent instanceof twaver.Group) {
            this._network.invalidateElementUI(parent, false);
        }
    },
    createBodyRect: function () {
        return this._element.getRect();
    },
    validateImpl: function () {
        twaver.canvas.NodeUI.superClass.validateImpl.call(this);
        var shape = this.getStyle('vector.shape');
        var rect = this.getBodyRect();
        this._hotSpot = $math.getHotSpot(rect.x, rect.y, rect.width, rect.height, shape);
        this.validateBodyBounds();
    },
    validate: function () {
        if (this._invalidateFlag == false) {
            return;
        }
        twaver.canvas.NodeUI.superClass.validate.call(this);
    },
    validateBodyBounds: function () {
        var type = this.getStyle('body.type');
        if (type === 'default') {
            this.addBodyBounds(this.getDefaultBodyRect());
        }
        else if (type === 'vector') {
            this.addBodyBounds(this.getVectorBody());
        } else if (type === 'default.vector') {
            this.addBodyBounds(this.getVectorBody());
            this.addBodyBounds(this.getDefaultBodyRect());
        } else if (type === 'vector.default') {
            this.addBodyBounds(this.getDefaultBodyRect());
            this.addBodyBounds(this.getVectorBody());
        }
        if (this._outerColor) {
            this.addBodyBounds(this.getOuterBorderRect());
        }
        if (!this._editAttachment && this.getStyle('select.style') === 'border' && this._network.isSelected(this._element)) {
            this.addBodyBounds(this.getSelectBorderRect());
        }
    },
    getDefaultBodyRect: function () {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        if (!imageAsset) {
            return rect;
        }
        $math.addPadding(rect, this._element, 'image.padding', 1);
        this._defaultRect = rect;
        var bounds = _twaver.clone(rect);
        this.appendShadowBound(this, bounds);
        rect = bounds;
        return rect;
    },
    getVectorBody: function () {
        var rect = this.getPathRect("vector");
        return rect;
    },
    getOuterBorderRect: function () {
        return this._getBorderRect("outer");
    },
    getSelectBorderRect: function () {
        return this._getBorderRect("select");
    },
    _getBorderRect: function (prefix) {
        var node = this._element;
        var lineWidth = node.getStyle(prefix + '.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            $math.addPadding(rect, node, prefix + '.padding', 1);
            var bounds = _twaver.clone(rect);
            $math.grow(bounds, lineWidth / 2, lineWidth / 2);
            return bounds;
        }
        return null;
    },
    getPathRect: function (prefix, padding) {
        var node = this._element;
        var rect = this.getBodyRect();
        if (padding) {
            $math.addPadding(rect, node, prefix + '.padding', 1);
        }
        var bounds = _twaver.clone(rect);
        var lineWidth = node.getStyle(prefix + '.outline.width');
        if (lineWidth > 0) {
            $math.grow(bounds, lineWidth / 2, lineWidth / 2);
        }
        this.appendShadowBound(this, bounds);
        return bounds;
    },
    paintBody: function (ctx) {
        if(this.curInterval) {
            clearInterval(this.curInterval);
        }
        var type = this.getStyle('body.type');
        if (type === 'default') {
            this.drawDefaultBody(ctx);
        }
        else if (type === 'vector') {
            this.drawVectorBody(ctx);
        }
        else if (type === 'default.vector') {
            this.drawVectorBody(ctx);
            this.drawDefaultBody(ctx);
        }
        else if (type === 'vector.default') {
            this.drawDefaultBody(ctx);
            this.drawVectorBody(ctx);
        }

        if (this._outerColor) {
            this.drawOuterBorder(ctx);
        }
        if (this.getStyle('select.style') === 'border' && this._network.isSelected(this._element)) {
            this.drawSelectBorder(ctx);
        }
    },

    drawOuterBorder: function (ctx) {
        var node = this._element;
        var lineWidth = node.getStyle('outer.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            $math.addPadding(rect, node, 'outer.padding', 1);
            ctx.lineWidth = lineWidth;
            ctx.lineCap = node.getStyle('outer.cap');
            ctx.lineJoin = node.getStyle('outer.join');
            ctx.strokeStyle = this._outerColor;
            $g.drawVector(ctx, node.getStyle('outer.shape'), null, rect);
            ctx.stroke();
        }
    },
    drawDefaultBody: function (ctx) {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this._defaultRect;
        if (!imageAsset) {
            return;
        }
        if (imageAsset.getImage()) {
            if(node.getAngle() != 0) {
                ctx.save();
                rect = node.getOriginalRect();
                twaver.Util.rotateCanvas(ctx, rect, node.getAngle());
            }
            this.setShadow(this, ctx);
            var self = this;
            if(imageAsset.getImage() instanceof _gif) {
                var frames = imageAsset.getImage().frames;
                var size = imageAsset.getImage().size;
                var i = 0,curFrame;
                curFrame = getGifFrame(frames,size,0);
                ctx.drawImage(curFrame, rect.x ,rect.y, rect.width, rect.height);
                    this.curInterval = setInterval(function() {
                        i = (i + frames.length) % frames.length;
                        curFrame = getGifFrame(frames,size,i);
                        ctx.drawImage(curFrame, rect.x ,rect.y, rect.width, rect.height);
                        i++;
                    },100);
            } else {
                drawImage(ctx, node.getImage(), this.getInnerColor(), rect, node, this._network);
            }
            if(node.getAngle() != 0) {
                ctx.restore();
            }
        }
    },
    drawSelectBorder: function (ctx) {
        var node = this._element;
        var lineWidth = node.getStyle('select.width');
        if (lineWidth > 0) {

            var rect = this.getBodyRect();
            rect = _twaver.clone(rect);
            var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getZoom();
            $math.addPadding(rect, node, 'select.padding', 1 / zoom);
            $math.grow(rect, lineWidth / 2 / zoom, lineWidth / 2 / zoom);
            ctx.lineWidth = lineWidth / zoom;
            ctx.lineCap = node.getStyle('select.cap');
            ctx.lineJoin = node.getStyle('select.join');
            ctx.strokeStyle = node.getStyle('select.color');
            $g.drawVector(ctx, node.getStyle('select.shape'), null, rect);
            ctx.stroke();
        }
    },
    drawVectorBody: function (ctx) {
        this.drawPath(ctx, 'vector', true, this._element.getStyle('vector.outline.pattern'));
        var deep = this.getStyle('vector.deep');
        var fillColor = this.getStyle('vector.fill.color');
        var rect = this.getBodyRect();
        if (deep !== 0 && fillColor) {
            var angle = this._element.getAngle();
            if(angle != 0) {
                ctx.save();
                rect = this._element.getOriginalRect();
                twaver.Util.rotateCanvas(ctx, rect, angle);
            }
            if (this.getStyle('vector.shape') === 'rectangle') {
                $g.draw3DRect(ctx, fillColor, deep, rect);
            }
            if(angle != 0) {
                ctx.restore();
            }
        }
    },
    drawPath: function (ctx, prefix, padding, pattern, points, segments, close) {
        var node = this._element;
        var rect = this.getBodyRect();
        if (padding) {
            $math.addPadding(rect, node, prefix + '.padding', 1);
        }
        var lineWidth = node.getStyle(prefix + '.outline.width');
        this.setShadow(this, ctx);
        if(node.getAngle() != 0) {
            if(!(node instanceof $Group)) {
                rect = node.getOriginalRect();
            }
            ctx.save();
            twaver.Util.rotateCanvas(ctx, rect, node.getAngle());
        }
        var fill = node.getStyle(prefix + '.fill');
        var fillColor;
        if (fill) {
            if (this._innerColor && !$element.hasDefault(this._element)) {
                fillColor = this._innerColor;
            } else {
                fillColor = node.getStyle(prefix + '.fill.color');
            }
            var gradient = node.getStyle(prefix + '.gradient');
            if (gradient) {
                $g.fill(ctx, fillColor, gradient, node.getStyle(prefix + '.gradient.color'), rect);
            } else {
                ctx.fillStyle = fillColor;
            }
        }
        var shape = node.getStyle(prefix + '.shape');
        var roundRectRadiusValue = node.getStyle("group.shape.roundrect.radius");
        roundRectRadiusValue < 0 && (roundRectRadiusValue = 10);
        if (fill) {
            ctx.beginPath();
            if (points) {
                $g.drawLinePoints(ctx, points, null, segments, close);
            } else {
                if(shape === "roundrect" && prefix ==="group"){
                    $g.drawVector(ctx, shape, null, rect, roundRectRadiusValue);
                }else{
                    $g.drawVector(ctx, shape, null, rect);
                }
            }
            ctx.fill();
        }
        if (lineWidth > 0) {
            ctx.lineWidth = lineWidth;
            ctx.lineCap = node.getStyle(prefix + '.cap');
            ctx.lineJoin = node.getStyle(prefix + '.join');
            ctx.strokeStyle = node.getStyle(prefix + '.outline.color');
            ctx.beginPath();
            if (points) {
                $g.drawLinePoints(ctx, points, pattern, segments, close);
            } else {
                if(shape === "roundrect" && prefix ==="group"){
                    $g.drawVector(ctx, shape, pattern, rect, roundRectRadiusValue);
                }else{
                    $g.drawVector(ctx, shape, pattern, rect);
                }
            }
            ctx.stroke();
        }
        if(node.getAngle() != 0) {
            ctx.restore();
        }
    },
    hit: function (x, y) {
        var targetRect = { x: x, y: y, width: 0, height: 0 };
        var tolerance = this._network.getSelectionTolerance();
        if (tolerance && tolerance > 0) {
          $math.grow(targetRect, tolerance, tolerance);
        }
        if (this._network._transparentSelectionEnable) {
            var bodyRect = this.getBodyRect();
            if (_twaver.math.intersects(bodyRect, targetRect)) {
                return true;
            }
        }
        if ($math.intersects(this.getViewRect(), targetRect)) {
            return this.hitCanvasPoint(x, y);
        }
        return false;
    },
    intersects: function (r) {
        var it = twaver.canvas.NodeUI.superClass.intersects.apply(this, arguments);
        if (it == true) {
            return true;
        }
        if (this._network._transparentSelectionEnable) {
            var bodyRect = this.getBodyRect();
            if (_twaver.math.intersects(bodyRect, r)) {
                return true;
            }
        }
        if ($math.intersects(r, this.getViewRect())) {
            return this.hitCanvasRect(r);
        }
        return false;
    }
});

twaver.canvas.LinkUI = function (network, element) {
    twaver.canvas.LinkUI.superClass.constructor.call(this, network, element);
}
_twaver.ext('twaver.canvas.LinkUI', twaver.canvas.ElementUI, {
    isEditable: function () {
        if ($link.isOrthogonalLink(this._element) && this.getControlPoint()) {
            return true;
        }
        return false;
    },
    invalidate: function (checkAttachments) {
        this._linkPoints = null;
        this._fromPoint = null;
        this._toPoint = null;
        this._angle = null;
        twaver.canvas.LinkUI.superClass.invalidate.call(this, checkAttachments);
    },
    validateImpl: function () {
        this.validateBodyBounds();
        twaver.canvas.LinkUI.superClass.validateImpl.call(this);
    },
    validateBodyBounds: function () {
        var points = this.getLinkPoints();
        if (!points || points.size() < 2) {
            return;
        }
        var link = this._element;
        var bounds = $math.getLineRect(points);

        var width = link.getStyle('link.width');
        var grow = width;
        if (this._outerColor) {
            var outerWidth = link.getStyle('outer.width');
            grow += outerWidth * 2;
        }
        var selectBorder = !this._editAttachment && link.getStyle('select.style') === 'border' && this._network.isSelected(this._element);
        if (selectBorder) {
            var selectWidth = link.getStyle('select.width');
            grow += selectWidth * 2;
        }
        $math.grow(bounds, grow / 2, grow / 2);

        if (link.getStyle('arrow.from')) {
            if(this._network._debug){
                this._arrowFromRect = $arrow.getArrowRect(this, points, true,
                    link.getStyle('arrow.from.shape'),
                    link.getStyle('arrow.from.width'),
                    link.getStyle('arrow.from.height'),
                    link.getStyle('arrow.from.xoffset'),
                    link.getStyle('arrow.from.yoffset')
                    );
            }

            bounds = $math.unionRect(bounds,
                $arrow.getArrowRect(this, points, true,
                    link.getStyle('arrow.from.shape'),
                    link.getStyle('arrow.from.width'),
                    link.getStyle('arrow.from.height'),
                    link.getStyle('arrow.from.xoffset'),
                    link.getStyle('arrow.from.yoffset')
                    ));
        }
        if (link.getStyle('arrow.to')) {
           if(this._network._debug){
            this._arrowToRect =  $arrow.getArrowRect(this, points, false,
                link.getStyle('arrow.to.shape'),
                link.getStyle('arrow.to.width'),
                link.getStyle('arrow.to.height'),
                link.getStyle('arrow.to.xoffset'),
                link.getStyle('arrow.to.yoffset')
                );
            }

            bounds = $math.unionRect(bounds,
                $arrow.getArrowRect(this, points, false,
                    link.getStyle('arrow.to.shape'),
                    link.getStyle('arrow.to.width'),
                    link.getStyle('arrow.to.height'),
                    link.getStyle('arrow.to.xoffset'),
                    link.getStyle('arrow.to.yoffset')
                    ));
        }
        this.appendShadowBound(this, bounds);
        this.addBodyBounds(bounds);
    },
    createBodyRect: function () {
        var h = this.getHotSpot();
        if (h) {
            return {
                x: h.x - 1,
                y: h.y - 1,
                width: 2,
                height: 2
            };
        }
        return null;
    },
    paintBody: function (ctx) {
        var points = this._linkPoints;
        if (!points || points.size() < 2) {
            return;
        }
        var link = this._element;

        var width = link.getStyle('link.width');
        var grow = width;
        if (this._outerColor) {
            var outerWidth = link.getStyle('outer.width');
            grow += outerWidth * 2;
        }
        var selectBorder = !this._editAttachment && link.getStyle('select.style') === 'border' && this._network.isSelected(this._element);
        if (selectBorder) {
            var selectWidth = link.getStyle('select.width');
            grow += selectWidth * 2;
        }
        this.setShadow(this, ctx);
        ctx.lineCap = link.getStyle('link.cap');
        ctx.lineJoin = link.getStyle('link.join');
        var pattern = link.getStyle('link.pattern');
        if (selectBorder) {
            this.drawLinePoints(ctx, points, grow, link.getStyle('select.color'), pattern);
        }
        if (this._outerColor) {
            this.drawLinePoints(ctx, points, width + outerWidth * 2, this._outerColor, pattern);
        }
        this.drawLinePoints(ctx, points, width, this._innerColor || link.getStyle('link.color'), pattern);
        $arrow.drawLinkArrow(this, ctx, points);
    },
    drawLinePoints: function (g, points, width, color, pattern) {
        g.lineWidth = width;
        g.strokeStyle = color;

        /*
        g.beginPath();
        $g.drawLinePoints(g, points, pattern);
        g.stroke();
        */
        if (this._element.getStyle("link.flow") === true && pattern && pattern.length > 1) {
            var dashedLine = new $DashedLine(g, pattern[0], pattern[1]);
            var offset = this._element.getStyle("link.flow.offset");
            var mod = Math.floor(offset /(pattern[0] + pattern[1]));
            if (mod > 2) {
                offset = offset - (pattern[0] + pattern[1]) * mod;
            }
            
            if (this._element.getStyle("link.flow.converse")) {
                if (offset < pattern[0]) {
                    dashedLine.overflow = pattern[0] - offset;
                } else if (offset >= pattern[0] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = pattern[1] - (offset - pattern[0]);
                    if (dashedLine.overflow) { dashedLine.isLine = false };
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    dashedLine.overflow = pattern[0] - offset;
                }
            } else {
                if (offset <= pattern[1]) {
                    dashedLine.overflow = offset;
                    if (offset) dashedLine.isLine = false;
                } else if (offset > pattern[1] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = offset - pattern[1];
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    if (offset) { dashedLine.isLine = false };
                    dashedLine.overflow = offset;
                }
            }

            this._element._styleMap["link.flow.offset"] = offset;
            g.beginPath();
            $g._drawLine(points, g);
            g.stroke();

            g.shadowColor = 'transparent';
            g.beginPath();
            var linkFlowColor = this._element.getStyle("link.flow.color");
            linkFlowColor = linkFlowColor ? linkFlowColor : $Defaults.NETWORK_LINK_FLOW_COLOR;
            g.strokeStyle = linkFlowColor;
            $g._drawLine(points, dashedLine);
            g.stroke();
            g.shadowColor = this._shadowColor;
        } else {
            g.beginPath();
            $g.drawLinePoints(g, points, pattern);
            g.stroke();
        }
    },
    getLinkPoints: function () {
        if (!this._linkPoints) {
            this._linkPoints = this.createLinkPoints();
            this._lineLength = $math.calculateLineLength(this._linkPoints);
        }
        return this._linkPoints;
    },
    getFromPosition: function (xoffset, yoffset) {
        var point = this.getFromPoint();
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        return null;
    },
    getToPosition: function (xoffset, yoffset) {
        var point = this.getToPoint();
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        return null;
    },
    getFromPoint: function () {
        if (!this._fromPoint) {
            this._fromPoint = $link.createFromPoint(this);
        }
        return this._fromPoint;
    },
    getToPoint: function () {
        if (!this._toPoint) {
            this._toPoint = $link.createToPoint(this);
        }
        return this._toPoint;
    },
    createLinkPoints: function () {
        var fromPoint = this.getFromPoint();
        var toPoint = this.getToPoint();
        var type = this.getStyle('link.type');
        var points = new twaver.List();

        if ($link.isOrthogonalOrFlexionalLink(this._element)) {
            points = $link.orthogonalAndFlexional(this, type);
        } else {
            if (this._element.isLooped()) {
                var nodeUI = this._network.getElementUI(this._element.getFromAgent());
                if (nodeUI != null) {
                    this._hotSpot = $link.fillLoopedPoints(this, nodeUI.getBodyRect(), points);
                }
            } else if (type === 'arc' || type === 'triangle' || type === 'parallel') {
                this._hotSpot = $link.fillBundlePoints(this, type, fromPoint, toPoint, points);
            } else {
                throw "Can not resolve link type '" + type + "'";
            }
        }
        if (this._network._linkPathFunction) {
            var result = this._network._linkPathFunction(this, points);
            result && (points = result);
        }
        return points;
    },
    checkAttachments: function () {
        twaver.canvas.LinkUI.superClass.checkAttachments.call(this);
        this.checkLinkHandlerAttachment();
    },
    checkLinkHandlerAttachment: function () {
        var label = this._network.getLinkHandlerLabel(this._element);
        if (label != null && label !== '') {
            if (!this._linkHandlerAttachment) {
                this._linkHandlerAttachment = new twaver.canvas.LinkHandlerAttachment(this);
                this.addAttachment(this._linkHandlerAttachment);
            }
        } else {
            if (this._linkHandlerAttachment) {
                this.removeAttachment(this._linkHandlerAttachment);
                this._linkHandlerAttachment = null;
            }
        }
    },
    getLinkHandlerAttachment: function () {
        return this._linkHandlerAttachment;
    },
    getControlPoint: function () {
        return $link.getControlPoint(this._element, this);
    },
    setControlPoint: function (point) {
        if (!point) {
            return;
        }
        var linkType = this.getStyle('link.type');
        if (!$link.hasControlPoint(linkType)) {
            return;
        }
        var sourceBounds = $link.getLinkSourceBounds(this);
        var targetBounds = $link.getLinkTargetBounds(this);
        $link.setParamsByControlPoint(point, sourceBounds, targetBounds, linkType, this._element);
    },
    getLineLength: function () {
        return this._lineLength;
    },
    hit: function (x, y) {
        var targetRect = { x: x, y: y, width: 0, height: 0 };
        var tolerance = this._network.getSelectionTolerance();
        if (tolerance && tolerance > 0) {        
          $math.grow(targetRect, tolerance, tolerance);
        }
        if ($math.intersects(this.getViewRect(), targetRect)) {
            return this.hitCanvasPoint(x, y);
        }
        return false;
    },
    intersects: function (r) {
        var it = twaver.canvas.LinkUI.superClass.intersects.apply(this, arguments);
        if (it == true) {
            return true;
        }

        if ($math.intersects(r, this.getViewRect()) == false) {
            return false;
        }

        var points = this.getLinkPoints();
        var size = points.size();
        if (size == 2) {
            for (var i = 0; i < size; i += 2) {
                var p1 = points.get(i);
                if (i + 1 < size) {
                    var p2 = points.get(i + 1);
                    if ($CanvasUtil.intersectsLine(p1.x, p1.y, p2.x, p2.y, r.x, r.y, r.width, r.height)) {
                        return true;
                    }
                }
            }
        }

        return this.hitCanvasRect(r);
    },
    getAngle: function () {
        if (!this._angle && this._fromPoint && this._toPoint) {
            this._angle = $math.getAngle(this._fromPoint, this._toPoint);
        }
        return this._angle || 0;
    }
});


twaver.canvas.GroupUI = function (network, element) {
    twaver.canvas.GroupUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.canvas.GroupUI', twaver.canvas.NodeUI, {
    isEditable: function () {
        return !this._element.isExpanded();
    },
    paintBody: function (ctx) {
        if (this._shapeRect) {
            this.drawExpandedGroup(ctx);
        } else {
            twaver.canvas.GroupUI.superClass.paintBody.apply(this, arguments);
        }
    },
    validateBodyBounds: function () {
        this.getBodyRect();
        if (this._shapeRect) {
            this.addBodyBounds(this.getPathRect("group", false));
        } else {
            twaver.canvas.GroupUI.superClass.validateBodyBounds.call(this);
        }
    },
    drawExpandedGroup: function (ctx) {
        this.drawPath(ctx, 'group', false, this._element.getStyle('vector.outline.pattern'));
        var deep = this.getStyle('group.deep');
        var fillColor = this.getStyle('group.fill.color');
        if (deep !== 0 && fillColor) {
            if (this.getStyle('group.shape') === 'rectangle') {
                $g.draw3DRect(ctx, fillColor, deep, this._bodyRect);
            }
        }
    },
    getChildrenRects: function () {
        return this._network.getGroupChildrenRects(this._element);
    },
    createBodyRect: function () {
        this._shapeRect = null;
        var group = this._element;
        var network = this._network;
        if (group.isExpanded()) {
            group.getChildren().forEach(function (child) {
                var ui = network.getElementUI(child);
                ui && ui.validate();
            });
            var rects = this.getChildrenRects();
            if (!rects.isEmpty()) {
                var shape = group.getStyle('group.shape');
                var func = $group[shape];
                if (!func) {
                    throw "Can not resolve group shape '" + shape + "'";
                }
                this._shapeRect = func(rects);
            }
        }
        if (this._shapeRect) {
            $math.addPadding(this._shapeRect, group, 'group.padding', 1);
            return this._shapeRect;
        } else {
            return twaver.canvas.GroupUI.superClass.createBodyRect.call(this);
        }
    }
});

twaver.canvas.ShapeNodeUI = function (network, element) {
    twaver.canvas.ShapeNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.canvas.ShapeNodeUI', twaver.canvas.NodeUI, {
    getDefaultBodyRect: function () {
        if (this._element._points.size() < 2) {
            return null;
        }
        return this.getPathRect("vector", true);
    },
    drawDefaultBody: function (ctx) {
        if (this._element._points.size() < 2) {
            return;
        }
        this.drawPath(ctx, "vector", true, this._element.getStyle('vector.outline.pattern'),
        	this._element._points, this._element._segments, this._element.getStyle('shapenode.closed'));
        $arrow.drawLinkArrow(this, ctx, $math.getPointObject(this._element._points, this._element._segments));
    },
    drawSelectBorder: function (ctx) {
        var node = this._element;
        var lineWidth = node.getStyle('select.width');
        if (lineWidth > 0) {
            var rect = this.getBodyRect();
            rect = _twaver.clone(rect);
            var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getGraphicsZoom();

            $math.addPadding(rect, node, 'select.padding', 1 / zoom);

            $math.grow(rect, lineWidth / 2, lineWidth / 2);
            var outlineWidth = node.getStyle('vector.outline.width');
            if (outlineWidth > 0) {
                $math.grow(rect, outlineWidth / 2 / zoom, outlineWidth / 2 / zoom);
            }

            ctx.lineWidth = lineWidth / zoom;
            ctx.lineCap = node.getStyle('select.cap');
            ctx.lineJoin = node.getStyle('select.join');
            ctx.strokeStyle = node.getStyle('select.color');
            $g.drawVector(ctx, node.getStyle('select.shape'), null, rect);
            ctx.stroke();
        }
    }
});

twaver.canvas.ShapeLinkUI = function (network, element) {
    twaver.canvas.ShapeLinkUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.canvas.ShapeLinkUI', twaver.canvas.LinkUI, {
    isEditable: function () {
        return true;
    },
    createLinkPoints: function () {
        var fromPoint = this.getFromPoint();
        var toPoint = this.getToPoint();
        var points = new twaver.List();
        var type = this.getStyle('shapelink.type');

        points.add(fromPoint);
        if (this._element._points != null) {
            points.addAll(this._element._points);
        }
        points.add(toPoint);

        var halfDistance = $math.calculateLineLength(points)/2;
        
        var index, count = points.size(), first, next, point, perDistance, dx, dy, prevSumDistance = 0,sumDistance = 0;
        for (index = 0; index < count; index++) {
            point = points.get(index);
            if (index == 0) {
                first = point;
                continue;
            }
            next = point;
            if (next instanceof $List) {
                next = next._as;
            }
            if (next instanceof Array) {
                perDistance = $math.calculateCurveLength(first, next, 1);
                first = next[next.length - 1];
            } else {
                dy = point.y - first.y;
                dx = point.x - first.x;
                perDistance = Math.sqrt(dx * dx + dy * dy);
                first = next;
            }
            sumDistance += perDistance;
            if(prevSumDistance <= halfDistance && sumDistance >= halfDistance){
                var ds = halfDistance - prevSumDistance;
                var f = points.get(index-1);
                if(f instanceof $List){
                    f = f._as;
                    if(f instanceof Array){
                        f = f[f.length - 1];
                    }
                }
                var t = points.get(index);
                var p = $math.getPathInfo(t,f,ds,0,-1).point;
                this._hotSpot = _twaver.clone(p);
            }
            prevSumDistance = sumDistance;
        }
        
        // var pointCount = points.size();
        // var half = Math.floor(pointCount / 2);
        // if (pointCount % 2 === 0) {
        //     var p1 = points.get(half);
        //     var p2 = points.get(half - 1);
        //     this._hotSpot = {
        //         x: (p1.x + p2.x) / 2,
        //         y: (p1.y + p2.y) / 2
        //     };
        // } else {
        //     this._hotSpot = _twaver.clone(points.get(half));
        // }

        var result, i, lastPoint;
        if (type === 'lineto') {
            //Do Nonthing
        }
        else if (type === 'quadto') {
            result = new twaver.List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    result.add(new twaver.List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'cubicto') {
            result = new twaver.List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 2) {
                    result.add(new twaver.List([points.get(i++), points.get(i++), points.get(i)]));
                } else if (i < pointCount - 1) {
                    result.add(new twaver.List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'orthogonalto') {
            lastPoint = points.get(0);
            result = new twaver.List(lastPoint);
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    var point = _twaver.clone(points.get(i));
                    var x = point.x;
                    var y = point.y;
                    var dx = x - lastPoint.x;
                    var dy = y - lastPoint.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        point.x = x;
                        point.y = lastPoint.y;
                    } else {
                        point.x = lastPoint.x;
                        point.y = y;
                    }
                    lastPoint = point;
                    result.add(lastPoint);
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else {
            throw "Can not resolve shapelink type '" + type + "'";
        }
        return points;
    }
});

twaver.canvas.GridUI = function (network, element) {
    twaver.canvas.GridUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.canvas.GridUI', twaver.canvas.NodeUI, {
    drawDefaultBody: function (ctx) {
        if (this._element.getImage()) {
            twaver.canvas.GridUI.superClass.drawDefaultBody.apply(this, arguments);
        } else {
            this.drawGridBody(ctx);
        }
    },
    validateBodyBounds: function () {
        if (this._element.getImage()) {
            twaver.canvas.GridUI.superClass.validateBodyBounds.call(this);
        } else {
            var bodyRect = this.getBodyRect();
            var bounds = _twaver.clone(bodyRect);
            this.appendShadowBound(this, bounds);
            this.addBodyBounds(bounds);
        }
    },
    drawGridBody: function (ctx) {
        var fill = this.getStyle('grid.fill');
        var gridDeep = this.getStyle('grid.deep');
        var cellDeep = this.getStyle('grid.cell.deep');

        if (!fill && gridDeep === 0 && cellDeep === 0) {
            return;
        }
        ctx.beginPath();
        var bodyRect = this._element.getRect();
        var fillColor = this.getDyeColor('grid.fill.color');
        this.setShadow(this, ctx);
        // draw body
        if (fill) {
            ctx.fillStyle = fillColor;
            ctx.rect(bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
            ctx.fill();
        }
        ctx.closePath();
        this.clearShadow(ctx);
        ctx.beginPath();
        // draw border deep
        if (gridDeep != 0) {
            $g.draw3DRect(ctx, fillColor, gridDeep, bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
        }
        ctx.closePath();
        // draw cell deep
        if (cellDeep != 0) {
            var row = this.getStyle('grid.row.count');
            var col = this.getStyle('grid.column.count');
            for (var r = 0; r < row; r++) {
                for (var c = 0; c < col; c++) {
                    var rect = this._element.getCellRect(r, c);
                    if (rect != null) {
                        ctx.beginPath();
                        $g.draw3DRect(ctx, fillColor, cellDeep, rect.x, rect.y, rect.width, rect.height);
                        ctx.closePath();
                    }
                }
            }
        }
    }
});

twaver.canvas.RotatableNodeUI = function (network, element) {
    twaver.canvas.RotatableNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.canvas.RotatableNodeUI', twaver.canvas.NodeUI, {
    isEditable: function () {
        return false;
    },
    //need
    getDefaultBodyRect: function () {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        if (!imageAsset) {
            return rect;
        }
        $math.addPadding(rect, this._element, 'image.padding', 1);
        return rect;
    },
    drawDefaultBody: function (ctx) {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        $math.addPadding(rect, this._element, 'image.padding', 1);

        if (imageAsset.getImage()) {
            var ow = this._element._getOrignalWidth(),
            oh = this._element._getOrignalHeight(),
            rotateRect = this._element._getRotateRect();

            ctx.save();
            ctx.translate(rect.x - rotateRect.x + ow / 2, rect.y - rotateRect.y + oh / 2);
            ctx.rotate(this._element._angle * Math.PI / 180);
            var rect = {x:-ow / 2,y: -oh / 2, width: ow, height: oh }
            drawImage(ctx, imageAsset.getImage(this._innerColor, rect.width, rect.height), this._innerColor, rect, node, this._network);
            ctx.restore();
        }
        else if (imageAsset.getSrc()) {
        }
        else if (imageAsset.getFunction()) {
        }
        else {
            throw "ImageAsset '" + node.getImage() + " ' is empty";
        }
    }
});

twaver.canvas.HTMLNodeUI = function (network, element) {
    twaver.canvas.HTMLNodeUI.superClass.constructor.call(this, network, element);
}

_twaver.ext('twaver.canvas.HTMLNodeUI', twaver.canvas.NodeUI, {
    checkAttachments: function () {
        twaver.canvas.NodeUI.prototype.checkAttachments.call(this);
    },
    checkLabelAttachment: function () {
        var type = this._element.getStyle('attachment.label.style');
        if(type && type === 'none'){
            twaver.canvas.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            return;
        }

        var label = this._network.getLabel(this._element);
        if (label != null && label !== "") {
            if (!this._labelAttachment) {
                this._labelAttachment = new twaver.canvas.HTMLLabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._labelAttachment);
            }
        } else {
            if (this._labelAttachment) {
                this.removeAttachment(this._labelAttachment);
                this._labelAttachment = null;
            }
        }
    },
    checkAlarmAttachment: function () {
        var type = this._element.getStyle('attachment.alarm.style');
        if(type && type === 'none'){
            twaver.canvas.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

        var label = this._network.getAlarmLabel(this._element);
        if (label != null && label !== "") {
            if (!this._alarmAttachment) {
                this._alarmAttachment = new twaver.canvas.HTMLAlarmAttachment(this, false);
                this.addAttachment(this._alarmAttachment);
            }
        } else {
            if (this._alarmAttachment) {
                this.removeAttachment(this._alarmAttachment);
                this._alarmAttachment = null;
            }
        }
    },
    setAttachmentVisible: function (visible) {
        if(visible){
            this._labelAttachment && this._labelAttachment.setVisibility('visible');
            this._alarmAttachment && this._alarmAttachment.setVisibility('visible');
        }else {
            this._labelAttachment && this._labelAttachment.setVisibility('hidden');
            this._alarmAttachment && this._alarmAttachment.setVisibility('hidden');
        }
    },
});

twaver.canvas.HTMLLinkUI = function(network, element){
	twaver.canvas.HTMLLinkUI.superClass.constructor.call(this, network, element);
}

_twaver.ext('twaver.canvas.HTMLLinkUI', twaver.canvas.LinkUI, {
	checkAttachments: function () {
		twaver.canvas.LinkUI.prototype.checkAttachments.call(this);
	},
	checkLabelAttachment: function () {
		var style = this._element.getStyle('attachment.label.style');
        if(style && style === 'none'){
            twaver.canvas.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            return;
        }

		var label = this._network.getLabel(this._element);
		if (label != null && label !== "") {
			if (!this._labelAttachment) {
				this._labelAttachment = new twaver.canvas.HTMLLabelAttachment(this);
				this.addAttachment(this._labelAttachment);
			}
		} else {
			if (this._labelAttachment) {
				this.removeAttachment(this._labelAttachment);
				this._labelAttachment = null;
			}
		}
	},
	checkAlarmAttachment: function () {
		var style = this._element.getStyle('attachment.alarm.style');
        if(style && style === 'none'){
            twaver.canvas.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

		var label = this._network.getAlarmLabel(this._element);
		if (label != null && label !== "") {
			if (!this._alarmAttachment) {
				this._alarmAttachment = new twaver.canvas.HTMLAlarmAttachment(this, false);
				this.addAttachment(this._alarmAttachment);
			}
		} else {
			if (this._alarmAttachment) {
				this.removeAttachment(this._alarmAttachment);
				this._alarmAttachment = null;
			}
		}
	}
});
twaver.canvas.Attachment = function (elementUI, showInTop) {
    this._ui = elementUI;
    this._element = this._ui.getElement();
    this._network = elementUI.getNetwork();
    this._showOnTop = showInTop;
};
_twaver.ext('twaver.canvas.Attachment', Object, {
    getElement: function () {
        return this._element;
    },
    getElementUI: function () {
        return this._ui;
    },
    getNetwork: function () {
        return this._network;
    },
    isShowOnTop: function () {
        return this._showOnTop === true;
    },
    setShowOnTop: function (t) {
        this._showOnTop = t;
    },
    getStyle: function (styleProp) {
        return this._ui.getStyle(styleProp);
    },
    getFont: function (styleProp) {
        return this._ui.getFont(styleProp);
    },
    getViewRect: function () {
        return _twaver.clone(this._viewRect);
    },
    getAlpha: function () {
        return 1;
    },
    validate: function () {
    },
    paint: function (ctx) {
    },
    hit: function (x, y) {
        if ($math.containsPoint(this._viewRect, x, y)) {
            return this.hitCanvasRect({
                x: x - 1,
                y: y - 1,
                width: 2,
                height: 2
            });
        }
        return false;
    },
    hitCanvasRect: function (rect) {
        var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
        var ctx = $CanvasUtil.getCtx(cvs);
        ctx.save();
        ctx.translate(-rect.x, -rect.y);
        this.paint(ctx);
        try {
            var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
            var pixs = imageData.data;
            for (var c = 0; c < imageData.width; c++) {
                for (var r = 0; r < imageData.height; r++) {
                    var index = 4 * (r * imageData.width + c);
                    var a = pixs[index + 3];
                    if (a !== 0) {
                        ctx.restore();
                        return true;
                    }
                }
            }
        } catch (e) {
            $CanvasUtil.disposeHitCanvas();
        }
        ctx.restore();
        return false;
    },
    dispose: function() {

    },
     _rotatePoint: function(point,angle,rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _rotatePointList: function(list, angle, rect) {
        var self = this;
        var newList = new twaver.List();
        list.forEach(function(p) {
            newList.add(self._rotatePoint(p, angle, rect));
        });
        return newList;
    },
});
twaver.canvas.BasicAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.canvas.BasicAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._roundRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    this._contentRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
};
_twaver.ext('twaver.canvas.BasicAttachment', twaver.canvas.Attachment, {
    paint: function (ctx) {
        twaver.canvas.BasicAttachment.superClass.paint.apply(this, arguments);
        var fill = this.isFill();
        var outlineWidth = this.getOutlineWidth();
        this.getElementUI().setShadow(this, ctx);
        if (outlineWidth > 0 || fill) {
            $g.drawRoundRect(ctx, this._roundRect.x, this._roundRect.y, this._roundRect.width, this._roundRect.height, this.getCornerRadius());
            //todo make sure drawRoundRect and pointer same direction
            if (this._pointers) {
                ctx.moveTo(this._pointers[0].x, this._pointers[0].y);
                ctx.lineTo(this._pointers[1].x, this._pointers[1].y);
                ctx.lineTo(this._pointers[2].x, this._pointers[2].y);
            }
            ctx.closePath();

            if (outlineWidth > 0) {
                ctx.lineWidth = outlineWidth;
                ctx.strokeStyle = this.getOutlineColor();
                ctx.lineCap = this.getCap();
                ctx.lineJoin = this.getJoin();
                ctx.stroke();
            }
            if (fill) {
                var fillColor = this.getFillColor();
                var gradient = this.getGradient();
                if (gradient) {
                    $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
                } else {
                    ctx.fillStyle = fillColor;
                }
                ctx.fill();
            }
        }
    },
    validate: function () {
        twaver.canvas.BasicAttachment.superClass.validate.call(this);
        this.calculateMeasure();

        var outlineWidth = this.getOutlineWidth();

        this._viewRect = $math.getRect(this._pointers);
        this._viewRect = $math.unionRect(this._viewRect, this._roundRect);
        if (outlineWidth > 0) {
            $math.grow(this._viewRect, outlineWidth / 2, outlineWidth / 2);
        }
        this._viewRect = this._ui.appendShadowBound(this, this._viewRect);
    },
    calculateMeasure: function () {
        var contentWidth = this.getContentWidth();
        var contentHeight = this.getContentHeight();
        var cornerRadius = this.getCornerRadius();
        var pointerLength = this.getPointerLength();
        var pointerWidth = this.getPointerWidth();
        var position = this.getPosition();
        var xOffset = this.getXOffset();
        var yOffset = this.getYOffset();
        var roundRect = this._roundRect;
        roundRect.width = contentWidth + cornerRadius;
        roundRect.height = contentHeight;
        var location;

        if(this._ui._element instanceof twaver.Link){
            var points = this._ui.getLinkPoints();
            var lineLength;
            if (this._ui.getLineLength) {
                lineLength = this._ui.getLineLength();
            } else {
                lineLength = this._ui._element.getLineLength();
            }
            
            if (Math.abs(xOffset) > 0 && Math.abs(xOffset) < 1) {
                if(position === 'from'){
                    xOffset *= lineLength;
                }else if(position === 'to'){
                    xOffset = lineLength * (1 - xOffset);
                }else{
                    xOffset /= 2;
                    xOffset += 0.5;
                    xOffset *= lineLength;
                }
            }else{
                if(position === 'from'){
                    xOffset = xOffset;
                }else if(position === 'to'){
                    xOffset = lineLength - xOffset;
                }else{
                    xOffset += lineLength/2;
                }
            }

                var pointInfo = $math.calculatePointInfoAlongLine(points, true, xOffset, yOffset);
                var translatePoint = pointInfo.point;
                var rotateAngle = pointInfo.angle;

                var c;
                if(position === 'from'){
                    c = this._ui.getFromPoint();
                }else if(position === 'to'){
                    c = this._ui.getToPoint();
                }else{
                    c = this._ui._hotSpot;
                }

            xOffset = translatePoint.x - c.x;
            yOffset = translatePoint.y - c.y;
        }
        
        if (pointerLength > 0) {
            var direction = this.getDirection();
            location = this._network.getPosition(position, this._ui, null, xOffset, yOffset,false);
            var endPoint;
            if (direction === 'aboveleft') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, location.x - (roundRect.width - cornerRadius) + cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x,
                    y: location.y - pointerLength
                },
                {
                    x: endPoint,
                    y: location.y - pointerLength
                }];
            }
            else if (direction === 'aboveright') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, location.x - cornerRadius + roundRect.width - cornerRadius / 2);

                this._pointers = [location,
                {
                    x: location.x,
                    y: location.y - pointerLength
                },
                {
                    x: endPoint,
                    y: location.y - pointerLength
                }];
            }
            else if (direction === 'belowleft') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, location.x - (roundRect.width - cornerRadius) + cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x,
                    y: location.y + pointerLength
                },
                {
                    x: endPoint,
                    y: location.y + pointerLength
                }];
            }
            else if (direction === 'belowright') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, location.x - cornerRadius + roundRect.width - cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x,
                    y: location.y + pointerLength
                },
                {
                    x: endPoint,
                    y: location.y + pointerLength
                }];
            }
            else if (direction === 'leftabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.max(location.y - pointerWidth, location.y + cornerRadius - roundRect.height + cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x - pointerLength,
                    y: location.y
                },
                {
                    x: location.x - pointerLength,
                    y: endPoint
                }];
            }
            else if (direction === 'leftbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(location.y + pointerWidth, location.y - cornerRadius + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x - pointerLength,
                    y: location.y
                },
                {
                    x: location.x - pointerLength,
                    y: endPoint
                }];
            }
            else if (direction === 'rightabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.max(location.y - pointerWidth, location.y + cornerRadius - roundRect.height + cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x + pointerLength,
                    y: location.y
                },
                {
                    x: location.x + pointerLength,
                    y: endPoint
                }];
            }
            else if (direction === 'rightbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(location.y + pointerWidth, location.y - cornerRadius + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
                {
                    x: location.x + pointerLength,
                    y: location.y
                },
                {
                    x: location.x + pointerLength,
                    y: endPoint
                }];
            }
            else if (direction === 'above') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
                {
                    x: location.x - endPoint,
                    y: location.y - pointerLength
                },
                {
                    x: location.x + endPoint,
                    y: location.y - pointerLength
                }];
            }
            else if (direction === 'below') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
                {
                    x: location.x - endPoint,
                    y: location.y + pointerLength
                },
                {
                    x: location.x + endPoint,
                    y: location.y + pointerLength
                }];
            }
            else if (direction === 'left') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
                {
                    x: location.x - pointerLength,
                    y: location.y + endPoint
                },
                {
                    x: location.x - pointerLength,
                    y: location.y - endPoint
                }];
            }
            else if (direction === 'right') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
                {
                    x: location.x + pointerLength,
                    y: location.y + endPoint
                },
                {
                    x: location.x + pointerLength,
                    y: location.y - endPoint
                }];
            }
            else {
                throw "Can not resolve '" + direction + "' attachment direction";
            }
        }else {
           location = this._network.getPosition(position, this._ui, {
            width: roundRect.width,
            height: roundRect.height
            }, xOffset, yOffset,false);

            // if(this._ui instanceof twaver.vector.LinkUI && xOffset != 0){
            //     var paths = new $List();
            //     var startPoint = this._network.getPosition(position, this._ui, {
            //         width: 0,
            //         height: 0
            //     }, 0, 0,false);
            //     var endPoint = this._ui.getToPoint();
            //     if(startPoint.x == endPoint.x && startPoint.y == endPoint.y){
            //         endPoint = this._ui.getFromPoint();
            //         xOffset *= -1;
            //     }
            //     paths.add(startPoint);
            //     paths.add(endPoint);
            //     var pointInfo = $math.calculatePointInfoAlongLine(paths, true, xOffset, yOffset);
            //     location = pointInfo.point;
            //     location.x -= roundRect.width/2;
            //     location.y -= roundRect.height/2;
            // }
            roundRect.x = location.x;
            roundRect.y = location.y;
            this._pointers = null;
        }

        this._contentRect.x = roundRect.x + (roundRect.width - contentWidth) / 2;
        this._contentRect.y = roundRect.y + (roundRect.height - contentHeight) / 2;
        this._contentRect.width = contentWidth;
        this._contentRect.height = contentHeight;

        var padding = this.getPadding();
        if (padding != 0) {
            $math.grow(roundRect, padding, padding);
        }
        padding = this.getPaddingLeft();
        if (padding != 0) {
            roundRect.x -= padding;
            roundRect.width += padding;
        }
        padding = this.getPaddingRight();
        if (padding != 0) {
            roundRect.width += padding;
        }
        padding = this.getPaddingTop();
        if (padding != 0) {
            roundRect.y -= padding;
            roundRect.height += padding;
        }
        padding = this.getPaddingBottom();
        if (padding != 0) {
            roundRect.height += padding;
        }
        if (roundRect.width < 0) {
            roundRect.width = roundRect.width;
            roundRect.x -= roundRect.width;
        }
        if (roundRect.height < 0) {
            roundRect.height = -roundRect.height;
            roundRect.y -= roundRect.height;
        }
    },
    getContentWidth: function () {
        return twaver.Defaults.ATTACHMENT_CONTENT_WIDTH;
    },
    getContentHeight: function () {
        return twaver.Defaults.ATTACHMENT_CONTENT_HEIGHT;
    },
    getCornerRadius: function () {
        return twaver.Defaults.ATTACHMENT_CORNER_RADIUS;
    },
    getPointerLength: function () {
        return twaver.Defaults.ATTACHMENT_POINTER_LENGTH;
    },
    getPointerWidth: function () {
        return twaver.Defaults.ATTACHMENT_POINTER_WIDTH;
    },
    getPosition: function () {
        return twaver.Defaults.ATTACHMENT_POSITION;
    },
    getXOffset: function () {
        return twaver.Defaults.ATTACHMENT_XOFFSET;
    },
    getYOffset: function () {
        return twaver.Defaults.ATTACHMENT_YOFFSET;
    },
    getPadding: function () {
        return twaver.Defaults.ATTACHMENT_PADDING;
    },
    getPaddingLeft: function () {
        return twaver.Defaults.ATTACHMENT_PADDING_LEFT;
    },
    getPaddingRight: function () {
        return twaver.Defaults.ATTACHMENT_PADDING_RIGHT;
    },
    getPaddingTop: function () {
        return twaver.Defaults.ATTACHMENT_PADDING_TOP;
    },
    getPaddingBottom: function () {
        return twaver.Defaults.ATTACHMENT_PADDING_BOTTOM;
    },
    getDirection: function () {
        return twaver.Defaults.ATTACHMENT_DIRECTION;
    },
    isFill: function () {
        return twaver.Defaults.ATTACHMENT_FILL;
    },
    getFillColor: function () {
        return twaver.Defaults.ATTACHMENT_FILL_COLOR;
    },
    getGradient: function () {
        return twaver.Defaults.ATTACHMENT_GRADIENT;
    },
    getGradientColor: function () {
        return twaver.Defaults.ATTACHMENT_GRADIENT_COLOR;
    },
    getOutlineWidth: function () {
        return twaver.Defaults.ATTACHMENT_OUTLINE_WIDTH;
    },
    getOutlineColor: function () {
        return twaver.Defaults.ATTACHMENT_OUTLINE_COLOR;
    },
    getCap: function () {
        return twaver.Defaults.ATTACHMENT_CAP;
    },
    getJoin: function () {
        return twaver.Defaults.ATTACHMENT_JOIN;
    },
    isShadowable: function () {
        return twaver.Defaults.ATTACHMENT_SHADOWABLE;
    },
    getRoundRect: function () {
        return _twaver.clone(this._roundRect);
    },
    getContentRect: function () {
        return _twaver.clone(this._contentRect);
    }
    /**
    ,
    getContent: function () {
    return this._content;
    },
    setContent: function (value) {
    if (this._content === value) {
    return;
    }
    this._content = value;
    }*/
});



twaver.canvas.LabelAttachment = function(elementUI, showInAttachmentDiv) {
	twaver.canvas.LabelAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.canvas.LabelAttachment', twaver.canvas.BasicAttachment, {
	paint : function(ctx) {
		var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label.rotatable');
		if (rotatable) {
			ctx.save();
			var x = this._viewRect.x + this._viewRect.width / 2,
			y = this._viewRect.y + this._viewRect.height / 2;
			ctx.translate(x, y);
			ctx.rotate(this._network.getElementUI(this._element).getAngle());
			ctx.translate(-x, -y);
		}
		twaver.canvas.LabelAttachment.superClass.paint.apply(this, arguments);
		var align = this._element.getStyle("label.align");
		var angle = this._element && this._element.getStyle('label.rotate.angle');

		if(angle !== 0) {
			ctx.save();
			twaver.Util.rotateCanvas(ctx,this._contentRect,angle);
		}
		$g.drawText(ctx, this.text, this._contentRect, this.font, this.getStyle('label.color'),align,this.getStyle('label.linespacing'));
		if (rotatable || angle !== 0) {
			ctx.restore();
		}
	},
	validate : function() {
		this.font = this.getFont('label.font');
		var originalText = this.getLabel();
    var originalTextSize = _twaver.g.getTextSize(this.font, originalText);
    var originalMaxLength = this.getMaxLength();
    if(originalMaxLength !==0 && originalTextSize.width > originalMaxLength){
      this.text = _twaver.g.getCollapseTextInLength(this.font,originalText,originalMaxLength);
      this._textSize = _twaver.g.getTextSize(this.font, this.text);
    }else{
      this.text = originalText;
      this._textSize = originalTextSize;
    }
		twaver.canvas.LabelAttachment.superClass.validate.call(this);
		var rect = this._viewRect;
		var angle = this._element && this._element.getStyle('label.rotate.angle');
		if(angle !== 0){
			var points = new twaver.List();
			points.add({x:rect.x, y:rect.y});
			points.add({x:rect.x + rect.width, y:rect.y});
			points.add({x:rect.x + rect.width, y:rect.y + rect.height});
			points.add({x:rect.x, y:rect.y + rect.height});

			points = this._rotatePointList(points,angle,rect);
			var result = twaver.Util.getRect(points);
			this._viewRect = result;
		}
	},
	getLabel : function() {
		return this._network.getLabel(this._element);
	},
	getContentWidth : function() {
		return this._textSize ? this._textSize.width : 0;
	},
	getContentHeight : function() {
		return this._textSize ? this._textSize.height : 0;
	},
	getCornerRadius : function() {
		return this.getStyle('label.corner.radius');
	},
	getPointerLength : function() {
		return this.getStyle('label.pointer.length');
	},
	getPointerWidth : function() {
		return this.getStyle('label.pointer.width');
	},
	getPosition : function() {
		return this.getStyle('label.position');
	},
	getXOffset : function() {
		return this.getStyle('label.xoffset');
	},
	getYOffset : function() {
		return this.getStyle('label.yoffset');
	},
	getPadding : function() {
		return this.getStyle('label.padding');
	},
	getPaddingLeft : function() {
		return this.getStyle('label.padding.left');
	},
	getPaddingRight : function() {
		return this.getStyle('label.padding.right');
	},
	getPaddingTop : function() {
		return this.getStyle('label.padding.top');
	},
	getPaddingBottom : function() {
		return this.getStyle('label.padding.bottom');
	},
	getDirection : function() {
		return this.getStyle('label.direction');
	},
	isFill : function() {
		return this.getStyle('label.fill');
	},
	getFillColor : function() {
		return this.getStyle('label.fill.color');
	},
	getGradient : function() {
		return this.getStyle('label.gradient');
	},
	getGradientColor : function() {
		return this.getStyle('label.gradient.color');
	},
	getOutlineWidth : function() {
		return this.getStyle('label.outline.width');
	},
	getOutlineColor : function() {
		return this.getStyle('label.outline.color');
	},
	getCap : function() {
		return this.getStyle('label.cap');
	},
	getJoin : function() {
		return this.getStyle('label.join');
	},
	getAlpha : function() {
		return this.getStyle('label.alpha');
	},
	getMaxLength:function(){
    return this.getStyle('label.maxlength');
  },
	isShadowable : function() {
		return this.getStyle('label.shadowable');
	},
}); 
twaver.canvas.AlarmAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.canvas.AlarmAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.canvas.AlarmAttachment', twaver.canvas.BasicAttachment, {
    paint: function (ctx) {
        twaver.canvas.AlarmAttachment.superClass.paint.apply(this, arguments);
        $g.drawText(ctx, this.text, this._contentRect, this.font, this.getStyle('alarm.color'));
    },
    validate: function () {
        this.font = this.getFont('alarm.font');
        this.text = this._network.getAlarmLabel(this._element);
        this._textSize = $g.getTextSize(this.font, this.text);
        this._fillColor = this._network.getAlarmFillColor(this._element);
        twaver.canvas.LabelAttachment.superClass.validate.call(this);
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('alarm.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('alarm.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('alarm.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('alarm.position');
    },
    getXOffset: function () {
        return this.getStyle('alarm.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('alarm.yoffset');
    },
    getPadding: function () {
        return this.getStyle('alarm.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('alarm.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('alarm.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('alarm.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('alarm.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('alarm.direction');
    },
    isFill: function () {
        return this._fillColor != null;
    },
    getFillColor: function () {
        return this._fillColor;
    },
    getGradient: function () {
        return this.getStyle('alarm.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('alarm.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('alarm.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('alarm.outline.color');
    },
    getCap: function () {
        return this.getStyle('alarm.cap');
    },
    getJoin: function () {
        return this.getStyle('alarm.join');
    },
    getAlpha: function () {
        return this.getStyle('alarm.alpha');
    },
    isShadowable: function () {
        return this.getStyle('alarm.shadowable');
    }
});

twaver.canvas.LinkHandlerAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.canvas.LinkHandlerAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.canvas.LinkHandlerAttachment', twaver.canvas.BasicAttachment, {
    paint: function (ctx) {
        twaver.canvas.LinkHandlerAttachment.superClass.paint.apply(this, arguments);
        $g.drawText(ctx, this.linkHandlerLabel, this._contentRect, this.linkHandlerFont, this.getStyle('link.handler.color'));
    },
    validate: function () {
        this.linkHandlerFont = this.getFont('link.handler.font');
        this.linkHandlerLabel = this._network.getLinkHandlerLabel(this._element);
        this._textSize = $g.getTextSize(this.linkHandlerFont, this.linkHandlerLabel);
        twaver.canvas.LinkHandlerAttachment.superClass.validate.call(this);
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('link.handler.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('link.handler.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('link.handler.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('link.handler.position');
    },
    getXOffset: function () {
        return this.getStyle('link.handler.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('link.handler.yoffset');
    },
    getPadding: function () {
        return this.getStyle('link.handler.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('link.handler.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('link.handler.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('link.handler.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('link.handler.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('link.handler.direction');
    },
    isFill: function () {
        return this.getStyle('link.handler.fill');
    },
    getFillColor: function () {
        return this.getStyle('link.handler.fill.color');
    },
    getGradient: function () {
        return this.getStyle('link.handler.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('link.handler.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('link.handler.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('link.handler.outline.color');
    },
    getCap: function () {
        return this.getStyle('link.handler.cap');
    },
    getJoin: function () {
        return this.getStyle('link.handler.join');
    },
    getAlpha: function () {
        return this.getStyle('link.handler.alpha');
    },
    isShadowable: function () {
        return this.getStyle('link.handler.shadowable');
    }

});

//need to test
twaver.canvas.IconsAttachment = function(elementUI, showInAttachmentDiv) {
    twaver.canvas.IconsAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.canvas.IconsAttachment', twaver.canvas.Attachment, {
    isShadowable : function() {
        return twaver.Defaults.ATTACHMENT_SHADOWABLE;
    },
    validate : function() {
        twaver.canvas.IconsAttachment.superClass.validate.call(this);
        this.iconsNames = this._network.getIconsNames(this._element);
        if (!this.iconsNames || this.iconsNames.length == 0) {
            return;
        }
        var iconsGroups = this._makeGroup(this.iconsNames);
        var colorGroups = this._makeGroup(this._network.getIconsColors(this._element));

        len = iconsGroups.length;
        this.iconsOrientation = this._makeArray(this._element.getStyle('icons.orientation'), len,'right');
        this.iconsPosition = this._makeArray(this._element.getStyle('icons.position'), len,'topleft.bottomright');
        this.iconsXoffset = this._makeArray(this._element.getStyle('icons.xoffset'), len,0);
        this.iconsYoffset = this._makeArray(this._element.getStyle('icons.yoffset'), len,0);
        this.iconsXgap = this._makeArray(this._element.getStyle('icons.xgap'), len,1);
        this.iconsYgap = this._makeArray(this._element.getStyle('icons.ygap'), len,1);

        this.locations = [], this.iconsSizes = [];
        var iconsSize, location;

        for ( i = 0; i < len; i++) {
            var iconsNames = iconsGroups[i];
            var iconsOrientation = this.iconsOrientation[i] || "right";
            var iconsPosition = this.iconsPosition[i] || 'topleft.bottomright';
            var iconsXgap = this.iconsXgap[i] || 1;
            var iconsYgap = this.iconsYgap[i] || 1;
            var iconsXoffset = this.iconsXoffset[i] || 0;
            var iconsYoffset = this.iconsYoffset[i] || 0;

             if(this._ui._element instanceof twaver.Link){
                var points = this._ui.getLinkPoints();
                var lineLength;
                if (this._ui.getLineLength) {
                    lineLength = this._ui.getLineLength();
                } else {
                    lineLength = this._ui._element.getLineLength();
                }
                
                if (Math.abs(iconsXoffset) > 0 && Math.abs(iconsXoffset) < 1) {
                    if(iconsPosition === 'from'){
                        iconsXoffset *= lineLength;
                    }else if(iconsPosition === 'to'){
                        iconsXoffset = lineLength * (1 - iconsXoffset);
                    }else{
                        iconsXoffset /= 2;
                        iconsXoffset += 0.5;
                        iconsXoffset *= lineLength;
                    }
                }else{
                    if(iconsPosition === 'from'){
                        iconsXoffset = iconsXoffset;
                    }else if(iconsPosition === 'to'){
                        iconsXoffset = lineLength - iconsXoffset;
                    }else{
                        iconsXoffset += lineLength/2;
                    }
                }

                var pointInfo = $math.calculatePointInfoAlongLine(points, true, iconsXoffset, iconsYoffset);
                var translatePoint = pointInfo.point;
                var rotateAngle = pointInfo.angle;

                var c;
                if(iconsPosition === 'from'){
                    c = this._ui.getFromPoint();
                }else if(iconsPosition === 'to'){
                    c = this._ui.getToPoint();
                }else{
                    c = this._ui._hotSpot;
                }

                iconsXoffset = translatePoint.x - c.x;
                iconsYoffset = translatePoint.y - c.y;
            }

            location = null;
            iconsSize = this._getIconsSize(iconsNames, iconsOrientation, iconsXgap, iconsYgap);
            if (iconsSize) {
                location = this._network.getPosition(iconsPosition, this._ui, iconsSize, iconsXoffset, iconsYoffset);

                if (iconsOrientation === 'top') {
                    location.y += iconsSize.height;
                } else if (iconsOrientation === 'left') {
                    location.x += iconsSize.width;
                }
            }

            this.locations.push(location);
            this.iconsSizes.push(iconsSize);

        }

        var unionRect = null;
        for ( i = 0; i < this.locations.length; i++) {
            location = this.locations[i];
            iconsSize = this.iconsSizes[i];
            if(location == null){
                continue;
            }
            if (unionRect == null) {
                unionRect = {
                    x : location.x,
                    y : location.y,
                    width : iconsSize.width,
                    height : iconsSize.height
                };
            } else {
                unionRect = $math.unionRect(unionRect, {
                    x : location.x,
                    y : location.y,
                    width : iconsSize.width,
                    height : iconsSize.height
                });
            }
        }
        this._viewRect = unionRect || { x : this._element.getLocation().x,y : this._element.getLocation().y,width : 0,height : 0};
        this.iconsGroups = iconsGroups;
        this.colorGroups = colorGroups;

        var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.icons.rotatable');
        for ( i = 0; i < len; i++) {
            if (rotatable instanceof Array && rotatable[i] && this._viewRect) {
                var cx = this._viewRect.x + this._viewRect.width / 2,
                cy = this._viewRect.y + this._viewRect.height / 2;
                var w = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
                this._viewRect = {
                    x: cx - w/2,
                    y: cy - w/2,
                    width: w ,
                    height: w
                }
            }
        }
    },
    
    _makeGroup : function(originalArray){
        if(!Array.isArray(originalArray)){
            return [[originalArray]];
        }
        var groups = [], group = false, i, len = originalArray.length, item, temp;
        for ( i = 0; i < len; i++) {
            item = originalArray[i];
            if (!Array.isArray(item)) {
                temp = [item];
                groups.push(temp);
            } else {
                group = true;
                groups.push(item);
            }
        }
        if (!group) {
            groups.length = 0;
            groups.push(originalArray);
        }
        return groups;
    },

    _makeArray : function(value, len,defaultValue) {
        if (Array.isArray(value)) {
            return value;
        } else {
            var array = [];
            for (var i = 0; i < len; i++) {
                array.push(value || defaultValue);
            }
            return array;
        }
    },

    paint : function(ctx) {
        twaver.canvas.IconsAttachment.superClass.paint.apply(this, arguments);

        if (!this.iconsNames || this.iconsNames.length == 0 || !this.locations) {
            return;
        }
        var i,location,index,iconsNames,x,y,iconsColors,iconsOrientation,iconsXgap,iconsYgap;
        for (i = 0; i < this.iconsGroups.length; i++) {
            location = this.locations[i];
            if(!location){
                continue;
            }
            x = location.x;
            y = location.y;
            iconsNames = this.iconsGroups[i];
            iconsColors = this.colorGroups[i];
            iconsOrientation = this.iconsOrientation[i];
            iconsXgap = this.iconsXgap[i] || 1;
            iconsYgap = this.iconsYgap[i] || 1;
            index = 0;
            for (var name in iconsNames) {
                var rect = null;
                var color = null;
                if (iconsColors && iconsColors.length > index) {
                    color = iconsColors[index++];
                }
                var imageAsset = _twaver.getImageAsset(iconsNames[name]);
                if (imageAsset == null) {
                    continue;
                }
                if (iconsOrientation === 'right') {
                    rect = {
                        x : x,
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    x += rect.width + iconsXgap;
                } else if (iconsOrientation === 'left') {
                    rect = {
                        x : x - imageAsset.getWidth(),
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    x -= rect.width + iconsXgap;
                } else if (iconsOrientation === 'top') {
                    rect = {
                        x : x,
                        y : y - imageAsset.getHeight(),
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    y -= rect.height + iconsYgap;
                } else if (iconsOrientation === 'bottom') {
                    rect = {
                        x : x,
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    y += rect.height + iconsYgap;
                } else {
                    throw "Can not resolve '" + iconsOrientation + "' orientation";
                }
                // drawImage(ctx, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
                var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.icons.rotatable');
                if(rotatable instanceof Array && rotatable[i]) {
                    ctx.save();
                // var _vewRect = this.getZoomViewRect();
                var _vewRect = rect;
                var x = _vewRect.x + _vewRect.width / 2,
                y = _vewRect.y + _vewRect.height / 2;
                ctx.translate(x, y);
                ctx.rotate(this._network.getElementUI(this._element).getAngle());
                ctx.translate(-x, -y);
                drawImage(ctx, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
                ctx.restore();
            }else{
                drawImage(ctx, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
            }
            if(this._network._debug) {
                var rect = this._viewRect;
                $g.strokeRect(ctx, rect, '#FCFC00',1);
                $g.strokeRect(ctx, rect, '#FCFC00',1);
            }
        }
    }
},

_getIconsSize : function(names, orientation, xgap, ygap) {
    var x = 0;
    var y = 0;
    var rect = null;
    var imageAsset = null;
    var unionRect = null;
    for (var name in names) {
        imageAsset = _twaver.getImageAsset(names[name]);
        if (!imageAsset) {
            continue;
        }
        if (orientation === 'right') {
            rect = {
                x : x,
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            x += rect.width + xgap;
        } else if (orientation === 'left') {
            rect = {
                x : x - imageAsset.getWidth(),
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            x -= rect.width + xgap;
        } else if (orientation === 'top') {
            rect = {
                x : x,
                y : y - imageAsset.getHeight(),
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            y -= rect.height + ygap;
        } else if (orientation === 'bottom') {
            rect = {
                x : x,
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            y += rect.height + ygap;
        } else {
            throw "Can not resolve '" + orientation + "' orientation";
        }
        if (unionRect == null) {
            unionRect = _twaver.clone(rect);
        } else {
            unionRect = $math.unionRect(unionRect, rect);
        }
    }
    if (unionRect) {
        return {
            width : Math.abs(unionRect.width),
            height : Math.abs(unionRect.height)
        };
    }
    return null;
}
});

twaver.canvas.EditAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.canvas.EditAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.canvas.EditAttachment', twaver.canvas.Attachment, {
    paint: function (ctx) {
        twaver.canvas.EditAttachment.superClass.paint.apply(this, arguments);
        this._viewRect = null;
        this.paintResizingPoints(ctx);
        this.paintEditPoints(ctx);
        this.paintRotatePoints(ctx);
    },
    paintResizingPoints: function (ctx) {
        var size = this.resizingPoints.size();
        if (size <= 0) {
            return;
        }
        var width = this.resizePointSize * 2;
        var height = this.resizePointSize * 2;
        var fillColor = this._network.getResizePointFillColor();
        var outlineWidth = this._network.getResizePointOutlineWidth();
        var outlineColor = this._network.getResizePointOutlineColor();
        var angle = this._element.getAngle();
        var rect = this._element.getOriginalRect();
        ctx.lineWidth = outlineWidth;
        for (var i = 0; i < size; i++) {
            var point = this.resizingPoints.get(i);
            var resizeRect = {x:point.x - this.resizePointSize, y:point.y - this.resizePointSize, width:this.resizePointSize * 2, height:this.resizePointSize * 2};
            var rotatedRect = this._getRotateRect(resizeRect,angle,{x:rect.x + rect.width / 2, y:rect.y + rect.height / 2});
            ctx.save();
            twaver.Util.rotateCanvas(ctx, rotatedRect, angle);
            $CanvasUtil.rect(ctx, rotatedRect.x, rotatedRect.y, width, height);
            ctx.restore();
        }
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = outlineColor;
        ctx.fill();
        ctx.stroke();
    },
    paintEditPoints: function (ctx) {
        var size = this.editPoints.size();
        if (size <= 0) {
            return;
        }
        var outlineColor = this._network.getEditPointOutlineColor();
        var fillColor = this._network.getEditPointFillColor();
        var outlineWidth = this._network.getEditPointOutlineWidth();
        ctx.beginPath();
        ctx.lineWidth = outlineWidth;
        for (var i = 0; i < size; i++) {
            var p = this.editPoints.get(i);
            ctx.beginPath();
            $CanvasUtil.circle(ctx, p.x, p.y, this.editPointSize, fillColor, outlineColor);
            ctx.closePath();
        }
    },
    paintRotatePoints: function(ctx) {
        var size = this.rotatePoints.size();
        if (size <= 0) {
            return;
        }
        var outlineColor = this._network.getRotatePointOutlineColor();
        var fillColor = this._network.getRotatePointFillColor();
        var outlineWidth = this._network.getRotatePointOutlineWidth();
        ctx.beginPath();
        ctx.lineWidth = outlineWidth;
        for (var i = 0; i < size; i++) {
            var p = this.rotatePoints.get(i);
            ctx.beginPath();
            $CanvasUtil.circle(ctx, p.x, p.y, this.rotatePointSize, fillColor, outlineColor);
            ctx.closePath();
        }

    },
    validate: function () {
        twaver.canvas.EditAttachment.superClass.validate.call(this);

        this.editPointSize = this._network.getEditPointSize();
        this.resizePointSize = this._network.getResizePointSize();
        this.rotatePointSize = this._network.getRotatePointSize();

        this.resizingPoints = new twaver.List();
        this.editPoints = new twaver.List();
        this.rotatePoints = new twaver.List();

        if (this._element instanceof twaver.Node) {
            this._addResizingPoint(this._element);
        }
        if(this._network.isRotatable(this._element) && this._element instanceof $Node && !(this._element instanceof twaver.ShapeNode) && !(this._element instanceof twaver.Grid) && !(this._element instanceof twaver.Group)) {
            this._addRotatePoint(this._element);
        }
        if (this._element instanceof twaver.ShapeNode) {
            this._addResizingPoint(this._element);
            this._addShapeNodePoint(this._element);
        }
        if (this._ui instanceof twaver.canvas.ShapeLinkUI) {
            this._addShapeLinkPoints(this._element);
        }
        if (this._ui instanceof twaver.canvas.LinkUI) {
            this._addLinkControlPoint(this._ui);
        }
    },
    _addResizingPoint: function (node) {
        var rect = node.getOriginalRect();
        if (!rect) {
            return;
        }
        var size = this._network.getResizePointSize();
        if (size <= 0) {
            return;
        }
        var points = new $List([
            { x: rect.x, y: rect.y },
            { x: rect.x + rect.width / 2, y: rect.y },
            { x: rect.x + rect.width, y: rect.y },

            { x: rect.x, y: rect.y + rect.height / 2 },
            { x: rect.x + rect.width, y: rect.y + rect.height / 2 },

            { x: rect.x, y: rect.y + rect.height },
            { x: rect.x + rect.width / 2, y: rect.y + rect.height },
            { x: rect.x + rect.width, y: rect.y + rect.height }
        ]);
        var outlineWidth = this._network.getResizePointOutlineWidth();
        var outlineColor = this._network.getResizePointOutlineColor();
        var fillColor = this._network.getResizePointFillColor();

        this._addPoints(node.getRect(), points, outlineWidth,outlineColor, fillColor, true);
    },
    _addRotatePoint: function (node) {
        var rect = node.getOriginalRect();
        if (!rect) {
            return;
        }
        var size = this._network.getRotatePointSize();
        if (size <= 0) {
            return;
        }
        var width = size * 2;
        var points = new twaver.List([{x: rect.x + rect.width/2, y: rect.y - this._network.getRotatePointOffset() - width/2}]);
        var angle = node.getAngle();
        if(angle != 0) {
            points = this._rotatePointList(points,angle,node.getOriginalRect());
        }
        var rotatedPoint = points.get(0);
        var rotatedRect = {x: rotatedPoint.x - width / 2, y: rotatedPoint.y - width / 2, width: width, height: width};
        var outlineWidth = this._network.getRotatePointOutlineWidth();
        var offset = this.rotatePointSize + outlineWidth;
        $math.grow(rect, offset, offset);
        var unionRect = $math.unionRect(node.getRect(),rotatedRect);
        this._viewRect = $math.unionRect(unionRect, this._viewRect);
        this.rotatePoints = points;
    },
    _addShapeNodePoint: function (shapeNode) {
        this._addEditPoints(shapeNode.getPoints());
    },
    _addShapeLinkPoints: function (shapeLink) {
        this._addEditPoints(shapeLink.getPoints());
    },
    _addLinkControlPoint: function (linkUI) {
        if ($link.isOrthogonalLink(linkUI._element)) {
            var controlPoint = linkUI.getControlPoint();
            if (controlPoint) {
                var points = new twaver.List();
                points.add(controlPoint);
                this._addEditPoints(points);
            }
        }
    },
    _addEditPoints: function (points) {
        var rect = $math.getRect(points);
        if (!rect) {
            return;
        }
        var size = this._network.getEditPointSize();
        if (size <= 0) {
            return;
        }
        var outlineWidth = this._network.getEditPointOutlineWidth();
        this._addPoints(rect, points, outlineWidth, false);
    },
    _addPoints: function (rect, points, outlineWidth,outlineColor, fillColor, isResizePoints) {
        var size = isResizePoints ? this._network.getResizePointSize():this._network.getEditPointSize();
        if(size < 0) {
            return;
        }
        var offset = size + outlineWidth;
        $math.grow(rect, offset, offset);
        this._viewRect = $math.unionRect(rect, this._viewRect);

        if (isResizePoints == true) {
            this.resizingPoints = points;
        } else {
            this.editPoints = points;
        }
    },
    _rotatePoint: function(point,angle,rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _rotatePointList: function(list, angle, rect) {
        var self = this;
        var newList = new twaver.List();
        list.forEach(function(p) {
            newList.add(self._rotatePoint(p, angle, rect));
        });
        return newList;
    },
    _getRotateRect: function(rect,angle,center) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, center.x, center.y);
        var centerPoint = {x: rect.x + rect.width / 2,y: rect.y + rect.height / 2};
        var point = matrix.transform(centerPoint);
        var points = new twaver.List([
            {x: point.x - rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y + rect.height / 2},
            {x: point.x - rect.width / 2, y: point.y + rect.height / 2}
        ]);
        return $math.getRect(points);
    }
});
twaver.canvas.HTMLLabelAttachment = function(elementUI, showInAttachmentDiv) {
  twaver.canvas.HTMLLabelAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
  this._triangleDiv = twaver.Util.createDiv();
  this._roundDiv = twaver.Util.createDiv();
  this._contentDiv = twaver.Util.createDiv();
  var self = this;
  this._network.getView().appendChild(this._roundDiv);
  this._roundDiv.appendChild(this._contentDiv);
};

_twaver.ext('twaver.canvas.HTMLLabelAttachment', twaver.canvas.LabelAttachment, {
  validate: function () {
    // var hyperlink = this._element.getStyle('attachment.htmllabel.hyperlink');
    // if(hyperlink){
    //   twaver.Util.setCSSStyle(this._triangleDiv,'pointer-events','auto');
    //   twaver.Util.setCSSStyle(this._contentDiv,'pointer-events','auto');
    // }else{
    //   twaver.Util.setCSSStyle(this._triangleDiv,'pointer-events','none');
    //   twaver.Util.setCSSStyle(this._contentDiv,'pointer-events','none');
    // }
    var peFlag = this._element.getStyle('attachment.pointer.events');
    twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', peFlag);
    twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', peFlag);
    twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
    twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");
    var font = this.getFont('label.font');
    var text = this.getLabel();
    this._contentDiv.innerHTML = text;
    this._contentDiv.style.visibility = 'hidden';
    twaver.canvas.HTMLLabelAttachment.superClass.validate.call(this);
  },
  getContentWidth : function () {
    return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
  },
  getContentHeight : function () {
    return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
  },
  paint : function(ctx) {
    var fill = this.isFill();
    var outlineWidth = this.getOutlineWidth();
    var rect = this._contentRect;
    this.getElementUI().setShadow(this, ctx);

    if (outlineWidth > 0 || fill) {
     $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
     if (this._pointers) {
       var pointers = this._pointers;
       ctx.moveTo(pointers[0].x, pointers[0].y);
       ctx.lineTo(pointers[1].x, pointers[1].y);
       ctx.lineTo(pointers[2].x, pointers[2].y);
     }
     ctx.closePath();

     if (outlineWidth > 0) {
      ctx.lineWidth = outlineWidth;
      ctx.strokeStyle = this.getOutlineColor();
      ctx.lineCap = this.getCap();
      ctx.lineJoin = this.getJoin();
      ctx.stroke();
    }
    if (fill) {
      var fillColor = this.getFillColor();
      var gradient = this.getGradient();
      if (gradient) {
        $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
      } else {
        ctx.fillStyle = fillColor;
      }
      ctx.fill();
    }
  }
  
  var font = this.getFont('label.font');
  var text = this.getLabel();
  var cx = this._network.getViewRect().x;
  var cy = this._network.getViewRect().y;
  var zoom = this._network.getZoom();
  var cl = {x: this._contentRect.x + this._contentRect.width/2 , y: this._contentRect.y + this._contentRect.height/2};
  var left = (cl.x * zoom - cx) - this._contentDiv.offsetWidth/2 * zoom + 'px';
  var top = (cl.y * zoom - cy) - this._contentDiv.offsetHeight/2  * zoom+ 'px';
  this._contentDiv.style.left =  left ;
  this._contentDiv.style.top =  top;
  this._contentDiv.style.setProperty("-webkit-transform", "scale("+ zoom +")", null);
  this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null);

  if(this._network._debug){
    $g.strokeRect(ctx, this._contentRect, '#AAAAAA');
  }
},
setVisibility: function(visibility){
  this._contentDiv.style.visibility = visibility;
},
dispose: function() {
  this._network.getView().removeChild(this._roundDiv);
},
getView: function () {
  return this._roundDiv;
},
}); 
twaver.canvas.HTMLAlarmAttachment = function(elementUI, showInAttachmentDiv) {
  twaver.canvas.HTMLAlarmAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
  this._triangleDiv = twaver.Util.createDiv();
  this._roundDiv = twaver.Util.createDiv();
  this._contentDiv = twaver.Util.createDiv();
  twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
  twaver.Util.setCSSStyle(this._triangleDiv,'pointer-events','none');
  twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");
  twaver.Util.setCSSStyle(this._contentDiv,'pointer-events','none');
  var self = this;
  this._network.getView().appendChild(this._roundDiv);
  this._roundDiv.appendChild(this._contentDiv);
};

_twaver.ext('twaver.canvas.HTMLAlarmAttachment', twaver.canvas.AlarmAttachment, {
  validate: function () {
    var font = this.getFont('alarm.font');
    var text = this._network.getAlarmLabel(this._element);
    this._contentDiv.innerHTML = text;
    this._contentDiv.style.visibility = 'hidden';
    twaver.canvas.HTMLAlarmAttachment.superClass.validate.call(this);
  },
  getContentWidth : function () {
    return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
  },
  getContentHeight : function () {
    return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
  },
  paint : function(ctx) {
    var fill = this.isFill();
    var outlineWidth = this.getOutlineWidth();
    var rect = this._contentRect;
    this.getElementUI().setShadow(this, ctx);

    if (outlineWidth > 0 || fill) {
     $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
            if (this._pointers) {
             var pointers = this._pointers;
             ctx.moveTo(pointers[0].x, pointers[0].y);
             ctx.lineTo(pointers[1].x, pointers[1].y);
             ctx.lineTo(pointers[2].x, pointers[2].y);
           }
           ctx.closePath();

           if (outlineWidth > 0) {
            ctx.lineWidth = outlineWidth;
            ctx.strokeStyle = this.getOutlineColor();
            ctx.lineCap = this.getCap();
            ctx.lineJoin = this.getJoin();
            ctx.stroke();
          }
          if (fill) {
            var fillColor = this.getFillColor();
            var gradient = this.getGradient();
            if (gradient) {
              $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
            } else {
              ctx.fillStyle = fillColor;
            }
            ctx.fill();
          }
        }
        
    var font = this.getFont('alarm.font');
    var text = this._network.getAlarmLabel(this._element);
    var cx = this._network.getViewRect().x;
    var cy = this._network.getViewRect().y;
    var zoom = this._network.getZoom();
    var cl = {x: this._contentRect.x + this._contentRect.width/2 , y: this._contentRect.y + this._contentRect.height/2};
    var left = (cl.x * zoom - cx) - this._contentDiv.offsetWidth/2 * zoom + 'px';
    var top = (cl.y * zoom - cy) - this._contentDiv.offsetHeight/2  * zoom+ 'px';
    this._contentDiv.style.left =  left ;
    this._contentDiv.style.top =  top;
    this._contentDiv.style.setProperty("-webkit-transform", "scale("+ zoom +")", null);
    this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null);

    if(this._network._debug){
      $g.strokeRect(ctx, this._contentRect, '#AAAAAB');
    }
    
    twaver.canvas.AlarmAttachment.superClass.paint.apply(this, arguments);
  },
  setVisibility: function(visibility){
    this._contentDiv.style.visibility = visibility;
  },
  dispose: function() {
    this._network.getView().removeChild(this._roundDiv);
  },
  getView: function () {
    return this._roundDiv;
  },
}); 
twaver.canvas.interaction.BaseInteraction = function (network) {
    this.network = network;
};
_twaver.ext('twaver.canvas.interaction.BaseInteraction', Object, {
    setUp: function () {
    },
    tearDown: function () {
    },
    repaint: function () {
        this.network.repaintTopCanvas();
    },
    convertPointFromView: function (p) {
        var x = p.x * this.network.getZoom() - this.network.getViewRect().x;
        var y = p.y * this.network.getZoom() - this.network.getViewRect().y;
        return {
            x: x,
            y: y
        };
    },
    convertFromUIToMarkerRect: function (vr, xoff, yoff) {
        var zoom = this.network.getZoom();
        return {
            x: vr.x * zoom - this.network.getViewRect().x + xoff * zoom,
            y: vr.y * zoom - this.network.getViewRect().y + yoff * zoom,
            width: vr.width * zoom,
            height: vr.height * zoom
        }
    },
    getMarkerPoint: function (e) {
        var point;

        if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
            var touch = e.changedTouches[0];
            point = {
                x: touch.clientX,
                y: touch.clientY
            };
            return point;
        }
        if ($ua.isFirefox) {
            point = {
                x: e.layerX,
                y: e.layerY
            };
        } else {
            point = {
                x: e.offsetX,
                y: e.offsetY
            };
        }
        return point;
    },
    paint: function (ctx) {
    },
    addListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            var type = arguments[i];
            $html.addEventListener(type, 'handle_' + type, this.network.getView(), this);
        }
    },
    removeListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            $html.removeEventListener(arguments[i], this.network.getView(), this);
        }
    },
    _handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        this._startLogical = this.network.getLogicalPoint(e);
        this._startClient = $html.getClientPoint(e);
        if (this._startLogical) {
            $html.handle_mousedown(this, e);
        }
    },
    _handle_mousemove: function (e) {
        this._endLogical = {
            x: this._startLogical.x + (e.clientX - this._startClient.x) / this.network.getZoom(),
            y: this._startLogical.y + (e.clientY - this._startClient.y) / this.network.getZoom()
        };
    },
    _handle_mouseup: function (e) {
        delete this._startClient;
        delete this._startLogical;
        delete this._endLogical;
    }
});

twaver.canvas.interaction.SelectInteraction = function (network) {
    twaver.canvas.interaction.SelectInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.SelectInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseup');
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseup');
        this.end();
        this.network.removeMarker(this);
    },
    paint: function (ctx) {
        if (this.startPoint == null || this.endPoint == null) {
            return;
        }
        var sp = this.convertPointFromView(this.startPoint);
        var ep = this.convertPointFromView(this.endPoint);
        var sx = sp.x;
        var sy = sp.y;
        var ex = ep.x;
        var ey = ep.y;
        var rect = $math.getRect([{ x: sx, y: sy }, { x: ex, y: ey}]);
        if (rect != null) {
            ctx.beginPath();
            var lineWidth = this.network.getSelectOutlineWidth();
            var fillStyle = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
            ctx.strokeStyle = this.network.getSelectOutlineColor();
            ctx.lineWidth = lineWidth;
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, fillStyle, this.network.getSelectOutlineColor());
            ctx.closePath();
        }
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e) || this.network.isMovingElement() || this.network.isEditingElement()) {
            return;
        }
        if (e.shiftKey) {
            return;
        }
        var element = this.network.getElementAt(e);
        var sm = this.network.getSelectionModel();
        if (element) {
            if (_twaver.isCtrlDown(e)) {
                if (sm.contains(element)) {
                    sm.removeSelection(element);
                } else {
                    sm.appendSelection(element);
                }
            } else {
                if (!sm.contains(element)) {
                    sm.setSelection(element);
                }
            }
        } else {
            if (!_twaver.isCtrlDown(e)) {
                sm.clearSelection();
            }
            this.end(e);
            this.startPoint = this.network.getLogicalPoint(e);
            if (this.startPoint && this.network.isRectSelectEnabled()) {
                this.addListener('mousemove');
            }
        }
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (this.network.isMovingElement() || this.network.isEditingElement()) {
            this.end(e);
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        this.network.setSelectingElement(true);
        if (this.endPoint == null) {
            this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
        } else {
            this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
        }
        this.endPoint = point;
        this.repaint();
    },
    end: function (e) {
        if (this.startPoint) {
            if (this.endPoint && this.startPoint.x !== this.endPoint.x && this.startPoint.y !== this.endPoint.y) {
                var rect = $math.getRect([this.startPoint, this.endPoint]);
                var elements = this.network.getElementsAtRect(rect, this.getIntersectMode(), this.network.getRectSelectFilter());
                if (elements && elements.size() > 0) {
                    var sm = this.network.getSelectionModel();
                    var selections = sm.toSelection();
                    elements.forEach(function (element) {
                        if (sm.contains(element)) {
                            selections.remove(element);
                        } else {
                            selections.add(element);
                        }
                    }, this);
                    sm.setSelection(selections);
                }
                this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            }
            this.network.setSelectingElement(false);
            this.removeListener('mousemove');
            this.startPoint = null;
            this.endPoint = null;
            this.repaint();
        }
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this.startPoint.x > this.endPoint.x && this.startPoint.y > this.endPoint.y;
    }
});

twaver.canvas.interaction.MoveInteraction = function (network, lazyMode) {
    this.lazyMode = lazyMode;
    twaver.canvas.interaction.MoveInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.MoveInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseup', 'keydown', 'mouseout');
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseup', 'keydown', 'mouseout');
        this.end();
        this.network.removeMarker(this);
    },
    handle_keydown: function (e) {
        this.currentKeyEvent = e;
        this.addListener('keyup');
    },

    handle_keyup: function (e) {
        this.currentKeyEvent = null;
        this.removeListener('keyup');
    },
    isParenting: function () {
        return this.pressPoint && this.currentKeyEvent != null
						&& this.currentKeyEvent.keyCode === 80;
    },
    parentProcess: function (e, released) {
        var rect = null;
        this.parent = null;
        var self = this;
        if (!released && this.isParenting()) {
            var hitRect = {};
            var p = this.network.getLogicalPoint(e);
            hitRect.x = p.x - 1;
            hitRect.y = p.y - 1;
            hitRect.width = 2;
            hitRect.height = 2;

            var elements = this.network
							.getElementsAtRect(hitRect, true);
            if (elements && elements.size() > 0) {
                var size = elements.size();
                for (var i = 0; i < size; i++) {
                    var element = elements.get(i);
                    if (!self.network.getElementBox()
										.getSelectionModel().contains(element)) {
                        self.parent = element;
                        break;
                    }
                }
            }

        } else {
            this.parent = null;
        }
        if (this.parent != null) {
            rect = this.network.getElementUI(this.parent).getViewRect();
        }
        if (rect != null && !released) {
            this.parentRect = rect;
        } else {
            this.parentRect = null;
        }
    },
    paint: function (ctx) {
        if (this.lazyMode) {
            if (this.pressPoint == null || this.dragPoint == null) {
                return;
            }
            ctx.beginPath();
            var xoff = this.dragPoint.x - this.pressPoint.x
            var yoff = this.dragPoint.y - this.pressPoint.y
            var list = this.network.getMovableSelectedElements();
            var size = list.size();

            var fillColor = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null;
            var lineWidth = this.network.getLazyMoveOutlineWidth();
            var strokeColor = this.network.getLazyMoveOutlineColor();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.fillStyle = fillColor;
            for (var i = 0; i < size; i++) {
                var n = list.get(i);
                var ui = this.network.getElementUI(n);
                if (ui) {
                    var vr = this.convertFromUIToMarkerRect(ui.getViewRect(), xoff, yoff);
                    $CanvasUtil.rect(ctx, vr.x, vr.y, vr.width, vr.height);
                }
            }
            ctx.fill();
            ctx.stroke();
        }
        if (this.parentRect) {
            ctx.beginPath();
            var fillColor = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null;
            var lineWidth = this.network.getLazyMoveOutlineWidth();
            var strokeColor = this.network.getLazyMoveOutlineColor();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.fillStyle = fillColor;
            var vr = this.parentRect;
            $CanvasUtil.rect(ctx, vr.x, vr.y, vr.width, vr.height);
            ctx.fill();
            ctx.stroke();
        }
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (!this.network.isValidEvent(e) || this.network.isSelectingElement() || this.network.isEditingElement()) {
            return;
        }
        var element = this.network.getElementAt(e);
        if (!this.network.isMovable(element)) {
            return;
        }
        this.end(e);
        this.lastPoint = this.network.getLogicalPoint(e);
        if (this.lazyMode) {
            this.pressPoint = this.lastPoint;
        }
        if (this.lastPoint) {
            this.addListener('mousemove');
        }
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mouseout: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (this.network.isSelectingElement() || this.network.isEditingElement() || !this.network.hasMovableSelectedElements()) {
            this.end(e);
            return;
        }
        var newPoint = this.network.getLogicalPoint(e);
        if (!newPoint) {
            return;
        }
        if(!this.lastPoint) {
            return;
        }
        this.xoffset = newPoint.x - this.lastPoint.x;
        this.yoffset = newPoint.y - this.lastPoint.y;
        if (Math.abs(this.xoffset) < 1 && Math.abs(this.yoffset) < 1) {
            return;
        }

        if (this.lazyMode) {
            if (this.dragPoint == null) {
                this.network.fireInteractionEvent({
                    kind: 'lazyMoveStart',
                    event: e
                });
                this.network.setMovingElement(true);
            } else {
                this.network.fireInteractionEvent({
                    kind: 'lazyMoveBetween',
                    event: e
                });
            }
        } else {
            this.lastPoint = newPoint;
            if (this.network.isMovingElement()) {
                this.network.fireInteractionEvent({
                    kind: 'liveMoveBetween',
                    event: e
                });
            } else {
                this.network.setMovingElement(true);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveStart',
                    event: e
                });
            }
            this.network.moveSelectedElements(this.xoffset, this.yoffset);
        }
        this.parentProcess(e, false);
        if (this.lazyMode) {
            this.dragPoint = newPoint;
        }
        if (this.lazyMode || this.isParenting()) {
            this.repaint();
        }
    },
    end: function (e) {
        if (this.lazyMode) {
            if (this.dragPoint != null && this.pressPoint != null) {
                var self = this;
                var f = function () {
                    self.network.fireInteractionEvent({
                        kind: 'lazyMoveEnd',
                        event: e
                    });
                    self.network.setMovingElement(false);
                };
                var xoff = this.dragPoint.x - this.pressPoint.x;
                var yoff = this.dragPoint.y - this.pressPoint.y;
                this.network.moveSelectedElements(xoff, yoff, this.network.isLazyMoveAnimate(), f);
            }
        } else {
            if (this.network.isMovingElement()) {
                this.network.setMovingElement(false);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveEnd',
                    event: e
                });
            }
        }
        if (this.isParenting()) {
            if (this.parent == null) {
                this.parent = this.network.getCurrentSubNetwork();
            }
            var self = this;
            this.network.getMovableSelectedElements().forEach(
			    function (element) {
			        element.setParent(self.parent);
			    }, this.network);
        }
        this.parentProcess(e, true);
        if (this.isParenting()) {
            this.repaint();
        }
        this.network.invalidateCanvasSize();
        this.removeListener('mousemove');
        this.lastPoint = null;
        this.dragPoint = null;
        this.pressPoint = null;
    }
});

twaver.canvas.interaction.ScrollInteraction = function (network) {
    twaver.canvas.interaction.ScrollInteraction.superClass.constructor.call(this, network);
    this.hThumbRect = null;
    this.vThumbRect = null;
    this.scrollBarVisible = false;
};
_twaver.ext('twaver.canvas.interaction.ScrollInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseover', 'mouseout');
        if ($ua.isFirefox) {
            $html.addEventListener("DOMMouseScroll", "handleMouseWheel", this.network.getView(), this);
        } else {
            $html.addEventListener("mousewheel", "handleMouseWheel", this.network.getView(), this);
        }
        $html.addEventListener("mouseup", "handleMouseUp", window, this);
        $html.addEventListener("mousemove", "handleMouseMove", window, this);

        this.network.addPropertyChangeListener(this.handleViewRectChange, this);
        this.validateScrollBar();
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseover', 'mouseout');
        if ($ua.isFirefox) {
            $html.removeEventListener("DOMMouseScroll", this.network.getView(), this);
        } else {
            $html.removeEventListener("mousewheel", this.network.getView(), this);
        }
        $html.removeEventListener("mouseup", window, this);
        $html.removeEventListener("mousemove", window, this);

        this.network.removePropertyChangeListener(this.handleViewRectChange, this);
        this.network.removeMarker(this);
    },
    handleViewRectChange: function (e) {
        if (e.property == "viewRect" || e.property == "canvasSizeChange") {
            this.validateScrollBar();
        }
    },
    getScrollBarWidth: function () {
        return this.network.getScrollBarWidth();
    },
    getScrollBarColor: function () {
        return '#cccccc';
    },
    validateScrollBar: function () {
        this.hThumbRect = null;
        this.vThumbRect = null;
        if (this.network.isScrollBarVisible() == false) {
            this.repaint();
            return;
        }

        var h = this.network.getViewRect().height;
        var w = this.network.getViewRect().width;
        var x = this.network.getViewRect().x;
        var y = this.network.getViewRect().y;
        var realSize = this.network.getCanvasSize();
        var rw = realSize.width;
        var rh = realSize.height;
        if (rw > w) {
            if (x < 0 || x + w > rw) {
                this.repaint();
                return;
            }
        }
        if (rh > h) {
            if (y < 0 || y + h > rh) {
                this.repaint();
                return;
            }
        }
        var vth = 0;
        var vVisible = h < rh;
        var hVisible = w < rw;

        var scroolBarSize = this.getScrollBarWidth();

        if (h < rh) {
            if (hVisible) {
                vth = h * (h - scroolBarSize) / rh;
            } else {
                vth = h * h / rh;
            }
            var vy = y / (rh - h) * (h - vth - scroolBarSize);
            this.vThumbRect = {
                x: w - scroolBarSize,
                y: vy,
                width: scroolBarSize,
                height: vth
            }
        }
        var wtw = 0;
        if (w < rw) {
            if (vVisible) {
                wtw = w * (w - scroolBarSize) / rw;
            } else {
                wtw = w * w / rw;
            }
            var hx = x / (rw - w) * (w - wtw - scroolBarSize);
            this.hThumbRect = {
                x: hx,
                y: h - scroolBarSize,
                width: wtw,
                height: scroolBarSize
            }
        }
        this.network.setHScrollBarVisible(this.hThumbRect != null);
        this.network.setVScrollBarVisible(this.vThumbRect != null);

        this.repaint();
    },
    scrollXOffset:function(left){
        var h = this.network.getViewRect().height;
        var w = this.network.getViewRect().width;
        var x = this.network.getViewRect().x;
        var y = this.network.getViewRect().y;
        var xoffset = 30;
        if (left) {
            xoffset = -30;
        }
        this.network.setViewRect(x+xoffset, y, w, h);
    },
    scrollYOffset:function(up){
        var h = this.network.getViewRect().height;
        var w = this.network.getViewRect().width;
        var x = this.network.getViewRect().x;
        var y = this.network.getViewRect().y;
        var yoffset = 30;
        if (up) {
            yoffset = -30;
        }
        this.network.setViewRect(x, y+yoffset, w, h);
    },
    handle_mousedown: function (e) {
        if (this.network.isValidEvent(e) == true) {
            return;
        }
        var point = this.getMarkerPoint(e);

        this.hBarDownPoint = null;
        this.vBarDownPoint = null;
        if (this.vThumbRect != null) {
            if ($math.containsPoint(this.vThumbRect, point.x, point.y)) {
                this.vBarDownPoint = {
                    x: e.screenX,
                    y: e.screenY
                };
                this.vBarDownOffset = this.vBarDownPoint.y - this.vThumbRect.y;
            }
        }
        if (this.hThumbRect != null) {
            if ($math.containsPoint(this.hThumbRect, point.x, point.y)) {
                this.hBarDownPoint = {
                    x: e.screenX,
                    y: e.screenY
                };
                this.hBarDownOffset = this.hBarDownPoint.x - this.hThumbRect.x;
            }
        }
    },
    handle_mouseover: function (e) {
        if (this.scrollBarVisible == true) {
            return;
        }
        this.scrollBarVisible = true;
        this.repaint();
    },
    handle_mouseout: function (e) {
        if (this.scrollBarVisible == false) {
            return;
        }
        this.scrollBarVisible = false;
        this.repaint();
    },
    handleMouseUp: function (e) {
        this.vBarDownPoint = null;
        this.hBarDownPoint = null;
        this.repaint();
    },
    handleMouseMove: function (e) {
        var point = {
            x: e.screenX,
            y: e.screenY
        };
        var realSize = this.network.getCanvasSize();
        var h = this.network.getViewRect().height;
        var w = this.network.getViewRect().width;

        var scroolBarSize = this.getScrollBarWidth();

        if (this.hBarDownPoint != null) {
            var xoff = (point.x - this.hBarDownPoint.x);
            this.hBarDownPoint = point;
            this.network.setViewOffSet(xoff * realSize.width / (w - scroolBarSize), 0);
            return;
        }
        if (this.vBarDownPoint != null) {
            var yoff = (point.y - this.vBarDownPoint.y);
            this.vBarDownPoint = point;
            this.network.setViewOffSet(0, yoff * realSize.height / (h - scroolBarSize));
            return;
        }
    },
    handleMouseWheel: function (e) {
        var up = false;
        var left = false;
        if(e.wheelDelta !== e.wheelDeltaX){
             if (e.wheelDelta) {
                if (e.wheelDelta > 0) {
                    up = true;
                }
            } else {
                if (e.detail < 0) {
                    up = true;
                }
            }
            this.scrollYOffset(up);
        }else{
            if (e.wheelDelta) {
                if (e.wheelDelta > 0) {
                    up = true;
                }
            } else {
                if (e.detail < 0) {
                    up = true;
                }
            }
            this.scrollYOffset(up);
        }
    },
    paintRoundRect: function (ctx, fillStyle, alpha, x, y, w, h, r) {
        ctx.beginPath();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = fillStyle;
        $g.drawRoundRect(ctx, x, y, w, h, r);
        ctx.fill();
    },
    paint: function (ctx) {
        if (this.network.isScrollBarVisible() == false) {
            return;
        }
        if (this.scrollBarVisible == false) {
            if (this.hBarDownPoint == null && this.vBarDownPoint == null) {
                return;
            }
        }
        var scroolBarSize = this.getScrollBarWidth();
        var h = this.network.getViewRect().height;
        var w = this.network.getViewRect().width;

        ctx.save();
        var lingrad;
        var color = this.getScrollBarColor();
        if (this.hThumbRect != null) {
            lingrad = ctx.createLinearGradient(this.hThumbRect.x, this.hThumbRect.y, this.hThumbRect.x, this.hThumbRect.y + this.hThumbRect.height);
            lingrad.addColorStop(0, color);
            lingrad.addColorStop(1, '#666666');
            this.paintRoundRect(ctx, this.getScrollBarColor(), 0.5, 0, h - scroolBarSize, w - scroolBarSize, scroolBarSize, scroolBarSize / 2);
            this.paintRoundRect(ctx, lingrad, 0.9, this.hThumbRect.x, this.hThumbRect.y + 1, this.hThumbRect.width, this.hThumbRect.height - 2, scroolBarSize / 2);
        }
        if (this.vThumbRect != null) {
            lingrad = ctx.createLinearGradient(this.vThumbRect.x, this.vThumbRect.y, this.vThumbRect.x + this.vThumbRect.width, this.vThumbRect.y);
            lingrad.addColorStop(0, color);
            lingrad.addColorStop(1, '#666666');
            this.paintRoundRect(ctx, this.getScrollBarColor(), 0.5, w - scroolBarSize, 0, scroolBarSize, h - scroolBarSize, scroolBarSize / 2);
            this.paintRoundRect(ctx, lingrad, 0.9, this.vThumbRect.x + 1, this.vThumbRect.y, this.vThumbRect.width - 2, this.vThumbRect.height, scroolBarSize / 2);
        }
        ctx.restore();
    }
});

twaver.canvas.interaction.DefaultInteraction = function (network) {
    twaver.canvas.interaction.DefaultInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.DefaultInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove', 'keydown');
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove', 'keydown');
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if (this.network.isFocusOnClick()) {
            twaver.Util.setFocus(this.network.getView());
        }
        var element = this.network.getElementAt(e);
        if (e.detail === 2) {
            this.handleDoubleClicked(e, element);
        } else {
            this.handleClicked(e, element);
        }
    },
    handleClicked: function (e, element) {
        $network_interaction.handleClicked(this.network, e, element);
    },
    handleDoubleClicked: function (e, element) {
        $network_interaction.handleDoubleClicked(this.network, e, element);
    },
    handle_keydown: function (e) {
        $network_interaction.handleKeyDown(this.network, e);
    },
    handle_mousemove: function (e) {
        var element = this.network.getElementAt(e),
            preElement = this._preElement,
            preImage = _getElementImage(preElement),
            image = _getElementImage(element);
        if (preElement !== element) {
            if (preElement) {
                preImage && preImage.onMouseLeave && preImage.onMouseLeave(preElement, this.network);
                this.network.onMouseLeave(preElement, e);
            }
            if (element) {
                image && image.onMouseEnter && image.onMouseEnter(element, this.network);
                this.network.onMouseEnter(element, e);
            }
        }
        element && image && image.onMouseMove && image.onMouseMove(element, this.network);
        this.network.onMouseMove(element, e);
        this._preElement = element;
    }
});

twaver.canvas.interaction.PanInteraction = function (network) {
    twaver.canvas.interaction.PanInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.PanInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseup');
        this._oldCursor = this.network.getView().style.cursor;
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseup');
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        this.lastPoint = this.getMarkerPoint(e);

        if (this.lastPoint) {
            this.addListener('mousemove');
            this.network.getView().style.cursor = 'pointer';
        }
    },
    handle_mouseup: function (e) {
        this._clear();
    },
    handle_mousemove: function (e) {
        if (!this.lastPoint) {
            return;
        }
        var newPoint = this.getMarkerPoint(e);
        if (!newPoint) {
            return;
        }
        var xoffset = newPoint.x - this.lastPoint.x;
        var yoffset = newPoint.y - this.lastPoint.y;
        this.network.panByOffset(-xoffset, -yoffset);
        this.lastPoint = newPoint;
    },
    _clear: function (e) {
        if (this.lastPoint) {
            this.lastPoint = null;
            this.network.getView().style.cursor = this._oldCursor;
            this.removeListener('mousemove');
        }
    }
});
twaver.canvas.interaction.CreateElementInteraction = function (network, typeOrElementFunction) {
    if (!typeOrElementFunction) {
        typeOrElementFunction = twaver.Node;
    }
    if (twaver.Util.isTypeOf(typeOrElementFunction, twaver.Node)) {
        this.elementFunction = function (point) {
            var element = new typeOrElementFunction();
            if (element instanceof twaver.Node) {
                element.setCenterLocation(point);
            }
            return element;
        };
    } else {
        this.elementFunction = typeOrElementFunction;
    }
    twaver.canvas.interaction.CreateElementInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.CreateElementInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
    },
    tearDown: function () {
        this.removeListener('mousedown');
    },
    handle_mousedown: function (e) {
        var point = this.network.getLogicalPoint(e);
        if (point) {
            var element = this.elementFunction(point);
            if (element) {
                this.network.addElementByInteraction(element);
            }
        }
    }
});

twaver.canvas.interaction.EditInteraction = function (network, lazyMode) {
    this.lazyMode = lazyMode;
    this.pointIndex = -1;
    twaver.canvas.interaction.EditInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.EditInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseup', 'mousemove');
        this.oldCursor = this.network.getView().style.cursor;
        this.network.setHasEditInteraction(true);
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseup', 'mousemove');
        this.network.getView().style.cursor = this.oldCursor;
        this.network.setHasEditInteraction(false);
        this.clear();
        this.network.removeMarker(this);
    },
    paint: function (ctx) {
        if (this.lazyMode == true && this.resizingRect != null) {
            ctx.lineWidth = this.network.getResizeLineWidth();
            var rect = this.convertFromUIToMarkerRect(this.resizingRect, 0, 0);
            ctx.save();
            twaver.Util.rotateCanvas(ctx, rect, this.node.getAngle());
            ctx.beginPath();
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, null, this.network.getResizeLineColor());
            ctx.restore();
        }
        if(this.isStartRotate) {
            this.showRotateScale(ctx);
        }
    },
    clear: function () {
        this.network.setEditingElement(false);
        this.network.setRotatingElement(false);
        this.isStart = false;
        this.isStartRotate = false;
        this.node = null;
        this.shapeNode = null;
        this.shapeLink = null;
        this.linkUI = null;
        this.resizingRect = null;
        this.resizeDirection = null;
        this.pointIndex = -1;
        this._removeCursor();
        this.oldCursor = null;
        this.network.repaintTopCanvas();
    },
    _removeCursor: function () {
        if (this.cursorID) {
            this.network.getView().style.cursor = this.oldCursor || 'default';
            this.cursorID = null;
        }
        this.resizeDirection = null;
        this.isCrossCursor = false;
    },
    _setCrossCursor: function () {
        if (!this.isCrossCursor) {
            this._removeCursor();
            this._setCursor("crosshair");
            this.isCrossCursor = true;
        }
    },
    _setCursor: function (cursorID) {
        this.cursorID = cursorID;
        if (this.network.getView().style.cursor !== this.cursorID) {
            this.network.getView().style.cursor = this.cursorID;
        }
    },
    isKeyDown: function(e) {
        return _twaver.isAltDown(e);
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.isKeyDown(e) && !this.network.isEditingElement()) {
            var element = this.network.getElementAt(e);
            var point = this.network.getLogicalPoint(e);
            if (element instanceof twaver.ShapeNode) {
                var pointIndex = this.getPointIndex(element.getPoints(), point, true);
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeNode = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            if (element instanceof twaver.ShapeLink) {
                var points = new twaver.List(element.getPoints());
                var shapeLinkUI = this.network.getElementUI(element);
                points.add(shapeLinkUI.getFromPoint(), 0);
                points.add(shapeLinkUI.getToPoint());
                var pointIndex = this.getPointIndex(points, point) - 1;
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeLink = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            return;
        }
        if (!this.network.isEditingElement() || this.isStart || this.isStartRotate) {
            return;
        }
        if (this.node && this.resizeDirection) {
            this.isStart = true;
            this._handle_mousedown(e);
            this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyResizeStart' : 'liveResizeStart', event: e, element: this.node, resizeDirection: this.resizeDirection });
        } else if (this.shapeNode && this.pointIndex >= 0) {
            if (this.isKeyDown(e)) {
                this.shapeNode.removeAt(this.pointIndex);
                this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeNode });
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            }
        } else if (this.shapeLink && this.pointIndex >= 0) {
            if (this.isKeyDown(e)) {
                this.shapeLink.removeAt(this.pointIndex);
                this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeLink });
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
            }
        } else if (this.linkUI) {
            this.isStart = true;
            this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.linkUI._element });
        } else if (this.node) {
            this.isStartRotate = true;
            this._handle_mousedown(e);
        }
    },
    handle_mouseup: function (e) {
        if (this.isStart) {
            var point = this.network.getLogicalPoint(e);
            if (this.resizingRect) {
                if (this.lazyMode) {
                    if (this.network.isResizeAnimate()) {
                        var self = this;
                        var animate = new twaver.animate.AnimateBounds(this.node, this.resizingRect, function () {
                            self.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: self.node, resizeDirection: self.resizeDirection });
                            self.clear();
                        });
                        twaver.animate.AnimateManager.start(animate);
                    } else {
                        this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                        this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                        this.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                    }
                } else {
                    this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                    this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                    this.network.fireInteractionEvent({ kind: 'liveResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                }
            } else if (this.shapeNode && this.pointIndex >= 0 && point) {
                this.shapeNode.setPoint(this.pointIndex, point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            } else if (this.shapeLink && this.pointIndex >= 0 && point) {
                this.shapeLink.setPoint(this.pointIndex, point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
            } else if (this.linkUI && point) {
                this.linkUI.setControlPoint(point);
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.linkUI._element });
            }
        }
        this._handle_mouseup(e);
        // if (!this.lazyMode) { //canvasnetwork.setEditInteractions(true)
            this.clear();
        // }
    },
    handle_mousemove: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if(this.isStartRotate) {
            if(this.node) {
                this._handleRotateElement(e,this.node);
                if(this.network.isShowRotateScale()) {
                    this.repaint();
                }
                return;
            }
        }
        if (this.isStart) {
            if (this.shapeNode && this.pointIndex >= 0) {
                this._handleMovingShapeNodePoint(e);
                return;
            }
            if (this.shapeLink && this.pointIndex >= 0) {
                this._handleMovingShapeLinkPoint(e);
                return;
            }
            if (this.node && this.resizeDirection) {
                this._handleResizing(e);
                return;
            }
            if (this.linkUI) {
                this._handleMovingLinkControlPoint(e);
                return;
            }
        }
        if (this.network.isSelectingElement() || this.network.isMovingElement() || this.network.getSelectionModel().size() === 0) {
            this.clear();
            return;
        }

        var element = this.network.getElementAt(e);
        var elementUI = this.network.getElementUI(element);
        if (!elementUI || !elementUI.getEditAttachment()) {
            this.clear();
            return;
        }

        var point = this.network.getLogicalPoint(e);
        if (element instanceof twaver.Node) {
            this.node = element;
            if (this._isEditingShapeNode(point) || this._isResizingNode(point)) {
                this.network.setEditingElement(true);
                return;
            }
            if(this._isRotatingElement(point)) {
                this.network.setRotatingElement(true);
                this.network.setEditingElement(true)
                return;
            }
        } else if (element instanceof twaver.ShapeLink) {
            this.shapeLink = element;
            if (this._isEditingShapeLink(point)) {
                this.network.setEditingElement(true);
                return;
            }
        } else if (elementUI instanceof twaver.canvas.LinkUI) {
            var size = this.network.getEditPointSize();
            if ($link.isOrthogonalLink(elementUI._element)) {
                this.linkUI = elementUI;
                var controlPoint = this.linkUI.getControlPoint();
                if (controlPoint && this._contains(point, controlPoint,size)) {
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                }
                return;
            }
        }
        this.clear();
    },
    _isRotatingElement: function(point) {
        var size = this.network.getRotatePointSize();
        if (size <= 0) {
            return false;
        }
        var rect = this.node.getOriginalRect();
        var angle = this.node.getAngle();
        return this._isRotating(point, "crosshair", rect, angle);
    },
    _isRotating: function(point,cursor,rect,angle) {
        var size = this.network.getRotatePointSize();
        var p = {x: rect.x + rect.width/2 , y: rect.y - this.network.getRotatePointOffset() - size};
        var rotatep = this._rotatePoint(p, angle, rect);
        var newrect = { x: rotatep.x - size, y: rotatep.y - size , width: size * 2, height: size * 2};
        if($math.containsPoint(newrect, point)) {
            this._removeCursor();
            this._setCursor(cursor);
            return true;
        }
        return false;
    },
    _handleRotateElement: function(e,node) {
        this._handle_mousemove(e);
        var angle = this._calculateAngle(this.network.getLogicalPoint(e),node);
        node.setAngle(angle);
    },
    _calculateAngle: function(p,node) {
        var c = node.getCenterLocation();
        return Math.round(Math.atan2(c.x-p.x,p.y - c.y) * 180 / Math.PI + 180);
    },
    _handleMovingShapeNodePoint: function (e) {
        var point = this.network.getLogicalPoint(e);
        this.shapeNode.setPoint(this.pointIndex, point);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeNode, pointIndex: this.pointIndex });
    },
    _handleMovingShapeLinkPoint: function (e) {
        var point = this.network.getLogicalPoint(e);
        this.shapeLink.setPoint(this.pointIndex, point);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeLink, pointIndex: this.pointIndex });
    },
    _handleMovingLinkControlPoint: function (e) {
        this.linkUI.setControlPoint(this.network.getLogicalPoint(e));
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.linkUI._element });
    },
    _handleResizing: function (e) {
        this._handle_mousemove(e);
        var angle = this.node.getAngle();
        var oldLocation = this.node.getLocation();
        var w = this.node.getWidth()/2,h = this.node.getHeight()/2;
        var center = {x : oldLocation.x + w, y : oldLocation.y + h};

        var p1 = {x: (-w),y : (-h)}; // northwest
        var p2 = {x : (-w),y : h}; //southwest
        var p3 = {x : w, y : h};//southeast
        var p4 = {x : w,y :(-h)};//northeast
        var p5 = {x:0,y:-h};//north
        var p6 = {x:w,y:0};//east
        var p7 = {x:0,y:h};//south
        var p8 ={x:-w,y:0};//west


        if (this.resizeDirection === 'northwest') {
            this._transformPoint(p3,center,angle);
            p1.x = this._endLogical.x;
            p1.y = this._endLogical.y;

            center.x = (p1.x + p3.x) / 2;
            center.y = (p1.y + p3.y) / 2;

            this._reversPoint(p1,center,angle);
            this._reversPoint(p3,center,angle);

            this.resizingRect = {x:p1.x,y:p1.y,width:p3.x-p1.x,height:p3.y - p1.y};
        }
        if (this.resizeDirection === 'north') {
            var p= {x:this._endLogical.x, y:this._endLogical.y};

            this._reversPoint(p,center,angle);
            p5.y = p.y - center.y;
            this._transformPoint(p5,center,angle);
            this._transformPoint(p7,center,angle);


            center.x = (p5.x + p7.x) / 2;
            center.y = (p5.y + p7.y) / 2;

            this._reversPoint(p5,center,angle);
            this._reversPoint(p7,center,angle);

            this.resizingRect = {x:center.x - this.node.getWidth()/2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
        }
        if (this.resizeDirection === 'northeast') {
            this._transformPoint(p2,center,angle);
            p4.x = this._endLogical.x;
            p4.y = this._endLogical.y;

            center.x = (p2.x + p4.x) / 2;
            center.y = (p2.y + p4.y) / 2;

            this._reversPoint(p2,center,angle);
            this._reversPoint(p4,center,angle);

            this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
        }
        if (this.resizeDirection === 'west') {
            var p= {x:this._endLogical.x, y:this._endLogical.y};

            this._reversPoint(p,center,angle);
            p8.x = p.x - center.x;
            this._transformPoint(p6,center,angle);
            this._transformPoint(p8,center,angle);


            center.x = (p6.x + p8.x) / 2;
            center.y = (p6.y + p8.y) / 2;

            this._reversPoint(p6,center,angle);
            this._reversPoint(p8,center,angle);


            this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
        }
        if (this.resizeDirection === 'east') {
            var p= {x:this._endLogical.x, y:this._endLogical.y};

            this._reversPoint(p,center,angle);
            p6.x = p.x - center.x;
            this._transformPoint(p6,center,angle);
            this._transformPoint(p8,center,angle);


            center.x = (p6.x + p8.x) / 2;
            center.y = (p6.y + p8.y) / 2;

            this._reversPoint(p6,center,angle);
            this._reversPoint(p8,center,angle);


            this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
        }
        if (this.resizeDirection === 'southwest') {
            this._transformPoint(p4,center,angle);
            p2.x = this._endLogical.x;
            p2.y = this._endLogical.y;

            center.x = (p2.x + p4.x) / 2;
            center.y = (p2.y + p4.y) / 2;

            this._reversPoint(p2,center,angle);
            this._reversPoint(p4,center,angle);

            this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
        }
        if (this.resizeDirection === 'south') {
            var p= {x:this._endLogical.x, y:this._endLogical.y};

            this._reversPoint(p,center,angle);
            p7.y = p.y - center.y;
            this._transformPoint(p5,center,angle);
            this._transformPoint(p7,center,angle);


            center.x = (p5.x + p7.x) / 2;
            center.y = (p5.y + p7.y) / 2;

            this._reversPoint(p5,center,angle);
            this._reversPoint(p7,center,angle);


            this.resizingRect = {x:center.x - this.node.getWidth() / 2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
        }
        if (this.resizeDirection === 'southeast') {
            this._transformPoint(p1,center,angle);
            p3.x = this._endLogical.x;
            p3.y = this._endLogical.y;

            center.x = (p1.x + p3.x) / 2;
            center.y = (p1.y + p3.y) / 2;

            this._reversPoint(p1,center,angle);
            this._reversPoint(p3,center,angle);

            this.resizingRect = {x:p1.x,y:p1.y,width:p3.x - p1.x,height:p3.y - p1.y};
        }

        if (this.lazyMode) {
            this.repaint();
            this.network.fireInteractionEvent({ kind: 'lazyResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
        } else {
            this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
            this.node.setSize(this.resizingRect.width, this.resizingRect.height);
            this.network.fireInteractionEvent({ kind: 'liveResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
        }
    },
    _isEditingShapeNode: function (point) {
        var size = this.network.getEditPointSize();
        if (this.node instanceof twaver.ShapeNode) {
            this.shapeNode = this.node;
            var points = this.shapeNode.getPoints();
            for (var i = 0, n = points.size(); i < n; i++) {
                var p = points.get(i);
                if (this._contains(point, p, size)) {
                    this._setCrossCursor();
                    this.pointIndex = i;
                    return true;
                }
            }
        }
        this.pointIndex = -1;
        return false;
    },
    _isEditingShapeLink: function (point) {
        var size = this.network.getEditPointSize();
        var points = this.shapeLink.getPoints();
        for (var i = 0, n = points.size(); i < n; i++) {
            var p = points.get(i);
            if (this._contains(point, p, size)) {
                this._setCrossCursor();
                this.pointIndex = i;
                return true;
            }
        }
        this.pointIndex = -1;
        return false;
    },
    _isResizingNode: function (point) {
        var size = this.network.getResizePointSize();
        if (size <= 0) {
            return false;
        }
        var rect = this.node.getOriginalRect();
        var angle = this.node.getAngle();
        var p = {x: rect.x, y:rect.y};
        var rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x, rotatep.y, 'northwest', 'nwse-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width / 2, y: rect.y};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'north', 'ns-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y:rect.y};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,rotatep.x ,rotatep.y, 'northeast', 'nesw-resize')) {
            return true;
        }
        p = {x: rect.x, y:rect.y + rect.height / 2};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'west', 'ew-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y: rect.y + rect.height / 2};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,  rotatep.x ,rotatep.y, 'east', 'ew-resize')) {
            return true;
        }
        p = {x: rect.x, y: rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,rotatep.x ,rotatep.y, 'southwest', 'nesw-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width / 2, y: rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'south', 'ns-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y:rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'southeast', 'nwse-resize')) {
            return true;
        }
        return false;
    },
    _rotatePoint: function(point,angle,rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _isResizing: function (point, x, y, direction, cursor) {
        var size = this.network.getResizePointSize();
        if (this._contains(point, { x: x, y: y },size)) {
            if (this.resizeDirection !== direction) {
                this._removeCursor();
                cursor = this._changeCursorWithAngle(direction, this.node.getAngle());
                this._setCursor(cursor);
                this.resizeDirection = direction;
            }
            return true;
        }
        return false;
    },
    _getRect: function (x1, y1, x2, y2) {
        var x = x1 < x2 ? x1 : x2;
        var y = y1 < y2 ? y1 : y2;
        var w = Math.abs(x1 - x2);
        var h = Math.abs(y1 - y2);
        return { x: x, y: y, width: w, height: h };
    },
    _contains: function (point, center, size) {
        var rect = { x: center.x - size, y: center.y - size, width: size * 2, height: size * 2 };
        return $math.containsPoint(rect, point);
    },
    getPointIndex: function (points, point, closed) {
        if(points.size() < 2){
            return 0;
        }
        var p1 = points.get(0), p2;
        for(var i=1; i<points.size(); i++){
            p2 = points.get(i);
            if(this.isPointOnLine(point, p1, p2, 6)){
                return i;
            }
            p1 = p2;
        }
        p1 = points.get(0);
        if(closed && this.isPointOnLine(point, p1, p2, 6)){
            return points.size();
        }
        return 0;
    },
    showRotateScale: function(ctx) {
        var rmpList = new twaver.List(),
            width = this.network.getRotateScaleWidth(),
            height = this.network.getRotateScaleHeight(),
            size = this.network.getRotatePointSize(),
            angle = this.node.getAngle(),
            rect = this.node.getOriginalRect(),
            point = {x: rect.x + rect.width / 2, y: rect.y - this.network.getRotatePointOffset() - size},
            rotatePoint = this._rotatePoint(point, angle, rect),
            rscaleRect,
            font = "13px Arial",
            text = angle + '\u00B0',
            p1,p2,p3,p4;
        if(this.node.getAngle() >= 0 && this.node.getAngle() <= 180) {
            p1 = {x: rotatePoint.x + size, y: rotatePoint.y};
            p2 = {x: p1.x + width, y: p1.y};
            p3 = {x: p2.x, y: p2.y -  height};
            p4 = {x: p1.x, y: p3.y};
        } else if (this.node.getAngle() > 180 && this.node.getAngle() <= 360) {
            p1 = {x: rotatePoint.x - size, y: rotatePoint.y};
            p2 = {x: p1.x - width, y: p1.y};
            p3 = {x: p2.x, y: p2.y - height};
            p4 = {x: p1.x, y: p3.y};
        }
        var rscalePointsList = new twaver.List([p1,p2,p3,p4]),
            rscaleRect = _twaver.math.getRect(rscalePointsList);
        ctx.fillStyle = this.network.getRotateScaleFillColor();
        ctx.fillRect(rscaleRect.x, rscaleRect.y, rscaleRect.width, rscaleRect.height);
        ctx.fillStyle = this.network.getRotateScaleFontColor();
        ctx.textBaseline="middle";
        ctx.textAlign = "center";
        ctx.font = font;
        ctx.fillText(text, rscaleRect.x + rscaleRect.width / 2, rscaleRect.y + rscaleRect.height/2);

    },
    isPointOnLine: function (point, point1, point2, width) {
        if(width < 0){
            width = 0;
        }
        var distance = this.getDistanceFromPointToLine(point, point1, point2);
        return distance <= width &&
            (point.x >= Math.min(point1.x, point2.x) - width) &&
            (point.x <= Math.max(point1.x, point2.x) + width) &&
            (point.y >= Math.min(point1.y, point2.y) - width) &&
            (point.y <= Math.max(point1.y, point2.y) + width);
    },
    getDistanceFromPointToLine: function (point, point1, point2) {
        if (point1.x === point2.x) {
            return Math.abs(point.x - point1.x);
        }
        var lineK = (point2.y - point1.y) / (point2.x - point1.x);
        var lineC = (point2.x * point1.y - point1.x * point2.y) / (point2.x - point1.x);
        return Math.abs(lineK * point.x - point.y + lineC) / (Math.sqrt(lineK * lineK + 1));
    },
    _transformPoint : function(p,center,angle){
        var cos = Math.cos(angle * Math.PI / 180);
        var sin = Math.sin(angle * Math.PI / 180);
        var x = p.x;
        var y = p.y;

        var newX = x * cos - y *sin;
        var newY = x * sin + y *cos;

        p.x = newX + center.x;
        p.y = newY + center.y;
    },

    _reversPoint : function(p,center,angle){
        angle *= -1;
        var cos = Math.cos(angle * Math.PI / 180);
        var sin = Math.sin(angle * Math.PI / 180);
        var x = p.x - center.x;
        var y = p.y - center.y;

        var newX = x * cos - y *sin;
        var newY = x * sin + y *cos;

        p.x = newX + center.x;
        p.y = newY + center.y;
    },
    _changeCursorWithAngle: function(direction, angle) {
        var flag,cursorArray = ['auto','nwse-resize','ns-resize','nesw-resize','ew-resize','nwse-resize','ns-resize','nesw-resize','ew-resize'];
        switch(direction)
        {
            case 'northwest':
                flag = 1;
                break;
            case 'north':
                flag = 2
                break;
            case 'northeast':
                flag = 3
                break;
            case 'east':
                flag = 4;
                break;
            case 'southeast':
                flag = 5;
                break;
            case 'south':
                flag = 6;
                break;
            case 'southwest':
                flag = 7;
                break;
            case 'west':
                flag = 8;
                break;
            default:
                flag = 0;
        }
        if(angle >= 360 || angle <= -360) {
            angle = angle % 360;
        }
        if(angle > 45 / 2 && angle <= 135 / 2) {
            flag = flag + 1;
        }
        if(angle < -45/2 && angle >= -135/2) {
            flag = flag - 1;
        }
        if(angle > 135 / 2 && angle <= 225 / 2) {
            flag = flag + 2;
        }
        if(angle < -135 / 2 && angle >= -225 / 2) {
            flag = flag - 2;
        }
        if(angle > 225 / 2 && angle <= 315 / 2) {
            flag = flag + 3;
        }
        if(angle < -225 / 2 && angle >= -315 / 2) {
            flag = flag - 3;
        }
        if(angle > 315 / 2 && angle <= 405 / 2) {
            flag = flag + 4;
        }
        if(angle < -315 / 2 && angle >= -405 / 2) {
            flag = flag - 4;
        }
        if(angle > 405 / 2 && angle <= 495 / 2) {
            flag = flag + 5;
        }
        if(angle < -405 / 2 && angle >= -495 / 2) {
            flag = flag - 5;
        }
        if(angle > 495 / 2 && angle <= 585 / 2) {
            flag = flag + 6;
        }
        if(angle < -495 / 2 && angle >= -585 / 2) {
            flag = flag - 6;
        }
        if(angle > 585 / 2 && angle <= 675 / 2) {
            flag = flag + 7;
        }
        if(angle < -585 / 2 && angle >= -675 / 2) {
            flag = flag - 7;
        }
        if(flag > 8) {
            flag = flag - 8;
        }
        if(flag <= 0) {
            flag = flag + 8;
        }
        return cursorArray[flag];
    }
});

twaver.canvas.interaction.MoveLinkInteraction = function(network, lazyMode) {
	twaver.canvas.interaction.MoveLinkInteraction.superClass.constructor.call(this, network);
	//this.lazyMode = lazyMode;
	this.xoffset = 0;
	this.yoffset = 0;
};
_twaver.ext('twaver.canvas.interaction.MoveLinkInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
        this.oldCursor = this.network.getView().style.cursor;
    },
    tearDown: function () {
        this.removeListener('mousedown'/*, 'mousemove'*/);
        this.network.getView().style.cursor = this.oldCursor;
        this.end();
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.network.isSelectingElement() || this.network.isEditingElement()) {
            return;
        }
        var element = this.network.getElementAt(e);
        if (!(element instanceof twaver.Link)) {
            return;
        }
        this.element = element;
        this.end(e);
        this._handle_mousedown(e);
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (!this._startLogical
            || this.network.isSelectingElement()
            || this.network.isEditingElement()) {
            this.end(e);
        return;
    }
    this._handle_mousemove(e);

    this.xoffset = this._endLogical.x - this._startLogical.x;
    this.yoffset = this._endLogical.y - this._startLogical.y;

    if (this.lazyMode) {
        if (this.mark) {
            this.network.fireInteractionEvent({
                kind: 'lazyMoveBetween',
                event: e,
                element: this.element
            });
        } else {
            this.mark = $html.createCanvas();

            var rect;
            this.network.getMovableSelectedElements().forEach(
              function (element) {
                  var ui = this.getElementUI(element);
                  if (ui) {
                      rect = $math.unionRect(rect, ui.getViewRect());
                  }
              }, this.network);

            this.network.getTopDiv().appendChild(this.mark);
            this.network.setMovingElement(true);

            $html.setDiv(this.mark, rect, this.network
                .isLazyMoveFill() ? this.network
                .getLazyMoveFillColor() : null,
                this.network.getLazyMoveOutlineWidth(),
                this.network.getLazyMoveOutlineColor());

            this.network.fireInteractionEvent({
                kind: 'lazyMoveStart',
                event: e,
                element: this.element
            });
        }
        this.mark.style.left = this.xoffset + this.mark._viewRect.x + "px";
        this.mark.style.top = this.yoffset + this.mark._viewRect.y + "px";
    } else {
        var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
        twaver.Util.moveElements(elements, this.xoffset, this.yoffset);
        this._startLogical = this._endLogical;
        this._startClient = $html.getClientPoint(e);
        if (this.network.isMovingElement()) {
            this.network.fireInteractionEvent({
                kind: 'liveMoveBetween',
                event: e,
                element: this.element
            });
        } else {
            this.network.setMovingElement(true);
            this.network.fireInteractionEvent({
                kind: 'liveMoveStart',
                event: e,
                element: this.element
            });
        }
    }
},
end: function (e) {
    if (this._startLogical) {
        if (this.lazyMode) {
            if (this.mark) {
                var self = this;
                var f = function () {
                    self.network.fireInteractionEvent({
                        kind: 'lazyMoveEnd',
                        event: e,
                        element: this.element
                    });
                    if (self.mark) {
                        self.network.getTopDiv().removeChild(self.mark);
                        self.mark = null;
                        self.network.setMovingElement(false);
                    }
                };
                var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
                twaver.Util.moveElements(elements, this.xoffset, this.yoffset, this.network.isLazyMoveAnimate(), f);
            }
        } else {
            if (this.network.isMovingElement()) {
                this.network.setMovingElement(false);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveEnd',
                    event: e,
                    element: this.element
                });

            }
        }
        this._handle_mouseup(e);
        delete this.element;
    }
}
});

twaver.canvas.interaction.CreateLinkInteraction = function (network, typeOrLinkFunction) {
    if (!typeOrLinkFunction) {
        typeOrLinkFunction = twaver.Link;
    }
    if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.Link)) {
        this.linkFunction = function (fromNode, toNode) {
            var link = new typeOrLinkFunction();
            if (link instanceof twaver.Link) {
                link.setFromNode(fromNode);
                link.setToNode(toNode);
            }
            return link;
        };
    } else {
        this.linkFunction = typeOrLinkFunction;
    }
    twaver.canvas.interaction.CreateLinkInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.CreateLinkInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove');
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove');
        this.clear();
        this.network.removeMarker(this);
    },
    paint: function (ctx) {
        ctx.beginPath();
        var rect;
        var r;
        ctx.lineWidth = this.network.getEditLineWidth();
        var lineColor = this.network.getEditLineColor();
        if (this.currentNode && this.currentNode !== this.fromNode) {
            rect = this.network.getElementUI(this.currentNode).getViewRect();
            r = this.convertFromUIToMarkerRect(rect, 0, 0);
            $CanvasUtil.rect(ctx, r.x, r.y, r.width, r.height, null, lineColor);
        }
        if (this.fromNode) {
            rect = this.network.getElementUI(this.fromNode).getViewRect();
            r = this.convertFromUIToMarkerRect(rect, 0, 0);
            $CanvasUtil.rect(ctx, r.x, r.y, r.width, r.height, null, lineColor);
        }
        if (this.currentPoint) {
            this.paintLine(ctx);
        }
        ctx.closePath();
    },
    paintLine: function (ctx) {
        var lineColor = this.network.getEditLineColor();
        var center = this.convertPointFromView(this.fromNode.getCenterLocation());
        var x1 = center.x, y1 = center.y;
        var x2 = this.currentPoint.x, y2 = this.currentPoint.y;
        ctx.strokeStyle = lineColor;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
    },
    clear: function () {
        this.currentPoint = null;
        this.currentNode = null;
        this.fromNode = null;
        this.toNode = null;
    },
    createLink: function () {
        return this.linkFunction(this.fromNode, this.toNode);
    },
    handle_mousedown: function (e) {
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if (this.fromNode) {
            this.toNode = this.currentNode;
            if (this.toNode) {
                var link = this.createLink();
                if (link) {
                    this.network.addElementByInteraction(link);
                }
            }
            this.clear();
        } else {
            this.fromNode = this.currentNode;
            this.currentNode = null;
            this.currentPoint = null;
            this.repaint();
        }
    },
    handle_mousemove: function (e) {
        var point = this.getMarkerPoint(e);
        if (!point) {
            return;
        }
        if (this.network.isMovingElement() || this.network.isEditingElement()) {
            this.clear();
            return;
        }
        var node = null;
        if (this.fromNode) {
            this.currentNode = this.getToNode(e);
            this.currentPoint = point;
            this.repaint();
        } else {
            node = this.getFromNode(e);
            if (this.currentNode !== node) {
                this.currentNode = node;
                this.repaint();
            }
        }
    },
    getFromNode: function (e) {
        return this.getNode(e);
    },
    getToNode: function (e) {
        return this.getNode(e);
    },
    getNode: function (e) {
        var node = this.network.getElementAt(e);
        if (node instanceof $Node && this.network.isLinkable(node) && this.network.getElementBox().getSelectionModel().isSelectable(node)) {
            return node;
        }
        return null;
    }
});

twaver.canvas.interaction.CreateShapeLinkInteraction = function (network, typeOrLinkFunction) {
    twaver.canvas.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, network);
    if (!typeOrLinkFunction) {
        typeOrLinkFunction = twaver.ShapeLink;
    }
    if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.ShapeLink)) {
        this.linkFunction = function (fromNode, toNode, points) {
            var link = new typeOrLinkFunction();
            if (link instanceof twaver.ShapeLink) {
                link.setFromNode(fromNode);
                link.setToNode(toNode);
                if (points) {
                    link.setPoints(points);
                }
            }
            return link;
        };
    } else {
        this.linkFunction = typeOrLinkFunction;
    }
};
_twaver.ext('twaver.canvas.interaction.CreateShapeLinkInteraction', twaver.canvas.interaction.CreateLinkInteraction, {
    clear: function () {
        this.points = null;
        twaver.canvas.interaction.CreateShapeLinkInteraction.superClass.clear.call(this);
    },
    createLink: function () {
        return this.linkFunction(this.fromNode, this.toNode, this.points);
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        if (this.fromNode) {
            this.toNode = this.currentNode;
            if (this.toNode) {
                var shapeLink = this.createLink();
                if (shapeLink) {
                    this.network.addElementByInteraction(shapeLink);
                }
                this.clear();
            } else {
                if (!this.points) {
                    this.points = new twaver.List();
                }
                if (this.points.size() > 0) {
                    var lastPoint = this.points.get(this.points.size() - 1);
                    if (lastPoint.x === point.x && lastPoint.y === point.y) {
                        return;
                    }
                }
                this.points.add(point);
            }
        } else {
            this.fromNode = this.currentNode;
            this.points = null;
            this.currentNode = null;
            this.currentPoint = null;
        }
        this.repaint();
    },
    paintLine: function (ctx) {
        if (this.currentPoint) {
            var newPoints = new twaver.List();
            var np;
            np = this.convertPointFromView(this.fromNode.getCenterLocation());
            newPoints.add(np, 0);
            if (this.points && this.points.size() > 0) {
                var size = this.points.size();
                for (var i = 0; i < size; i++) {
                    np = this.convertPointFromView(this.points.get(i));
                    newPoints.add(np);
                }
            }
            // np = this.convertPointFromView(this.currentPoint);
            np = this.currentPoint;
            newPoints.add(np);
            ctx.lineWidth = this.network.getEditLineWidth();
            ctx.strokeStyle = this.network.getEditLineColor();
            ctx.beginPath();
            $g.drawLinePoints(ctx, newPoints);
            ctx.stroke();
        }
    }
});

twaver.canvas.interaction.CreateShapeNodeInteraction = function (network, typeOrShapeNodeFunction) {
    if (!typeOrShapeNodeFunction) {
        typeOrShapeNodeFunction = twaver.ShapeNode;
    }
    if (twaver.Util.isTypeOf(typeOrShapeNodeFunction, twaver.ShapeNode)) {
        this.shapeNodeFunction = function (points) {
            var shapeNode = new typeOrShapeNodeFunction();
            if (shapeNode instanceof twaver.ShapeNode) {
                if (points) {
                    shapeNode.setPoints(points);
                }
            }
            return shapeNode;
        };
    } else {
        this.shapeNodeFunction = typeOrShapeNodeFunction;
    }
    twaver.canvas.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, network);
    this.timeStamp = -1;
};
_twaver.ext('twaver.canvas.interaction.CreateShapeNodeInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mousemove');
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mousemove');
        this.clear();
        this.network.removeMarker(this);
        this.network.setEditingElement(false);
    },
    clear: function () {
        this.points = null;
        this.currentPoint = null;
    },
    paint: function (ctx) {
        if (this.points && this.points.size() > 0) {
            if (this.currentPoint) {
                var newPoints = new twaver.List();
                var size = this.points.size();
                var np;
                for (var i = 0; i < size; i++) {
                    np = this.convertPointFromView(this.points.get(i));
                    newPoints.add(np);
                }
                np = this.convertPointFromView(this.currentPoint);
                newPoints.add(np);
                ctx.lineWidth = this.network.getEditLineWidth();
                ctx.strokeStyle = this.network.getEditLineColor();
                ctx.beginPath();
                $g.drawLinePoints(ctx, newPoints);
                ctx.stroke();
            }
        }
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var point = this.network.getLogicalPoint(e);
        if (!point) {
            return;
        }
        if (e.detail === 2 || e.timeStamp - this.timeStamp < 300) {
            if (this.points) {
                var shapeNode = this.shapeNodeFunction(this.points);
                this.network.addElementByInteraction(shapeNode);
                this.clear();
                var self = this;
                setTimeout(function () {
                    self.network.setEditingElement(false);
                }, 0);
            }
        } else {
            if (!this.network.isEditingElement()) {
                this.network.setEditingElement(true);
            }
            if (!this.points) {
                this.points = new twaver.List();
            }
            if (this.points.size() > 0) {
                var lastPoint = this.points.get(this.points.size() - 1);
                if (lastPoint.x === point.x && lastPoint.y === point.y) {
                    return;
                }
            }
            this.points.add(point);
        }
        this.timeStamp = e.timeStamp;
        this.repaint();
    },
    handle_mousemove: function (e) {
        if (this.points) {
            this.currentPoint = this.network.getLogicalPoint(e);
            this.repaint();
        }
    }
});

twaver.canvas.interaction.MagnifyInteraction = function(network, zoom, xRadius, yRadius, shape) {
	twaver.canvas.interaction.MagnifyInteraction.superClass.constructor.call(this, network);
	this.zoom = zoom || 2;
	this.xRadius = xRadius || 100;
	this.yRadius = yRadius || 100;
	this.shape = shape || 'circle';
	this.borderColor = 'black';
	this.borderWidth = 1;
	this.backgroundColor = 'white';
	this.markCanvas = $html.createCanvas();
};
_twaver.ext('twaver.canvas.interaction.MagnifyInteraction', twaver.canvas.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousemove');
		this.network.addMarker(this);
	},
	tearDown : function() {
		this.removeListener('mousemove');
		this.network.removeMarker(this);
	},
	paint : function(g) {
		if (!this.point) {
		    return;
		}
		var zoom = this.network._zoom,
		    scale = this.zoom * zoom,
		    x = this.point.x * zoom - this.network.viewRect.x - this.xRadius,
		    y = this.point.y * zoom - this.network.viewRect.y - this.yRadius,
		    width = this.xRadius * 2,
		    height = this.yRadius * 2,
		    rect = {
    		    x: this.point.x - this.xRadius / scale,
    		    y: this.point.y - this.yRadius / scale,
    		    width: width / scale,
    		    height: height / scale
    		},
    		borderWidth = this.borderWidth,
    		canvas = $html.createCanvas();
		
		canvas.width = width;
		canvas.height = height;
		this.network.toCanvasByRegion(rect, scale, canvas);
    	
		g.save();
		g.beginPath();
		$g.drawVector(g, this.shape, null, x, y, width, height);
		g.clip();
		// background
        g.fillStyle = this.backgroundColor;
        g.beginPath();
    	g.rect(x, y, width, height);
    	g.fill();
    	// image
    	g.drawImage(canvas, x, y);
    	g.restore();
    	// border
		g.beginPath();
		g.lineWidth = borderWidth;
		$g.drawVector(g, this.shape, null, x + borderWidth / 2, y + borderWidth / 2, width - borderWidth, height - borderWidth);
		g.strokeStyle = this.borderColor;
		g.stroke();
	},
	handle_mousemove : function(e) {
		this.point = this.network.getLogicalPoint(e);
		if (!this.point) {
			return;
		}
		this.repaint();
	},
	getZoom: function () {
	    return this.zoom;
	},
	setZoom: function (value) {
	    this.zoom = value;
	    this.network.repaintTopCanvas();
	},
	getShape: function () {
	    return this.shape;
	},
	setShape: function (value) {
	    this.shape = value;
	    this.network.repaintTopCanvas();
	},
	getXRadius: function () {
	    return this.xRadius;
	},
	setXRadius: function (value) {
	    this.xRadius = value;
	    this.network.repaintTopCanvas();
	},
	getYRadius: function () {
	    return this.yRadius;
	},
	setYRadius: function (value) {
	    this.yRadius = value;
	    this.network.repaintTopCanvas();
	},
	getBorderColor: function () {
	    return this.borderColor;
	},
	setBorderColor: function (value) {
	    this.borderColor = value;
	    this.network.repaintTopCanvas();
	},
	getBorderWidth: function () {
	    return this.borderWidth;
	},
	setBorderWidth: function (value) {
	    this.borderWidth = value;
	    this.network.repaintTopCanvas();
	},
	getBackgroundColor: function () {
	    return this.backgroundColor;
	},
	setBackgroundColor: function (value) {
	    this.backgroundColor = value;
	    this.network.repaintTopCanvas();
	}
});

twaver.canvas.interaction.TouchInteraction = function (network) {
    twaver.canvas.interaction.TouchInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.canvas.interaction.TouchInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener('touchstart', 'handleTouchstart', view, this);
        $html.addEventListener('touchmove', 'handleTouchmove', view, this);
        $html.addEventListener('touchend', 'handleTouchend', view, this);
        $html.addEventListener('touchcancel', 'handleTouchend', view, this);
        this.network.addMarker(this);
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener('touchstart', this.network.getView(), this);
        $html.removeEventListener('touchmove', view, this);
        $html.removeEventListener('touchend', view, this);
        $html.removeEventListener('touchcancel', view, this);
        this.network.removeMarker(this);
    },
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        if (e.touches && e.touches.length == 1) {
            var point = this.network.getLogicalPoint(e);
            var element = this.network.getElementAt(point);
            this._startTouchTime = new Date();
            this._startTouchPoint = point;
            this._startTouchClient = this.getMarkerPoint(e);
            if (element) {
                this._haveElementUnderTouch = true;
                this._startTouchElement = element;
            } else {
                this._haveElementUnderTouch = false;
                this._startTouchElement = null;
            }
            this.timer = setTimeout(function(){
                $network_interaction.handleLongClicked(self.network,e,element);
            },1000);

        } else if (e.touches && e.touches.length == 2) {
            this._distance = $touch.getDistance(e);
            this._zoom = this.network.getZoom();
        }
        this._touchCount = e.touches.length;
    },
    handleTouchmove: function (e) {
        $html.preventDefault(e);
        if (this._touchCount == 2 && e.touches && e.touches.length == 2) {
            if(this.timer) {
                clearTimeout(this.timer);
            }
            if(Math.abs(this._distance - $touch.getDistance(e)) >= $Defaults.TOUCH_ZOOM_THRESHOLD || this._zoomFlag) {
                this._zoomFlag = true;
                var scale = $touch.getDistance(e) / this._distance;
                this.network.setTouchZoom(this._zoom*scale,false);
            }else{
                //pan
                var newClientPoint = this.getMarkerPoint(e);
                var xoffset = this._startTouchClient.x - newClientPoint.x;
                var yoffset = this._startTouchClient.y - newClientPoint.y;
                this.network.panByOffset(xoffset, yoffset);
                this._startTouchClient = newClientPoint;
            }
        } else if (this._touchCount == 1 && e.touches && e.touches.length == 1) {
            if (this._haveElementUnderTouch || !this.network.isRectSelectEnabled()) {
                var newPoint = this.network.getLogicalPoint(e);
                var element = this.network.getElementAt(newPoint);
                if (this.network.isMovingElement() || (this._startTouchElement != null && this._startTouchElement == element && this.network.getMovableSelectedElements().contains(element))) {
                    //drag element
                    var xoffset = newPoint.x - this._startTouchPoint.x;
                    var yoffset = newPoint.y - this._startTouchPoint.y;
                    if(Math.abs(xoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD || Math.abs(yoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD) {
                        this._startTouchPoint = newPoint;
                        this.network.moveSelectedElements(xoffset, yoffset);
                        if (this.network.isMovingElement()) {
                            this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                        } else {
                            this.network.setMovingElement(true);
                            this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                            if(this.timer) {
                                clearTimeout(this.timer);
                            }
                        }
                    }
                } else {
                    var xoffset = newPoint.x - this._startTouchPoint.x;
                    var yoffset = newPoint.y - this._startTouchPoint.y;
                    if(Math.abs(xoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD || Math.abs(yoffset) >= $Defaults.TOUCH_MOVE_THRESHOLD) {
                        if (this.timer) {
                            clearTimeout(this.timer);
                        }
                    }
//                    pan
                    var newClientPoint = this.getMarkerPoint(e);
                    var xoffset = this._startTouchClient.x - newClientPoint.x;
                    var yoffset = this._startTouchClient.y - newClientPoint.y;
                    this.network.panByOffset(xoffset, yoffset);
                    this._startTouchClient = newClientPoint;
                }
            } else {
                var point = this.network.getLogicalPoint(e);
                if (!point) {
                    return;
                }
                //rect select

                var xoffset =  point.x - this._startTouchPoint.x;
                var yoffset =  point.y - this._startTouchPoint.y;
                if(Math.abs(xoffset) >= $Defaults.TOUCH_RECT_SELECT_THRESHOLD  && Math.abs(yoffset) >= $Defaults.TOUCH_RECT_SELECT_THRESHOLD) {
                    this.network.setSelectingElement(true);
                    if (this._moveTouchPoint) {
                        this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
                    } else {
                        this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
                    if (this.timer) {
                        clearTimeout(this.timer);
                    }
                    }
                    this._moveTouchPoint = point;
                    this.repaint();
                }
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        } else if (this.network.isSelectingElement()) {
            var rect = $math.getRect([this._startTouchPoint, this._moveTouchPoint]);
            var elements = this.network.getElementsAtRect(rect, this.getIntersectMode(), this.network.getRectSelectFilter());
            if (elements && elements.size() > 0) {
                var sm = this.network.getSelectionModel();
                var selections = sm.toSelection();
                elements.forEach(function (element) {
                    if (sm.contains(element)) {
                        selections.remove(element);
                    } else {
                        selections.add(element);
                    }
                }, this);
                sm.setSelection(selections);
            }
            this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            this._moveTouchPoint = null;
            this.network.setSelectingElement(false);
//            if(this.timer) {
//                clearTimeout(this.timer);
//            }
            this.repaint();
        } else if (this._startTouchPoint) {
            //set this.zoomFlag = false;
            this._zoomFlag = false;

            //handle click&double click
            var endTouchTime = new Date();
            var endTouchPoint = this.network.getLogicalPoint(e);
            var element = this.network.getElementAt(this._startTouchPoint);
            if (endTouchPoint && (endTouchTime.getTime() - this._startTouchTime.getTime()) <= 500
        		&& $math.getDistance(this._startTouchPoint, endTouchPoint) <= 20) {
                if (element) {
                    if (!this.network.getSelectionModel().contains(element)) {
                        this.network.getSelectionModel().setSelection(element);
                    }
                } else {
                    this.network.getSelectionModel().clearSelection();
                }

                $network_interaction.handleClicked(this.network, e, element);
                if(this.timer) {
                    clearTimeout(this.timer);
                }
                if (this._endTouchTime
        		&& (endTouchTime.getTime() - this._endTouchTime.getTime()) <= 500
                && $math.getDistance(this._endTouchPoint, endTouchPoint) <= 20) {
                    delete this._endTouchTime;
                    delete this._endTouchPoint;
                    $network_interaction.handleDoubleClicked(this.network, e, element);
                } else {
                    this._endTouchTime = endTouchTime;
                    this._endTouchPoint = endTouchPoint;
                }
            }
        }

    },
    paint: function (ctx) {
        if (!this._startTouchPoint || !this._moveTouchPoint) {
            return;
        }
        var sp = this.convertPointFromView(this._startTouchPoint);
        var ep = this.convertPointFromView(this._moveTouchPoint);
        var sx = sp.x;
        var sy = sp.y;
        var ex = ep.x;
        var ey = ep.y;
        var rect = $math.getRect([{ x: sx, y: sy }, { x: ex, y: ey}]);
        if (rect != null) {
            ctx.beginPath();
            var lineWidth = this.network.getSelectOutlineWidth();
            var fillStyle = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
            ctx.strokeStyle = this.network.getSelectOutlineColor();
            ctx.lineWidth = lineWidth;
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, fillStyle, this.network.getSelectOutlineColor());
            ctx.closePath();
        }
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
    }

});
twaver.canvas.interaction.MSTouchInteraction = function (network) {
    twaver.canvas.interaction.MSTouchInteraction.superClass.constructor.call(this, network);
    this._pointerMap = {};
    this._pointerIdArray = [];
};
_twaver.ext('twaver.canvas.interaction.MSTouchInteraction', twaver.canvas.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener("MSPointerDown", "handleTouchstart", view, this)
        $html.addEventListener("MSPointerMove", "handleTouchmove", view, this)
        $html.addEventListener("MSPointerUp", "handleTouchend", view, this)
        $html.addEventListener("MSPointerCancel", "handleTouchend", view, this)
        this.network.addMarker(this)
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener("MSPointerDown", view, this)
        $html.removeEventListener("MSPointerMove", view, this)
        $html.removeEventListener("MSPointerUp", view, this)
        $html.removeEventListener("MSPointerCancel", view, this)
        this.network.removeMarker(this)
    },
    handleTouchstart: function (e) {
        if (this.network.isFocusOnClick()) {
            twaver.Util.setFocus(this.network._view);
        }

        if (this.network.isSelectingElement() && e.pointerType == e.MSPOINTER_TYPE_MOUSE) {
            //view
            return;
        }

        var currentTouchPoint = this.network.getLogicalPoint(e);
        var currentTouchTime = new Date();


        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this.handle_mouseup(e);
        }

        if (!this._pointerMap[e.pointerId]) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }
        if (this._pointerIdArray.length == 1) {
            var element = this.network.getElementAt(currentTouchPoint);
            this._startTouchElement = element;
            this._startClientPoint = { x: e.clientX, y: e.clientY }
            //this._startClientPoint = this.getMarkerPoint(e);
            $network_interaction.handleClicked(this.network, e, element); //click
            if (this._startTouchTime
                && this._startTouchPoint
                && currentTouchTime.getTime() - this._startTouchTime.getTime() <= 500
                && $math.getDistance(this._startTouchPoint, currentTouchPoint) <= 20) {
                $network_interaction.handleDoubleClicked(this.network, e, element); //double click
                this._doubleClick = true;
            } else {
                $html.handle_mousedown(this, e);
                this._startTouchPoint = currentTouchPoint;
                this._startTouchTime = currentTouchTime;
            }
            var sm = this.network.getSelectionModel();
            if (element) {
                if (_twaver.isCtrlDown(e)) {
                    if (sm.contains(element)) {
                        sm.removeSelection(element);
                    } else {
                        sm.appendSelection(element);
                    }
                } else {
                    if (!sm.contains(element)) {
                        sm.setSelection(element);
                    }
                }
            } else {
                if (!_twaver.isCtrlDown(e)) {
                    sm.clearSelection();
                }
            }
        } else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }

    },
    handleTouchmove: function (e) {
        if (this._startTouchPoint == null || this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        }
    },
    handleTouchend: function (e) {
        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        }
        if (this.network.isSelectingElement()) {
            var rect = $math.getRect([this._startTouchPoint, this._moveTouchPoint]);
            var elements = this.network.getElementsAtRect(rect, this.getIntersectMode(), this.network.getRectSelectFilter());
            if (elements && elements.size() > 0) {
                var sm = this.network.getSelectionModel();
                var selections = sm.toSelection();
                elements.forEach(function (element) {
                    if (sm.contains(element)) {
                        selections.remove(element);
                    } else {
                        selections.add(element);
                    }
                }, this);
                sm.setSelection(selections);
            }
            this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            this._moveTouchPoint = null;
            this.network.setSelectingElement(false);
            this.repaint();
        }
        if (this._doubleClick) {
            delete this._doubleClick;
            delete this._startTouchPoint;
            delete this._startTouchTime;
        }
        var index = -1;
        for (var i = 0; i < this._pointerIdArray.length; i++) {
            if (this._pointerIdArray[i] == e.pointerId) {
                index = i;
                break;
            }
        }
        if (index >= 0) this._pointerIdArray.splice(index, 1);
        delete this._pointerMap[e.pointerId];
        this._startTouchPoint = null;
        this._moveTouchPoint = null;
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
    },
    handle_mousemove: function (e) {

        //e.buttons >= 1 &&
        var newClientPoint = { x: e.clientX, y: e.clientY };
        if ($math.getDistance(this._startClientPoint, newClientPoint) < 3) return;
        if (this._startTouchPoint && this._pointerIdArray.length == 1) {
            this._moveTouchPoint = {
                x: this._startTouchPoint.x + (newClientPoint.x - this._startClientPoint.x) / this.network.getZoom(),
                y: this._startTouchPoint.y + (newClientPoint.y - this._startClientPoint.y) / this.network.getZoom()
            };
            if (this._startTouchElement == null && this.network.isRectSelectEnabled()) {
                var point = this.network.getLogicalPoint(e);
                if (!point) {
                    return;
                }
                //rect select
                this.network.setSelectingElement(true);
                if (this._moveTouchPoint) {
                    this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
                } else {
                    this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
                }
                //this._moveTouchPoint = point;
                this.repaint();
            } else {
                var element = this.network.getElementAt(this._moveTouchPoint);

                if (this._startTouchElement == null && !this.network.isRectSelectEnabled()) {
                    var xoffset = this._startClientPoint.x - newClientPoint.x;
                    var yoffset = this._startClientPoint.y - newClientPoint.y;
                    this.network.panByOffset(xoffset, yoffset);
                } else if (this.network.isMovingElement() || (this._startTouchElement != null && element == this._startTouchElement && this.network.getMovableSelectedElements().contains(element))) {
                    var xoffset = this._moveTouchPoint.x - this._startTouchPoint.x;
                    var yoffset = this._moveTouchPoint.y - this._startTouchPoint.y;
                    this.network.moveSelectedElements(xoffset, yoffset);
                    if (this.network.isMovingElement()) {
                        this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                    } else {
                        this.network.setMovingElement(true);
                        this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                    }
                }
                this._startClientPoint = newClientPoint;
            }
        }
    },
    handle_mouseup: function (e) {
        this.handleTouchend(e);
        this._pointerIdArray = [];
        this._pointerMap = {};
    },
    paint: function (ctx) {
        if (!this._startTouchPoint || !this._moveTouchPoint || this._startTouchElement || !this.network.isRectSelectEnabled()) {
            return;
        }
        var sp = this.convertPointFromView(this._startTouchPoint);
        var ep = this.convertPointFromView(this._moveTouchPoint);
        var sx = sp.x;
        var sy = sp.y;
        var ex = ep.x;
        var ey = ep.y;
        var rect = $math.getRect([{ x: sx, y: sy }, { x: ex, y: ey}]);
        if (rect != null) {
            ctx.beginPath();
            var lineWidth = this.network.getSelectOutlineWidth();
            var fillStyle = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
            ctx.strokeStyle = this.network.getSelectOutlineColor();
            ctx.lineWidth = lineWidth;
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, fillStyle, this.network.getSelectOutlineColor());
            ctx.closePath();
        }
    }
});
var _registerImage = function (name, image) {
  _twaver.registerImage(name, image);
  _defaultImages[name] = 1;
}, _defaultImages = {};

_registerImage('node_image', {
  "w": 32,
  "h": 24,
  "origin": {
    "x": 0,
    "y": 0
  },
  "v": [
    {
      "shape": "path",
      "data": "M32,23.5c0,0.276-0.224,0.5-0.5,0.5h-31C0.224,24,0,23.776,0,23.5v-2C0,21.224,0.224,21,0.5,21h31  c0.276,0,0.5,0.224,0.5,0.5V23.5z",
      "gradient": {
        "id": "SVGID_1_",
        "type": "linear",
        "x1": "15.9995",
        "y1": "21",
        "x2": "15.9995",
        "y2": "24",
        "stop": [
          {
            "offset": "0",
            "color": "#666767"
          },
          {
            "offset": "1",
            "color": "#232424"
          }
        ]
      }
    },
    {
      "shape": "path",
      "data": "M15,22.3c0-0.165-0.134-0.3-0.3-0.3H3.3C3.134,22,3,22.135,3,22.3V24h12V22.3z",
      "gradient": {
        "id": "SVGID_2_",
        "type": "linear",
        "x1": "9",
        "y1": "22",
        "x2": "9",
        "y2": "25",
        "stop": [
          {
            "offset": "0",
            "color": "#69B4A5"
          },
          {
            "offset": "0.1",
            "color": "#61AD9C"
          }
        ]
      }
    },
    {
      "shape": "path",
      "data": "M31,20H1V1c0-0.553,0.448-1,1-1h28c0.553,0,1,0.447,1,1V20z",
      "gradient": {
        "id": "SVGID_3_",
        "type": "linear",
        "x1": "15.9995",
        "y1": "-0.1221",
        "x2": "15.9995",
        "y2": "19.9471",
        "stop": [
          {
            "offset": "0",
            "color": "#666767"
          },
          {
            "offset": "1",
            "color": "#232424"
          }
        ]
      }
    },
    {
      "shape": "rect",
      "x": 2,
      "y": 1,
      "w": 28,
      "h": 18,
      "fill": "#FFFFFF"
    },
    {
      "shape": "rect",
      "x": 3,
      "y": 2,
      "w": 26,
      "h": 16,
      "gradient": {
        "id": "SVGID_4_",
        "type": "linear",
        "x1": "15.9995",
        "y1": "2.0654",
        "x2": "15.9995",
        "y2": "17.3835",
        "stop": [
          {
            "offset": "0",
            "color": "#61B7D9"
          },
          {
            "offset": "1",
            "color": "#0089C1"
          }
        ]
      }
    },
    {
      "shape": "path",
      "data": "9.649,17.034 6.815,17.034 9.935,2.966 12.768,2.966 z",
      "fill": "#FFFFFF"
    },
    {
      "shape": "path",
      "data": "12.065,17.034 10.815,17.034 13.935,2.966 15.185,2.966 z",
      "fill": "#FFFFFF"
    },
    {
      "shape": "path",
      "data": "14.065,17.034 13.315,17.034 16.435,2.966 17.185,2.966 z",
      "fill": "#FFFFFF"
    }
  ]
});

_registerImage('group_image', {
    "w": 32,
    "h": 24,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
            {
                "shape": "path",
                "data": "M32,16.5c0,0.276-0.224,0.5-0.5,0.5h-24C7.224,17,7,16.776,7,16.5v-1C7,15.224,7.224,15,7.5,15h24   c0.276,0,0.5,0.224,0.5,0.5V16.5z",
                "gradient": {
                    "id": "SVGID_1_",
                    "type": "linear",
                    "x1": "19.5",
                    "y1": "15",
                    "x2": "19.5",
                    "y2": "17",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#666767"
                        },
                        {
                            "offset": "1",
                            "color": "#232424"
                        }
                    ]
                }
            },
            {
                "shape": "path",
                "data": "M19,16.5c0-0.277-0.224-0.5-0.5-0.5h-8c-0.276,0-0.5,0.223-0.5,0.5V17h9V16.5z",
                "gradient": {
                    "id": "SVGID_2_",
                    "type": "linear",
                    "x1": "14.4995",
                    "y1": "15.9209",
                    "x2": "14.4995",
                    "y2": "17.0459",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#58AC9A"
                        },
                        {
                            "offset": "1",
                            "color": "#248576"
                        }
                    ]
                }
            },
            {
                "shape": "path",
                "data": "M31,14H8V1c0-0.553,0.448-1,1-1h21c0.553,0,1,0.447,1,1V14z",
                "gradient": {
                    "id": "SVGID_3_",
                    "type": "linear",
                    "x1": "19.5",
                    "y1": "0",
                    "x2": "19.5",
                    "y2": "14.0005",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#666767"
                        },
                        {
                            "offset": "1",
                            "color": "#232424"
                        }
                    ]
                }
            },
            {
                "shape": "rect",
                "x": 9,
                "y": 1,
                "w": 21,
                "h": 12,
                "fill": "#FFFFFF"
            },
            {
                "shape": "rect",
                "x": 10,
                "y": 2,
                "w": 19,
                "h": 10,
                "gradient": {
                    "id": "SVGID_4_",
                    "type": "linear",
                    "x1": "19.5",
                    "y1": "1.9619",
                    "x2": "19.5",
                    "y2": "11.9744",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#58AC9A"
                        },
                        {
                            "offset": "1",
                            "color": "#248576"
                        }
                    ]
                }
            },
            {
                "shape": "path",
                "data": "M25,23.5c0,0.276-0.224,0.5-0.5,0.5h-24C0.224,24,0,23.776,0,23.5v-1C0,22.224,0.224,22,0.5,22h24   c0.276,0,0.5,0.224,0.5,0.5V23.5z",
                "gradient": {
                    "id": "SVGID_5_",
                    "type": "linear",
                    "x1": "12.4995",
                    "y1": "22",
                    "x2": "12.4995",
                    "y2": "24",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#666767"
                        },
                        {
                            "offset": "1",
                            "color": "#232424"
                        }
                    ]
                }
            },
            {
                "shape": "path",
                "data": "M12,23.5c0-0.277-0.224-0.5-0.5-0.5h-8C3.224,23,3,23.223,3,23.5V24h9V23.5z",
                "gradient": {
                    "id": "SVGID_6_",
                    "type": "linear",
                    "x1": "7.5",
                    "y1": "22.9209",
                    "x2": "7.5",
                    "y2": "24.0459",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#58AC9A"
                        },
                        {
                            "offset": "1",
                            "color": "#248576"
                        }
                    ]
                }
            },
            {
                "shape": "path",
                "data": "M24,21H1V8c0-0.553,0.448-1,1-1h21c0.553,0,1,0.447,1,1V21z",
                "gradient": {
                    "id": "SVGID_7_",
                    "type": "linear",
                    "x1": "12.4995",
                    "y1": "7",
                    "x2": "12.4995",
                    "y2": "21.0005",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#666767"
                        },
                        {
                            "offset": "1",
                            "color": "#232424"
                        }
                    ]
                }
            },
            {
                "shape": "rect",
                "x": 2,
                "y": 8,
                "w": 21,
                "h": 12,
                "fill": "#FFFFFF"
            },
            {
                "shape": "rect",
                "x": 3,
                "y": 9,
                "w": 19,
                "h": 10,
                "gradient": {
                    "id": "SVGID_8_",
                    "type": "linear",
                    "x1": "12.4995",
                    "y1": "8.9619",
                    "x2": "12.4995",
                    "y2": "18.9749",
                    "stop": [
                        {
                            "offset": "0",
                            "color": "#61B7D9"
                        },
                        {
                            "offset": "1",
                            "color": "#0089C1"
                        }
                    ]
                }
            }
    ]
});
_registerImage('subnetwork_image', {
    "w": 32,
    "h": 24,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M32,14.499c0,0.276-0.224,0.5-0.5,0.5h-20c-0.276,0-0.5-0.224-0.5-0.5v-1c0-0.276,0.224-0.5,0.5-0.5  h20c0.276,0,0.5,0.224,0.5,0.5V14.499z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 21.5,
                "y1": 12.999,
                "x2": 21.5,
                "y2": 14.9995,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M22,14.499c0-0.277-0.224-0.5-0.5-0.5h-7c-0.276,0-0.5,0.223-0.5,0.5v0.5h8V14.499z",
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 18,
                "y1": 13.9199,
                "x2": 18,
                "y2": 15.0449,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M31,11.499c0,0.276-0.224,0.5-0.5,0.5h-18c-0.276,0-0.5-0.224-0.5-0.5v-11c0-0.276,0.224-0.5,0.5-0.5  h18c0.276,0,0.5,0.224,0.5,0.5V11.499z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 21.5,
                "y1": -0.9502,
                "x2": 21.5,
                "y2": 12.5498,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 13,
            "y": 0.999,
            "w": 17,
            "h": 10,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 14,
            "y": 1.999,
            "w": 15,
            "h": 8,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 21.5,
                "y1": 1.9312,
                "x2": 21.5,
                "y2": 9.6537,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M21,23.5c0,0.276-0.224,0.5-0.5,0.5h-20C0.224,24,0,23.776,0,23.5v-1C0,22.224,0.224,22,0.5,22h20  c0.276,0,0.5,0.224,0.5,0.5V23.5z",
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 10.4995,
                "y1": 22,
                "x2": 10.4995,
                "y2": 24,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 22,
            "y": 20.5,
            "w": 3,
            "h": 1.999,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": -464.9424,
                "y1": -722.2754,
                "x2": -462.9424,
                "y2": -722.2754,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 28,
            "y": 16,
            "w": 2,
            "h": 3,
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 29,
                "y1": 16,
                "x2": 29,
                "y2": 19,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M11,23.5c0-0.277-0.224-0.5-0.5-0.5h-7C3.224,23,3,23.223,3,23.5V24h8V23.5z",
            "gradient": {
                "id": "SVGID_8_",
                "type": "linear",
                "x1": 7,
                "y1": 22.9209,
                "x2": 7,
                "y2": 24.0459,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M20,20.5c0,0.276-0.224,0.5-0.5,0.5h-18C1.224,21,1,20.776,1,20.5v-11C1,9.224,1.224,9,1.5,9h18  C19.776,9,20,9.224,20,9.5V20.5z",
            "gradient": {
                "id": "SVGID_9_",
                "type": "linear",
                "x1": 10.4995,
                "y1": 8.0508,
                "x2": 10.4995,
                "y2": 21.5513,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 2,
            "y": 10,
            "w": 17,
            "h": 10,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 11,
            "w": 15,
            "h": 8,
            "gradient": {
                "id": "SVGID_10_",
                "type": "linear",
                "x1": 10.4995,
                "y1": 10.9321,
                "x2": 10.4995,
                "y2": 18.6551,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#0089C1"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M32,22.7c0,0.165-0.135,0.3-0.301,0.3h-5.4C26.134,23,26,22.865,26,22.7v-2.4  c0-0.165,0.134-0.3,0.299-0.3h5.4C31.865,20,32,20.135,32,20.3V22.7z",
            "gradient": {
                "id": "SVGID_11_",
                "type": "linear",
                "x1": 29,
                "y1": 20,
                "x2": 29,
                "y2": 23,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        }
    ]
});
_registerImage('bus_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "rect",
            "x": 4,
            "y": 6,
            "w": 1,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "path",
            "data": "M7,4c0,0.552-0.448,1-1,1H3C2.448,5,2,4.552,2,4V3c0-0.552,0.448-1,1-1h3c0.552,0,1,0.448,1,1V4z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 4.5,
                "y1": 2,
                "x2": 4.5,
                "y2": 5,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 3,
            "w": 3,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 3,
            "w": 3,
            "h": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "path",
            "data": "M6,5.5C6,5.776,5.776,6,5.5,6h-2C3.224,6,3,5.776,3,5.5l0,0C3,5.224,3.224,5,3.5,5h2  C5.776,5,6,5.224,6,5.5L6,5.5z",
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 4.5,
                "y1": 6,
                "x2": 4.5,
                "y2": 5,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 12,
            "y": 6,
            "w": 1,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "path",
            "data": "M15,4c0,0.552-0.447,1-1,1h-3c-0.553,0-1-0.448-1-1V3c0-0.552,0.447-1,1-1h3c0.553,0,1,0.448,1,1V4z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 12.5,
                "y1": 2,
                "x2": 12.5,
                "y2": 5,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 11,
            "y": 3,
            "w": 3,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "rect",
            "x": 11,
            "y": 3,
            "w": 3,
            "h": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "path",
            "data": "M14,5.5C14,5.776,13.777,6,13.5,6h-2C11.225,6,11,5.776,11,5.5l0,0C11,5.224,11.225,5,11.5,5h2  C13.777,5,14,5.224,14,5.5L14,5.5z",
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 12.5,
                "y1": 6,
                "x2": 12.5,
                "y2": 5,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 8,
            "y": 10,
            "w": 1,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "path",
            "data": "M6,13c0-0.553,0.448-1,1-1h3c0.553,0,1,0.447,1,1v1c0,0.553-0.447,1-1,1H7c-0.552,0-1-0.447-1-1V13z",
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": -1428.3853,
                "y1": -571.5747,
                "x2": -1428.3853,
                "y2": -568.5747,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 7,
            "y": 13,
            "w": 3,
            "h": 1,
            "fill": "#232424"
        },
        {
            "shape": "rect",
            "x": 7,
            "y": 13,
            "w": 3,
            "h": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "path",
            "data": "M7,11.5C7,11.223,7.224,11,7.5,11h2c0.277,0,0.5,0.223,0.5,0.5l0,0c0,0.275-0.223,0.5-0.5,0.5h-2  C7.224,12,7,11.775,7,11.5L7,11.5z",
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": -1428.3862,
                "y1": -567.5737,
                "x2": -1428.3862,
                "y2": -568.5737,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M15,7.5C15,7.776,14.777,8,14.5,8h-12C2.224,8,2,7.776,2,7.5l0,0C2,7.224,2.224,7,2.5,7h12  C14.777,7,15,7.224,15,7.5L15,7.5z",
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 6.1152,
                "x2": 8.4995,
                "y2": 7.5558,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M15,9.5c0,0.275-0.223,0.5-0.5,0.5h-12C2.224,10,2,9.775,2,9.5l0,0C2,9.223,2.224,9,2.5,9h12  C14.777,9,15,9.223,15,9.5L15,9.5z",
            "gradient": {
                "id": "SVGID_8_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 8.1147,
                "x2": 8.4995,
                "y2": 9.556,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        }
    ]
});
_registerImage('data_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,12c0,0.553-0.447,1-1,1H7c-0.552,0-1-0.447-1-1V8c0-0.552,0.448-1,1-1h7c0.553,0,1,0.448,1,1V12   z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 10.5,
                "y1": 6.959,
                "x2": 10.5,
                "y2": 12.2259,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 7,
            "y": 8,
            "w": 7,
            "h": 4,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 8,
            "y": 9,
            "w": 5,
            "h": 2,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 10.5,
                "y1": 8.6997,
                "x2": 10.5,
                "y2": 11.0333,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M15,14.5c0,0.275-0.225,0.5-0.5,0.5h-8C6.224,15,6,14.775,6,14.5l0,0C6,14.223,6.224,14,6.5,14h8   C14.775,14,15,14.223,15,14.5L15,14.5z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 10.5,
                "y1": 13.125,
                "x2": 10.5,
                "y2": 14.5518,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 8,
            "y": 14,
            "w": 1,
            "h": 1,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 14.0049,
                "x2": 8.4995,
                "y2": 14.9471,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M12,4H6c0,0-0.152-0.275-0.5-1C5.021,2,5.021,2,4,2C3.057,2,2,2,2,2C1.448,2,1,2.448,1,3v8  c0,0.553,0.448,1,1,1h3v-1H2V3h2.387l1.024,1.998L12,5v1h1V5C13,4.448,12.553,4,12,4z",
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 6.9995,
                "y1": 2.0527,
                "x2": 6.9995,
                "y2": 11.4757,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M12,5L5.411,4.998L4.387,3H2v8h3v-0.645V7.254V7c0-0.552,0.448-1,1-1h0.324h3.032H12V5z",
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 6.9995,
                "y1": 2.9902,
                "x2": 6.9995,
                "y2": 11.0032,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        }
    ]
});
_registerImage('grid_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,14c0,0.553-0.447,1-1,1H3c-0.552,0-1-0.447-1-1V3c0-0.552,0.448-1,1-1h11c0.553,0,1,0.448,1,1V14  z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 2.1255,
                "x2": 8.4995,
                "y2": 14.909,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 3,
            "w": 11,
            "h": 11,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 5,
            "w": 11,
            "h": 1,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 3.209,
                "x2": 8.4995,
                "y2": 13.8043,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 8,
            "w": 11,
            "h": 1,
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 3.209,
                "x2": 8.4995,
                "y2": 13.8043,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 11,
            "w": 11,
            "h": 1,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 3.2095,
                "x2": 8.4995,
                "y2": 13.8048,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 11,
            "y": 3,
            "w": 1,
            "h": 11,
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 11.5,
                "y1": 3.209,
                "x2": 11.5,
                "y2": 13.8048,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 8,
            "y": 3,
            "w": 1,
            "h": 11,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 3.209,
                "x2": 8.4995,
                "y2": 13.8048,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 5,
            "y": 3,
            "w": 1,
            "h": 11,
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 5.5,
                "y1": 3.209,
                "x2": 5.5,
                "y2": 13.8048,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        }
    ]
});
_registerImage('databox_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M14.5,6h-12H2v0.5v7C2,13.776,2.224,14,2.5,14h12c0.276,0,0.5-0.224,0.5-0.5v-7V6H14.5z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 8.4995,
                "y1": 6.0625,
                "x2": 8.4995,
                "y2": 14.063,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M14.776,5.553l-1.553-3.105C13.101,2.201,12.775,2,12.5,2h-8C4.225,2,3.899,2.201,3.776,2.447  L2.224,5.553L2,6h0.5h12H15L14.776,5.553z",
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 8.5005,
                "y1": 3.104,
                "x2": 8.5005,
                "y2": -5.6467,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "12,2 9.5,2 7.5,2 5,2 3,6 7.5,6 9.5,6 14,6 z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 8.5005,
                "y1": 9.2295,
                "x2": 8.5005,
                "y2": 5.4586,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M11.5,9c0,0.276-0.224,0.5-0.5,0.5H6C5.724,9.5,5.5,9.276,5.5,9l0,0c0-0.276,0.224-0.5,0.5-0.5h5  C11.276,8.5,11.5,8.724,11.5,9L11.5,9z",
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('group_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,8.5C15,8.776,14.776,9,14.5,9h-10C4.224,9,4,8.776,4,8.5v-7C4,1.224,4.224,1,4.5,1h10    C14.776,1,15,1.224,15,1.5V8.5z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 9.5,
                "y1": 0.9512,
                "x2": 9.5,
                "y2": 8.9787,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 5,
            "y": 2,
            "w": 9,
            "h": 6,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 6,
            "y": 3,
            "w": 7,
            "h": 4,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 9.5,
                "y1": 3.02,
                "x2": 9.5,
                "y2": 6.9606,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M16,10.5c0,0.276-0.224,0.5-0.5,0.5h-12C3.224,11,3,10.776,3,10.5l0,0C3,10.224,3.224,10,3.5,10h12    C15.776,10,16,10.224,16,10.5L16,10.5z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 9.5,
                "y1": 9.9941,
                "x2": 9.5,
                "y2": 10.9976,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 6,
            "y": 10.001,
            "w": 2,
            "h": 0.999,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 7,
                "y1": 10.0059,
                "x2": 7,
                "y2": 10.9472,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M12,12.5c0,0.276-0.224,0.5-0.5,0.5h-10C1.224,13,1,12.776,1,12.5v-7C1,5.224,1.224,5,1.5,5h10    C11.776,5,12,5.224,12,5.5V12.5z",
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 6.4995,
                "y1": 4.9512,
                "x2": 6.4995,
                "y2": 12.9792,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 2,
            "y": 6,
            "w": 9,
            "h": 6,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 7,
            "w": 7,
            "h": 4,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 6.4995,
                "y1": 7.02,
                "x2": 6.4995,
                "y2": 10.9611,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M13,14.5c0,0.276-0.224,0.5-0.5,0.5h-12C0.224,15,0,14.776,0,14.5l0,0C0,14.224,0.224,14,0.5,14h12    C12.776,14,13,14.224,13,14.5L13,14.5z",
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 6.4995,
                "y1": 13.9941,
                "x2": 6.4995,
                "y2": 14.9976,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 14.001,
            "w": 2,
            "h": 0.999,
            "gradient": {
                "id": "SVGID_8_",
                "type": "linear",
                "x1": 4,
                "y1": 14.0059,
                "x2": 4,
                "y2": 14.9472,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        }
    ]
});
_registerImage('link_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "line",
            "p1": {
                "x": 2.5,
                "y": 2.5
            },
            "p2": {
                "x": 13.5,
                "y": 13.5
            },
            "lineColor": "url(#SVGID_1_)",
            "lineWidth": 1
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 13,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 11.5371,
                "y1": 11.5371,
                "x2": 14.2155,
                "y2": 14.2155,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 13,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 3,
            "cy": 3,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 1.4956,
                "y1": 1.4956,
                "x2": 4.1473,
                "y2": 4.1473,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 3,
            "cy": 3,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('linksubnetwork_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,7.661c0-1.202-0.642-2.247-1.596-2.835C12.848,3.188,11.314,2,9.486,2  c-1.587,0-2.95,0.902-3.649,2.211C4.573,4.22,3.548,5.194,3.438,6.432C3.389,6.429,3.342,6.417,3.292,6.417  C2.026,6.417,1,7.443,1,8.708C1,9.975,2.026,11,3.292,11h8.371l0,0C13.506,11,15,9.506,15,7.661z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 1.959,
                "x2": 7.9995,
                "y2": 11.0921,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M3.292,10C2.58,10,2,9.42,2,8.708c0-0.712,0.58-1.292,1.292-1.292C3.286,7.422,3.332,7.427,3.379,7.43  l0.969,0.058L4.435,6.52C4.5,5.779,5.106,5.216,5.844,5.211l0.595-0.004l0.28-0.524C7.273,3.645,8.334,3,9.486,3  c1.342,0,2.535,0.863,2.971,2.147l0.116,0.341l0.307,0.189C13.581,6.11,14,6.851,14,7.661C14,8.951,12.951,10,11.661,10H3.292z",
            "fill": "#FFFFFF"
        },
        {
            "shape": "path",
            "data": "M3.292,10h8.37c1.11,0,2.04-0.781,2.276-1.821c-0.131-0.615-0.5-1.158-1.058-1.501l-0.307-0.189  l-0.116-0.341C12.021,4.863,10.828,4,9.486,4C8.334,4,7.273,4.645,6.719,5.682l-0.28,0.524L5.844,6.211  C5.106,6.216,4.5,6.779,4.435,7.52L4.349,8.487L3.379,8.43C3.332,8.427,3.286,8.422,3.292,8.417c-0.535,0-0.994,0.328-1.19,0.792  C2.297,9.672,2.757,10,3.292,10z",
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 8.019,
                "y1": 4.084,
                "x2": 8.019,
                "y2": 9.8062,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "line",
            "p1": {
                "x": 8.01,
                "y": 8.01
            },
            "p2": {
                "x": 13.186,
                "y": 13.186
            },
            "lineColor": "url(#SVGID_3_)",
            "lineWidth": 1
        },
        {
            "shape": "ellipse",
            "cx": 8,
            "cy": 8,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 6.7881,
                "y1": 6.7881,
                "x2": 9.9924,
                "y2": 9.9924,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 8,
            "cy": 8,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 13,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 11.5791,
                "y1": 11.5791,
                "x2": 14.3132,
                "y2": 14.3132,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 13,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('node_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,11.5c0,0.276-0.224,0.5-0.5,0.5h-13C1.224,12,1,11.776,1,11.5v-9C1,2.224,1.224,2,1.5,2h13  C14.776,2,15,2.224,15,2.5V11.5z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 1.939,
                "x2": 7.9995,
                "y2": 11.9739,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 2,
            "y": 3,
            "w": 12,
            "h": 8,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 3,
            "y": 4,
            "w": 10,
            "h": 6,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 4.0513,
                "x2": 7.9995,
                "y2": 9.865,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M16,14.5c0,0.276-0.224,0.5-0.5,0.5h-15C0.224,15,0,14.776,0,14.5v-1C0,13.224,0.224,13,0.5,13h15  c0.276,0,0.5,0.224,0.5,0.5V14.5z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 13.0508,
                "x2": 7.9995,
                "y2": 14.9258,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M9,14.5C9,14.224,8.776,14,8.5,14h-5C3.224,14,3,14.224,3,14.5V15h6V14.5z",
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 5.9995,
                "y1": 14.0508,
                "x2": 5.9995,
                "y2": 15.9258,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#69B4A5"
                    },
                    {
                        "offset": "0.1",
                        "color": "#61AD9C"
                    },
                    {
                        "offset": "0.4637",
                        "color": "#449981"
                    },
                    {
                        "offset": "0.7764",
                        "color": "#2C8E73"
                    },
                    {
                        "offset": "1",
                        "color": "#218A6E"
                    }
                ]
            }
        }
    ]
});
_registerImage('shapelink_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "line",
            "p1": {
                "x": 7.5,
                "y": 2.5
            },
            "p2": {
                "x": 2.5,
                "y": 7.5
            },
            "lineColor": "url(#SVGID_1_)",
            "lineWidth": 1
        },
        {
            "shape": "line",
            "p1": {
                "x": 2.5,
                "y": 7.5
            },
            "p2": {
                "x": 8.5,
                "y": 13.5
            },
            "lineColor": "url(#SVGID_2_)",
            "lineWidth": 1
        },
        {
            "shape": "line",
            "p1": {
                "x": 9,
                "y": 13.186
            },
            "p2": {
                "x": 13.5,
                "y": 6.5
            },
            "lineColor": "url(#SVGID_3_)",
            "lineWidth": 1
        },
        {
            "shape": "ellipse",
            "cx": 7,
            "cy": 3,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 5.5864,
                "y1": 1.5864,
                "x2": 8.4149,
                "y2": 4.4149,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 7,
            "cy": 3,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 2,
            "cy": 8,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 0.5864,
                "y1": 6.5864,
                "x2": 3.4142,
                "y2": 9.4142,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 2,
            "cy": 8,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 8,
            "cy": 13,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 6.5869,
                "y1": 11.5869,
                "x2": 9.4147,
                "y2": 14.4147,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 8,
            "cy": 13,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 7,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 11.5859,
                "y1": 5.5859,
                "x2": 14.4144,
                "y2": 8.4144,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 7,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('shapenode_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M14.5,3h-9l-4,4v7h13L9,8.5L14.5,3z M12.086,13H2.5V7.414L5.914,4h6.172l-4.5,4.5L12.086,13z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 3.209,
                "x2": 7.9995,
                "y2": 13.6621,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 6,
            "cy": 3,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 4.5859,
                "y1": 1.5859,
                "x2": 7.4151,
                "y2": 4.4151,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 6,
            "cy": 3,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 3,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 11.5869,
                "y1": 1.5864,
                "x2": 14.4153,
                "y2": 4.4149,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 13,
            "cy": 3,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 9,
            "cy": 8,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 7.5864,
                "y1": 6.5864,
                "x2": 10.4149,
                "y2": 9.4149,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 9,
            "cy": 8,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 2,
            "cy": 7,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 0.5859,
                "y1": 5.5859,
                "x2": 3.4144,
                "y2": 8.4144,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 2,
            "cy": 7,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 12.825,
            "cy": 13,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 11.4111,
                "y1": 11.5869,
                "x2": 14.2396,
                "y2": 14.4153,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 12.825,
            "cy": 13,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('shapesubnetwork_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "path",
            "data": "M15,6.661c0-1.202-0.642-2.247-1.596-2.835C12.848,2.188,11.314,1,9.486,1  c-1.587,0-2.95,0.902-3.649,2.211C4.573,3.22,3.548,4.194,3.438,5.432C3.389,5.429,3.342,5.417,3.292,5.417  C2.026,5.417,1,6.443,1,7.708S2.026,10,3.292,10h8.371l0,0C13.506,10,15,8.505,15,6.661z",
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 1.3755,
                "x2": 7.9995,
                "y2": 9.733,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M3.292,9C2.58,9,2,8.42,2,7.708s0.58-1.292,1.292-1.292C3.286,6.422,3.332,6.427,3.379,6.43l0.969,0.058  L4.435,5.52C4.5,4.779,5.106,4.216,5.844,4.211l0.595-0.004l0.28-0.524C7.273,2.645,8.334,2,9.486,2  c1.342,0,2.535,0.863,2.971,2.147l0.116,0.341l0.307,0.189C13.581,5.11,14,5.851,14,6.661C14,7.951,12.951,9,11.661,9H3.292z",
            "fill": "#FFFFFF"
        },
        {
            "shape": "path",
            "data": "M3.272,9h8.37c1.11,0,2.039-0.689,2.275-1.729c-0.131-0.615-0.499-1.249-1.057-1.593l-0.307-0.189  l-0.116-0.341C12.002,3.863,10.809,3,9.468,3C8.314,3,7.254,3.645,6.7,4.682L6.42,5.207L5.825,5.211  C5.087,5.216,4.481,5.779,4.416,6.52L4.33,7.487L3.36,7.43C3.313,7.427,3.267,7.422,3.272,7.417c-0.535,0-0.994,0.327-1.19,0.792  C2.278,8.672,2.738,9,3.272,9z",
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 7.9995,
                "y1": 3.459,
                "x2": 7.9995,
                "y2": 8.4597,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M11.516,7.102h-8l2.469,6h8.5L11.516,7.102z M5.024,8.123h5.905l1.938,3.979H6.662L5.024,8.123z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 7.4443,
                "y1": 7.1724,
                "x2": 10.1111,
                "y2": 12.8383,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "5,8.112 10.904,8.112 12.842,12.092 6.638,12.092 z",
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 5,
            "cy": 8,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 3,
                "y1": 8,
                "x2": 7,
                "y2": 8,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 5,
            "cy": 8,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 12,
            "cy": 8,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 10,
                "y1": 8,
                "x2": 14,
                "y2": 8,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 12,
            "cy": 8,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 7,
            "cy": 12,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 5,
                "y1": 12,
                "x2": 9,
                "y2": 12,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 7,
            "cy": 12,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        },
        {
            "shape": "ellipse",
            "cx": 14,
            "cy": 12,
            "rx": 2,
            "ry": 2,
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 12,
                "y1": 12,
                "x2": 16,
                "y2": 12,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "ellipse",
            "cx": 14,
            "cy": 12,
            "rx": 1,
            "ry": 1,
            "fill": "#FFFFFF"
        }
    ]
});
_registerImage('subnetwork_icon',{
    "w": 16,
    "h": 16,
    "origin": {
        "x": 0,
        "y": 0
    },
    "v": [
        {
            "shape": "rect",
            "x": 10,
            "y": 14.001,
            "w": 2,
            "h": 1,
            "gradient": {
                "id": "SVGID_1_",
                "type": "linear",
                "x1": 11,
                "y1": 14.0059,
                "x2": 11,
                "y2": 14.9481,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 14,
            "y": 10.001,
            "w": 1,
            "h": 2,
            "gradient": {
                "id": "SVGID_2_",
                "type": "linear",
                "x1": 14.5,
                "y1": 10.0117,
                "x2": 14.5,
                "y2": 11.8962,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M16,6.001c0,0.552-0.447,1-1,1H8c-0.552,0-1-0.448-1-1v-4c0-0.552,0.448-1,1-1h7   c0.553,0,1,0.448,1,1V6.001z",
            "gradient": {
                "id": "SVGID_3_",
                "type": "linear",
                "x1": 11.5,
                "y1": 0.96,
                "x2": 11.5,
                "y2": 6.2265,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 8,
            "y": 2.001,
            "w": 7,
            "h": 4,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 9,
            "y": 3.001,
            "w": 5,
            "h": 2,
            "gradient": {
                "id": "SVGID_4_",
                "type": "linear",
                "x1": 11.5,
                "y1": 2.7007,
                "x2": 11.5,
                "y2": 5.0337,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M16,8.501c0,0.276-0.225,0.5-0.5,0.5h-8c-0.276,0-0.5-0.224-0.5-0.5l0,0c0-0.276,0.224-0.5,0.5-0.5   h8C15.775,8.001,16,8.225,16,8.501L16,8.501z",
            "gradient": {
                "id": "SVGID_5_",
                "type": "linear",
                "x1": 11.5,
                "y1": 7.126,
                "x2": 11.5,
                "y2": 8.5535,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 9,
            "y": 8.001,
            "w": 1,
            "h": 0.999,
            "gradient": {
                "id": "SVGID_6_",
                "type": "linear",
                "x1": 9.5,
                "y1": 8.0063,
                "x2": 9.5,
                "y2": 8.9477,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#58AC9A"
                    },
                    {
                        "offset": "1",
                        "color": "#248576"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M9,12c0,0.553-0.447,1-1,1H1c-0.552,0-1-0.447-1-1V8c0-0.552,0.448-1,1-1h7c0.553,0,1,0.448,1,1V12z   ",
            "gradient": {
                "id": "SVGID_7_",
                "type": "linear",
                "x1": 4.4995,
                "y1": 6.959,
                "x2": 4.4995,
                "y2": 12.2259,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 1,
            "y": 8,
            "w": 7,
            "h": 4,
            "fill": "#FFFFFF"
        },
        {
            "shape": "rect",
            "x": 2,
            "y": 9,
            "w": 5,
            "h": 2,
            "gradient": {
                "id": "SVGID_8_",
                "type": "linear",
                "x1": 4.5,
                "y1": 8.6997,
                "x2": 4.5,
                "y2": 11.0333,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M9,14.5C9,14.776,8.775,15,8.5,15h-8C0.224,15,0,14.776,0,14.5l0,0C0,14.224,0.224,14,0.5,14h8   C8.775,14,9,14.224,9,14.5L9,14.5z",
            "gradient": {
                "id": "SVGID_9_",
                "type": "linear",
                "x1": 4.4995,
                "y1": 13.125,
                "x2": 4.4995,
                "y2": 14.5518,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        },
        {
            "shape": "rect",
            "x": 2,
            "y": 14,
            "w": 1,
            "h": 1,
            "gradient": {
                "id": "SVGID_10_",
                "type": "linear",
                "x1": 2.5,
                "y1": 14.0049,
                "x2": 2.5,
                "y2": 14.9471,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#61B7D9"
                    },
                    {
                        "offset": "1",
                        "color": "#005EAD"
                    }
                ]
            }
        },
        {
            "shape": "path",
            "data": "M16,14.501c0,0.276-0.224,0.5-0.5,0.5h-2c-0.276,0-0.5-0.224-0.5-0.5v-1c0-0.276,0.224-0.5,0.5-0.5  h2c0.276,0,0.5,0.224,0.5,0.5V14.501z",
            "gradient": {
                "id": "SVGID_11_",
                "type": "linear",
                "x1": 14.5,
                "y1": 13.0117,
                "x2": 14.5,
                "y2": 14.8962,
                "stop": [
                    {
                        "offset": "0",
                        "color": "#666767"
                    },
                    {
                        "offset": "1",
                        "color": "#232424"
                    }
                ]
            }
        }
    ]
});
var $CanvasUtil = {
    _hitCanvas: null,
    getHitCanvas: function (w, h) {
        if (this._hitCanvas == null) {
            this._hitCanvas = $html.createCanvas();
        }
        if (arguments.length == 0) {
            w = 2;
            h = 2;
        }
        this._hitCanvas.setAttribute("width", '' + w - 1);
        this._hitCanvas.setAttribute("height", '' + h - 1);
        this._hitCanvas.setAttribute("width", '' + w);
        this._hitCanvas.setAttribute("height", '' + h);
        var ctx = this.getCtx(this._hitCanvas);
        ctx.clearRect(0, 0, w, h);
        return this._hitCanvas;
    },
    disposeHitCanvas: function () {
        this._hitCanvas = null;
    },
    getCtx: function (cvs) {
        return cvs.getContext("2d");
    },
    render: function (ctx, fillStyle, strokeStyle) {
        if (fillStyle != undefined) {
            ctx.fillStyle = fillStyle;
            ctx.fill();
        }
        if (strokeStyle != undefined) {
            ctx.strokeStyle = strokeStyle;
            ctx.stroke();
        }
    },
    text: function (ctx, text, x, y, fillStyle, strokeStyle) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        if (fillStyle != null) {
            ctx.fillStyle = fillStyle;
            ctx.fillText(text, x, y);
        }
        if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
            ctx.strokeText(text, x, y);
        }
    },
    circle: function (ctx, cx, cy, r, fillStyle, strokeStyle) {
        ctx.arc(cx, cy, r, 0, 2 * Math.PI, true);
        ctx.closePath();
        this.render(ctx, fillStyle, strokeStyle);
    },
    rect: function (ctx, x, y, width, height, fillStyle, strokeStyle) {
        ctx.rect(x, y, width, height);
        ctx.closePath();
        this.render(ctx, fillStyle, strokeStyle);
    },
    OUT_LEFT: 1,
    OUT_TOP: 2,
    OUT_RIGHT: 4,
    OUT_BOTTOM: 8,

    outcode: function (pX, pY, rectX, rectY, rectWidth, rectHeight) {
        var out = 0;
        if (rectWidth <= 0) {
            out |= this.OUT_LEFT | this.OUT_RIGHT;
        } else if (pX < rectX) {
            out |= this.OUT_LEFT;
        } else if (pX > rectX + rectWidth) {
            out |= this.OUT_RIGHT;
        }
        if (rectHeight <= 0) {
            out |= this.OUT_TOP | this.OUT_BOTTOM;
        } else if (pY < rectY) {
            out |= this.OUT_TOP;
        } else if (pY > rectY + rectHeight) {
            out |= this.OUT_BOTTOM;
        }
        return out;
    },

    intersectsLine: function (lineX1, lineY1, lineX2, lineY2, rectX, rectY, rectWidth, rectHeight) {
        var out1, out2;
        if ((out2 = this.outcode(lineX2, lineY2, rectX, rectY, rectWidth, rectHeight)) == 0) {
            return true;
        }
        while ((out1 = this.outcode(lineX1, lineY1, rectX, rectY, rectWidth, rectHeight)) != 0) {
            if ((out1 & out2) != 0) {
                return false;
            }
            if ((out1 & (this.OUT_LEFT | this.OUT_RIGHT)) != 0) {
                var x = rectX;
                if ((out1 & this.OUT_RIGHT) != 0) {
                    x += rectWidth;
                }
                lineY1 = lineY1 + (x - lineX1) * (lineY2 - lineY1) / (lineX2 - lineX1);
                lineX1 = x;
            } else {
                var y = rectY;
                if ((out1 & this.OUT_BOTTOM) != 0) {
                    y += rectHeight;
                }
                lineX1 = lineX1 + (y - lineY1) * (lineX2 - lineX1) / (lineY2 - lineY1);
                lineY1 = y;
            }
        }
        return true;
    }
};


twaver.vector = {};
twaver.vector.interaction = {};
twaver.vector.Network = function(elementBox) {
    twaver.vector.Network.superClass.constructor.apply(this, arguments);
    this.zoomManager = new twaver.vector.PhysicalZoomManager(this);
    /* 
    network hierarchy:
    -> view        
    -> rootCanvas
    -> topcanvas
    */
    this._view = $html.createView('hidden');
    this._rootCanvas = $html.createCanvas();
    this._topCanvas = $html.createCanvas();

    this._view.appendChild(this._rootCanvas);
    this._view.appendChild(this._topCanvas);

    //real size
    this.realWidth = 0;
    this.realHeight = 0;
    this._unionBounds = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    this._zoom = 1;
    this._elementUIMap = {};
    this._zoomMap = {};
    this._viewRectMap = {};

    this.viewRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    this.state = {
        zooming: false,
        panning: false,
        autoLayout: false
    };

    this.hScrollBarVisible = false;
    this.vScrollBarVisible = false;

    this.markerList = new twaver.List();
    this._topAttachmentList = new twaver.List();
    this._hitTestTopAttachmentList = new twaver.List();

    this.setElementBox(elementBox ? elementBox : new twaver.ElementBox());

    if ($ua.isTouchable) {
        if ($ua.isMSTouchable) {
            this.setDefaultInteractions(false, false);
        } else {
            this.setTouchInteractions();
        }
    } else {
        this.setDefaultInteractions(false, false);
    }

    var self = this;
    this._flowLink = function() {
        if (self.isMovingElement() || self.isSelectingElement() || self.isEditingElement() || self._box._layoutMovingElements) {
            return;
        }
        if (!self._flowLinkQuickFinder) {
            self._flowLinkQuickFinder = new twaver.QuickFinder(self._box, "link.flow", "style");
        }
        var links = self._flowLinkQuickFinder.find(true);

        links.forEach(function(link) {
            link._styleMap["link.flow.offset"] = self.getLinkFlowOffset(link);
            self.invalidateElementUI(link);
        });
    };
    this.setToolTipEnabled(twaver.Defaults.NETWORK_TOOLTIP_ENABLED);

    this._paintAll = true;
    this._dirtyRects = new $List();
    this._invalidateMap = {};
    this._invalidateAll = true;
    self._count = 0;
    self._invalidate = true;
    (function animateLoop(time) {
        self._loopId = requestAnimationFrame(animateLoop);
        if (self._invalidate) {
            self._count++;
            self._now = time;
            self.validate();
        }
    })(0);
    twaver.imageUtil.addEventListener(this.invalidateElementUIs, this);

    $html.addEventListener("mousemove", 'handle_mousemove', this._view, this);
};
_twaver.ext('twaver.vector.Network', twaver.controls.View, {

    __accessor: ['selectMode', 'makeVisibleOnSelected', 'movableFunction',
        'editPointSize', 'editPointFillColor',
        'scrollBarWidth',
        'editPointOutlineWidth', 'editPointOutlineColor', 'editLineColor',
        'editLineWidth', 'resizePointSize', 'resizePointFillColor', 'resizePointOutlineWidth',
        'resizePointOutlineColor', 'resizeLineColor', 'resizeLineWidth',
        'rotatePointSize', 'rotatePointFillColor', 'rotatePointOffset',
        'rotatePointOutlineWidth', 'rotatePointOutlineColor', 'rotateScaleFillColor', 'rotateScaleFontColor', 'rotateScaleWidth', 'rotateScaleHeight',
        'selectOutlineColor', 'selectOutlineWidth', 'selectFillColor',
        'lazyMoveOutlineColor', 'lazyMoveOutlineWidth', 'lazyMoveFillColor',
        'rectSelectFilter', 'selectionTolerance'
    ],

    __bool: ['doubleClickToUpSubNetwork', 'doubleClickToSubNetwork', 'doubleClickToEmptySubNetwork',
        'doubleClickToLinkBundle', 'doubleClickToGroupExpand',
        'scrollBarVisible', 'limitViewInCanvas', 'autoValidateCanvasSize',
        'subNetworkAnimate', 'lazyMoveAnimate', 'resizeAnimate',
        'noAgentLinkVisible', 'keyboardRemoveEnabled', 'keyboardSelectEnabled',
        'sendToTopOnSelected', 'lazyMoveFill', 'editingElement', 'rotatingElement', 'movingElement',
        'selectingElement', 'rectSelectEnabled', 'limitElementInPositiveLocation', 'showRotateScale', 'transparentSelectionEnable', 'edgeDetect',
        'dragToPan', 'wheelToZoom', 'asyncZoomAndViewRect', 'debug', 'zoomDivVisible', 'showShadowInEdit', 'showAttachOnChg'
    ],

    _currentSubNetwork: null,
    _subNetworkAnimate: twaver.Defaults.NETWORK_SUBNETWORK_ANIMATE,
    _scrollBarWidth: 10, //need twaver.Defaults.NETWORK_CANVAS_SCROLLBAR_WIDTH

    _scrollBarVisible: true, //need twaver.Defaults.NETWORK_CANVAS_SCROLLBAR_VISIBLE
    _limitViewInCanvas: false, //need twaver.Defaults.NETWORK_CANVAS_LIMIT_VIEW_IN_CANVAS
    _autoValidateCanvasSize: true, //need twaver.Defaults.NETWORK_CANVAS_AUTO_VALIDATE_CANVAS_SIZE

    _makeVisibleOnSelected: twaver.Defaults.NETWORK_MAKE_VISIBLE_ON_SELECTED,
    _keyboardRemoveEnabled: twaver.Defaults.NETWORK_KEYBOARD_REMOVE_ENABLED,
    _keyboardSelectEnabled: twaver.Defaults.NETWORK_KEYBOARD_SELECT_ENABLED,
    _rectSelectEnabled: $Defaults.NETWORK_RECT_SELECT_ENABLED,
    _rectSelectFilter: null,
    _elementUIFunction: twaver.Defaults.VECTORUI_FUNCTION,

    _doubleClickToUpSubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_UPSUBNETWORK,
    _doubleClickToSubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_SUBNETWORK,
    _doubleClickToEmptySubNetwork: twaver.Defaults.NETWORK_DOUBLECLICK_TO_EMPTYSUBNETWORK,
    _doubleClickToLinkBundle: twaver.Defaults.NETWORK_DOUBLECLICK_TO_LINKBUNDLE,
    _doubleClickToGroupExpand: twaver.Defaults.NETWORK_DOUBLECLICK_TO_GROUPEXPAND,

    _selectOutlineColor: twaver.Defaults.NETWORK_SELECT_OUTLINE_COLOR,
    _selectOutlineWidth: twaver.Defaults.NETWORK_SELECT_OUTLINE_WIDTH,
    _selectFillColor: twaver.Defaults.NETWORK_SELECT_FILL_COLOR,
    _sendToTopOnSelected: twaver.Defaults.NETWORK_SENDTOTOP_ON_SELECTED,

    _lazyMoveOutlineColor: twaver.Defaults.NETWORK_LAZYMOVE_OUTLINE_COLOR,
    _lazyMoveOutlineWidth: twaver.Defaults.NETWORK_LAZYMOVE_OUTLINE_WIDTH,
    _lazyMoveFillColor: twaver.Defaults.NETWORK_LAZYMOVE_FILL_COLOR,
    _lazyMoveFill: twaver.Defaults.NETWORK_LAZYMOVE_FILL,
    _lazyMoveAnimate: twaver.Defaults.NETWORK_LAZYMOVE_ANIMATE,

    _resizePointSize: twaver.Defaults.NETWORK_RESIZE_POINT_SIZE,
    _resizePointFillColor: twaver.Defaults.NETWORK_RESIZE_POINT_FILL_COLOR,
    _resizePointOutlineColor: twaver.Defaults.NETWORK_RESIZE_POINT_OUTLINE_COLOR,
    _resizePointOutlineWidth: twaver.Defaults.NETWORK_RESIZE_POINT_OUTLINE_WIDTH,
    _resizeLineColor: twaver.Defaults.NETWORK_RESIZE_LINE_COLOR,
    _resizeLineWidth: twaver.Defaults.NETWORK_RESIZE_LINE_WIDTH,
    _resizeAnimate: twaver.Defaults.NETWORK_RESIZE_ANIMATE,

    _rotatePointSize: twaver.Defaults.NETWORK_ROTATE_POINT_SIZE,
    _rotatePointFillColor: twaver.Defaults.NETWORK_ROTATE_POINT_FILL_COLOR,
    _rotatePointOffset: twaver.Defaults.NETWORK_ROTATE_POINT_OFFSET,
    _rotatePointOutlineWidth: twaver.Defaults.NETWORK_ROTATE_POINT_OUTLINE_WIDTH,
    _rotatePointOutlineColor: twaver.Defaults.NETWORK_ROTATE_POINT_OUTLINE_COLOR,

    _rotateScaleWidth: $Defaults.NETWORK_ROTATE_SCALE_WIDTH,
    _rotateScaleHeight: $Defaults.NETWORK_ROTATE_SCALE_HEIGHT,
    _rotateScaleFillColor: $Defaults.NETWORK_ROTATE_SCALE_FILL_COLOR,
    _rotateScaleFontColor: $Defaults.NETWORK_ROTATE_SCALE_FONT_COLOR,

    _editPointSize: twaver.Defaults.NETWORK_EDIT_POINT_SIZE,
    _editPointFillColor: twaver.Defaults.NETWORK_EDIT_POINT_FILL_COLOR,
    _editPointOutlineColor: twaver.Defaults.NETWORK_EDIT_POINT_OUTLINE_COLOR,
    _editPointOutlineWidth: twaver.Defaults.NETWORK_EDIT_POINT_OUTLINE_WIDTH,
    _editLineColor: twaver.Defaults.NETWORK_EDIT_LINE_COLOR,
    _editLineWidth: twaver.Defaults.NETWORK_EDIT_LINE_WIDTH,

    _limitElementInPositiveLocation: false,

    _linkFlowInterval: $Defaults.NETWORK_LINK_FLOW_INTERVAL,
    _selectionTolerance: $Defaults.NETWORK_SELECTION_TOLERANCE,

    _invalidateViewRectFlag: false,
    _repaintTopFlag: false,
    _invalidateCanvasSizeFlag: false,

    _isEditingElement: false,
    _isRotatingElement: false,
    _isMovingElement: false,
    _isSelectingElement: false,
    _hasEditInteraction: false,
    _showRotateScale: true,
    _transparentSelectionEnable: twaver.Defaults.NETWORK_TRANSPARENT_SELECTION_ENABLE,
    _edgeDetect: false,
    _dragToPan: true,
    _wheelToZoom: true,
    _asyncZoomAndViewRect: false,
    _debug: false,
    _zoomDivVisible: true,
    _showShadowInEdit: false,
    _showAttachOnChg: true,

    adjustBounds: function(rect) {
        var b = false;
        var style = this._view.style;
        if (style.left == rect.x + 'px' &&
            style.top == rect.y + 'px' &&
            style.width == rect.width + 'px' &&
            style.height == rect.height + 'px') {
            b = true;
        }
        twaver.vector.Network.superClass.adjustBounds.apply(this, arguments);
        if (b == true) {
            return;
        }
        // var w = this._view.offsetWidth;
        // var h = this._view.offsetHeight;
        //adjustBoundsnetworkdisplay nonedom treecanvas0
        var w = rect.width;
        var h = rect.height;

        this._rootCanvas.setAttribute("width", w);
        this._rootCanvas.setAttribute("height", h);
        this._topCanvas.setAttribute("width", w);
        this._topCanvas.setAttribute("height", h);

        this.setViewRect(this.viewRect.x, this.viewRect.y, w, h);

        if (typeof twaver.gis == 'undefined') {
            twaver.Util.makeHighRes(this._rootCanvas);
            twaver.Util.makeHighRes(this._topCanvas);
        }
        this.invalidateElementVisibility();
    },

    getLabel: function(element) {
        return element.getStyle('network.label') || element.getName();
    },

    getLabel2: function(element) {
        return element.getStyle('network.label') || element.getName2();
    },

    setZoomManager: function(zoomManager) {
        var old = this.zoomManager;
        if (old == zoomManager) {
            return;
        }
        this.zoomManager = zoomManager;
        // this.zoomManager._invalidateZoom();
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this.validateCanvasSize();
        this.invalidateElementUIs();
        this.firePropertyChange("zoomManager", old, zoomManager);
    },
    getZoomManager: function() {
        return this.zoomManager;
    },
    getRootCanvas: function() {
        return this._rootCanvas;
    },
    getTopCanvas: function() {
        return this._topCanvas;
    },
    validateImpl: function() { // vector
        __l.twm(this);
        //validate ui
        var list = this.getElementBox().getDatas()._as;
        var size = list.length;
        var visibleMap = {};
        var i, id, n, ui, visibleFunction = this._visibleFunction,
            defaultLayer = this._box._layerBox.size() === 1 ? this._box._layerBox._defaultLayer : null;
        for (i = 0; i < size; i++) {
            n = list[i];
            // if(this._visibleMap && this._visibleMap[n._id] != null){
            //     visibleMap[n._id] = this._visibleMap[n._id];
            // }else{

            // }
            visibleMap[n._id] = this.isVisible(n, visibleFunction, defaultLayer);
        }
        var zoom = this.getGraphicsZoom();
        var dirtyRect = null,
            viewPortRect = {
                x: this.viewRect.x / zoom,
                y: this.viewRect.y / zoom,
                width: this.viewRect.width / zoom,
                height: this.viewRect.height / zoom,
            };
        if (this._invalidateAll) {
            if (this._visibleMap) {
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (visibleMap[n._id] !== this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui) {
                            ui.invalidate();
                        }
                    }
                }
            }
            for (i = 0; i < size; i++) {
                n = list[i];
                ui = this._elementUIMap[n._id];
                if (ui) {
                    ui.validate();
                }
            }
            this._paintAll = true;
        } else {
            if (this._paintAll) {
                for (id in this._invalidateMap) {
                    ui = this._elementUIMap[id];
                    if (ui) {
                        ui.invalidate();
                    }
                }
                for (id in this._invalidateMap) {
                    ui = this._elementUIMap[id];
                    if (ui) {
                        ui.validate();
                    }
                }
            } else {
                for (id in this._invalidateMap) {
                    ui = this._elementUIMap[id];
                    if (ui) {
                        this._dirtyRects.add(ui.getZoomViewRect(false));
                        ui.invalidate();
                    }
                }

                for (id in this._invalidateMap) {
                    ui = this._elementUIMap[id];
                    if (ui) {
                        ui.validate();
                        this._dirtyRects.add(ui.getZoomViewRect(true));
                    }
                }
            }
        }
        if (this._paintAll) {
            dirtyRect = viewPortRect;
        } else {
            this._dirtyRects.forEach(function(rect) {
                if (dirtyRect == null) {
                    dirtyRect = _twaver.cloneRect(rect);
                } else {
                    dirtyRect = $math.unionRect(dirtyRect, rect);
                }
            });
            if (dirtyRect) {
                $math.grow(dirtyRect, 2, 2);
                dirtyRect = $math.intersection(dirtyRect, viewPortRect);
            } else {
                dirtyRect = viewPortRect;
            }
        }
        this._visibleMap = visibleMap;
        dirtyRect && this.paintRoot(dirtyRect);

        this.validateCanvasSize();
        if (this._repaintTopFlag == true) {
            this._repaintTopFlag = false;
            this.paintTopCanvas();
        }
    },
    isLinkFlowEnabled: function() {
        return this._linkFlowEnabled ? true : false;
    },
    setLinkFlowEnabled: function(value) {
        if (value) {
            if (!this._linkFlowEnabled) {
                this._linkFlowEnabled = true;
                this.firePropertyChange('linkFlowEnabled', false, true);
            }
            clearInterval(this._linkFlowTimerId);
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        } else {
            if (this._linkFlowEnabled) {
                this._linkFlowEnabled = false;
                this.firePropertyChange('linkFlowEnabled', true, false);
            }
            clearInterval(this._linkFlowTimerId);
            delete this._linkFlowTimerId;
        }
    },
    getLinkFlowInterval: function() {
        return this._linkFlowInterval;
    },
    setLinkFlowInterval: function(value) {
        var oldValue = this._linkFlowInterval;
        this._linkFlowInterval = value;
        this.firePropertyChange('linkFlowInterval', oldValue, value);

        clearInterval(this._linkFlowTimerId);
        if (this.isLinkFlowEnabled()) {
            this._linkFlowTimerId = setInterval(this._flowLink, this._linkFlowInterval);
        }
    },
    getElementBox: function() {
        return this._box;
    },
    setElementBox: function(elementBox) {
        if (!elementBox) {
            throw "ElementBox can not be null";
        }
        if (this._box === elementBox) {
            return;
        }
        var oldValue = this._box;
        if (oldValue) {
            oldValue.removeDataBoxChangeListener(this.handleElementBoxChange, this);
            oldValue.removeDataPropertyChangeListener(this.handleElementPropertyChange, this);
            oldValue.removePropertyChangeListener(this.handleElementBoxPropertyChange, this);
            oldValue.removeIndexChangeListener(this.handleIndexChange, this);
            oldValue.getLayerBox().removeDataBoxChangeListener(this.handleLayerBoxChange, this);
            oldValue.getLayerBox().removeDataPropertyChangeListener(this.handleLayerPropertyChange, this);
            oldValue.getLayerBox().removeHierarchyChangeListener(this.handleLayerHierarchyChange, this);
            if (!this._selectionModel) {
                oldValue.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
            }
        }
        this._box = elementBox;
        this._box.addDataBoxChangeListener(this.handleElementBoxChange, this);
        this._box.addDataPropertyChangeListener(this.handleElementPropertyChange, this);
        this._box.addPropertyChangeListener(this.handleElementBoxPropertyChange, this);
        this._box.addIndexChangeListener(this.handleIndexChange, this);
        this._box.getLayerBox().addDataBoxChangeListener(this.handleLayerBoxChange, this);
        this._box.getLayerBox().addDataPropertyChangeListener(this.handleLayerPropertyChange, this);
        this._box.getLayerBox().addHierarchyChangeListener(this.handleLayerHierarchyChange, this);
        if (this._flowLinkQuickFinder) {
            this._flowLinkQuickFinder.dispose();
            this._flowLinkQuickFinder = new twaver.QuickFinder(this._box, "link.flow", "style");
        }

        if (this._selectionModel) {
            this._selectionModel._setDataBox(elementBox);
        } else {
            this._box.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        }
        this._elementUIMap = {};
        this._box.forEach(this.createElementUI, this);
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this.firePropertyChange("elementBox", oldValue, this._box);
    },
    // handle event change.
    handleElementBoxChange: function(e) {
        var element = e.data;
        if (e.kind === 'add') {
            this.createElementUI(element);
            this.invalidateBundleLink(element);
        } else if (e.kind === "remove") {
            var ui = this.getElementUI(element);
            if (ui) {
                this._dirtyRects.add(ui.getZoomViewRect());
                ui.dispose();
                delete this._elementUIMap[element.getId()];
            }
            if (element === this._currentSubNetwork && this._currentSubNetwork != null) {
                this._setCurrentSubNetwork(null);
            }
            delete this._invalidateMap[element._id];
        } else if (e.kind === 'clear') {
            for (var p in this._elementUIMap) {
                this._elementUIMap[p] && this._elementUIMap[p].dispose && this._elementUIMap[p].dispose();
            }
            this._elementUIMap = {};
            if (this._currentSubNetwork != null) {
                this._setCurrentSubNetwork(null);
            }
            this._paintAll = true;
        } else if (e.kind === 'layoutEnd') {
            this.state.layouting = false;
        } else if (e.kind === 'layouting') {
            this.state.layouting = true;
        }
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
    },
    handleElementPropertyChange: function(e) {
        var element = e.source;
        var ui = this.getElementUI(element);
        if (ui) {
            this.invalidateElementUI(element);
            ui.handlePropertyChange(e);
        }
        this.invalidateBundleLink(element);
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
    },
    handleElementBoxPropertyChange: function() {
        this.invalidateElementVisibility();
    },
    handleIndexChange: function(c) {
        this.invalidateElementVisibility();
    },
    handleLayerBoxChange: function() {
        this.invalidateElementVisibility();
    },
    handleLayerPropertyChange: function(e) {
        if (e.property === "editable") {
            this.invalidateSelectedElementUIs(true);
        }
        this.invalidateElementVisibility();
    },
    handleLayerHierarchyChange: function() {
        this.invalidateElementVisibility();
    },
    handleSelectionChange: function(e) {

        var element = this.getSelectionModel().getLastData();
        if (element) {
            if (e.kind === 'append' || e.kind === 'set') {
                if (this.isMakeVisibleOnSelected()) {
                    this.makeVisible(element);
                }
                if (this.isSendToTopOnSelected()) {
                    this.sendToTop(element);
                }
            }
        }

        e.datas.forEach(function(element) {
            var ui = this.getElementUI(element);
            if (ui) {
                ui.handleSelectionChange(e);
            }
            this.invalidateElementUI(element);
        }, this);

        //   move top for fix the select link link lable go to zero position bug;
        // var element = this.getSelectionModel().getLastData();
        // if (element) {
        // if (e.kind === 'append' || e.kind === 'set') {
        // if (this.isMakeVisibleOnSelected()) {
        // this.makeVisible(element);
        // }
        // if (this.isSendToTopOnSelected()) {
        // this.sendToTop(element);
        // }
        // }
        // }
        this.invalidateElementVisibility();
    },
    sendToTop: function(element) {
        if (!this._box.contains(element)) {
            return;
        }
        var parent = element;
        while (parent._parent && this.isVisible(parent._parent)) {
            parent = parent._parent;
            if (!parent) {
                break;
            }
        }
        if (parent !== element) {
            this._box.adjustElementIndex(parent);
        }
        this._box.adjustElementIndex(element);
    },
    getScopeRect: function(type) {
        var zoom = this.getGraphicsZoom();
        var zoomManager = this.zoomManager;
        if (type === 'viewsize') {
            return {
                x: this._unionBounds.x - this.viewRect.x,
                y: this._unionBounds.y - this.viewRect.y,
                width: this._unionBounds.width,
                height: this._unionBounds.height
            };
        } else if (type === 'viewport') {
            if (this.viewRect) {
                return _twaver.cloneRect(this.viewRect);
            }
        } else if (type === 'rootcanvas') {
            return {
                x: this.viewRect.x,
                y: this.viewRect.y,
                width: (Math.abs(this.viewRect.x - this._unionBounds.x) + this._unionBounds.width) * zoom,
                height: (Math.abs(this.viewRect.y - this._unionBounds.y) + this._unionBounds.height) * zoom
            };
        }
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    },
    //view&&real size
    getViewRect: function() {
        if (this.viewRect) {
            return _twaver.cloneRect(this.viewRect);
        }
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        };
    },
    getCanvasSize: function() {
        return {
            width: this.realWidth,
            height: this.realHeight
        };
    },
    //    setCanvasSize:function(w,h){
    //        this.realWidth =   w*this.getZoom(),
    //        this.realHeight=  h*this.getZoom()
    //    },
    setViewOffSet: function(xoff, yoff) {
        var x = this.viewRect.x;
        var y = this.viewRect.y;
        var w = this.viewRect.width;
        var h = this.viewRect.height;
        this.setViewRect(x + xoff, y + yoff, w, h);
    },

    setViewRect: function(x, y, w, h) {
        if (this.isLimitViewInCanvas() == true) {
            if (x < 0) {
                x = 0;
            }
            if (w > this.realWidth) {
                x = 0;
            } else {
                if (x + w > this.realWidth) {
                    x = this.realWidth - w;
                }
            }
            if (y < 0) {
                y = 0;
            }
            if (h > this.realHeight) {
                y = 0;
            } else {
                if (y + h > this.realHeight) {
                    y = this.realHeight - h;
                }
            }
        }
        var old = this.viewRect;
        if (this.viewRect != null) {
            if (x == this.viewRect.x && y == this.viewRect.y && w == this.viewRect.width && h == this.viewRect.height) {
                return;
            }
        }
        this.viewRect = {
            x: x,
            y: y,
            width: w,
            height: h
        };
        this.firePropertyChange("viewRect", old, this.viewRect);
        this.invalidateElementVisibility();
        this._paintAll = true;
    },
    //scroll bar 
    isHScrollBarVisible: function() {
        return this.hScrollBarVisible;
    },
    setHScrollBarVisible: function(v) {
        this.hScrollBarVisible = v;
    },
    isVScrollBarVisible: function() {
        return this.vScrollBarVisible;
    },
    setVScrollBarVisible: function(v) {
        this.vScrollBarVisible = v;
    },

    setZoomVisibilityThresholds: function(value) {
        var oldValue = this._visibilityThresholds;
        this._zoomVisibilityThresholds = value;
        this.firePropertyChange("zoomVisibilityThresholds", oldValue, value);
        this.invalidateElementVisibility();
    },

    getZoomVisibilityThresholds: function() {
        return this._zoomVisibilityThresholds || {};
    },

    //handle validate
    invalidateElementVisibility: function() {
        this.invalidate();
    },
    repaintTopCanvas: function() {
        if (!this._repaintTopFlag) {
            this._repaintTopFlag = true;
            this.invalidate();
        }
    },
    invalidateCanvasSize: function(delay) {
        if (!this._invalidateCanvasSizeFlag) {
            this._invalidateCanvasSizeFlag = true;
            this.invalidate();
        }
    },
    validateCanvasSize: function() {
        if (this._invalidateCanvasSizeFlag == false) {
            return;
        }
        this._invalidateCanvasSizeFlag = false;
        this._validateCanvasSize();
    },
    _validateCanvasSize: function() {
        // if (this.isMovingElement()) {
        //     return;
        // }
        if (this.isAutoValidateCanvasSize() == false) {
            this.realWidth = 0;
            this.realHeight = 0;
            this._unionBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
            return;
        }
        var list = this.getElementBox().getDatas();
        var size = list.size();
        var r;
        if (size > 0) {
            for (var i = 0; i < size; i++) {
                var n = list.get(i);
                if (this._visibleMap[n._id]) {
                    var ui = this._elementUIMap[n._id]; //this.getElementUI(n);
                    if (ui) {
                        if (r) {
                            r = $math.unionRect(r, ui.getZoomViewRect(true));
                            // r = $math.unionRect(r,ui.getViewRect());
                        } else {
                            r = _twaver.cloneRect(ui.getZoomViewRect(true));
                            // r = _twaver.clone(ui.getViewRect());
                        }

                    }
                }
            }
            // if (r.x < 0) {
            // r.width += r.x;
            // r.x = 0;
            // }
            // if (r.y < 0) {
            // r.height += r.y;
            // r.y = 0;
            // }
            if (r == null) {
                r = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            }
            var zoom = this.getGraphicsZoom();
            this._unionBounds = {
                x: r.x * zoom,
                y: r.y * zoom,
                width: r.width * zoom,
                height: r.height * zoom
            };
            if (this.realWidth == (r.x + r.width) * zoom && this.realHeight == (r.y + r.height) * zoom) {
                return;
            }
            this.realWidth = (r.x + r.width) * zoom;
            this.realHeight = (r.y + r.height) * zoom;
        } else {
            this.realWidth = 0;
            this.realHeight = 0;
            this._unionBounds = {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
        }
        this.setViewRect(this.viewRect.x, this.viewRect.y, this.viewRect.width, this.viewRect.height);
        this.firePropertyChange("canvasSizeChange", null, this.viewRect);
        ////////////////////fire event/////////////////////////////
    },
    //element ui
    getElementUI: function(data) {
        if (data == null) {
            return null;
        }
        return this._elementUIMap[data._id];
    },

    getUnionBounds: function() {
        return this._unionBounds;
    },

    getZoomBodyRect: function(data) {
        var ui = this.getElementUI(data);
        if (ui) {
            return ui.getZoomBodyRect();
        }
        return null;
    },
    getShapeNodeZoomPoints: function(shapeNode, reverseZoom) {
        if (shapeNode._points) {
            var ui = this.getElementUI(shapeNode);
            if (ui) {
                return ui._getZoomPoints();
            }
        }
        return null;
    },

    createElementUI: function(data) {
        var ui = this._elementUIMap[data.getId()];
        if (!ui) {
            ui = this._elementUIFunction(this, data);
            if (!ui) {
                var name = data.getClassName();
                var uiName = name.substr(name.indexOf('.') + 1) + "UI";
                var uiClass = twaver.vector[uiName];
                if (uiClass) {
                    ui = new uiClass(this, data);
                }
            }
            if (ui) {
                this._elementUIMap[data.getId()] = ui;
            }

        }
        this._invalidateMap && (this._invalidateMap[data._id] = data);
        return ui;
    },
    getElementUIFunction: function() {
        return this._elementUIFunction;
    },
    setElementUIFunction: function(value) {
        if (!value) {
            throw "ElementUIFunction can not be null";
        }
        if (this._elementUIFunction === value) {
            return;
        }
        var oldValue = this._elementUIFunction;
        this._elementUIFunction = value;
        this.firePropertyChange("elementUIFunction", oldValue, value);

        if (!this._box.isEmpty()) {
            this._elementUIMap = {};
            this._box.forEach(this.createElementUI, this);
            this.invalidateElementVisibility();
            this.invalidateCanvasSize();
        }
    },
    invalidateElementUI: function(element, checkAttachments) {
        if (this._invalidateAll) {
            return;
        }
        this._invalidateMap[element._id] = element;
        var ui = this.getElementUI(element);
        // if (ui) {
        // ui.invalidate(checkAttachments);
        // }
        if (element instanceof $Node) {
            var links = element.getAgentLinks();
            if (links != null) {
                links.forEach(this.invalidateElementUI, this);
            }
            var parent = element.getParent();
            if (parent instanceof twaver.Group) {
                this.invalidateElementUI(parent);
            }
        }
        this.invalidateElementVisibility();
    },
    invalidateElementUIs: function(checkAttachments) {
        this._invalidateAll = true;
        this._invalidateMap = {};
        this._visibleMap = {};
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this.invalidate();
    },
    invalidateSelectedElementUIs: function(checkAttachments) {
        this.getSelectionModel().getSelection().forEach(function(element) {
            this.invalidateElementUI(element, checkAttachments);
        }, this);
    },
    invalidateBundleLink: function(element) {
        if (element instanceof twaver.Link && element._bundleLinks) {
            var elementUIMap = this._elementUIMap;
            element._bundleLinks.forEachSiblingLink(function(link) {
                if (link !== element) {
                    var ui = elementUIMap[link._id];
                    if (ui) {
                        ui.invalidate(false);
                    }
                }
            }, this);
        }
    },

    //paint
    paintRoot: function(dirtyRect) {
        var ctx = this._rootCanvas.getContext("2d");
        ctx.save();
        var zoom = this.getGraphicsZoom();

        ctx.beginPath();
        ctx.rect(Math.round(dirtyRect.x * zoom - this.viewRect.x), Math.round(dirtyRect.y * zoom - this.viewRect.y), Math.round(dirtyRect.width * zoom), Math.round(dirtyRect.height * zoom));
        ctx.clip();

        ctx.clearRect(Math.round(dirtyRect.x * zoom - this.viewRect.x), Math.round(dirtyRect.y * zoom - this.viewRect.y), Math.round(dirtyRect.width * zoom), Math.round(dirtyRect.height * zoom));

        this.visibleList = new twaver.List();
        this._topAttachmentList = new twaver.List();
        $backgroundUI.draw(ctx, this);
        var list = this.getElementBox().getDatas()._as;
        var size = list.length;
        /*if (size === 0) {
            return;
        }*/
        var zm = this.zoomManager;
        zm._zoomGraphicsBegin(ctx);
        this.paintBottom(ctx, dirtyRect);
        var layerBox = this._box._layerBox,
            i, n, ui, att;
        var zoom = this.getGraphicsZoom();
        var rect = {
            x: this.viewRect.x / zoom,
            y: this.viewRect.y / zoom,
            width: this.viewRect.width / zoom,
            height: this.viewRect.height / zoom
        }

        this.adjustLinkIndex();

        if (layerBox.size() === 1) {
            for (i = 0; i < size; i++) {
                n = list[i];
                if (this._visibleMap[n._id]) {
                    ui = this._elementUIMap[n._id];
                    if (this._debug) {
                        $g.strokeRect(ctx, dirtyRect, 'red');
                    }
                    if (ui != null && this._isInView(ui, dirtyRect)) {
                        ui.paint(ctx);
                        ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                    }
                    if (ui != null && $math.intersects(rect, ui.getZoomViewRect())) {
                        ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                    } else {
                        ui.setAttachmentVisible && ui.setAttachmentVisible(false);
                    }
                    this.visibleList.add(n);
                } else {
                    ui = this._elementUIMap[n._id];
                    ui && ui.setAttachmentVisible && ui.setAttachmentVisible(false);
                }
            }

        } else {
            layerBox.forEachByDepthFirst(function(layer) {
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui != null && this._isInView(ui, dirtyRect)) {
                            ui.paint(ctx);
                            ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                        }
                        if (ui != null && $math.intersects(rect, ui.getZoomViewRect())) {
                            ui.setAttachmentVisible && ui.setAttachmentVisible(true);
                        } else {
                            ui.setAttachmentVisible && ui.setAttachmentVisible(false);
                        }
                        ui && ui.validateZIndex && ui.validateZIndex(layerBox.getDatas().indexOf(layer));
                        this.visibleList.add(n);
                    } else {
                        ui = this._elementUIMap[n._id];
                        // ui && ui.setAttachmentVisible && ui.setAttachmentVisible(false);
                    }
                }
            }, null, this);
        }
        size = this._topAttachmentList.size();
        for (i = 0; i < size; i++) {
            att = this._topAttachmentList.get(i);
            att.getElementUI().paintAttachment(ctx, att);
        }

        this.paintTop(ctx, dirtyRect);

        // paint license compoent
        if (this._xyz !== undefined) {
            var ld = this._xyz;
            var mark = ld.markText;
            var t = ld.type;
            var expired = ld.expired;
            var text = ld.innerHTML;
            var x = 0;
            var y = 0;
            var size;
            var scale = 1;
            var r = this.viewRect;
            ctx.translate(this.viewRect.x / this.getZoom(), this.viewRect.y / this.getZoom());
            ctx.scale(1 / this.getZoom(), 1 / this.getZoom());
            var zoom = this.getZoom();
            if ((mark != undefined && mark != null && mark != '') || t == '2') {
                ctx.font = '15px Arial sans-serif';
                size = _twaver.g.getTextSize(ctx.font, text);
                ctx.fillStyle = 'red';
                x = r.width - size.width;
                y = r.height - 20;
            } else {
                ctx.font = '10px Arial sans-serif';
                size = _twaver.g.getTextSize(ctx.font, text);
                x = r.width / 2 - size.width / 2;
                y = r.height / 2;
            }
            ctx.fillText(text, x, y);
        }
        ctx.restore();
        this._invalidateMap = {};
        this._invalidateAll = false;
        this._paintAll = false;
        this._dirtyRects = new $List();
    },
    adjustLinkIndex: function() {
        var list = this._box.getDatas()._as;
        var hasEditInteraction = this.hasEditInteraction();
        var element;
        var oldIndex;
        if (hasEditInteraction) {
            this._hasAdjustedLinks = false;
            for (i = list.length - 1; i > -1; i--) {
                element = list[i];
                if (element instanceof twaver.Link) {
                    if (this.isEditable(element) && this.getElementUI(element).isEditable() && this.isSelected(element)) {
                        oldIndex = this._box.getDatas().indexOf(element);
                        this._box.getDatas().removeAt(oldIndex);
                        this._box.getDatas().add(element);
                        this._hasAdjustedLinks = true;
                    } else {
                        var toNode = element.getToNode();
                        oldIndex = this._box.getDatas().indexOf(toNode);
                        this._box.getDatas().removeAt(oldIndex);
                        this._box.getDatas().add(toNode);
                        var fromNode = element.getFromNode();
                        oldIndex = this._box.getDatas().indexOf(fromNode);
                        this._box.getDatas().removeAt(oldIndex);
                        this._box.getDatas().add(fromNode);
                    }
                }
            }
        } else {
            if (this._hasAdjustedLinks) {
                for (i = list.length - 1; i > -1; i--) {
                    element = list[i];
                    if (element instanceof twaver.Link) {
                        var toNode = element.getToNode();
                        oldIndex = this._box.getDatas().indexOf(toNode);
                        this._box.getDatas().removeAt(oldIndex);
                        this._box.getDatas().add(toNode);
                        var fromNode = element.getFromNode();
                        oldIndex = this._box.getDatas().indexOf(fromNode);
                        this._box.getDatas().removeAt(oldIndex);
                        this._box.getDatas().add(fromNode);
                    }
                }
                this._hasAdjustedLinks = false;
            }
        }
    },
    paintBottom: function(ctx, dirtyRect) {},
    paintTop: function(ctx, dirtyRect) {},
    _isInView: function(ui, realRect) {
        // return $math.intersects(realRect, ui.getViewRect());
        return $math.intersects(realRect, ui.getZoomViewRect());
    },
    paintTopCanvas: function() {
        var ctx = this._topCanvas.getContext("2d");
        ctx.clearRect(0, 0, this._topCanvas.width, this._topCanvas.height);
        this.paintMarker(ctx);
    },
    paintMarker: function(ctx) {
        var size = this.markerList.size();
        for (var i = 0; i < size; i++) {
            var marker = this.markerList.get(i);
            marker.paint(ctx);
        }
    },
    getLayerByElement: function(element) {
        return this._box.getLayerBox().getLayerByElement(element);
    },

    getLogicalPoint2: function(e) {
        return this.zoomManager._getLogicalPoint(e);
    },

    //location 
    getLogicalPoint: function(e) {
        return this.zoomManager._getLogicalPoint(e, true);
        // var point;
        // if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
        // var bound = this._view.getBoundingClientRect();
        // var touch = e.changedTouches[0];
        // var scrollLeft = $ua.isAndroid ? 0 : $touch.scrollLeft();
        // var scrollTop = $ua.isAndroid ? 0 : $touch.scrollTop();
        // point = { x: (touch.clientX + this.viewRect.x - bound.left - scrollLeft) / this._zoom,
        // y: (touch.clientY + this.viewRect.y - bound.top - scrollTop) / this._zoom
        // };
        // return point;
        // }
        // 
        // if ($ua.isFirefox) {
        // point = {
        // x: (e.layerX + this.viewRect.x) / this.getZoom(),
        // y: (e.layerY + this.viewRect.y) / this.getZoom()
        // };
        // } else {
        // point = {
        // x: (e.offsetX + this.viewRect.x) / this.getZoom(),
        // y: (e.offsetY + this.viewRect.y) / this.getZoom()
        // };
        // }
        // return point;
    },
    getElementAt: function(e) {
        if (this.visibleList == null) {
            return null;
        }
        var point;
        if (e.target) {
            point = this.getLogicalPoint2(e);
        } else if (e.event) {
            if (e.event.target) {
                point = this.getLogicalPoint2(e.event);
            }
        } else {
            point = e;
        }
        if (this._hitTestTopAttachmentList != null) {
            var tsize = this._hitTestTopAttachmentList.size();
            for (var j = tsize - 1; j >= 0; j--) {
                var att = this._hitTestTopAttachmentList.get(j);
                if (att.hit(point.x, point.y)) {
                    return att.getElement();
                }
            }
        }
        if (this.visibleList != null) {
            var size = this.visibleList.size();
            for (var i = size - 1; i >= 0; i--) {
                var n = this.visibleList.get(i);
                var ui = this.getElementUI(n);
                if (ui && ui.hit(point.x, point.y)) {
                    return n;
                }
            }
        }
        return null;
    },
    getElementsAt: function(e) {
        var list = new twaver.List();
        if (this.visibleList == null) {
            return null;
        }
        var point;
        if (e.target) {
            point = this.getLogicalPoint2(e);
        } else if (e.event) {
            if (e.event.target) {
                point = this.getLogicalPoint2(e.event);
            }
        } else {
            point = e;
        }

        if (this._hitTestTopAttachmentList != null) {
            var tsize = this._hitTestTopAttachmentList.size();
            for (var j = tsize - 1; j >= 0; j--) {
                var att = this._hitTestTopAttachmentList.get(j);
                if (att.hit(point.x, point.y)) {
                    list.add(att.getElement());
                }
            }
        }

        if (this.visibleList != null) {
            var size = this.visibleList.size();
            for (var i = size - 1; i >= 0; i--) {
                var n = this.visibleList.get(i);
                var ui = this.getElementUI(n);
                if (ui && ui.hit(point.x, point.y)) {
                    list.add(n);
                }
            }
        }
        return list;
    },

    hitTest: function(e) {
        var element = this.getElementAt(e);
        if (!element) {
            return null;
        }
        var elementUI = this.getElementUI(element);
        if (!elementUI) {
            return null;
        }
        var point;
        if (e.target) {
            point = this.getLogicalPoint2(e);
        } else if (e.event) {
            point = this.getLogicalPoint2(e.event);
        } else {
            point = e;
        }
        return elementUI.hitTest(point.x, point.y);
    },
    getElementsAtRect: function(rect, intersectMode, filter, selectable) {
        var list = new twaver.List();
        if (this.visibleList == null) {
            return list;
        }
        selectable = selectable === undefined ? true : selectable;
        var size = this.visibleList.size();
        for (var i = size - 1; i >= 0; i--) {
            var n = this.visibleList.get(i);
            var ui = this.getElementUI(n);
            if (ui && (!filter || filter(ui._element)) && ((selectable && this.isSelectable(ui._element)) || !selectable)) {
                if (intersectMode) {
                    if (ui.intersects(rect)) {
                        list.add(n);
                    }
                } else {
                    if ($math.contains(rect, ui.getZoomViewRect(t))) { //vector
                        list.add(n);
                    }
                }
            }
        }
        return list;
    },
    getPosition: function(position, obj, tarSize, xoffset, yoffset, zoom) {
        var point;
        var ui = obj instanceof twaver.vector.ElementUI ? obj : this.getElementUI(obj);
        if (ui) {
            if (position === 'from' || position === 'to') {
                if (ui.getFromPosition) {
                    point = position === 'from' ? ui.getFromPosition(xoffset, yoffset) : ui.getToPosition(xoffset, yoffset);
                    if (point) {
                        if (!tarSize) {
                            return point;
                        }
                        return {
                            x: point.x - tarSize.width / 2,
                            y: point.y - tarSize.height / 2
                        };
                    }
                }
            } else if (position === 'hotspot') {
                point = zoom ? ui.getZoomHotSpot(this.zoomManager) : ui.getHotSpot();
            } else {
                point = $position.get(position, zoom ? ui.getZoomBodyRect() : ui.getBodyRect(), tarSize);
            }
        }
        if (!point && obj.getRect) {
            point = $position.get(position, obj.getRect(), tarSize);
        }
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        throw "position '" + position + "' object '" + obj + "'";
    },
    isValidEvent: function(e) {
        if (!e) {
            return false;
        }
        var x;
        var y;
        if (e.currentTarget === this._view) {
            if ($ua.isFirefox) {
                x = e.layerX;
                y = e.layerY;
            } else {
                x = e.offsetX;
                y = e.offsetY;
            }
            if (this.isHScrollBarVisible() == true) {
                if (y >= this.viewRect.height - this.getScrollBarWidth()) {
                    return false;
                }
            }
            if (this.isVScrollBarVisible() == true) {
                if (x >= this.viewRect.width - this.getScrollBarWidth()) {
                    return false;
                }
            }
        }
        return true;
    },
    //marker
    addMarker: function(marker) {
        this.markerList.add(marker);
        this.repaintTopCanvas();
    },
    removeMarker: function(marker) {
        this.markerList.remove(marker);
        this.repaintTopCanvas();
    },
    clearMarker: function() {
        this.markerList.clear();
        this.repaintTopCanvas();
    },
    //move
    isMovable: function(element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (!element.isMovable()) {
            return false;
        }
        /*if (element instanceof twaver.Link) {
            return false;
        }*/
        if (this._movableFunction && !this._movableFunction(element)) {
            return false;
        }
        return this.getLayerByElement(element).isMovable();
    },
    hasMovableSelectedElements: function() {
        var selection = this.getSelectionModel().getSelection();
        for (var i = 0; i < selection.size(); i++) {
            var element = selection.get(i);
            if (this.isMovable(element)) {
                return true;
            }
        }
        return false;
    },
    getMovableSelectedElements: function() {
        return this.getSelectionModel().toSelection(function(element) {
            return this.isMovable(element);
        }, this);
    },
    moveSelectedElements: function(xoffset, yoffset, animate, finishFunction) {
        if (xoffset === 0 && yoffset === 0) {
            return;
        }
        var bound = this.getMovableSelectedElementsRect();
        if (bound == null) {
            return;
        }
        if (this._limitElementInPositiveLocation) {
            if (bound.x + xoffset < 0) {
                xoffset = -bound.x;
            }
            if (bound.y + yoffset < 0) {
                yoffset = -bound.y;
            }
        }
        twaver.Util.moveElements(this.getMovableSelectedElements(), xoffset, yoffset, animate, finishFunction, this);
    },
    getMovableSelectedElementsRect: function() {
        var elements = this.getMovableSelectedElements();
        if (elements.size() === 0) {
            return null;
        }
        var unionRect = null;
        for (var i = 0, n = elements.size(); i < n; i++) {
            var element = elements.get(i);
            if (element instanceof $Node) {
                var ui = this.getElementUI(element);
                if (ui) {
                    unionRect = $math.unionRect(unionRect, ui.getViewRect());
                }
            }
        }
        return unionRect;
    },
    isVisibleAttachment: function(data) {
        return !this.state.zooming && !this.state.panning && !this.state.layouting;
    },

    isVisible: function(element, visibleFunction, defaultLayer) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (!element.isVisible()) {
            return false;
        }
        if (arguments.length !== 3) {
            visibleFunction = this._visibleFunction;
        }
        if (visibleFunction && !visibleFunction(element)) {
            return false;
        }
        if (!(defaultLayer || this._box._layerBox.getLayerByElement(element))._visible) {
            return false;
        }
        if ($element.getSubNetwork(element) !== this._currentSubNetwork) {
            return false;
        }
        if (!this.zoomManager.isElementVisible(element)) {
            return false;
        }
        if (element instanceof twaver.Link) {
            if (!this._noAgentLinkVisible) {
                if (!element._fromAgent || !element._toAgent) {
                    return false;
                }
                if (!this.isVisible(element._fromAgent, visibleFunction, defaultLayer) || !this.isVisible(element._toAgent, visibleFunction, defaultLayer)) {
                    return false;
                }
            }
            if (element.getBundleIndex() > 0 && element.getBundleCount() > 1 && !element.getStyle("link.bundle.expanded")) {
                return false;
            }
        } else {
            var parent = element._parent;
            while (parent && !parent.ISubNetwork) {
                if (parent instanceof twaver.Group) {
                    if (!parent.isExpanded() || !this.isVisible(parent, visibleFunction, defaultLayer)) {
                        return false;
                    }
                }
                parent = parent._parent;
            }
        }
        if (element.IDummy) {
            return false;
        }
        return true;
    },
    getVisibleFunction: function() {
        return this._visibleFunction;
    },
    setVisibleFunction: function(value) {
        var oldValue = this._visibleFunction;
        this._visibleFunction = value;
        this.firePropertyChange("visibleFunction", oldValue, value);
        this.invalidateElementVisibility();
    },
    isEditable: function(element) {
        if (!this._box.contains(element)) {
            return false;
        }
        if (this._editableFunction && !this._editableFunction(element)) {
            return false;
        }
        return this.getLayerByElement(element).isEditable();
    },
    getEditableFunction: function() {
        return this._editableFunction;
    },
    setEditableFunction: function(value) {
        var oldValue = this._editableFunction;
        this._editableFunction = value;
        this.firePropertyChange("editableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    isRotatable: function(element) {
        if (this._rotatableFunction && !this._rotatableFunction(element)) {
            return false;
        }
        return true;
    },
    getRotatableFunction: function() {
        return this._rotatableFunction;
    },
    setRotatableFunction: function(value) {
        var oldValue = this._rotatableFunction;
        this._rotatableFunction = value;
        this.firePropertyChange("rotatableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    isLinkable: function(node, fromNode) {
        return (this._linkableFunction == null || this._linkableFunction(node, fromNode));
    },
    getLinkableFunction: function() {
        return this._linkableFunction;
    },
    setLinkableFunction: function(value) {
        var oldValue = this._linkableFunction;
        this._linkableFunction = value;
        this.firePropertyChange("linkableFunction", oldValue, value);
        this.invalidateSelectedElementUIs(true);
    },
    onShareSelectionModelChanged: function() {
        this.invalidateElementUIs();
    },
    //paint attribute
    getShadowColor: function(element) {
        var color = element.getStyle('shadow.color');
        if (!color && this.isSelected(element) && element.getStyle('select.style') === 'shadow') {
            return element.getStyle('select.color');
        }
        return color;
    },
    getSelectColor: function(element) {
        return element.getStyle('select.color');
    },
    getAlarmLabel: function(element) {
        var severity = element.getAlarmState().getHighestNewAlarmSeverity();
        if (severity) {
            var label = element.getAlarmState().getNewAlarmCount(severity) + severity.nickName;
            if (element.getAlarmState().hasLessSevereNewAlarms()) {
                label += "+";
            }
            return label;
        }
        return null;
    },
    getLinkHandlerLabel: function(link) {
        if (link.isBundleAgent()) {
            return "+(" + link.getBundleCount() + ")";
        }
        return null;
    },

    //interaction 
    setInteractions: function(interactions) {
        var oldValue = this._interactions;
        if (oldValue) {
            oldValue.forEach(function(handler) {
                handler.tearDown();
            });
        }
        this._interactions = interactions;
        if (interactions) {
            interactions.forEach(function(handler) {
                handler.setUp();
            });
        }
        this.invalidateSelectedElementUIs(true);
        this.firePropertyChange("interactions", oldValue, interactions);
    },
    getInteractions: function() {
        return this._interactions;
    },
    setDefaultInteractions: function(lazyMode, moveLink) {
        var interactions = [
            new twaver.vector.interaction.DefaultInteraction(this, lazyMode)
        ];
        if (moveLink) interactions.push(new twaver.vector.interaction.MoveLinkInteraction(this, lazyMode));
        this.setInteractions(interactions);
    },
    setTouchInteractions: function() {
        this.setInteractions([
            new twaver.vector.interaction.DefaultInteraction(this, false),
            new twaver.vector.interaction.TouchInteraction(this)
        ]);
    },
    setMSTouchInteractions: function() {
        this.setInteractions([
            new twaver.vector.interaction.MSTouchInteraction(this)
        ]);
    },
    setEditInteractions: function(lazyMode, moveLink) {
        var interactions = [
            new twaver.vector.interaction.EditInteraction(this, lazyMode),
            new twaver.vector.interaction.DefaultInteraction(this)
        ];
        if (moveLink) interactions.push(new twaver.vector.interaction.MoveLinkInteraction(this, lazyMode));
        this.setInteractions(interactions);
    },
    setCreateElementInteractions: function(type) {
        this.setInteractions([
            new twaver.vector.interaction.CreateElementInteraction(this, type),
            new twaver.vector.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateLinkInteractions: function(type) {
        this.setInteractions([
            new twaver.vector.interaction.CreateLinkInteraction(this, type),
            new twaver.vector.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateShapeLinkInteractions: function(type) {
        this.setInteractions([
            new twaver.vector.interaction.CreateShapeLinkInteraction(this, type),
            new twaver.vector.interaction.DefaultInteraction(this)
        ]);
    },
    setCreateShapeNodeInteractions: function(type) {
        this.setInteractions([
            new twaver.vector.interaction.CreateShapeNodeInteraction(this, type),
            new twaver.vector.interaction.DefaultInteraction(this),
        ]);
    },
    setMagnifyInteractions: function() {
        this.setInteractions([
            new twaver.vector.interaction.DefaultInteraction(this),
            new twaver.vector.interaction.MagnifyInteraction(this)
        ]);
    },
    hasEditInteraction: function() {
        return this._hasEditInteraction;
    },
    setHasEditInteraction: function(value) {
        var oldValue = this._hasEditInteraction;
        this._hasEditInteraction = value;
        this.firePropertyChange("hasEditInteraction", oldValue, value);
    },
    addElementByInteraction: function(element) {
        if (!element.getParent()) {
            element.setParent(this._currentSubNetwork);
        }
        this._box.add(element);
        this.getSelectionModel().setSelection(element);
        this.fireInteractionEvent({
            kind: 'createElement',
            element: element
        });
    },
    //tooltip
    getToolTip: function(element) {
        if (element) {
            var tooltip = element.getToolTip();
            if (tooltip) {
                return tooltip;
            }
            return element.getName();
        }
        return null;
    },
    isToolTipEnabled: function() {
        return this._toolTipEnabled ? true : false;
    },
    setToolTipEnabled: function(value) {
        this._toolTipEnabled = value;
        if (value) {
            if (!this._toolTipListener) {
                var self = this;
                this._toolTipListener = function(e) {
                    if (self.isMovingElement()) {
                        $popup.hideToolTip();
                        return;
                    }
                    var element = self.getElementAt(e);
                    if (self._preElement === element) {
                        return;
                    }
                    self._preElement = element;
                    if (element) {
                        var toolTip = self.getToolTip(element);
                        $popup.showToolTip({
                            x: e.pageX,
                            y: e.pageY
                        }, toolTip, function(toolTipDiv) {
                            var viewBounds = self._view.getBoundingClientRect();
                            var toolTipBounds = toolTipDiv.getBoundingClientRect();
                            if (toolTipBounds.width + toolTipBounds.left > viewBounds.width + viewBounds.left) {
                                toolTipDiv.style.left = (viewBounds.width + viewBounds.left - toolTipBounds.width + (document.documentElement.scrollLeft || document.body.scrollLeft)) + "px";
                            }
                            if (toolTipBounds.height + toolTipBounds.top > viewBounds.height + viewBounds.top) {
                                toolTipDiv.style.top = (viewBounds.height + viewBounds.top - toolTipBounds.height + (document.documentElement.scrollTop || document.body.scrollTop)) + "px";
                            }
                        });
                        return;
                    }
                    $popup.hideToolTip();
                };
                this._view.addEventListener('mousemove', this._toolTipListener, false);
                this.firePropertyChange('toolTipEnabled', false, true);
            }
        } else {
            if (this._toolTipListener) {
                $popup.hideToolTip();
                this._view.removeEventListener('mousemove', this._toolTipListener, false);
                delete this._toolTipListener;
                this.firePropertyChange('toolTipEnabled', true, false);
            }
        }
    },

    //zoom
    setZoom: function(z, point) {
        z = this.checkZoom(z);

        // var old = this._zoom;

        if (this.isAsyncZoomAndViewRect()) {
            var old = this._zoomMap[this._currentSubNetwork].zoom;
        } else {
            var old = this._zoom;
        }
        if (z == old) {
            return;
        }
        var size = this.getViewRect();
        if (!point) {
            point = {
                x: size.width / 2,
                y: size.height / 2
            };
        }
        var vr = this.viewRect;
        var offsetx = point.x - (point.x + vr.x) * z / old;
        var offsety = point.y - (point.y + vr.y) * z / old;
        // this._zoom = z;
        if (this.isAsyncZoomAndViewRect()) {
            this._zoomMap[this._currentSubNetwork].zoom = z;
        } else {
            this._zoom = z;
        }
        this._paintAll = true;
        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        // this.validateCanvasSize();
        // this.invalidateElementUIs();
        this.zoomManager._invalidateZoom();
        this.setViewRect(-offsetx, -offsety, this.viewRect.width, this.viewRect.height);
        if (this._asyncZoomAndViewRect) {
            this.firePropertyChange("zoom", old, this._zoomMap[this._currentSubNetwork].zoom);
        } else {
            this.firePropertyChange("zoom", old, this._zoom);
        }
        this.state.zooming = true;
        var timer = null;
        var self = this;
        if (timer) {
            clearTimeout(timer);
        } else {
            timer = setTimeout(function() {
                timer = null;
                self.state.zooming = false;
                self.invalidateElementUIs(true);
            }, 100);
        }
        // this.firePropertyChange("zoom", old, this._zoom);
    },
    getZoom: function() {
        // return this._zoom;

        if (this.isAsyncZoomAndViewRect()) {
            var zoom = this._zoomMap[this._currentSubNetwork];
            if (!zoom) {
                this._zoomMap[this._currentSubNetwork] = {
                    zoom: 1
                }
            }
            return this._zoomMap[this._currentSubNetwork].zoom;
        }

        return this._zoom;
    },
    getSizeZoom: function(ui) {
        return this.zoomManager.getSizeZoom(ui);
    },
    getLocationZoom: function() {
        return this.zoomManager.getLocationZoom();
    },
    getGraphicsZoom: function() {
        return this.zoomManager.getGraphicsZoom();
    },
    zoomOverview: function(animate) {
        if (this._unionBounds.width <= 0 || this._unionBounds.width <= 0) {
            return;
        }
        var zoom = this.getZoom();
        var ub = this._unionBounds;
        var rw = ub.width / zoom;
        var rh = ub.height / zoom;
        var wzoom = this.viewRect.width / rw;
        var hzoom = this.viewRect.height / rh;
        var min = Math.min(wzoom, hzoom);
        this.setZoom(min);
        var newZoom = this.getZoom();
        var offsetx = this.viewRect.width / 2 - this._unionBounds.width / 2 * newZoom / zoom;
        var offsety = this.viewRect.height / 2 - this._unionBounds.height / 2 * newZoom / zoom;
        this.setViewRect(this._unionBounds.x * newZoom / zoom - offsetx, this._unionBounds.y * newZoom / zoom - offsety, this.viewRect.width, this.viewRect.height);
        if (this.getLocationZoom() != 1) {

            var times = arguments[1] == null ? 5 : arguments[1];
            if (times > 0) {
                times--;
                var self = this;
                setTimeout(function() {
                    self.zoomOverview(animate, times);
                }, 25);
            }
        }
    },
    zoomReset: function(point) {
        this.setZoom(1, point);
    },
    zoomIn: function(point) {
        this.setZoom(this.getZoom() * 1.2, point);
    },
    zoomOut: function(point) {
        this.setZoom(this.getZoom() / 1.2, point);
    },
    //subnetwork
    upSubNetwork: function(animate, finishFunction) {
        if (this._currentSubNetwork) {
            this.setCurrentSubNetwork($element.getSubNetwork(this._currentSubNetwork), animate, finishFunction);
        }
    },
    getCurrentSubNetwork: function() {
        return this._currentSubNetwork;
    },
    setCurrentSubNetwork: function(currentSubNetwork, animate, finishFunction) {
        twaver.animate.AnimateManager.endAnimate();
        if (animate) {
            if (this._currentSubNetwork === currentSubNetwork) {
                return;
            }
            if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
                throw currentSubNetwork + " is not contained in this network's elementBox";
            }
            var animateSubNetwork = new twaver.animate.AnimateSubNetwork(this, currentSubNetwork, finishFunction);
            twaver.animate.AnimateManager.start(animateSubNetwork);
        } else {
            this._setCurrentSubNetwork(currentSubNetwork);
            if (finishFunction) {
                finishFunction();
            }
        }
    },
    _setCurrentSubNetwork: function(currentSubNetwork) {
        if (this._currentSubNetwork === currentSubNetwork) {
            return;
        }
        if (currentSubNetwork && !this._box.contains(currentSubNetwork)) {
            throw currentSubNetwork + " is not contained in this network's elementBox";
        }
        if (this.isAsyncZoomAndViewRect()) {
            var viewRect = this._viewRectMap[this._currentSubNetwork];
            if (!viewRect) {
                this._viewRectMap[this._currentSubNetwork] = this.viewRect ? this.viewRect : {
                    x: 0,
                    y: 0,
                    width: this.viewRect.width,
                    height: this.viewRect.height
                };
            } else {
                this._viewRectMap[this._currentSubNetwork] = this.viewRect;
            }
        }
        var oldValue = this._currentSubNetwork;
        this._currentSubNetwork = currentSubNetwork;
        this.firePropertyChange("currentSubNetwork", oldValue, currentSubNetwork);
        if (this.isAsyncZoomAndViewRect()) {
            if (!this._viewRectMap[this._currentSubNetwork]) {
                this._viewRectMap[this._currentSubNetwork] = {
                    x: 0,
                    y: 0,
                    width: this.viewRect.width,
                    height: this.viewRect.height
                };
            }
            var viewRect = this._viewRectMap[this._currentSubNetwork];
            this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
            this.invalidateElementUIs();
        }

        this.invalidateElementVisibility();
        this.invalidateCanvasSize();
        this._paintAll = true;
    },
    makeVisible: function(element) {
        var ui = this.getElementUI(element);
        if (!ui) {
            return;
        }
        var subNetwork = $element.getSubNetwork(element);
        if (subNetwork !== this._currentSubNetwork) {
            var self = this;
            this.setCurrentSubNetwork(subNetwork, this.isSubNetworkAnimate(), function() {
                _twaver.callLater(self.makeVisible, self, [element]);
            });
            return;
        }
        var e = element;
        while ((e = e.getParent()) && e !== subNetwork) {
            if (e instanceof twaver.Group) {
                e.setExpanded(true);
            }
        }
        var bounds = ui.getViewRect();

        if (!bounds) {
            return;
        }
        var zoomViewRect = ui.getZoomViewRect(this.zoomManager); //this.zoomManager.getElementViewRect(ui,bounds);
        var vr;
        if (bounds.x == zoomViewRect.x && bounds.y == zoomViewRect.y && bounds.width == zoomViewRect.width && bounds.height == zoomViewRect.height) {
            vr = {
                x: bounds.x * this.getGraphicsZoom(),
                y: bounds.y * this.getGraphicsZoom(),
                width: bounds.width * this.getGraphicsZoom(),
                height: bounds.height * this.getGraphicsZoom()
            };
        } else {
            vr = zoomViewRect;
        }
        if (!$math.intersects(this.viewRect, vr)) {
            if (this.isVisible(element)) {
                _twaver.callLater(this.centerByLogicalPoint, this, [vr.x + vr.width / 2, vr.y + vr.height / 2]);
            }
        }
    },
    centerByLogicalPoint: function(x, y, animate) {
        var xoff = x - this.viewRect.width / 2;
        var yoff = y - this.viewRect.height / 2;
        this.setViewRect(xoff, yoff, this.viewRect.width, this.viewRect.height);
    },
    panByOffset: function(xoff, yoff) {
        this.setViewOffSet(xoff, yoff);
    },
    getIconsNames: function(element) {
        return element.getStyle('icons.names');
    },
    getIconsColors: function(element) {
        return element.getStyle('icons.colors');
    },
    getLinkFlowStepping: function(link) {
        var stepping = parseInt(link.getStyle("link.flow.stepping"));
        if (!stepping) {
            stepping = $Defaults.NETWORK_LINK_FLOW_STEPPING;
        }
        return stepping;
    },
    getLinkFlowOffset: function(link) {
        var currentOffset = link.getStyle("link.flow.offset");
        if (isNaN(currentOffset)) {
            currentOffset = 0;
        }
        return currentOffset + this.getLinkFlowStepping(link);
    },
    toCanvas: function(w, h, c, zoom, dx, dy) {
        if (!c) {
            c = $html.createCanvas();
        }
        c.setAttribute('width', w);
        c.setAttribute('height', h);
        if (c._viewRect) {
            c._viewRect.width = w;
            c._viewRect.height = h;
        } else {
            c._viewRect = {
                x: 0,
                y: 0,
                width: w,
                height: h
            };
        }

        var ctx = c.getContext('2d');
        ctx.translate(-dx, -dy);
        ctx.clearRect(0, 0, w, h);
        $backgroundUI.draw(ctx, this);

        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }
        var sx = w / this.realWidth * this.getGraphicsZoom();
        var sy = h / this.realHeight * this.getGraphicsZoom();
        // ctx.scale(sx, sy);
        ctx.scale(zoom, zoom);

        var list = this.getElementBox().getDatas()._as;
        var size = list.length;
        this._topAttachmentList = new twaver.List();
        var layerBox = this.getElementBox().getLayerBox(),
            layers = layerBox.getRoots(),
            layerSize = layers.size(),
            j, layer, i, n, ui, att;

        this.adjustLinkIndex();

        if (layerSize === 1) {
            for (i = 0; i < size; i++) {
                n = list[i];
                if (this._visibleMap[n._id]) {
                    ui = this._elementUIMap[n._id];
                    if (ui != null) {
                        ui.paint(ctx);
                    }
                }
            }
        } else {
            for (j = 0; j < layerSize; j++) {
                layer = layers.get(j);
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui != null) {
                            ui.paint(ctx);
                        }
                    }
                }
            }
        }
        size = this._topAttachmentList.size();
        for (i = 0; i < size; i++) {
            att = this._topAttachmentList.get(i);
            att.getElementUI().paintAttachment(ctx, att);
        }
        return c;
    },
    toCanvasByRegion: function(rect, scale, c) {
        if (!c) {
            c = $html.createCanvas();
        }
        var width = rect.width * scale;
        var height = rect.height * scale;
        c.setAttribute('width', width);
        c.setAttribute('height', height);
        if (c._viewRect) {
            c._viewRect.width = width;
            c._viewRect.height = height;
        } else {
            c._viewRect = {
                x: 0,
                y: 0,
                width: width,
                height: height
            };
        }
        var ctx = c.getContext('2d');
        ctx.clearRect(0, 0, width, height);
        $backgroundUI.draw(ctx, this);
        if (this._view.clientWidth === 0 || this._view.clientHeight === 0) {
            return c;
        }

        ctx.save();
        ctx.scale(scale, scale);
        ctx.beginPath();

        ctx.translate(-rect.x, -rect.y);

        var list = this.getElementBox().getDatas()._as;
        var size = list.length;

        this._topAttachmentList = new twaver.List();

        var layerBox = this.getElementBox().getLayerBox(),
            layers = layerBox.getRoots(),
            layerSize = layers.size(),
            j, layer, i, n, ui, att;
        this.adjustLinkIndex();

        if (layerSize === 1) {
            for (i = 0; i < size; i++) {
                n = list[i];
                if (this._visibleMap[n._id]) {
                    ui = this._elementUIMap[n._id];
                    if (ui != null && $math.intersects(rect, ui.getZoomViewRect())) {
                        ui.paint(ctx);
                    }
                }
            }
        } else {
            for (j = 0; j < layerSize; j++) {
                layer = layers.get(j);
                for (i = 0; i < size; i++) {
                    n = list[i];
                    if (layerBox.getLayerByElement(n) === layer && this._visibleMap[n._id]) {
                        ui = this._elementUIMap[n._id];
                        if (ui != null && $math.intersects(rect, ui.getZoomViewRect())) {
                            ui.paint(ctx);
                        }
                    }
                }
            }
        }
        size = this._topAttachmentList.size();
        for (i = 0; i < size; i++) {
            att = this._topAttachmentList.get(i);
            att.getElementUI().paintAttachment(ctx, att);
        }
        ctx.restore();
        return c;
    },
    getGroupChildrenRects: function(group) {
        return this.zoomManager._getGroupChildrenRects(group);
    },
    convertPointFromView: function(p) {
        return this.zoomManager._convertPointFromView(p);
    },
    getOffset: function(newPoint, lastPoint) {
        return this.zoomManager._getOffset(newPoint, lastPoint);
    },
    panToCenter: function() {
        this.setViewRect((this.realWidth - this.viewRect.width) / 2,
            (this.realHeight - this.viewRect.height) / 2,
            this.viewRect.width,
            this.viewRect.height);
    },
    moveElementsToCenter: function() {
        if (this._limitViewInCanvas) {
            var viewRect = this.viewRect;
            var unionBounds = this._unionBounds;
            var offsetx = viewRect.x + viewRect.width / 2 - unionBounds.x - unionBounds.width / 2;
            var offsety = viewRect.y + viewRect.height / 2 - unionBounds.y - unionBounds.height / 2;
            twaver.Util.moveElements(this._box.toDatas(), offsetx, offsety);
        } else {
            var offsetx = this.viewRect.width / 2 - this._unionBounds.width / 2;
            var offsety = this.viewRect.height / 2 - this._unionBounds.height / 2;
            this.setViewRect(this._unionBounds.x - offsetx, this._unionBounds.y - offsety, this.viewRect.width, this.viewRect.height);
        }
    },
    getLinkPathFunction: function() {
        return this._linkPathFunction;
    },
    setLinkPathFunction: function(value) {
        var oldValue = this._linkPathFunction;
        this._linkPathFunction = value;
        this.firePropertyChange("linkPathFunction", oldValue, value);
        this.invalidateElementUIs();
    },
    invalidate: function() {
        if (!this._invalidate) {
            this._invalidate = true;
            this.fireViewEvent({
                kind: 'invalidate'
            });
        }
    },
    validate: function() {
        if (!this._invalidate) {
            return;
        }
        if (!isNodejs && this._view.offsetWidth === 0 && this._view.offsetHeight === 0) {
            return;
        }
        this._invalidate = false;
        this._isValidating = true;
        this.fireViewEvent({
            kind: 'validateStart'
        });
        this.validateImpl();
        this.fireViewEvent({
            kind: 'validateEnd'
        });
        this._isValidating = false;
    },
    onClickElement: function(element, e) {

    },
    onClickBackground: function(e) {

    },
    onDoubleClickElement: function(element, e) {

    },
    onDoubleClickBackground: function(e) {

    },
    onLongClickElement: function(element, e) {

    },
    onLongClickBackground: function(e) {

    },
    onMouseMove: function(element, e) {

    },
    onMouseEnter: function(element, e) {

    },
    onMouseLeave: function(element, e) {

    },
    setMovingElement: function(v) {
        if (v == this._movingElement) {
            return;
        }
        var oldValue = this._movingElement;
        this._movingElement = v;
        this.firePropertyChange("movingElement", oldValue, v);
        if (this._box._undoManager._enabled) {
            if (v) {
                this._box._undoManager.startBatch();
            } else {
                this._box._undoManager.endBatch();
            }
        }
    },
    setEditingElement: function(v) {
        if (v == this._editingElement) {
            return;
        }
        var oldValue = this._editingElement;
        this._editingElement = v;
        this.firePropertyChange("editingElement", oldValue, v);
        if (this._box._undoManager._enabled) {
            if (v) {
                this._box._undoManager.startBatch();
            } else {
                this._box._undoManager.endBatch();
            }
        }
    },
    dispose: function() {
        twaver.imageUtil.removeEventListener(this.invalidateElementUIs, this);
        this.setInteractions(null);
        cancelAnimationFrame(this._loopId);
    },
    handle_mousemove: function(e) {
        var element = this.getElementAt(e),
            preElement = this.__preElement,
            preImage = _getElementImage(preElement),
            image = _getElementImage(element);
        if (preElement !== element) {
            if (preElement) {
                preImage && preImage.onMouseLeave && preImage.onMouseLeave(preElement, this);
                this.onMouseLeave(preElement, e);
            }
            if (element) {
                image && image.onMouseEnter && image.onMouseEnter(element, this);
                this.onMouseEnter(element, e);
            }
        }
        element && image && image.onMouseMove && image.onMouseMove(element, this);
        this.onMouseMove(element, e);
        this.__preElement = element;
    }
});
twaver.vector.Overview = function(network) {
    twaver.vector.Overview.superClass.constructor.apply(this, network);
    this._view = $html.createView();
    this._rootDiv = $html.createDiv();
    this._imageCanvas = $html.createCanvas();
    this._imageDiv = $html.createDiv();
    this._maskCanvas = $html.createCanvas();
    this._selectDiv = $html.createDiv();
    this._isNetworkDirty = false;
    this._isMaskDirty = false;
    $html.setVisible(this._selectDiv, false);
    this._view.appendChild(this._rootDiv);
    this._rootDiv.appendChild(this._imageDiv);
    this._rootDiv.appendChild(this._maskCanvas);
    this._rootDiv.appendChild(this._selectDiv);
    this._imageDiv.appendChild(this._imageCanvas);
    this._exportImageCanvas = $html.createCanvas();
    this._imageCtx = this._imageCanvas.getContext('2d');
    this.setNetwork(network);
    if ($ua.isTouchable) {
        if ($ua.isMSTouchable) {
            new twaver.vector.OverviewMSTouchInteraction(this);
        } else {
            new twaver.vector.OverviewTouchInteraction(this);
            new twaver.vector.OverviewInteraction(this);
        }
    } else {
        new twaver.vector.OverviewInteraction(this);
    }
};
_twaver.ext('twaver.vector.Overview', twaver.controls.ControlBase, {
    __accessor: ['fillColor', 'outlineColor', 'outlineWidth', 'selectColor', 'selectWidth', 'padding', 'maxPackingWidth', 'maxPackingHeight'],
    __bool: ['animate'],
    _fillColor: $Defaults.OVERVIEW_FILL_COLOR,
    _outlineColor: $Defaults.OVERVIEW_OUTLINE_COLOR,
    _outlineWidth: $Defaults.OVERVIEW_OUTLINE_WIDTH,
    _selectColor: $Defaults.OVERVIEW_SELECT_COLOR,
    _selectWidth: $Defaults.OVERVIEW_SELECT_WIDTH,
    _padding: $Defaults.OVERVIEW_PADDING,
    _animate: $Defaults.OVERVIEW_ANIMATE,
    _maxPackingWidth: $Defaults.OVERVIEW_MAX_PACKING_WIDTH,
    _maxPackingHeight: $Defaults.OVERVIEW_MAX_PACKING_HEIGHT,
    getNetwork: function() {
        return this._network;
    },
    onPropertyChanged: function(e) {
        this._invalidateMask();
    },
    setNetwork: function(network) {
        if (network === this._network) {
            return;
        }
        if (this._network) {
            this._network.removePropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.removeViewListener(this._handleNetworkViewChange, this);
            $html.removeEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this._network = network;
        if (this._network) {
            this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this);
            this._network.addViewListener(this._handleNetworkViewChange, this);
            $html.addEventListener('scroll', '_handleScrollChange', this._network.getView(), this);
        }
        this.invalidate();
    },
    _handleNetworkPropertyChange: function(evt) {
        if (evt.property === 'zoom' || evt.property === 'currentSubNetwork' || evt.property === 'elementBox' || evt.property === 'dataBox' || evt.property === "canvasSizeChange") {
            this.invalidate();
        }
    },
    _handleNetworkViewChange: function(evt) {
        if (evt.kind === 'validateEnd') {
            this.invalidate();
        }
    },
    _handleScrollChange: function() {
        this._invalidateMask();
    },
    invalidate: function(delay) {
        if (!this._isNetworkDirty || !this._isMaskDirty) {
            if (!this._isNetworkDirty) {
                this._isNetworkDirty = true;
            }
            if (!this._isMaskDirty) {
                this._isMaskDirty = true;
            }
            _twaver.callLater(this.validate, this, null, delay);
        }
    },
    _invalidateMask: function() {
        if (!this._isMaskDirty) {
            this._isMaskDirty = true;
            _twaver.callLater(this.validate, this, [], 100);
        }
    },
    validate: function() {
        if ((this._isMaskDirty || this._isNetworkDirty) && this._network && ((this._maxPackingWidth > 0 && this._maxPackingHeight > 0) || (this._view.clientWidth > 0 && this._view.clientHeight > 0)) && this._network.getViewRect().width !== 0 && this._network.getViewRect().height !== 0 && !this._network._invalidate) {
            var isByMaxPackingWidthAndHeight = this._maxPackingWidth > 0 && this._maxPackingHeight > 0;
            var rect;
            if (isByMaxPackingWidthAndHeight) {
                rect = {
                    x: 0,
                    y: 0,
                    width: this._maxPackingWidth,
                    height: this._maxPackingHeight
                };
            } else {
                rect = {
                    x: 0,
                    y: 0,
                    width: this._view.clientWidth,
                    height: this._view.clientHeight
                };
            }
            $math.grow(rect, -this._padding, -this._padding);
            if (isByMaxPackingWidthAndHeight) {
                $html.setDiv(this._view, {
                    x: 0,
                    y: 0,
                    width: this._imageDiv._viewRect.width,
                    height: this._imageDiv._viewRect.height
                }, null, 0, null);
                rect.width = this._imageDiv._viewRect.width;
                rect.height = this._imageDiv._viewRect.height;
            }
            var gzoom = this._network.getGraphicsZoom();
            var unionBounds = this._network._unionBounds;
            unionBounds = $math.unionRect(unionBounds, {
                x: 0,
                y: 0,
                width: unionBounds.x,
                height: unionBounds.y
            });
            unionBounds = {
                x: unionBounds.x / gzoom,
                y: unionBounds.y / gzoom,
                width: unionBounds.width / gzoom,
                height: unionBounds.height / gzoom
            };
            var viewPort = {
                x: this._network.viewRect.x / gzoom,
                y: this._network.viewRect.y / gzoom,
                width: this._network.viewRect.width / gzoom,
                height: this._network.viewRect.height / gzoom,
            };
            var viewSize = unionBounds;
            var zoom = Math.min(rect.width / viewSize.width, rect.height / viewSize.height);
            var imageWidth = viewSize.width * zoom;
            var imageHeight = viewSize.height * zoom;
            var imageRectWidth = viewSize.width * zoom;
            var imageRectHeight = viewSize.height * zoom;
            var imageX = rect.x + (rect.width - imageRectWidth) / 2;
            var imageY = rect.y + (rect.height - imageRectHeight) / 2;
            if (this._isNetworkDirty) {
                var imageRect = {
                    x: imageX,
                    y: imageY,
                    width: imageRectWidth,
                    height: imageRectHeight
                };
                this._network.toCanvas(imageWidth, imageHeight, this._exportImageCanvas, zoom, viewSize.x * zoom, viewSize.y * zoom);
                this._imageCanvas.setAttribute('width', imageRectWidth);
                this._imageCanvas.setAttribute('height', imageRectHeight);
                this._imageCtx.drawImage(this._exportImageCanvas, 0, 0, imageWidth, imageHeight);
                $html.setDiv(this._imageDiv, imageRect, null, 0, null);
                if (this._network.getElementBox) {
                    this._imageDiv.style.backgroundColor = (this._network.getCurrentSubNetwork() || this._network.getElementBox()).getStyle('background.color') || '';
                }
                this._isNetworkDirty = false;
            }
            if (this._isMaskDirty) {
                var currentRect = {
                    x: (viewPort.x - viewSize.x) * zoom,
                    y: (viewPort.y - viewSize.y) * zoom,
                    width: viewPort.width * zoom,
                    height: viewPort.height * zoom
                };
                var g = $html.setCanvas(this._maskCanvas, imageX, imageY, imageRectWidth, imageRectHeight);
                g.lineWidth = 0;
                g.fillStyle = this._fillColor;
                $g.drawVector(g, 'rectangle', null, imageX, imageY, imageRectWidth, imageRectHeight);
                g.closePath();
                g.fill();
                g.stroke();
                g.clearRect(imageX + currentRect.x, imageY + currentRect.y, currentRect.width, currentRect.height);
                g.lineWidth = this._outlineWidth;
                g.strokeStyle = this._outlineColor;
                var w = currentRect.width - this._outlineWidth * 2,
                    h = currentRect.height - this._outlineWidth * 2;
                w = Math.min(w, imageRectWidth - 2 - currentRect.x - this._outlineWidth);
                h = Math.min(h, imageRectHeight - 2 - currentRect.y - this._outlineWidth);
                $g.drawVector(g, 'rectangle', null, imageX + currentRect.x + this._outlineWidth, imageY + currentRect.y + this._outlineWidth, w, h);
                g.closePath();
                g.stroke();
                this._isMaskDirty = false;
            }
        } else {
            this._isNetworkDirty = false;
            this._isMaskDirty = false;
        }
    },
    getLogicalPoint: function(e) {
        return $html.getLogicalPoint(this._view, e, 1, this._rootDiv);
    },
    centerNetwork: function(point, animate) {
        var imageRect = this._imageDiv._viewRect;
        if ($math.containsPoint(imageRect, point)) {
            var gzoom = this._network.getGraphicsZoom();
            var unionBounds = this._network._unionBounds;
            unionBounds = $math.unionRect(unionBounds, {
                x: 0,
                y: 0,
                width: unionBounds.x,
                height: unionBounds.y
            });
            unionBounds = {
                x: unionBounds.x / gzoom,
                y: unionBounds.y / gzoom,
                width: unionBounds.width / gzoom,
                height: unionBounds.height / gzoom
            };
            var viewPort = {
                x: this._network.viewRect.x / gzoom,
                y: this._network.viewRect.y / gzoom,
                width: this._network.viewRect.width / gzoom,
                height: this._network.viewRect.height / gzoom,
            };
            var viewSize = $math.unionRect(unionBounds, viewPort);
            this._network.centerByLogicalPoint(
                (viewSize.x + (point.x - imageRect.x) / imageRect.width * viewSize.width) * gzoom, (viewSize.y + (point.y - imageRect.y) / imageRect.height * viewSize.height) * gzoom, animate);
            this._invalidateMask();
        }
    }
});
twaver.vector.OverviewTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('touchstart', 'handleTouchstart', this.view, this);
};
_twaver.ext('twaver.vector.OverviewTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isMultiTouch(e)) {
            this.distance = $touch.getDistance(e);
            this.zoom = this.network.getZoom();
        }
        $html.addEventListener('touchmove', 'handleTouchmove', this.view, this);
        $html.addEventListener('touchend', 'handleTouchend', this.view, this);
    },
    handleTouchmove: function (e) {
        if (!this.moved) {
            this.moved = true;
        }
        this.endPoint = this.overview.getLogicalPoint(e);
        if ($touch.isSingleTouch(e)) {
            this.overview.centerNetwork(this.endPoint, false);
        } else {
            if (this.distance) {
                var scale = $touch.getDistance(e) / this.distance;
                this.network.setZoom(this.zoom * scale, false);
            }
        }
    },
    handleTouchend: function (e) {
        if (!this.moved) {
            this.endPoint = this.overview.getLogicalPoint(e);
            var isDoubleTouch = this.lastPoint && this.lastTouchStartTime
                && (new Date().getTime() - this.lastTouchStartTime.getTime() <= 300)
                && (Math.abs(this.endPoint.x - this.lastPoint.x) <= 10)
                && (Math.abs(this.endPoint.y - this.lastPoint.y) <= 10);
            if (isDoubleTouch) {
                this.lastPoint = null;
                this.lastTouchStartTime = null;
            } else {
                this.lastPoint = this.endPoint;
                this.lastTouchStartTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
        
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('touchmove', this.view, this);
            $html.removeEventListener('touchend', this.view, this);
        }
        this.moved = false;
    }
});

twaver.vector.OverviewMSTouchInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;

    this._pointerMap = {};
    this._pointerIdArray = [];
    $html.addEventListener("MSPointerDown", "handleTouchstart", this.view, this);
    $html.addEventListener("MSPointerMove", "handleTouchmove", this.view, this);
    $html.addEventListener("MSPointerUp", "handleTouchend", this.view, this);
    $html.addEventListener("MSPointerCancel", "handleTouchend", this.view, this);
};
_twaver.ext('twaver.vector.OverviewMSTouchInteraction', Object, {
    handleTouchstart: function (e) {
        $html.preventDefault(e);

        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this._pointerMap = {};
            this._pointerIdArray = [];
        }
        if (!this._pointerMap[e.pointerId] && this.overview.getLogicalPoint(e)) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }

        if (this._pointerIdArray.length == 1) {
            this._startTouchPoint = this.overview.getLogicalPoint(e);
            this._startTouchTime = new Date();
        }
        else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }
    },
    handleTouchmove: function (e) {
        if (this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;

        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        } else if (this._pointerIdArray.length == 1) {
            if (this._startTouchPoint) {
                var newPoint = this.overview.getLogicalPoint(e);
                if (newPoint == null) {
                    return
                };
                this._startTouchPoint = newPoint;
                this.overview.centerNetwork(this._startTouchPoint, false);
            }
        }
    },
    handleTouchend: function (e) {
        var newEndTouchPoint = this.overview.getLogicalPoint(e);
        if (this._pointerIdArray.length == 1 && newEndTouchPoint) {
            var isDoubleTouch = this._endTouchPoint && this._endTouchTime
                && (new Date().getTime() - this._endTouchTime.getTime() <= 500)
                && $math.getDistance(this._endTouchPoint , newEndTouchPoint) <= 10;
            if (isDoubleTouch) {
                this._endTouchPoint = null;
                this._endTouchTime = null;
            } else {
                this._endTouchPoint = newEndTouchPoint;
                this._endTouchTime = new Date();
            }
            if (isDoubleTouch) {
                _twaver.callLater(this.network.zoomReset, this.network, [this.overview._animate]);
            } else {
                this.overview.centerNetwork(this._endTouchPoint, this.overview._animate);
            }
        }

        this._pointerMap = {};
        this._pointerIdArray = [];
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    }
});

twaver.vector.OverviewInteraction = function (overview) {
    this.overview = overview;
    this.network = overview.getNetwork();
    this.view = overview._view;
    $html.addEventListener('mousedown', 'handleMousedown', this.view, this);
};
_twaver.ext('twaver.vector.OverviewInteraction', Object, {
    handleMousedown: function (e) {
        this.clear();
        this.endPoint = this.overview.getLogicalPoint(e);
        if (_twaver.isCtrlDown(e)) {
            this.startPoint = this.endPoint;
            $html.setVisible(this.overview._selectDiv, true);
        }
        $html.addEventListener('mousemove', 'handleMousemove', this.view, this);
        $html.addEventListener('mouseup', 'handleMouseup', document, this);
    },
    handleMouseup: function (e) {
        this.endPoint = this.overview.getLogicalPoint(e);
        if ('detail' in e && e.detail === 2) {
           _twaver.callLater(this.network.zoomReset, this.network, [this.endPoint, this.overview._animate]);
        } else {
            if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
                var rect = this.overview._imageDiv._viewRect;
                var x = this.overview._selectDiv._viewRect.x;
                var y = this.overview._selectDiv._viewRect.y;
                var zoomByWidth = rect.width / this.overview._selectDiv._viewRect.width;
                var zoomByHeight = rect.height / this.overview._selectDiv._viewRect.height;
                var zoom = Math.min(zoomByWidth, zoomByHeight);

                this.network.setZoom(zoom * Math.min(this.network.getViewRect().width / this.network.getCanvasSize().width,
                    this.network.getViewRect().height / this.network.getCanvasSize().height) * this.network.getZoom(), false);

                var centerX = this.network.getCanvasSize().width * ((x - rect.x + this.overview._selectDiv._viewRect.width / 2) / rect.width);
                var centerY = this.network.getCanvasSize().height * ((y - rect.y + this.overview._selectDiv._viewRect.height / 2) / rect.height);

                _twaver.callLater(this.network.centerByLogicalPoint, this.network, [centerX, centerY, this.overview._animate]);
                $html.setVisible(this.overview._selectDiv, false);
                $html.setDiv(this.overview._selectDiv, { x: 0, y: 0, width: 0, height: 0 }, null, 0, null);
                this.startPoint = null;
            } else {
                this.overview.centerNetwork(this.endPoint, this.overview._animate);
            }
        }
        this.clear();
    },
    handleMousemove: function (e) {
        var newPoint = this.overview.getLogicalPoint(e);
        this.endPoint = newPoint;
        if ($html.isVisible(this.overview._selectDiv) && this.startPoint) {
            var x = newPoint.x > this.startPoint.x ? this.startPoint.x : newPoint.x;
            var y = newPoint.x > this.startPoint.x ? this.startPoint.y : newPoint.y;
            if (newPoint.x > this.startPoint.x && newPoint.y < this.startPoint.y) {
                y = newPoint.y;
            }
            if (newPoint.x < this.startPoint.x && newPoint.y > this.startPoint.y) {
                y = this.startPoint.y;
            }
            var imageRect = this.overview._imageDiv._viewRect;
            if (x < imageRect.x) {
                x = imageRect.x;
            }
            if (x > imageRect.x + imageRect.width) {
                x = imageRect.x + imageRect.width;
            }
            if (y < imageRect.y) {
                y = imageRect.y;
            }
            if (y > imageRect.y + imageRect.height) {
                y = imageRect.y + imageRect.height;
            }
            var width = Math.abs(newPoint.x - this.startPoint.x);
            var height = Math.abs(newPoint.y - this.startPoint.y);
            if (x + width > imageRect.x + imageRect.width) {
                width = imageRect.x + imageRect.width - x;
            }
            //height = width * imageRect.height / imageRect.width;
            if (y + height > imageRect.y + imageRect.height) {
                height = imageRect.y + imageRect.height - y;
                //width = height * imageRect.width / imageRect.height;
            }
            $html.setDiv(this.overview._selectDiv, { x: x, y: y, width: width, height: height }, null, this.overview._selectWidth, this.overview._selectColor);
        } else {

            this.overview.centerNetwork(newPoint, false);
        }
    },
    clear: function () {
        if (this.endPoint) {
            this.endPoint = null;
            $html.removeEventListener('mousemove', this.view, this);
            $html.removeEventListener('mouseup', this.view, this);
        }
    }
});
twaver.vector.ElementUI = function (network, element) {
	this._network = network;
	this._element = element;

	this._attachments = new twaver.List();
	this._bodyBounds = new twaver.List();
	this._hitTest = false;
	this._hitTest = false;
	this._intersectTest = false;
	this.invalidate(true);
};

_twaver.ext('twaver.vector.ElementUI', Object, {
	getElement: function () {
		return this._element;
	},
	getNetwork: function () {
		return this._network;
	},
	handlePropertyChange: function (e) {
		// this.invalidate(true);
	},
	handleSelectionChange: function (e) {
		// this.invalidate(true);
	},
	//validate
	invalidate: function (checkAttachments) { //vector
		if (checkAttachments === undefined) {
			checkAttachments = true;
		}
		if (checkAttachments) {
			this._invalidateAttachmentsFlag = true;
		}
		if (this._invalidateFlag) {
			return;
		}
		this._hotSpot = null;
		this._bodyRect = null;
		this._invalidateFlag = true;
		this.invalidateZoom();
		this.setAttachmentVisible && this.setAttachmentVisible(false);
		// this._network.invalidateElementVisibility();
	},

	invalidateZoom: function () {
		this._zoomBodyRect = null;
		this._zoomViewRect = null;
		this._zoomHotSpot = null;
	},

	//update the style attribute.
	updateStyle: function () {
		this._innerColor = this._network.getInnerColor(this._element);
		this._outerColor = this._network.getOuterColor(this._element);
		this._glowBlur = this._element.getStyle('glow.blur');
		this._shadowColor = this._network.getShadowColor(this._element);
		this._shadowXOffset = this._element.getStyle('shadow.xoffset');
		this._shadowYOffset = this._element.getStyle('shadow.yoffset');
		this._shadowBlur = this._element.getStyle('shadow.blur');
		this._wholeAlpha = this._element.getStyle('whole.alpha');
	},
	validate: function () {
		var scope = this;
		if (this._invalidateFlag == false) {
			return;
		}
		this._bodyBounds.clear();
		if (this._invalidateAttachmentsFlag) {
			this._invalidateAttachmentsFlag = false;
			this.checkAttachments();
		}
		this._invalidateFlag = false;

		this.updateStyle();
		//calc body bounds
		this.validateImpl();

		this._attachments.forEach(function (attachment) {
			attachment.validate();
		});

		var unionRect;
		this._bodyBounds.forEach(function (rect) {
			unionRect = $math.unionRect(unionRect, rect);
		});
		if (unionRect == null) {
			unionRect = _twaver.cloneRect(this._element.getLocation());
			unionRect.width = 0;
			unionRect.height = 0;
		}
		//body sizeinclude border and select
		this._unionBodyBounds = {
			x: unionRect.x,
			y: unionRect.y,
			width: unionRect.width,
			height: unionRect.height
		};

		// update view rect
		this._attachments.forEach(function (attachment) {
			if (attachment instanceof twaver.vector.EditAttachment) {
				if (attachment.getElementUI() instanceof twaver.vector.LinkUI) {
					unionRect = $math.unionRect(unionRect, attachment._viewRect);
				} else {
					unionRect = $math.unionRect(unionRect, scope._network.zoomManager._reverseElementZoomRect(scope, attachment._viewRect));
				}
			} else if (attachment.getElementUI() instanceof twaver.vector.LinkUI) {
				unionRect = $math.unionRect(unionRect, scope._network.zoomManager._getAttachmentZoomOutLineRect(attachment, attachment._viewRect));
			} else if ((attachment.getElementUI() instanceof twaver.vector.GroupUI && attachment.getElementUI()._shapeRect)) {
				if (attachment instanceof twaver.vector.IconsAttachment) {
					unionRect = $math.unionRect(unionRect, attachment._viewRect);
				} else {
					unionRect = $math.unionRect(unionRect, scope._network.zoomManager._getAttachmentZoomOutLineRect(attachment, attachment._viewRect));
				}
			} else {
				unionRect = $math.unionRect(unionRect, attachment._viewRect);
			}
		});

		//the whole size of the ui
		this._viewRect = unionRect;
	},
	validateImpl: function () {

	},
	setGlow: function (part, ctx) {
		if (this._element.getStyle('outer.style') === 'glow') {
			ctx.shadowColor = this._outerColor;
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = this._glowBlur;
		}
	},
	clearGlow: function (ctx) {
		if (ctx.shadowOffsetX != 0 || ctx.shadowOffsetY != 0 || ctx.shadowBlur != 0) {
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = 0;
		}
	},
	setShadow: function (part, ctx) {
		var zoomManager = this._network.zoomManager;
		var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
		if (ctx.shadowOffsetX === this._shadowXOffset && ctx.shadowOffsetY === this._shadowYOffset && ctx.shadowBlur === this._shadowBlur) {
			return ctx;
		}

		if (shadowable || this._network._showShadowInEdit) {
			var gzoom = zoomManager.getGraphicsZoom();
			var sizeZoom = zoomManager.getSizeZoom();
			gzoom *= sizeZoom;
			if (gzoom > 1)
				gzoom = 1;
			ctx.shadowOffsetX = this._shadowXOffset * gzoom;
			ctx.shadowOffsetY = this._shadowYOffset * gzoom;
			ctx.shadowBlur = this._shadowBlur * gzoom;
			ctx.shadowColor = this._shadowColor;
		}
		return ctx;
	},
	clearShadow: function (ctx) {
		if (ctx.shadowOffsetX != 0 || ctx.shadowOffsetY != 0 || ctx.shadowBlur != 0) {
			ctx.shadowOffsetX = 0;
			ctx.shadowOffsetY = 0;
			ctx.shadowBlur = 0;
		}
	},
	//append shadow bound
	appendShadowBound: function (part, rect) {
		var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
		if (shadowable) {
			var zm = this._network.zoomManager;
			var gzoom = zm.getGraphicsZoom();
			var sizeZoom = zm.getSizeZoom();
			gzoom *= sizeZoom;
			if (gzoom > 1)
				gzoom = 1;
			if (this._shadowXOffset > 0) {
				rect.width += this._shadowXOffset;
			} else {
				rect.x += this._shadowXOffset;
				rect.width += -this._shadowXOffset;
			}
			if (this._shadowYOffset > 0) {
				rect.height += this._shadowYOffset;
			} else {
				rect.y += this._shadowYOffset;
				rect.height += -this._shadowYOffset;
			}
			var blur = this._shadowBlur;
			blur = Math.ceil(blur / gzoom);
			$math.grow(rect, blur + 1, blur + 1);

		}
		return rect;
	},
	appendGlowBound: function (part, rect) {
		if (this._element.getStyle('outer.style') === 'glow') {
			var zm = this._network.zoomManager;
			var gzoom = zm.getGraphicsZoom();
			var sizeZoom = zm.getSizeZoom();
			gzoom *= sizeZoom;
			if (gzoom > 1)
				gzoom = 1;

			var blur = this._glowBlur;
			blur = Math.ceil(blur / gzoom);
			$math.grow(rect, blur + 1, blur + 1);
		}
	},
	isShadowable: function () {
		if (this._shadowColor && this._network.isSelected(this._element) && this._element.getStyle('select.style') === 'shadow') {
			return true;
		}
		return false;
	},

	//attachment
	addAttachment: function (attachment) {
		this._attachments.add(attachment);
		this.invalidate(false);
	},
	removeAttachment: function (attachment) {
		this._attachments.remove(attachment);
		this._network._hitTestTopAttachmentList.remove(attachment);
		this.invalidate(false);
	},
	getAttachments: function () {
		return this._attachments;
	},
	checkAttachments: function () {
		this.checkLabelAttachment();
		this.checkLabel2Attachment();
		this.checkAlarmAttachment();
		this.checkIconsAttachment();
		this.checkEditAttachment();
	},

	checkLabelAttachment: function () {
		var label = this._network.getLabel(this._element);
		if (label != null && label !== "") {
			if (!this._labelAttachment) {
				this._labelAttachment = new twaver.vector.LabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
				this.addAttachment(this._labelAttachment);
			}
		} else {
			if (this._labelAttachment) {
				this.removeAttachment(this._labelAttachment);
				this._labelAttachment = null;
			}
		}
	},
	checkLabel2Attachment: function () {
		var label = this._network.getLabel2(this._element);
		if (label != null && label !== "") {
			if (!this._label2Attachment) {
				this._label2Attachment = new twaver.vector.Label2Attachment(this, $Defaults.SHOW_LABEL2_IN_ATTACHMENT_DIV);
				this.addAttachment(this._label2Attachment);
			}
		} else {
			if (this._label2Attachment) {
				this.removeAttachment(this._label2Attachment);
				this._label2Attachment = null;
			}
		}
	},
	checkAlarmAttachment: function () {
		var label = this._network.getAlarmLabel(this._element);
		if (label != null && label !== "") {
			if (!this._alarmAttachment) {
				this._alarmAttachment = new twaver.vector.AlarmAttachment(this, $Defaults.SHOW_ALARM_IN_ATTACHMENT_DIV);
				this.addAttachment(this._alarmAttachment);
			}
		} else {
			if (this._alarmAttachment) {
				this.removeAttachment(this._alarmAttachment);
				this._alarmAttachment = null;
			}
		}
	},
	checkIconsAttachment: function () {
		var icons = this._network.getIconsNames(this._element);
		if (icons && icons.length > 0) {
			if (!this._iconsAttachment) {
				this._iconsAttachment = new twaver.vector.IconsAttachment(this, $Defaults.SHOW_ICON_IN_ATTACHMENT_DIV);
				this.addAttachment(this._iconsAttachment);
			}
		} else {
			if (this._iconsAttachment) {
				this.removeAttachment(this._iconsAttachment);
				this._iconsAttachment = null;
			}
		}
	},
	checkEditAttachment: function () {
		if (this._network.hasEditInteraction() && this._network.isSelected(this._element) && this._network.isEditable(this._element) && this.isEditable()) {
			if (!this._editAttachment) {
				this._editAttachment = new twaver.vector.EditAttachment(this, $Defaults.SHOW_EDIT_IN_ATTACHMENT_DIV);
				this.addAttachment(this._editAttachment);
			}
		} else {
			if (this._editAttachment) {
				this.removeAttachment(this._editAttachment);
				this._editAttachment = null;
			}
		}
	},
	getLabelAttachment: function () {
		return this._labelAttachment;
	},
	getAlarmAttachment: function () {
		return this._alarmAttachment;
	},
	getIconsAttachment: function () {
		return this._iconsAttachment;
	},
	getEditAttachment: function () {
		return this._editAttachment;
	},
	isEditable: function () {
		return true;
	},
	getInnerColor: function () {
		return this._innerColor;
	},
	getOuterColor: function () {
		return this._outerColor;
	},
	getShadowColor: function () {
		return this._shadowColor;
	},
	getDyeColor: function (styleProp) {
		if (this._innerColor) {
			return this._innerColor;
		}
		return this.getStyle(styleProp);
	},
	getStyle: function (styleProp) {
		return this._element.getStyle(styleProp);
	},
	getFont: function (styleProp) {
		var font = this._element.getStyle(styleProp);
		return font ? font : twaver.Defaults.FONT;
	},
	//paint
	paint: function (ctx) {
		ctx.save();
		ctx.globalAlpha = this._wholeAlpha;
		ctx.beginPath();
		this.paintBody(ctx);
		this.clearShadow(ctx);
		this.clearGlow(ctx);
		ctx.closePath();
		ctx.beginPath();
		this.paintAttachments(ctx);
		ctx.closePath();
		ctx.restore();

		if (this._network._debug) {
			$g.strokeRect(ctx, this.getZoomBodyRect(), 'orange');
		}
	},
	paintBody: function (ctx) {

	},

	getZoomBodyRect: function (force) {
		return this._network.zoomManager._getElementZoomRect(this, this.getBodyRect());
	},

	getZoomHotSpot: function () {
		if (!this._zoomHotSpot) {
			this._zoomHotSpot = this._network.zoomManager._getZoomHotSpot(this, this._hotSpot);
		}
		return _twaver.clone(this._zoomHotSpot);
	},

	getZoomPointers: function (attachment, pointers) {
		return this._network.zoomManager._getZoomPointers(attachment, this, pointers);
	},

	_getZoomViewRect: function (rect, attachment, type) {
		var zoomManager = this._network.zoomManager;
		if (attachment) {
			var zoomRect = _twaver.cloneRect(zoomManager._getAttachmentZoomRect(attachment, rect));
			// zoomRect.width *= zoomManager.getAttachmentSizeZoom(attachment);
			// zoomRect.height *= zoomManager.getAttachmentSizeZoom(attachment);
			return zoomRect;
		}
		var locationZoom = zoomManager.getLocationZoom();
		var sizeZoom = zoomManager.getSizeZoom(this);
		var b = this._bodyRect ? this._bodyRect : this.getBodyRect();
		rect = rect || {
			x: b.x,
			y: b.y,
			width: 0,
			height: 0
		}
		var cx = b.x + b.width / 2;
		var cy = b.y + b.height / 2;
		return {
			x: cx * locationZoom + (rect.x - cx) * sizeZoom,
			y: cy * locationZoom + (rect.y - cy) * sizeZoom,
			width: rect.width * sizeZoom,
			height: rect.height * sizeZoom
		};
	},

	getZoomViewRect: function (force) {
		var zoomManager = this._network.zoomManager;
		var locationZoom = zoomManager.getLocationZoom();
		var gzoom = zoomManager.getGraphicsZoom();
		if (locationZoom == 1) {
			return _twaver.cloneRect(this._viewRect);
		}
		if (!this._zoomViewRect || force) {
			// if (locationZoom == 1) { // Graphics Zoom Or Logic Zoom but zoom == 1
			// return this._viewRect ;
			// } else {
			var bodyZoomViewRect = this._getZoomViewRect(_twaver.cloneRect(this._unionBodyBounds), false);
			// var bodyZoomViewRect = this._unionBodyBounds;
			var unionRect;
			unionRect = $math.unionRect(unionRect, bodyZoomViewRect);
			var scope = this;
			this._attachments.forEach(function (attachment) {
				if (attachment instanceof twaver.vector.EditAttachment) {
					unionRect = $math.unionRect(unionRect, attachment._viewRect);
				} else {
					unionRect = $math.unionRect(unionRect, attachment.getZoomViewRect());
				}
			});
			this._zoomViewRect = unionRect;
			// }

		}
		return _twaver.cloneRect(this._zoomViewRect);
	},

	paintAttachments: function (ctx) {
		var self = this;
		ctx.beginPath();
		var size = this._attachments.size();
		for (var i = 0; i < size; i++) {
			var att = this._attachments.get(i);
			if (!this._network.isShowAttachOnChg() && !this._network.isVisibleAttachment(att)) {
				continue;
			}
			if (this._hitTest == true) {
				if (att.isShowOnTop() == false) {
					this.paintAttachment(ctx, att);
				}
			}
			if (this._intersectTest == true) {
				this.paintAttachment(ctx, att);
			}
			if (this._hitTest == false && this._intersectTest == false) {
				if (att.isShowOnTop()) {
					this._network._topAttachmentList.add(att);
				} else {
					this.paintAttachment(ctx, att);
				}
			}
		}
	},
	paintAttachment: function (ctx, att) {
		var zoomManager = this._network.zoomManager;
		if (!zoomManager.isAttachmentVisible(this._element)) {
			return;
		}
		if ((att == this._labelAttachment || att == this._label2Attachment) && !zoomManager.isLabelVisible(this._element)) {
			return;
		} else if (att == this._alarmAttachment && !zoomManager.isAlarmBalloonVisible(this._element)) {
			return;
		}
		ctx.beginPath();
		att.paint(ctx);
		this.clearShadow(ctx);
	},
	/*
	 * Get the bounds of the whole ui
	 */
	getViewRect: function () {
		return _twaver.cloneRect(this._viewRect);
	},
	getUnionBodyBounds: function () {
		return _twaver.cloneRect(this._unionBodyBounds);
	},
	addBodyBounds: function (rect) {
		if (rect) {
			this._bodyBounds.add(rect);
		}
	},
	getBodyRect: function (clone) {
		if (clone == undefined) {
			clone = true;
		}
		if (!this._bodyRect) {
			this._bodyRect = this.createBodyRect();
		}
		return clone ? _twaver.cloneRect(this._bodyRect) : this._bodyRect;
	},

	//hot spot
	getHotSpot: function () {
		if (this._hotSpot) {
			return _twaver.clone(this._hotSpot);
		}
		return {
			x: 0,
			y: 0
		};
	},
	setHotSpot: function (value) { //vector
		this._hotSpot = value;
	},
	//hit interaction--getElementAt(e)
	hit: function (x, y) {
		return false;
	},
	//rect select--getELementsAtRect(rect);
	intersects: function (r) {
		if ($math.contains(r, this.getZoomViewRect())) {
			return true;
		}
		return false;
	},
	/*
	 * 1 true
	 * -1 false
	 * 0 exceptipn
	 */
	hitCanvasRectAtBody: function (rect) {
		if (rect.width < 1) {
			rect.width = 1;
		}
		if (rect.height < 1) {
			rect.height = 1;
		}
		var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
		var ctx = $CanvasUtil.getCtx(cvs);
		ctx.save();
		ctx.translate(-rect.x, -rect.y);
		if (this._element.getImage) {
			var imageAsset = _twaver.getImageAsset(this._element.getImage());
			if (imageAsset && imageAsset.getImage() instanceof _gif) {
				return 1;
			}
		}
		this.paintBody(ctx);
		try {
			var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
			var pixs = imageData.data;
			for (var c = 0; c < imageData.width; c++) {
				for (var r = 0; r < imageData.height; r++) {
					var index = 4 * (r * imageData.width + c);
					var a = pixs[index + 3];
					if (a !== 0) {
						ctx.restore();
						return 1;
					}
				}
			}
		} catch (e) {
			$CanvasUtil.disposeHitCanvas();
			if ($math.contains(this.getUnionBodyBounds(), rect)) {
				return 0;
			}
		}
		ctx.restore();
		return -1;
	},
	hitCanvasRectAtAttachments: function (rect) {
		var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
		var ctx = $CanvasUtil.getCtx(cvs);
		ctx.save();
		ctx.translate(-rect.x, -rect.y);
		this.paintAttachments(ctx);
		try {
			var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
			var pixs = imageData.data;
			for (var c = 0; c < imageData.width; c++) {
				for (var r = 0; r < imageData.height; r++) {
					var index = 4 * (r * imageData.width + c);
					var a = pixs[index + 3];
					if (a !== 0) {
						ctx.restore();
						return 1;
					}
				}
			}
		} catch (e) {
			$CanvasUtil.disposeHitCanvas();
		}
		ctx.restore();
		return -1;
	},

	hitCanvasRect: function (r) {
		this._intersectTest = true;
		if (this._hitTest == true) {
			this._intersectTest = false;
		}
		var rect = $math.intersection(r, this.getZoomViewRect());
		var bh = this.hitCanvasRectAtBody(rect);
		if (bh == 1) {
			this._intersectTest = false;
			return true;
		}
		var ah = this.hitCanvasRectAtAttachments(rect);
		if (ah == 1) {
			this._intersectTest = false;
			return true;
		}
		this._intersectTest = false;
		return bh == 0;
	},
	hitCanvasPoint: function (x, y) {
		var targetRect = {
			x: x,
			y: y,
			width: 0,
			height: 0
		};
		var tolerance = this._network.getSelectionTolerance();
		if (tolerance && tolerance > 0) {
			$math.grow(targetRect, tolerance, tolerance);
		}
		if (!$math.intersects(this.getZoomViewRect(), targetRect)) {
			return false;
		}
		this._hitTest = true;
		var h = this.hitCanvasRect(targetRect);
		this._hitTest = false;
		return h;
	},
	hitTest: function (x, y) {
		var targetRect = {
			x: x,
			y: y,
			width: 0,
			height: 0
		};
		var tolerance = this._network.getSelectionTolerance();
		if (tolerance && tolerance > 0) {
			$math.grow(targetRect, tolerance, tolerance);
		}
		if (!$math.intersects(this.getZoomViewRect(), targetRect)) {
			return null;
		}
		var rect = $math.intersection(targetRect, this.getZoomViewRect());

		var size = this._attachments.size();
		for (var i = 0; i < size; i++) {
			var att = this._attachments.get(i);
			if (att.hit(x, y)) {
				return att;
			}
		}

		var bh = this.hitCanvasRectAtBody(rect);
		if (bh == 1) {
			return this;
		}

		if (bh == 0) {
			return this;
		}
		return null;
	},
	dispose: function () {
		this._attachments.forEach(function (attachment) {
			attachment.dispose();
		});
		this._attachments.clear();
	},
});
twaver.vector.NodeUI = function(network, element) {
	twaver.vector.NodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.NodeUI', twaver.vector.ElementUI, {
	invalidate : function(checkAttachments) {
		if(this.curInterval) {
			clearInterval(this.curInterval);
		}
		twaver.vector.NodeUI.superClass.invalidate.call(this,checkAttachments);
	},
	createBodyRect : function() {
		return this._element.getRect();
	},
	validateImpl : function() {
		twaver.vector.NodeUI.superClass.validateImpl.call(this);
		var shape = this.getStyle('vector.shape');
		var rect = this.getBodyRect();
		this._hotSpot = $math.getHotSpot(rect.x, rect.y, rect.width, rect.height, shape);
		this.validateBodyBounds();
	},
	validate : function() {
		if (this._invalidateFlag == false) {
			return;
		}
		twaver.vector.NodeUI.superClass.validate.call(this);
	},
	validateBodyBounds : function() {
		var type = this.getStyle('body.type');
		if (type === 'default') {
			this.addBodyBounds(this.getDefaultBodyRect());
		} else if (type === 'vector') {
			this.addBodyBounds(this.getVectorBody());
		} else if (type === 'default.vector') {
			this.addBodyBounds(this.getVectorBody());
			this.addBodyBounds(this.getDefaultBodyRect());
		} else if (type === 'vector.default') {
			this.addBodyBounds(this.getDefaultBodyRect());
			this.addBodyBounds(this.getVectorBody());
		}
		if (this._outerColor  && this.getStyle('outer.style') === 'border') {
			this.addBodyBounds(this.getOuterBorderRect());
		}
		if (!this._editAttachment && this.getStyle('select.style') === 'border' && this._network.isSelected(this._element)) {
			this.addBodyBounds(this.getSelectBorderRect());
		}
	},
	getDefaultBodyRect : function() {
		var node = this._element;
		var rect = this.getBodyRect();
		if (!node.getImage() || typeof node.getImage() === 'string' && !_twaver.getImageAsset(node.getImage())) {
			return rect;
		}
		$math.addPadding(rect, this._element, 'image.padding', 1);
		var bounds = _twaver.cloneRect(rect);
		this.appendGlowBound(this, bounds);
		this.appendShadowBound(this, bounds);
		rect = bounds;
		return rect;
	},
	getVectorBody : function() {
		var rect = this.getPathRect("vector");
		return rect;
	},
	getOuterBorderRect : function() {
		return this._getBorderRect("outer");
	},
	getSelectBorderRect : function() {
		return this._getBorderRect("select");
	},
	_getBorderRect : function(prefix) {
		var node = this._element;
		var lineWidth = node.getStyle(prefix + '.width');
		var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getGraphicsZoom();
		if (lineWidth > 0) {
			lineWidth = prefix === 'select' ? lineWidth / zoom : lineWidth;
			var rect = this.getBodyRect();
			$math.addPadding(rect, node, prefix + '.padding', prefix === 'select' ? 1/zoom : 1);
			var bounds = _twaver.cloneRect(rect);
			$math.grow(bounds, lineWidth * 2 , lineWidth * 2 );
			return bounds;
		}
		return null;
	},
	getPathRect : function(prefix, padding) {
		var node = this._element;
		var rect = this.getBodyRect();
		// var rect = this.getZoomBodyRect();
		var sizeZoom = this._network.zoomManager.getSizeZoom();
		if (padding) {
			$math.addPadding(rect, node, prefix + '.padding', 1);
		}
		var bounds = _twaver.cloneRect(rect);
		var lineWidth = node.getStyle(prefix + '.outline.width');
		if (lineWidth > 0) {
			if (this._getZoomPoints) {
				var points = this._element._points;
				var size = points.size();
				var maxD = 0;
				for(var i=0;i<size;i++){
					if(i == 0){
						var p = points.get(i);
						var preP = points.get(size -1);
						var nextP = points.get(i+1);
					}else if(i == size-1){
						var p = points.get(i);
						var preP = points.get(i-1);
						var nextP = points.get(0);
					}else{
						var p = points.get(i);
						var preP = points.get(i-1);
						var nextP = points.get(i+1);
					}
					var centerP = $math.getCenterPoint(preP,nextP);
					var angle = $math.getAngle(centerP,p);
					var d = Math.abs(10 / 2 * (lineWidth + 1) * Math.sin(angle));
					maxD = maxD < d? d:maxD;
					d = Math.abs(10 / 2 * (lineWidth + 1) * Math.cos(angle));
					maxD = maxD < d? d:maxD;
				}
				$math.grow(bounds, maxD,maxD);
			} else {
				$math.grow(bounds, lineWidth /2, lineWidth /2);
			}
		}
		this.appendGlowBound(this, bounds);
		this.appendShadowBound(this, bounds);
		return bounds;
	},
	getZoomPathRect : function(prefix, padding) {
		var node = this._element;
		var rect = this.getZoomBodyRect();
		var sizeZoom = this._network.zoomManager.getSizeZoom();
		if (padding) {
			$math.addPadding(rect, node, prefix + '.padding', 1);
		}
		var bounds = _twaver.cloneRect(rect);
		var lineWidth = node.getStyle(prefix + '.outline.width');
		if (lineWidth > 0) {
			if (this._getZoomPoints) {
				var points = this._getZoomPoints();
				var size = points.size();
				var maxD = 0;
				for(var i=0;i<size;i++){
					if(i == 0){
						var p = points.get(i);
						var preP = points.get(size -1);
						var nextP = points.get(i+1);
					}else if(i == size-1){
						var p = points.get(i);
						var preP = points.get(i-1);
						var nextP = points.get(0);
					}else{
						var p = points.get(i);
						var preP = points.get(i-1);
						var nextP = points.get(i+1);
					}
					var centerP = $math.getCenterPoint(preP,nextP);
					var angle = $math.getAngle(centerP,p);
					var d = Math.abs(10 / 2 * (lineWidth + 1) * Math.sin(angle));
					maxD = maxD < d? d:maxD;
					d = Math.abs(10 / 2 * (lineWidth + 1) * Math.cos(angle));
					maxD = maxD < d? d:maxD;
				}
				$math.grow(bounds, maxD,maxD);
			} else {
				$math.grow(bounds, lineWidth /2, lineWidth /2);
			}
		}
		this.appendGlowBound(this, bounds);
		this.appendShadowBound(this, bounds);
		return bounds;
	},
	paintBody : function(ctx) {
		if(this.curInterval) {
			clearInterval(this.curInterval);
		}
		var type = this.getStyle('body.type');
		if (type === 'default') {
			this.drawDefaultBody(ctx);
		} else if (type === 'vector') {
			this.drawVectorBody(ctx);
		} else if (type === 'default.vector') {
			this.drawVectorBody(ctx);
			this.drawDefaultBody(ctx);
		} else if (type === 'vector.default') {
			this.drawDefaultBody(ctx);
			this.drawVectorBody(ctx);
		}
		if (this._outerColor && this.getStyle('outer.style') === 'border') {
			this.drawOuterBorder(ctx);
		}
		if (this.getStyle('select.style') === 'border' && this._network.isSelected(this._element)) {
			this.drawSelectBorder(ctx);
		}
	},
	drawOuterBorder : function(ctx) {
		var node = this._element;
		var lineWidth = node.getStyle('outer.width');
		if (lineWidth > 0) {
			var rect = this.getZoomBodyRect();
			$math.addPadding(rect, node, 'outer.padding', 1);
			ctx.lineWidth = lineWidth;
			ctx.lineCap = node.getStyle('outer.cap');
			ctx.lineJoin = node.getStyle('outer.join');
			ctx.strokeStyle = this._outerColor;
			$g.drawVector(ctx, node.getStyle('outer.shape'), null, rect);
			ctx.stroke();
		}
	},
	drawDefaultBody : function(ctx) {
		var node = this._element;
		var imageAsset;
		if (!node.getImage() || typeof node.getImage() === 'string' && !(imageAsset = _twaver.getImageAsset(node.getImage()))) {
			return;
		}
		if(this._shapeRect && (!node.getStyle('group.expend.image') || typeof node.getStyle('group.expend.image') === 'string' && !(imageAsset = _twaver.getImageAsset(node.getStyle('group.expend.image'))))){
			return;
		}
		var rect = this.getZoomBodyRect();
		$math.addPadding(rect, this._element, 'image.padding', 1);
		if(node.getAngle() != 0) {
			ctx.save();
			rect = node.getOriginalRect();
			rect = this._network.zoomManager._getElementZoomRect(this,rect);
			twaver.Util.rotateCanvas(ctx, rect, node.getAngle());
		}
		this.setGlow(this, ctx);
		this.setShadow(this, ctx);
		var self = this;
		if(imageAsset && imageAsset.getImage() instanceof _gif) {
			var frames = imageAsset.getImage().frames;
			var size = imageAsset.getImage().size;
			var i = 0,curFrame;
			curFrame = getGifFrame(frames,size,0);
			ctx.drawImage(curFrame, rect.x ,rect.y, rect.width, rect.height);
			this.curInterval = setInterval(function() {
				i = (i + frames.length) % frames.length;
				curFrame = getGifFrame(frames,size,i);
				ctx.drawImage(curFrame, rect.x ,rect.y, rect.width, rect.height);
				i++;
			},100);
		} else {
			if(this._shapeRect){
				drawImage(ctx, node.getStyle('group.expend.image'), this.getInnerColor(), rect, node, this._network);
			}else{
				drawImage(ctx, node.getImage(), this.getInnerColor(), rect, node, this._network);
			}
		}
		if(node.getAngle() != 0) {
			ctx.restore();
		}
	},
	drawSelectBorder : function(ctx) {
		this.clearGlow(ctx);
		var node = this._element;
		var lineWidth = node.getStyle('select.width');
		if (lineWidth > 0) {
			var rect = this.getZoomBodyRect();
			rect = _twaver.cloneRect(rect);
			var zoom = node.getStyle('select.physicalZoom') ? 1 : this._network.getGraphicsZoom();

			$math.addPadding(rect, node, 'select.padding', 1 / zoom);

			$math.grow(rect, lineWidth / 2 / zoom, lineWidth / 2 / zoom);

			ctx.lineWidth = lineWidth / zoom; //select border is logic border
			ctx.lineCap = node.getStyle('select.cap');
			ctx.lineJoin = node.getStyle('select.join');
			ctx.strokeStyle = node.getStyle('select.color');
			$g.drawVector(ctx, node.getStyle('select.shape'), null, rect);
			ctx.stroke();
		}
	},
	drawVectorBody : function(ctx) {
		this.drawPath(ctx, 'vector', true, this._element.getStyle('vector.outline.pattern'));
		var deep = this.getStyle('vector.deep');
		var fillColor = this.getStyle('vector.fill.color');
		if (deep !== 0 && fillColor) {
			if (this.getStyle('vector.shape') === 'rectangle') {
				var rect = this.getZoomBodyRect();
				var angle = this._element.getAngle();
				if (angle != 0) {
					ctx.save();
					var r = this._element.getOriginalRect();
					r = this._network.zoomManager._getElementZoomRect(this, r);
					twaver.Util.rotateCanvas(ctx, r, angle);
				}
				$g.draw3DRect(ctx, fillColor, deep, rect);
				if (angle != 0) {
					ctx.restore();
				}
			}
		}
	},
	drawPath : function(ctx, prefix, padding, pattern, points, segments, close) {
		var zoomManager = this._network.zoomManager;
		var node = this._element;
		var rect = null;
		if (prefix == 'group') {
			rect = this._shapeRect;
		} else {
			rect = this.getZoomBodyRect();
		};
		if (padding) {
			$math.addPadding(rect, node, prefix + '.padding', 1);
		}
		var lineWidth = node.getStyle(prefix + '.outline.width');
		this.setGlow(this, ctx);
		this.setShadow(this, ctx);
		if (node.getAngle() != 0) {
			if (!( node instanceof $Group)) {
				rect = node.getOriginalRect();
				rect = zoomManager._getElementZoomRect(this, rect);
			}
			ctx.save();
			twaver.Util.rotateCanvas(ctx, rect, node.getAngle());
		}
		var fill = node.getStyle(prefix + '.fill');
		var fillColor;
		if (fill) {
			if (this._innerColor && !$element.hasDefault(this._element)) {
				fillColor = this._innerColor;
			} else {
				fillColor = node.getStyle(prefix + '.fill.color');
			}
			var gradient = node.getStyle(prefix + '.gradient');
			if (gradient) {
				$g.fill(ctx, fillColor, gradient, node.getStyle(prefix + '.gradient.color'), rect);
			} else {
				ctx.fillStyle = fillColor;
			}
		}
		var shape = node.getStyle(prefix + '.shape');
		var roundRectRadiusValue = node.getStyle("group.shape.roundrect.radius");
		roundRectRadiusValue < 0 && (roundRectRadiusValue = 10);
		if (fill) {
			ctx.beginPath();
			if (points) {
				$g.drawLinePoints(ctx, points, null, segments, close);
			} else {
				if(shape === "roundrect" && prefix ==="group"){
					$g.drawVector(ctx, shape, null, rect, roundRectRadiusValue);
				}else{
					$g.drawVector(ctx, shape, null, rect);
				}
			}
			ctx.fill();
		}
		if (lineWidth > 0) {
			ctx.lineWidth = lineWidth;
			ctx.lineCap = node.getStyle(prefix + '.cap');
			ctx.lineJoin = node.getStyle(prefix + '.join');
			ctx.strokeStyle = node.getStyle(prefix + '.outline.color');
			ctx.beginPath();
			if (points) {
				$g.drawLinePoints(ctx, points, pattern, segments, close);
			} else {
				if(shape === "roundrect" && prefix ==="group"){
					$g.drawVector(ctx, shape, pattern, rect, roundRectRadiusValue);
				}else{
					$g.drawVector(ctx, shape, pattern, rect);
				}
			}
			ctx.stroke();
		}
		if (node.getAngle() != 0) {
			ctx.restore();
		}
	},
	hit : function(x, y) {
		var targetRect = { x: x, y: y, width: 0, height: 0 };
		var tolerance = this._network.getSelectionTolerance();
		if (tolerance && tolerance > 0) {        
			$math.grow(targetRect, tolerance, tolerance);
		}
		if (this._network._transparentSelectionEnable) {
			var bodyRect = this.getBodyRect();
			if(_twaver.math.intersects(bodyRect, targetRect)){
				return true;
			}
		}
		if($math.intersects(this.getZoomViewRect(), targetRect)){
			return this.hitCanvasPoint(x, y);
		}
		
		return false;
	},
	intersects : function(r) {
		var it = twaver.vector.NodeUI.superClass.intersects.apply(this, arguments);
		if (it == true) {
			return true;
		}
		if (this._network._transparentSelectionEnable) {
			var bodyRect = this.getBodyRect();
			if (_twaver.math.intersects(bodyRect, r)) {
				return true;
			}
		}
		if ($math.intersects(r, this.getZoomViewRect())){
			return this.hitCanvasRect(r);
		}
		return false;
	}
});

twaver.vector.LinkUI = function (network, element) {
    twaver.vector.LinkUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.LinkUI', twaver.vector.ElementUI, {
    isEditable: function () {
        return true;
    },
    invalidate: function (checkAttachments) {
        this._linkPoints = null;
        this._fromPoint = null;
        this._toPoint = null;
        this._angle = null;
        twaver.vector.LinkUI.superClass.invalidate.call(this, checkAttachments);
    },
    invalidateZoom: function () {
        this._fromPoint = null;
        this._toPoint = null;
        this._linkPoints = null;
        twaver.vector.LinkUI.superClass.invalidateZoom.call(this);
    },
    validateImpl: function () {
        this.validateBodyBounds();
        twaver.vector.LinkUI.superClass.validateImpl.call(this);
    },
    validateBodyBounds: function () {
        var points = this.getLinkPoints();
        if (!points || points.size() < 2) {
            return;
        }
        var link = this._element;
        var bounds = $math.getLineRect(points);

        var width = link.getStyle('link.width');
        var grow = width;
        if (this._outerColor) {
            var outerWidth = link.getStyle('outer.width');
            grow += outerWidth * 2;
        }
        var selectBorder = !this._editAttachment && link.getStyle('select.style') === 'border' && this._network.isSelected(this._element);
        if (selectBorder) {
            var selectWidth = link.getStyle('select.width');
            grow += selectWidth * 2;
        }
        $math.grow(bounds, grow / 2, grow / 2);

        if (link.getStyle('arrow.from')) {
            if (this._network._edgeDetect) {
                if (this._network._debug) {
                    this._arrowFromRect = $arrow.getArrowRect(this, points, true,
                        link.getStyle('arrow.from.shape'),
                        link.getStyle('arrow.from.width'),
                        link.getStyle('arrow.from.height'),
                        0,
                        0,
                        this._network.zoomManager);
                }

                bounds = $math.unionRect(bounds,
                    $arrow.getArrowRect(this, points, true,
                        link.getStyle('arrow.from.shape'),
                        link.getStyle('arrow.from.width'),
                        link.getStyle('arrow.from.height'),
                        0,
                        0,
                        this._network.zoomManager
                    ));
            } else {
                if (this._network._debug) {
                    this._arrowFromRect = $arrow.getArrowRect(this, points, true,
                        link.getStyle('arrow.from.shape'),
                        link.getStyle('arrow.from.width'),
                        link.getStyle('arrow.from.height'),
                        link.getStyle('arrow.from.xoffset'),
                        link.getStyle('arrow.from.yoffset'),
                        this._network.zoomManager
                    );
                }
                bounds = $math.unionRect(bounds,
                    $arrow.getArrowRect(this, points, true,
                        link.getStyle('arrow.from.shape'),
                        link.getStyle('arrow.from.width'),
                        link.getStyle('arrow.from.height'),
                        link.getStyle('arrow.from.xoffset'),
                        link.getStyle('arrow.from.yoffset'),
                        this._network.zoomManager
                    ));
            }
        }
        if (link.getStyle('arrow.to')) {
            if (this._network._edgeDetect) {
                if (this._network._debug) {
                    this._arrowToRect = $arrow.getArrowRect(this, points, false,
                        link.getStyle('arrow.to.shape'),
                        link.getStyle('arrow.to.width'),
                        link.getStyle('arrow.to.height'),
                        0,
                        0,
                        this._network.zoomManager
                    );
                }

                bounds = $math.unionRect(bounds,
                    $arrow.getArrowRect(this, points, false,
                        link.getStyle('arrow.to.shape'),
                        link.getStyle('arrow.to.width'),
                        link.getStyle('arrow.to.height'),
                        0,
                        0,
                        this._network.zoomManager
                    ));
            } else {
                if (this._network._debug) {
                    this._arrowToRect = $arrow.getArrowRect(this, points, false,
                        link.getStyle('arrow.to.shape'),
                        link.getStyle('arrow.to.width'),
                        link.getStyle('arrow.to.height'),
                        link.getStyle('arrow.to.xoffset'),
                        link.getStyle('arrow.to.yoffset'),
                        this._network.zoomManager
                    );
                }

                bounds = $math.unionRect(bounds,
                    $arrow.getArrowRect(this, points, false,
                        link.getStyle('arrow.to.shape'),
                        link.getStyle('arrow.to.width'),
                        link.getStyle('arrow.to.height'),
                        link.getStyle('arrow.to.xoffset'),
                        link.getStyle('arrow.to.yoffset'),
                        this._network.zoomManager
                    ));
            }
        }
        this.appendShadowBound(this, bounds);
        this.addBodyBounds(bounds);
        this._growLinkJoinBounds(bounds, grow);
    },

    _growLinkJoinBounds: function (bounds, grow) {

    },

    createBodyRect: function () {
        var h = this.getHotSpot();
        if (h) {
            return {
                x: h.x - 1,
                y: h.y - 1,
                width: 2,
                height: 2
            };
        }
        return null;
    },
    paintBody: function (ctx) {
        var points = this.getLinkPoints();
        if (!points || points.size() < 2) {
            return;
        }
        var link = this._element;
        var isBundleAgent = link.isBundleAgent() && link.getStyle('link.agent');
        var width = isBundleAgent ? link.getStyle('link.agent.width') : link.getStyle('link.width');
        var grow = width;
        if (this._outerColor && this.getStyle('outer.style') === 'border') {
            var outerWidth = link.getStyle('outer.width');
            grow += outerWidth * 2;
        }
        var selectBorder = !this._editAttachment && link.getStyle('select.style') === 'border' && this._network.isSelected(this._element);
        if (selectBorder) {
            var selectWidth = link.getStyle('select.width');
            grow += selectWidth * 2;
        }
        this.setGlow(this, ctx);
        this.setShadow(this, ctx);
        ctx.lineCap = isBundleAgent ? link.getStyle('link.agent.cap') : link.getStyle('link.cap');
        ctx.lineJoin = isBundleAgent ? link.getStyle('link.agent.join') : link.getStyle('link.join');
        var pattern = isBundleAgent ? link.getStyle('link.agent.pattern') : link.getStyle('link.pattern');
        if (selectBorder) {
            this.drawLinePoints(ctx, points, grow, link.getStyle('select.color'), pattern);
        }
        if (this._outerColor && this.getStyle('outer.style') === 'border') {
            this.drawLinePoints(ctx, points, width + outerWidth * 2, this._outerColor, pattern);
        }
        this.drawLinePoints(ctx, points, width, this._innerColor || (isBundleAgent ? link.getStyle('link.agent.color') : link.getStyle('link.color')), pattern);
        $arrow.drawLinkArrow(this, ctx, points, this._network.zoomManager);

        if (this._network._debug) {
            $g.strokeRect(ctx, this._arrowToRect, twaver.Util.randomColor());
            $g.strokeRect(ctx, this._arrowFromRect, twaver.Util.randomColor());
        }
    },
    drawLinePoints: function (g, points, width, color, pattern) {
        g.lineWidth = width;
        g.strokeStyle = color;

        /*
        g.beginPath();
        $g.drawLinePoints(g, points, pattern);
        g.stroke();
        */
        var isBundleAgent = this._element.isBundleAgent() && this._element.getStyle('link.agent');
        if (this._element.getStyle(isBundleAgent ? 'link.agent.flow' : "link.flow") === true && pattern && pattern.length > 1) {
            var dashedLine = new $DashedLine(g, pattern[0], pattern[1]);
            var offset = this._element.getStyle(isBundleAgent ? 'link.agent.flow.offset' : "link.flow.offset");
            var mod = Math.floor(offset / (pattern[0] + pattern[1]));
            if (mod > 2) {
                offset = offset - (pattern[0] + pattern[1]) * mod;
            }

            if (this._element.getStyle(isBundleAgent ? 'link.agent.flow.converse' : "link.flow.converse")) {
                if (offset < pattern[0]) {
                    dashedLine.overflow = pattern[0] - offset;
                } else if (offset >= pattern[0] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = pattern[1] - (offset - pattern[0]);
                    if (dashedLine.overflow) {
                        dashedLine.isLine = false
                    };
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    dashedLine.overflow = pattern[0] - offset;
                }
            } else {
                if (offset <= pattern[1]) {
                    dashedLine.overflow = offset;
                    if (offset) dashedLine.isLine = false;
                } else if (offset > pattern[1] && offset <= pattern[0] + pattern[1]) {
                    dashedLine.overflow = offset - pattern[1];
                } else {
                    offset -= (pattern[0] + pattern[1]);
                    if (offset) {
                        dashedLine.isLine = false
                    };
                    dashedLine.overflow = offset;
                }
            }

            this._element._styleMap[isBundleAgent ? 'link.agent.flow.offset' : "link.flow.offset"] = offset;
            g.beginPath();
            $g._drawLine(points, g);
            g.stroke();

            g.shadowColor = 'transparent';
            g.beginPath();
            var linkFlowColor = this._element.getStyle(isBundleAgent ? 'link.agent.flow.color' : "link.flow.color");
            linkFlowColor = linkFlowColor ? linkFlowColor : $Defaults.NETWORK_LINK_FLOW_COLOR;
            g.strokeStyle = linkFlowColor;
            $g._drawLine(points, dashedLine);
            g.stroke();
            g.shadowColor = this._shadowColor;
        } else {
            g.beginPath();
            $g.drawLinePoints(g, points, pattern);
            g.stroke();
        }
    },

    getLinkPoints: function () {
        if (!this._linkPoints) {
            this._linkPoints = this.createLinkPoints();
            this._lineLength = $math.calculateLineLength(this._linkPoints);
        }
        return this._linkPoints;
    },
    getFromPosition: function (xoffset, yoffset) {
        var point = this.getFromPoint();
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        return null;
    },
    getToPosition: function (xoffset, yoffset) {
        var point = this.getToPoint();
        if (point) {
            return {
                x: point.x + xoffset,
                y: point.y + yoffset
            };
        }
        return null;
    },
    getFromPoint: function () {
        if (!this._fromPoint) {
            this._fromPoint = $link.createFromPoint(this, this._network.zoomManager);
        }
        return this._fromPoint;
    },
    getToPoint: function () {
        if (!this._toPoint) {
            this._toPoint = $link.createToPoint(this, this._network.zoomManager);
        }
        return this._toPoint;
    },
    getZoomBodyRect: function () {
        return this.getBodyRect();
    },

    getZoomViewRect: function () {
        // var viewRect = this.getViewRect();
        // return viewRect;
        return this._viewRect;
    },
    createLinkPoints: function () {
        var zoomManager = this._network.zoomManager;
        var type = this.getStyle('link.type');
        var points = new twaver.List();

        if ($link.isOrthogonalOrFlexionalLink(this._element)) {
            points = $link.orthogonalAndFlexional(this, type, zoomManager);
        } else {
            if (this._element.isLooped()) {
                var nodeUI = this._network.getElementUI(this._element.getFromAgent());
                if (nodeUI != null) {
                    this._hotSpot = $link.fillLoopedPoints(this, nodeUI.getZoomBodyRect(), points);
                }
            } else if (type === 'arc' || type === 'triangle' || type === 'parallel') {
                var fromPoint = this.getFromPoint();
                var toPoint = this.getToPoint();
                this._hotSpot = $link.fillBundlePoints(this, type, fromPoint, toPoint, points, zoomManager);
            } else {
                throw "Can not resolve link type '" + type + "'";
            }
        }
        if (this._network._linkPathFunction) {
            var result = this._network._linkPathFunction(this, points);
            result && (points = result);
        }
        return points;
    },
    checkAttachments: function () {
        twaver.vector.LinkUI.superClass.checkAttachments.call(this);
        this.checkLinkHandlerAttachment();
    },
    checkLinkHandlerAttachment: function () {
        var label = this._network.getLinkHandlerLabel(this._element);
        if (label != null && label !== '') {
            if (!this._linkHandlerAttachment) {
                this._linkHandlerAttachment = new twaver.vector.LinkHandlerAttachment(this);
                this.addAttachment(this._linkHandlerAttachment);
            }
        } else {
            if (this._linkHandlerAttachment) {
                this.removeAttachment(this._linkHandlerAttachment);
                this._linkHandlerAttachment = null;
            }
        }
    },
    getLinkHandlerAttachment: function () {
        return this._linkHandlerAttachment;
    },
    getControlPoint: function () {
        return $link.getControlPoint(this._element, this, this._network.zoomManager);
    },
    setControlPoint: function (point) {
        if (!point) {
            return;
        }
        var linkType = this.getStyle('link.type');
        if (!$link.hasControlPoint(linkType)) {
            return;
        }
        // var sourceBounds = $link.getLinkSourceBounds(this);
        // var targetBounds = $link.getLinkTargetBounds(this);
        var sourceBounds = $link.getLinkSourceBounds(this, this._network.zoomManager);
        var targetBounds = $link.getLinkTargetBounds(this, this._network.zoomManager);
        $link.setParamsByControlPoint(point, sourceBounds, targetBounds, linkType, this._element);
    },
    getLineLength: function () {
        return this._lineLength;
    },
    hit: function (x, y) {
        var targetRect = {
            x: x,
            y: y,
            width: 0,
            height: 0
        };
        var tolerance = this._network.getSelectionTolerance();
        if (tolerance && tolerance > 0) {
            $math.grow(targetRect, tolerance, tolerance);
        }
        if ($math.intersects(this._viewRect, targetRect)) {
            return this.hitCanvasPoint(x, y);
        }
        return false;
    },
    intersects: function (r) {
        var it = twaver.vector.NodeUI.superClass.intersects.apply(this, arguments);
        if (it == true) {
            return true;
        }

        if ($math.intersects(r, this._viewRect) == false) {
            return false;
        }

        var points = this.getLinkPoints();
        var size = points.size();
        if (size == 2) {
            for (var i = 0; i < size; i += 2) {
                var p1 = points.get(i);
                if (i + 1 < size) {
                    var p2 = points.get(i + 1);
                    if ($CanvasUtil.intersectsLine(p1.x, p1.y, p2.x, p2.y, r.x, r.y, r.width, r.height)) {
                        return true;
                    }
                }
            }
        }

        return this.hitCanvasRect(r);
    },
    getAngle: function () {
        if (!this._angle && this._fromPoint && this._toPoint) {
            this._angle = $math.getAngle(this._fromPoint, this._toPoint);
        }
        return this._angle || 0;
    },
    getAbsoluteAngle: function () {
        var va = {
            x: 10,
            y: 0
        };
        var p1 = this._fromPoint;
        var p2 = this._toPoint;
        var vb = {
            x: p2.x - p1.x,
            y: p2.y - p1.y
        };
        var angle = Math.acos((vb.x * va.x + vb.y * va.y) / (Math.sqrt(va.x * va.x + va.y * va.y) * Math.sqrt(vb.x * vb.x + vb.y * vb.y))) * 180 / Math.PI;
        if (p1.y <= p2.y) {
            angle = angle;
        } else {
            angle = 360 - angle;
        }
        angle = (angle % 360) * Math.PI / 180;
        return angle;
    },
    //append shadow bound
    appendShadowBound: function (part, rect) {
        var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
        if (shadowable) {
            if (this._shadowXOffset > 0) {
                rect.width += this._shadowXOffset;
            } else {
                rect.x += this._shadowXOffset;
                rect.width += -this._shadowXOffset;
            }
            if (this._shadowYOffset > 0) {
                rect.height += this._shadowYOffset;
            } else {
                rect.y += this._shadowYOffset;
                rect.height += -this._shadowYOffset;
            }
            var blur = this._shadowBlur;
            $math.grow(rect, blur + 1, blur + 1);
        }
        return rect;
    },
});
twaver.vector.GroupUI = function (network, element) {
    twaver.vector.GroupUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.GroupUI', twaver.vector.NodeUI, {
    isEditable: function () {
        return !this._element.isExpanded();
    },
    paintBody: function (ctx) {
        if (this._shapeRect) {
            if(this._element.getStyle('group.expend.image')){
                twaver.vector.GroupUI.superClass.paintBody.apply(this, arguments);
                this._element.getStyle('group.expend.image.vector') && this.drawExpandedGroup(ctx);
            }else{
                this.drawExpandedGroup(ctx);
            }
        } else {
            twaver.vector.GroupUI.superClass.paintBody.apply(this, arguments);
        }
    },
    validateBodyBounds: function () {
        this.getBodyRect();
        if (this._shapeRect) {
        	var rect = this.getPathRect("group", false);
        	var deep = this.getStyle('group.deep');
        	$math.grow(rect,deep+1,deep+1);
            this.addBodyBounds(rect);
        } else {
            twaver.vector.GroupUI.superClass.validateBodyBounds.call(this);
        }
    },

    getZoomBodyRect : function(){
    	if(this._element.isExpanded()){
    		// return _twaver.cloneRect(this.getBodyRect());
    		return this.getBodyRect();
    	}
    	return twaver.vector.GroupUI.superClass.getZoomBodyRect.call(this);
    },

    getZoomViewRect : function(){
    	if(this._element.isExpanded()){
    		return this.getViewRect();
    	}
    	return twaver.vector.GroupUI.superClass.getZoomViewRect.call(this);
    },

    drawExpandedGroup: function (ctx) { //vector
        this.drawPath(ctx, 'group', false, this._element.getStyle('vector.outline.pattern'));
        var deep = this.getStyle('group.deep');
        var fillColor = this.getStyle('group.fill.color');
        if (deep !== 0 && fillColor) {
            if (this.getStyle('group.shape') === 'rectangle') {
                 $g.draw3DRect(ctx, fillColor, deep, this._shapeRect);
            }
        }
    },
    getChildrenRects: function () {
        return this._network.getGroupChildrenRects(this._element);
    },
    createBodyRect: function () {
        this._shapeRect = null;
        var group = this._element;
        var network = this._network;
        if (group.isExpanded()) {
        	 group.getChildren().forEach(function (child) {
                var ui = network.getElementUI(child);
                ui && ui.validate();
            });
            var rects = this.getChildrenRects();
            if (!rects.isEmpty()) {
                var shape = group.getStyle('group.shape');
                var func = $group[shape];
                if (!func) {
                    throw "Can not resolve group shape '" + shape + "'";
                }
                this._shapeRect = func(rects);
            }
        }
        if (this._shapeRect) {
            $math.addPadding(this._shapeRect, group, 'group.padding', 1);
            return this._shapeRect;
        } else {
            return twaver.vector.GroupUI.superClass.createBodyRect.call(this);
        }
    },
     //append shadow bound
    appendShadowBound : function(part, rect) {
        var shadowable = part.isShadowable() && this._shadowColor && !this._editAttachment;
        if (shadowable) {
            if (this._shadowXOffset > 0) {
                rect.width += this._shadowXOffset;
            } else {
                rect.x += this._shadowXOffset;
                rect.width += -this._shadowXOffset;
            }
            if (this._shadowYOffset > 0) {
                rect.height += this._shadowYOffset;
            } else {
                rect.y += this._shadowYOffset;
                rect.height += -this._shadowYOffset;
            }
            var blur = this._shadowBlur;
            $math.grow(rect, blur + 1,blur + 1);
        }
        return rect;
    },
});

twaver.vector.ShapeNodeUI = function (network, element) {
    twaver.vector.ShapeNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.ShapeNodeUI', twaver.vector.NodeUI, {
    getDefaultBodyRect: function () {
        if (this._element._points.size() < 2) {
            return null;
        }
        // return this.getPathRect("vector", true);
        return this._reverseZoomPathRect();
    },
    
    drawDefaultBody: function (ctx) {
        if (this._element._points.size() < 2) {//vector
            return;
        }
        this.drawPath(ctx, "vector", true, this._element.getStyle('vector.outline.pattern'),
        	this._getZoomPoints(), this._element._segments, this._element.getStyle('shapenode.closed'));
        $arrow.drawLinkArrow(this, ctx, $math.getPointObject(this._element._points, this._element._segments));
    },
    
    invalidateZoom : function(){
    	this._zoomPoints = null;
    	twaver.vector.LinkUI.superClass.invalidateZoom.call(this);
    },
    
    _getZoomPoints : function(){
    	this._zoomPoints = this._network.zoomManager._getShapeNodeZoomPoints(this,this._element._points);
    	return this._zoomPoints;
    },
    _reverseZoomPathRect : function(){
        return this._network.zoomManager._reverseElementZoomRect(this,this.getZoomPathRect('vector', true));
    }
});

twaver.vector.ShapeLinkUI = function (network, element) {
    twaver.vector.ShapeLinkUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.ShapeLinkUI', twaver.vector.LinkUI, {
    isEditable: function () {
        return true;
    },
    
    createLinkPoints: function () {
        var fromPoint = this.getFromPoint();
        var toPoint = this.getToPoint();
        var points = new twaver.List();
        var type = this.getStyle('shapelink.type');
        points.add(fromPoint);
        if (this._element._points != null &&this._element._points.size() > 0) {
        //shapeLinkbug,this._element._points,lenght0
        // if (this._element._points != null) {
            points.addAll(this._network.zoomManager._getShapeLinkZoomPoints(this._element._points));
        }
        points.add(toPoint);
        
        // var pointCount = points.size();
        // var half = Math.ceil(pointCount / 2);
        // if (pointCount % 2 === 0) {
        //     var p1 = points.get(half);
        //     var p2 = points.get(half - 1);
        //     this._hotSpot = {
        //         x: (p1.x + p2.x) / 2,
        //         y: (p1.y + p2.y) / 2
        //     };
        // } else {
        //     this._hotSpot = _twaver.clone(points.get(half));
        // }

        var result, i, lastPoint;
        if (type === 'lineto') {
            //Do Nonthing
        }
        else if (type === 'quadto') {
            result = new twaver.List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    result.add(new twaver.List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'cubicto') {
            result = new twaver.List(points.get(0));
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 2) {
                    result.add(new twaver.List([points.get(i++), points.get(i++), points.get(i)]));
                } else if (i < pointCount - 1) {
                    result.add(new twaver.List([points.get(i++), points.get(i)]));
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else if (type === 'orthogonalto') {
            lastPoint = points.get(0);
            result = new twaver.List(lastPoint);
            for (i = 1, pointCount = points.size(); i < pointCount; i++) {
                if (i < pointCount - 1) {
                    var point = _twaver.clone(points.get(i));
                    var x = point.x;
                    var y = point.y;
                    var dx = x - lastPoint.x;
                    var dy = y - lastPoint.y;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        point.x = x;
                        point.y = lastPoint.y;
                    } else {
                        point.x = lastPoint.x;
                        point.y = y;
                    }
                    lastPoint = point;
                    result.add(lastPoint);
                } else {
                    result.add(points.get(i));
                }
            }
            points = result;
        } else {
            throw "Can not resolve shapelink type '" + type + "'";
        }

        var halfDistance = $math.calculateLineLength(points)/2;
        
        var index, count = points.size(), first, next, point, perDistance, dx, dy, prevSumDistance = 0,sumDistance = 0;
        for (index = 0; index < count; index++) {
            point = points.get(index);
            if (index == 0) {
                first = point;
                continue;
            }
            next = point;
            if (next instanceof $List) {
                next = next._as;
            }
            if (next instanceof Array) {
                perDistance = $math.calculateCurveLength(first, next, 1);
                first = next[next.length - 1];
            } else {
                dy = point.y - first.y;
                dx = point.x - first.x;
                perDistance = Math.sqrt(dx * dx + dy * dy);
                first = next;
            }
            sumDistance += perDistance;
            if(prevSumDistance <= halfDistance && sumDistance >= halfDistance){
                var ds = halfDistance - prevSumDistance;
                var f = points.get(index-1);
                if(f instanceof $List){
                    f = f._as;
                    if(f instanceof Array){
                        f = f[f.length - 1];
                    }
                }
                var t = points.get(index);
                var p = $math.getPathInfo(t,f,ds,0,-1).point;
                this._hotSpot = _twaver.clone(p);
            }
            prevSumDistance = sumDistance;
        }
        return points;
    },
    _growLinkJoinBounds : function(bounds,grow){
    	 $math.grow(bounds, grow * 3, grow * 3);
    },
});

twaver.vector.GridUI = function (network, element) {
    twaver.vector.GridUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.GridUI', twaver.vector.NodeUI, {
    drawDefaultBody: function (ctx) {
        if (this._element.getImage()) {
            twaver.vector.GridUI.superClass.drawDefaultBody.apply(this, arguments);
        } else {
            this.drawGridBody(ctx);
        }
    },
    validateBodyBounds: function () {
        if (this._element.getImage()) {
            twaver.vector.GridUI.superClass.validateBodyBounds.call(this);
        } else {
            var bodyRect = this.getBodyRect();
            var bounds = _twaver.clone(bodyRect);
            var lineWidth = this._element.getStyle('outer.width');
            $math.grow(bounds,lineWidth,lineWidth);
            this.appendShadowBound(this, bounds);
            this.addBodyBounds(bounds);
        }
    },
    
    _getZoomCellRect : function(r,c){
    	 var rect = this._element.getCellRect(r, c);
    	 var b = this._element.getRect();
    	 var cx = b.x + b.width/2;
    	 var cy = b.y + b.height/2;
    	 var zb = this.getZoomBodyRect();
    	 var sizeZoom = zb.width/b.width;
    	 var czx = zb.x + zb.width/2;
    	 var dZoom = cx == 0 ? 1 : czx / cx;
    	 return {
    	 	x : cx * dZoom + (rect.x - cx) * sizeZoom,
    	 	y : cy * dZoom + (rect.y - cy) * sizeZoom,
    	 	width : rect.width * sizeZoom,
    	 	height : rect.height * sizeZoom
    	 };
    },
    
    drawGridBody: function (ctx) {
        var fill = this.getStyle('grid.fill');
        var gridDeep = this.getStyle('grid.deep');
        var cellDeep = this.getStyle('grid.cell.deep');

        if (!fill && gridDeep === 0 && cellDeep === 0) {
            return;
        }
        ctx.beginPath();
        var bodyRect = this.getZoomBodyRect();
        var fillColor = this.getDyeColor('grid.fill.color');
        this.setGlow(this, ctx);
        this.setShadow(this, ctx);
        // draw body
        if (fill) {
            ctx.fillStyle = fillColor;
            ctx.rect(bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
            ctx.fill();
        }
        ctx.closePath();
        this.clearShadow(ctx);
        ctx.beginPath();
        // draw border deep
        if (gridDeep != 0) {
            $g.draw3DRect(ctx, fillColor, gridDeep, bodyRect.x, bodyRect.y, bodyRect.width, bodyRect.height);
        }
        ctx.closePath();
        // draw cell deep
        if (cellDeep != 0) {
            var row = this.getStyle('grid.row.count');
            var col = this.getStyle('grid.column.count');
            for (var r = 0; r < row; r++) {
                for (var c = 0; c < col; c++) {
                    var rect = this._getZoomCellRect(r,c);//this._element.getCellRect(r, c);
                    if (rect != null) {
                        ctx.beginPath();
                        $g.draw3DRect(ctx, fillColor, cellDeep, rect.x, rect.y, rect.width, rect.height);
                        ctx.closePath();
                    }
                }
            }
        }
    }
});

twaver.vector.RotatableNodeUI = function (network, element) {
    twaver.vector.RotatableNodeUI.superClass.constructor.call(this, network, element);
};
_twaver.ext('twaver.vector.RotatableNodeUI', twaver.vector.NodeUI, {
    isEditable: function () {
        return false;
    },
    //need
    getDefaultBodyRect: function () {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        var rect = this.getBodyRect();
        if (!imageAsset) {
            return rect;
        }
        $math.addPadding(rect, this._element, 'image.padding', 1);
        return rect;
    },
    drawDefaultBody: function (ctx) {
        var node = this._element;
        var imageAsset = _twaver.getImageAsset(node.getImage());
        if (!imageAsset) {
            return;
        }
        var rect = this.getBodyRect();
        $math.addPadding(rect, this._element, 'image.padding', 1);

        if (imageAsset.getImage()) {
            var ow = this._element._getOrignalWidth(),
            oh = this._element._getOrignalHeight(),
            rotateRect = this._element._getRotateRect();

            ctx.save();
            ctx.translate(rect.x - rotateRect.x + ow / 2, rect.y - rotateRect.y + oh / 2);
            ctx.rotate(this._element._angle * Math.PI / 180);
            ctx.drawImage(imageAsset.getImage(this._innerColor), -ow / 2, -oh / 2, ow, oh);
            ctx.restore();
        }
        else if (imageAsset.getSrc()) {
        }
        else if (imageAsset.getFunction()) {
        }
        else {
            throw "ImageAsset '" + node.getImage() + " ' is empty";
        }
    }
});

twaver.vector.HTMLNodeUI = function (network, element) {
    twaver.vector.HTMLNodeUI.superClass.constructor.call(this, network, element);
}

_twaver.ext('twaver.vector.HTMLNodeUI', twaver.vector.NodeUI, {
    checkAttachments: function () {
        twaver.vector.NodeUI.prototype.checkAttachments.call(this);
    },
    checkLabelAttachment: function () {
        var type = this._element.getStyle('attachment.label.style');
        if(type && type === 'none'){
            twaver.vector.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            return;
        }

        var label = this._network.getLabel(this._element);
        if (label != null && label !== "") {
            if (!this._labelAttachment) {
                this._labelAttachment = new twaver.vector.HTMLLabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._labelAttachment);
            }
        } else {
            if (this._labelAttachment) {
                this.removeAttachment(this._labelAttachment);
                this._labelAttachment = null;
            }
        }
    },
    checkLabel2Attachment: function () {
        var type = this._element.getStyle('attachment.label2.style');
        if(type && type === 'none'){
            twaver.vector.HTMLNodeUI.superClass.checkLabel2Attachment.call(this);
            return;
        }

        var label = this._network.getLabel2(this._element);
        if (label != null && label !== "") {
            if (!this._label2Attachment) {
                this._label2Attachment = new twaver.vector.HTMLLabel2Attachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._label2Attachment);
            }
        } else {
            if (this._label2Attachment) {
                this.removeAttachment(this._label2Attachment);
                this._label2Attachment = null;
            }
        }
    },
    checkAlarmAttachment: function () {
        var type = this._element.getStyle('attachment.alarm.style');
        if(type && type === 'none'){
            twaver.vector.HTMLNodeUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

        var label = this._network.getAlarmLabel(this._element);
        if (label != null && label !== "") {
            if (!this._alarmAttachment) {
                this._alarmAttachment = new twaver.vector.HTMLAlarmAttachment(this, false);
                this.addAttachment(this._alarmAttachment);
            }
        } else {
            if (this._alarmAttachment) {
                this.removeAttachment(this._alarmAttachment);
                this._alarmAttachment = null;
            }
        }
    },
    setAttachmentVisible: function (visible) {
        if(visible){
            this._labelAttachment && this._labelAttachment.setVisibility('visible');
            this._label2Attachment && this._label2Attachment.setVisibility('visible');
            this._alarmAttachment && this._alarmAttachment.setVisibility('visible');
        }else {
            this._labelAttachment && this._labelAttachment.setVisibility('hidden');
            this._label2Attachment && this._label2Attachment.setVisibility('hidden');
            this._alarmAttachment && this._alarmAttachment.setVisibility('hidden');
        }
    },
    validateZIndex: function(layerIndex){
        this._labelAttachment && this._labelAttachment.validateZIndex(layerIndex);
    }  
});

twaver.vector.HTMLLinkUI = function(network, element){
	twaver.vector.HTMLLinkUI.superClass.constructor.call(this, network, element);
}

_twaver.ext('twaver.vector.HTMLLinkUI', twaver.vector.LinkUI, {
	checkAttachments: function () {
		twaver.vector.LinkUI.prototype.checkAttachments.call(this);
	},
	checkLabelAttachment: function () {
		var style = this._element.getStyle('attachment.label.style');
        if(style && style === 'none'){
            twaver.vector.HTMLLinkUI.superClass.checkLabelAttachment.call(this);
            return;
        }

		var label = this._network.getLabel(this._element);
		if (label != null && label !== "") {
			if (!this._labelAttachment) {
				this._labelAttachment = new twaver.vector.HTMLLabelAttachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
				this.addAttachment(this._labelAttachment);
			}
		} else {
			if (this._labelAttachment) {
				this.removeAttachment(this._labelAttachment);
				this._labelAttachment = null;
			}
		}
	},
	checkLabel2Attachment: function () {
        var type = this._element.getStyle('attachment.label2.style');
        if(type && type === 'none'){
            twaver.vector.HTMLNodeUI.superClass.checkLabelAttachment.call(this);
            return;
        }

        var label = this._network.getLabel2(this._element);
        if (label != null && label !== "") {
            if (!this._label2Attachment) {
                this._label2Attachment = new twaver.vector.HTMLLabel2Attachment(this, $Defaults.SHOW_LABEL_IN_ATTACHMENT_DIV);
                this.addAttachment(this._label2Attachment);
            }
        } else {
            if (this._label2Attachment) {
                this.removeAttachment(this._label2Attachment);
                this._label2Attachment = null;
            }
        }
    },
	checkAlarmAttachment: function () {
		var style = this._element.getStyle('attachment.alarm.style');
        if(style && style === 'none'){
            twaver.vector.HTMLLinkUI.superClass.checkAlarmAttachment.call(this);
            return;
        }

		var label = this._network.getAlarmLabel(this._element);
		if (label != null && label !== "") {
			if (!this._alarmAttachment) {
				this._alarmAttachment = new twaver.vector.HTMLAlarmAttachment(this, false);
				this.addAttachment(this._alarmAttachment);
			}
		} else {
			if (this._alarmAttachment) {
				this.removeAttachment(this._alarmAttachment);
				this._alarmAttachment = null;
			}
		}
	},
	setAttachmentVisible: function (visible) {
		if(visible){
			this._labelAttachment && this._labelAttachment.setVisibility('visible');
			this._label2Attachment && this._label2Attachment.setVisibility('visible');
			this._alarmAttachment && this._alarmAttachment.setVisibility('visible');
		}else {
			this._labelAttachment && this._labelAttachment.setVisibility('hidden');
			this._label2Attachment && this._label2Attachment.setVisibility('hidden');
			this._alarmAttachment && this._alarmAttachment.setVisibility('hidden');
		}
	}, 
});
twaver.vector.Attachment = function (elementUI, showInTop) {
    this._ui = elementUI;
    this._element = this._ui.getElement();
    this._network = elementUI.getNetwork();
    this._showOnTop = showInTop;
    if (showInTop) {
        this._network._hitTestTopAttachmentList.add(this);
    }
};
_twaver.ext('twaver.vector.Attachment', Object, {
    getElement: function () {
        return this._element;
    },
    getElementUI: function () {
        return this._ui;
    },
    getNetwork: function () {
        return this._network;
    },
    isShowOnTop: function () {
        return this._showOnTop === true;
    },
    setShowOnTop: function (t) {
        this._showOnTop = t;
    },
    getStyle: function (styleProp) {
        return this._ui.getStyle(styleProp);
    },
    getFont: function (styleProp) {
        return this._ui.getFont(styleProp);
    },
    getViewRect: function () {
        return _twaver.clone(this._viewRect);
    },
    getAlpha: function () {
        return 1;
    },
    validate: function () {},
    paint: function (ctx) {},

    getZoomViewRect: function () {
        var r = this._network.zoomManager._getAttachmentZoomOutLineRect(this, this._viewRect);
        return r;
    },

    hit: function (x, y) {
        if ($math.containsPoint(this.getZoomViewRect(), x, y)) {
            return this.hitCanvasRect({
                x: x - 1,
                y: y - 1,
                width: 2,
                height: 2
            });
        }
        return false;
    },
    hitCanvasRect: function (rect) {
        var cvs = $CanvasUtil.getHitCanvas(rect.width, rect.height);
        var ctx = $CanvasUtil.getCtx(cvs);
        ctx.save();
        ctx.translate(-rect.x, -rect.y);
        this.paint(ctx);
        try {
            var imageData = ctx.getImageData(0, 0, rect.width, rect.height);
            var pixs = imageData.data;
            for (var c = 0; c < imageData.width; c++) {
                for (var r = 0; r < imageData.height; r++) {
                    var index = 4 * (r * imageData.width + c);
                    var a = pixs[index + 3];
                    if (a !== 0) {
                        ctx.restore();
                        return true;
                    }
                }
            }
        } catch (e) {
            $CanvasUtil.disposeHitCanvas();
        }
        ctx.restore();
        return false;
    },
    dispose: function () {
        this._network._hitTestTopAttachmentList.remove(this);
    },
    _rotatePoint: function (point, angle, rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _rotatePointList: function (list, angle, rect) {
        var self = this;
        var newList = new twaver.List();
        list.forEach(function (p) {
            newList.add(self._rotatePoint(p, angle, rect));
        });
        return newList;
    },
});
twaver.vector.BasicAttachment = function(elementUI, showInAttachmentDiv) {
    twaver.vector.BasicAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._roundRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    this._contentRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
};
_twaver.ext('twaver.vector.BasicAttachment', twaver.vector.Attachment, {
    paint: function(ctx) {
        twaver.vector.BasicAttachment.superClass.paint.apply(this, arguments);
        var fill = this.isFill();
        var outlineWidth = this.getOutlineWidth();
        var rect = this._network.zoomManager._getAttachmentZoomOutLineRect(this, this._roundRect);
        this.getElementUI().setGlow(this, ctx);
        this.getElementUI().setShadow(this, ctx);

        if (outlineWidth > 0 || fill) {
            $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
            //todo make sure drawRoundRect and pointer same direction
            if (this._network._debug) {
                $g.strokeRect(ctx, rect, '#C71585');
            }
            if (this._pointers) {
                var pointers = this._ui.getZoomPointers(this, this._pointers);
                ctx.moveTo(pointers[0].x, pointers[0].y);
                ctx.lineTo(pointers[1].x, pointers[1].y);
                ctx.lineTo(pointers[2].x, pointers[2].y);
            }
            ctx.closePath();

            if (outlineWidth > 0) {
                ctx.lineWidth = outlineWidth;
                ctx.strokeStyle = this.getOutlineColor();
                ctx.lineCap = this.getCap();
                ctx.lineJoin = this.getJoin();
                ctx.stroke();
            }
            if (fill) {
                var fillColor = this.getFillColor();
                var gradient = this.getGradient();
                if (gradient) {
                    $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
                } else {
                    ctx.fillStyle = fillColor;
                }
                ctx.fill();
            }
        }
    },
    validate: function() {
        twaver.vector.BasicAttachment.superClass.validate.call(this);
        this.calculateMeasure();

        var outlineWidth = this.getOutlineWidth();
        if (outlineWidth == null || outlineWidth <= 0) {
            outlineWidth = 1;
        }
        this._viewRect = $math.getRect(this._pointers);
        this._viewRect = $math.unionRect(this._viewRect, this._roundRect);
        if (outlineWidth > 0) {
            $math.grow(this._viewRect, outlineWidth * 2, outlineWidth * 2);
        }
        this._viewRect = this._ui.appendShadowBound(this, this._viewRect);
        var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label.rotatable');
        if (rotatable) {
            var cx = this._viewRect.x + this._viewRect.width / 2,
                cy = this._viewRect.y + this._viewRect.height / 2;
            var w = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
            this._viewRect = {
                x: cx - w,
                y: cy - w,
                width: w * 2,
                height: w * 2
            }
        }

    },
    calculateMeasure: function() {
        var contentWidth = this.getContentWidth();
        var contentHeight = this.getContentHeight();
        var cornerRadius = this.getCornerRadius();
        var pointerLength = this.getPointerLength();
        var pointerWidth = this.getPointerWidth();
        var position = this.getPosition();
        var xOffset = this.getXOffset();
        var yOffset = this.getYOffset();
        var roundRect = this._roundRect;
        roundRect.width = contentWidth + cornerRadius;
        roundRect.height = contentHeight;
        var location;

        if (this._ui._element instanceof twaver.Link) {
            var points = this._ui.getLinkPoints();
            var lineLength;
            if (this._ui.getLineLength) {
                lineLength = this._ui.getLineLength();
            } else {
                lineLength = this._ui._element.getLineLength();
            }

            if (Math.abs(xOffset) > 0 && Math.abs(xOffset) < 1) {
                if (position === 'from') {
                    xOffset *= lineLength;
                } else if (position === 'to') {
                    xOffset = lineLength * (1 - xOffset);
                } else {
                    xOffset /= 2;
                    xOffset += 0.5;
                    xOffset *= lineLength;
                }
            } else {
                if (position === 'from') {
                    xOffset = xOffset;
                } else if (position === 'to') {
                    xOffset = lineLength - xOffset;
                } else {
                    xOffset += lineLength / 2;
                }
            }

            var pointInfo = $math.calculatePointInfoAlongLine(points, true, xOffset, yOffset);
            var translatePoint = pointInfo.point;
            var rotateAngle = pointInfo.angle;

            var c;
            if (position === 'from') {
                c = this._ui.getFromPoint();
            } else if (position === 'to') {
                c = this._ui.getToPoint();
            } else {
                c = this._ui._hotSpot;
            }

            xOffset = translatePoint.x - c.x;
            yOffset = translatePoint.y - c.y;
        }

        if (pointerLength > 0) {
            var direction = this.getDirection();
            location = this._network.getPosition(position, this._ui, null, xOffset, yOffset, false);
            var endPoint;
            if (direction === 'aboveleft') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, location.x - (roundRect.width - cornerRadius) + cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x,
                        y: location.y - pointerLength
                    },
                    {
                        x: endPoint,
                        y: location.y - pointerLength
                    }
                ];
            } else if (direction === 'aboveright') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, location.x - cornerRadius + roundRect.width - cornerRadius / 2);

                this._pointers = [location,
                    {
                        x: location.x,
                        y: location.y - pointerLength
                    },
                    {
                        x: endPoint,
                        y: location.y - pointerLength
                    }
                ];
            } else if (direction === 'belowleft') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - (roundRect.width - cornerRadius);
                endPoint = Math.max(location.x - pointerWidth, location.x - (roundRect.width - cornerRadius) + cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x,
                        y: location.y + pointerLength
                    },
                    {
                        x: endPoint,
                        y: location.y + pointerLength
                    }
                ];
            } else if (direction === 'belowright') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - cornerRadius;
                endPoint = Math.min(location.x + pointerWidth, location.x - cornerRadius + roundRect.width - cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x,
                        y: location.y + pointerLength
                    },
                    {
                        x: endPoint,
                        y: location.y + pointerLength
                    }
                ];
            } else if (direction === 'leftabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.max(location.y - pointerWidth, location.y + cornerRadius - roundRect.height + cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x - pointerLength,
                        y: location.y
                    },
                    {
                        x: location.x - pointerLength,
                        y: endPoint
                    }
                ];
            } else if (direction === 'leftbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(location.y + pointerWidth, location.y - cornerRadius + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x - pointerLength,
                        y: location.y
                    },
                    {
                        x: location.x - pointerLength,
                        y: endPoint
                    }
                ];
            } else if (direction === 'rightabove') {
                roundRect.y = location.y + cornerRadius - roundRect.height;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.max(location.y - pointerWidth, location.y + cornerRadius - roundRect.height + cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x + pointerLength,
                        y: location.y
                    },
                    {
                        x: location.x + pointerLength,
                        y: endPoint
                    }
                ];
            } else if (direction === 'rightbelow') {
                roundRect.y = location.y - cornerRadius;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(location.y + pointerWidth, location.y - cornerRadius + roundRect.height - cornerRadius / 2);
                this._pointers = [location,
                    {
                        x: location.x + pointerLength,
                        y: location.y
                    },
                    {
                        x: location.x + pointerLength,
                        y: endPoint
                    }
                ];
            } else if (direction === 'above') {
                roundRect.y = location.y - pointerLength - roundRect.height;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
                    {
                        x: location.x - endPoint,
                        y: location.y - pointerLength
                    },
                    {
                        x: location.x + endPoint,
                        y: location.y - pointerLength
                    }
                ];
            } else if (direction === 'below') {
                roundRect.y = location.y + pointerLength;
                roundRect.x = location.x - roundRect.width / 2;
                endPoint = Math.min(contentWidth / 2, pointerWidth / 2);
                this._pointers = [location,
                    {
                        x: location.x - endPoint,
                        y: location.y + pointerLength
                    },
                    {
                        x: location.x + endPoint,
                        y: location.y + pointerLength
                    }
                ];
            } else if (direction === 'left') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x - pointerLength - roundRect.width;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
                    {
                        x: location.x - pointerLength,
                        y: location.y + endPoint
                    },
                    {
                        x: location.x - pointerLength,
                        y: location.y - endPoint
                    }
                ];
            } else if (direction === 'right') {
                roundRect.y = location.y - roundRect.height / 2;
                roundRect.x = location.x + pointerLength;
                endPoint = Math.min(contentHeight / 2, pointerWidth / 2);
                this._pointers = [location,
                    {
                        x: location.x + pointerLength,
                        y: location.y + endPoint
                    },
                    {
                        x: location.x + pointerLength,
                        y: location.y - endPoint
                    }
                ];
            } else {
                throw "Can not resolve '" + direction + "' attachment direction";
            }
        } else {
            location = this._network.getPosition(position, this._ui, {
                width: roundRect.width,
                height: roundRect.height
            }, xOffset, yOffset, false);

            // if(this._ui instanceof twaver.vector.LinkUI && xOffset != 0){
            //     var paths = new $List();
            //     var startPoint = this._network.getPosition(position, this._ui, {
            //         width: 0,
            //         height: 0
            //     }, 0, 0,false);
            //     var endPoint = this._ui.getToPoint();
            //     if(startPoint.x == endPoint.x && startPoint.y == endPoint.y){
            //         endPoint = this._ui.getFromPoint();
            //         xOffset *= -1;
            //     }
            //     paths.add(startPoint);
            //     paths.add(endPoint);
            //     var pointInfo = $math.calculatePointInfoAlongLine(paths, true, xOffset, yOffset);
            //     location = pointInfo.point;
            //     location.x -= roundRect.width/2;
            //     location.y -= roundRect.height/2;
            // }
            roundRect.x = location.x;
            roundRect.y = location.y;
            this._pointers = null;
        }

        this._contentRect.x = roundRect.x + (roundRect.width - contentWidth) / 2;
        this._contentRect.y = roundRect.y + (roundRect.height - contentHeight) / 2;
        this._contentRect.width = contentWidth;
        this._contentRect.height = contentHeight;

        var padding = this.getPadding();
        if (padding != 0) {
            $math.grow(roundRect, padding, padding);
        }
        padding = this.getPaddingLeft();
        if (padding != 0) {
            roundRect.x -= padding;
            roundRect.width += padding;
        }
        padding = this.getPaddingRight();
        if (padding != 0) {
            roundRect.width += padding;
        }
        padding = this.getPaddingTop();
        if (padding != 0) {
            roundRect.y -= padding;
            roundRect.height += padding;
        }
        padding = this.getPaddingBottom();
        if (padding != 0) {
            roundRect.height += padding;
        }
        if (roundRect.width < 0) {
            roundRect.width = roundRect.width;
            roundRect.x -= roundRect.width;
        }
        if (roundRect.height < 0) {
            roundRect.height = -roundRect.height;
            roundRect.y -= roundRect.height;
        }
    },
    getContentWidth: function() {
        return twaver.Defaults.ATTACHMENT_CONTENT_WIDTH;
    },
    getContentHeight: function() {
        return twaver.Defaults.ATTACHMENT_CONTENT_HEIGHT;
    },
    getCornerRadius: function() {
        return twaver.Defaults.ATTACHMENT_CORNER_RADIUS;
    },
    getPointerLength: function() {
        return twaver.Defaults.ATTACHMENT_POINTER_LENGTH;
    },
    getPointerWidth: function() {
        return twaver.Defaults.ATTACHMENT_POINTER_WIDTH;
    },
    getPosition: function() {
        return twaver.Defaults.ATTACHMENT_POSITION;
    },
    getXOffset: function() {
        return twaver.Defaults.ATTACHMENT_XOFFSET;
    },
    getYOffset: function() {
        return twaver.Defaults.ATTACHMENT_YOFFSET;
    },
    getPadding: function() {
        return twaver.Defaults.ATTACHMENT_PADDING;
    },
    getPaddingLeft: function() {
        return twaver.Defaults.ATTACHMENT_PADDING_LEFT;
    },
    getPaddingRight: function() {
        return twaver.Defaults.ATTACHMENT_PADDING_RIGHT;
    },
    getPaddingTop: function() {
        return twaver.Defaults.ATTACHMENT_PADDING_TOP;
    },
    getPaddingBottom: function() {
        return twaver.Defaults.ATTACHMENT_PADDING_BOTTOM;
    },
    getDirection: function() {
        return twaver.Defaults.ATTACHMENT_DIRECTION;
    },
    isFill: function() {
        return twaver.Defaults.ATTACHMENT_FILL;
    },
    getFillColor: function() {
        return twaver.Defaults.ATTACHMENT_FILL_COLOR;
    },
    getGradient: function() {
        return twaver.Defaults.ATTACHMENT_GRADIENT;
    },
    getGradientColor: function() {
        return twaver.Defaults.ATTACHMENT_GRADIENT_COLOR;
    },
    getOutlineWidth: function() {
        return twaver.Defaults.ATTACHMENT_OUTLINE_WIDTH;
    },
    getOutlineColor: function() {
        return twaver.Defaults.ATTACHMENT_OUTLINE_COLOR;
    },
    getCap: function() {
        return twaver.Defaults.ATTACHMENT_CAP;
    },
    getJoin: function() {
        return twaver.Defaults.ATTACHMENT_JOIN;
    },
    isShadowable: function() {
        return twaver.Defaults.ATTACHMENT_SHADOWABLE;
    },
    getRoundRect: function() {
        return _twaver.clone(this._roundRect);
    },
    getContentRect: function() {
        return _twaver.clone(this._contentRect);
    }
    /**
    ,
    getContent: function () {
    return this._content;
    },
    setContent: function (value) {
    if (this._content === value) {
    return;
    }
    this._content = value;
    }*/
});
twaver.vector.LabelAttachment = function(elementUI, showInAttachmentDiv) {
	twaver.vector.LabelAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.LabelAttachment', twaver.vector.BasicAttachment, {
	paint : function(ctx) {
		var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label.rotatable');
		if (rotatable) {
			ctx.save();
			var _vewRect = this.getZoomViewRect();
			var x = _vewRect.x + _vewRect.width / 2,
			y = _vewRect.y + _vewRect.height / 2;
			ctx.translate(x, y);
			ctx.rotate(this._network.getElementUI(this._element).getAngle());
			ctx.translate(-x, -y);
		}

		twaver.vector.LabelAttachment.superClass.paint.apply(this, arguments);
		var zoomManager = this._network.zoomManager;
		// if (this.textArr === undefined) {
			var rect = zoomManager._getAttachmentZoomRect(this,this._contentRect);
			var align = this._element.getStyle("label.align");
			var angle = this._element && this._element.getStyle('label.rotate.angle');

			if(angle !== 0) {
				ctx.save();
				twaver.Util.rotateCanvas(ctx,this._contentRect,angle);
			}
			zoomManager._drawText(this,ctx,this.text,rect,this.font,this.getStyle('label.color'),align,this.getStyle('label.linespacing'));
		// } else {
			// for (var i in this.textArr) {
                // var rect = zoomManager._getAttachmentZoomRect(this,this._contentRect,i);
                // zoomManager._drawText(this,ctx,this.textArr[i],rect,this.font,this.getStyle('label.color'));
			// }
		// }
		if (rotatable || angle !== 0) {
			ctx.restore();
		}

		if(this._network._debug){
			var r = this._viewRect;
			$g.strokeRect(ctx, r, '#AAABBB');
		}
	},
	validate : function() {
		this.font = this.getFont('label.font');
		var originalText = this.getLabel();
		var originalTextSize = _twaver.g.getTextSize(this.font, originalText);
		var originalMaxLength = this.getMaxLength();
		if(originalMaxLength !== 0  && originalTextSize.width > originalMaxLength){
			this.text = _twaver.g.getCollapseTextInLength(this.font,originalText,originalMaxLength);
			this._textSize = _twaver.g.getTextSize(this.font, this.text);
		}else{
			this.text = originalText;
			this._textSize = originalTextSize;
		}
		twaver.vector.LabelAttachment.superClass.validate.call(this);
		var rect = this._viewRect;
		var angle = this._element && this._element.getStyle('label.rotate.angle');
		if(angle !== 0){
			var points = new twaver.List();
			points.add({x:rect.x, y:rect.y});
			points.add({x:rect.x + rect.width, y:rect.y});
			points.add({x:rect.x + rect.width, y:rect.y + rect.height});
			points.add({x:rect.x, y:rect.y + rect.height});

			points = this._rotatePointList(points,angle,rect);
			var result = twaver.Util.getRect(points);
			this._viewRect = result;
		}
	},
	getLabel : function() {
		return this._network.getLabel(this._element);
	},
	getContentWidth : function() {
		return this._textSize ? this._textSize.width : 0;
	},
	getContentHeight : function() {
		return this._textSize ? this._textSize.height : 0;
	},
	getCornerRadius : function() {
		return this.getStyle('label.corner.radius');
	},
	getPointerLength : function() {
		return this.getStyle('label.pointer.length');
	},
	getPointerWidth : function() {
		return this.getStyle('label.pointer.width');
	},
	getPosition : function() {
		return this.getStyle('label.position');
	},
	getXOffset : function() {
		return this.getStyle('label.xoffset');
	},
	getYOffset : function() {
		return this.getStyle('label.yoffset');
	},
	getPadding : function() {
		return this.getStyle('label.padding');
	},
	getPaddingLeft : function() {
		return this.getStyle('label.padding.left');
	},
	getPaddingRight : function() {
		return this.getStyle('label.padding.right');
	},
	getPaddingTop : function() {
		return this.getStyle('label.padding.top');
	},
	getPaddingBottom : function() {
		return this.getStyle('label.padding.bottom');
	},
	getDirection : function() {
		return this.getStyle('label.direction');
	},
	isFill : function() {
		return this.getStyle('label.fill');
	},
	getFillColor : function() {
		return this.getStyle('label.fill.color');
	},
	getGradient : function() {
		return this.getStyle('label.gradient');
	},
	getGradientColor : function() {
		return this.getStyle('label.gradient.color');
	},
	getOutlineWidth : function() {
		return this.getStyle('label.outline.width');
	},
	getOutlineColor : function() {
		return this.getStyle('label.outline.color');
	},
	getCap : function() {
		return this.getStyle('label.cap');
	},
	getJoin : function() {
		return this.getStyle('label.join');
	},
	getAlpha : function() {
		return this.getStyle('label.alpha');
	},
	getMaxLength:function(){
		return this.getStyle('label.maxlength');
	},
	isShadowable : function() {
		return this.getStyle('label.shadowable');
	},
}); 

twaver.vector.Label2Attachment = function(elementUI, showInAttachmentDiv) {
	twaver.vector.Label2Attachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.Label2Attachment', twaver.vector.BasicAttachment, {
    paint : function(ctx) {
        var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label.rotatable');
        if (rotatable) {
            ctx.save();
            var _vewRect = this.getZoomViewRect();
            var x = _vewRect.x + _vewRect.width / 2,
                y = _vewRect.y + _vewRect.height / 2;
            ctx.translate(x, y);
            ctx.rotate(this._network.getElementUI(this._element).getAngle());
            ctx.translate(-x, -y);
        }
        twaver.vector.Label2Attachment.superClass.paint.apply(this, arguments);
        var zoomManager = this._network.zoomManager;
        // if (this.textArr === undefined) {
            var rect = zoomManager._getAttachmentZoomRect(this,this._contentRect);
            var align = this._element.getStyle("label.align");
            var angle = this._element && this._element.getStyle('label2.rotate.angle');

            if(angle !== 0) {
                ctx.save();
                twaver.Util.rotateCanvas(ctx,this._contentRect,angle);
            }
            zoomManager._drawText(this,ctx,this.text,rect,this.font,this.getStyle('label2.color'),align,this.getStyle('label2.linespacing'));
        // } else {
            // for (var i in this.textArr) {
                // var rect = zoomManager._getAttachmentZoomRect(this,this._contentRect,i);
                // zoomManager._drawText(this,ctx,this.textArr[i],rect,this.font,this.getStyle('label2.color'));
            // }
        // }
        if (rotatable || angle !== 0) {
            ctx.restore();
        }
        if(this._network._debug){
            var attachmentSizeZoom = zoomManager.getAttachmentSizeZoom(this);
            var r = rect;
            r.width *= attachmentSizeZoom;
            r.height *= attachmentSizeZoom;
            $g.strokeRect(ctx, r, '#AAABBB');
        }
    },
    validate : function() {
        this.font = this.getFont('label2.font');
        var originalText = this.getLabel();
        var originalTextSize = _twaver.g.getTextSize(this.font, originalText);
        var originalMaxLength = this.getMaxLength();
        if(originalMaxLength !==0 && originalTextSize.width > originalMaxLength){
          this.text = _twaver.g.getCollapseTextInLength(this.font,originalText,originalMaxLength);
          this._textSize = _twaver.g.getTextSize(this.font, this.text);
        }else{
          this.text = originalText;
          this._textSize = originalTextSize;
        }
        twaver.vector.LabelAttachment.superClass.validate.call(this);
        var rect = this._viewRect;
        var angle = this._element && this._element.getStyle('label2.rotate.angle');
        if(angle !== 0){
         var points = new twaver.List();
         points.add({x:rect.x, y:rect.y});
         points.add({x:rect.x + rect.width, y:rect.y});
         points.add({x:rect.x + rect.width, y:rect.y + rect.height});
         points.add({x:rect.x, y:rect.y + rect.height});

         points = this._rotatePointList(points,angle,rect);
         var result = twaver.Util.getRect(points);
         this._viewRect = result;
     }
    },
    getLabel : function() {
        return this._network.getLabel2(this._element);
    },
    getContentWidth : function() {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight : function() {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius : function() {
        return this.getStyle('label2.corner.radius');
    },
    getPointerLength : function() {
        return this.getStyle('label2.pointer.length');
    },
    getPointerWidth : function() {
        return this.getStyle('label2.pointer.width');
    },
    getPosition : function() {
        return this.getStyle('label2.position');
    },
    getXOffset : function() {
        return this.getStyle('label2.xoffset');
    },
    getYOffset : function() {
        return this.getStyle('label2.yoffset');
    },
    getPadding : function() {
        return this.getStyle('label2.padding');
    },
    getPaddingLeft : function() {
        return this.getStyle('label2.padding.left');
    },
    getPaddingRight : function() {
        return this.getStyle('label2.padding.right');
    },
    getPaddingTop : function() {
        return this.getStyle('label2.padding.top');
    },
    getPaddingBottom : function() {
        return this.getStyle('label2.padding.bottom');
    },
    getDirection : function() {
        return this.getStyle('label2.direction');
    },
    isFill : function() {
        return this.getStyle('label2.fill');
    },
    getFillColor : function() {
        return this.getStyle('label2.fill.color');
    },
    getGradient : function() {
        return this.getStyle('label2.gradient');
    },
    getGradientColor : function() {
        return this.getStyle('label2.gradient.color');
    },
    getOutlineWidth : function() {
        return this.getStyle('label2.outline.width');
    },
    getOutlineColor : function() {
        return this.getStyle('label2.outline.color');
    },
    getCap : function() {
        return this.getStyle('label2.cap');
    },
    getJoin : function() {
        return this.getStyle('label2.join');
    },
    getAlpha : function() {
        return this.getStyle('label2.alpha');
    },
    getMaxLength:function(){
      return this.getStyle('label2.maxlength');
    },
    isShadowable : function() {
        return this.getStyle('label2.shadowable');
    },

}); 

twaver.vector.AlarmAttachment = function(elementUI, showInAttachmentDiv) {
    twaver.vector.AlarmAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.AlarmAttachment', twaver.vector.BasicAttachment, {
    paint: function(ctx) {
        twaver.vector.AlarmAttachment.superClass.paint.apply(this, arguments);
        var zoomManager = this._network.zoomManager;
        var rect = zoomManager._getAttachmentZoomRect(this, this._contentRect);
        zoomManager._drawText(this, ctx, this.text, rect, this.font, this.getStyle('alarm.color'));
    },
    validate: function() {
        this.font = this.getFont('alarm.font');
        this.text = this._network.getAlarmLabel(this._element);
        this._textSize = $g.getTextSize(this.font, this.text);
        this._fillColor = this._network.getAlarmFillColor(this._element);
        twaver.vector.AlarmAttachment.superClass.validate.call(this);
    },
    getContentWidth: function() {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function() {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function() {
        return this.getStyle('alarm.corner.radius');
    },
    getPointerLength: function() {
        return this.getStyle('alarm.pointer.length');
    },
    getPointerWidth: function() {
        return this.getStyle('alarm.pointer.width');
    },
    getPosition: function() {
        return this.getStyle('alarm.position');
    },
    getXOffset: function() {
        return this.getStyle('alarm.xoffset');
    },
    getYOffset: function() {
        return this.getStyle('alarm.yoffset');
    },
    getPadding: function() {
        return this.getStyle('alarm.padding');
    },
    getPaddingLeft: function() {
        return this.getStyle('alarm.padding.left');
    },
    getPaddingRight: function() {
        return this.getStyle('alarm.padding.right');
    },
    getPaddingTop: function() {
        return this.getStyle('alarm.padding.top');
    },
    getPaddingBottom: function() {
        return this.getStyle('alarm.padding.bottom');
    },
    getDirection: function() {
        return this.getStyle('alarm.direction');
    },
    isFill: function() {
        return this._fillColor != null;
    },
    getFillColor: function() {
        return this._fillColor;
    },
    getGradient: function() {
        return this.getStyle('alarm.gradient');
    },
    getGradientColor: function() {
        return this.getStyle('alarm.gradient.color');
    },
    getOutlineWidth: function() {
        return this.getStyle('alarm.outline.width');
    },
    getOutlineColor: function() {
        return this.getStyle('alarm.outline.color');
    },
    getCap: function() {
        return this.getStyle('alarm.cap');
    },
    getJoin: function() {
        return this.getStyle('alarm.join');
    },
    getAlpha: function() {
        return this.getStyle('alarm.alpha');
    },
    isShadowable: function() {
        return this.getStyle('alarm.shadowable');
    }
});
twaver.vector.LinkHandlerAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.vector.LinkHandlerAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.LinkHandlerAttachment', twaver.vector.BasicAttachment, {
    paint: function (ctx) {
    	var zoomManager = this._network.zoomManager;
        twaver.vector.LinkHandlerAttachment.superClass.paint.apply(this, arguments);
        // $g.drawText(ctx, this.linkHandlerLabel, this._contentRect, this.linkHandlerFont, this.getStyle('link.handler.color'));
        var rect = zoomManager._getAttachmentZoomRect(this,this._contentRect);
        zoomManager._drawText(this,ctx,this.linkHandlerLabel,rect,this.linkHandlerFont,this.getStyle('link.handler.color'));
    },
    validate: function () {
        this.linkHandlerFont = this.getFont('link.handler.font');
        this.linkHandlerLabel = this._network.getLinkHandlerLabel(this._element);
        this._textSize = $g.getTextSize(this.linkHandlerFont, this.linkHandlerLabel);
        twaver.vector.LinkHandlerAttachment.superClass.validate.call(this);
    },
    getContentWidth: function () {
        return this._textSize ? this._textSize.width : 0;
    },
    getContentHeight: function () {
        return this._textSize ? this._textSize.height : 0;
    },
    getCornerRadius: function () {
        return this.getStyle('link.handler.corner.radius');
    },
    getPointerLength: function () {
        return this.getStyle('link.handler.pointer.length');
    },
    getPointerWidth: function () {
        return this.getStyle('link.handler.pointer.width');
    },
    getPosition: function () {
        return this.getStyle('link.handler.position');
    },
    getXOffset: function () {
        return this.getStyle('link.handler.xoffset');
    },
    getYOffset: function () {
        return this.getStyle('link.handler.yoffset');
    },
    getPadding: function () {
        return this.getStyle('link.handler.padding');
    },
    getPaddingLeft: function () {
        return this.getStyle('link.handler.padding.left');
    },
    getPaddingRight: function () {
        return this.getStyle('link.handler.padding.right');
    },
    getPaddingTop: function () {
        return this.getStyle('link.handler.padding.top');
    },
    getPaddingBottom: function () {
        return this.getStyle('link.handler.padding.bottom');
    },
    getDirection: function () {
        return this.getStyle('link.handler.direction');
    },
    isFill: function () {
        return this.getStyle('link.handler.fill');
    },
    getFillColor: function () {
        return this.getStyle('link.handler.fill.color');
    },
    getGradient: function () {
        return this.getStyle('link.handler.gradient');
    },
    getGradientColor: function () {
        return this.getStyle('link.handler.gradient.color');
    },
    getOutlineWidth: function () {
        return this.getStyle('link.handler.outline.width');
    },
    getOutlineColor: function () {
        return this.getStyle('link.handler.outline.color');
    },
    getCap: function () {
        return this.getStyle('link.handler.cap');
    },
    getJoin: function () {
        return this.getStyle('link.handler.join');
    },
    getAlpha: function () {
        return this.getStyle('link.handler.alpha');
    },
    isShadowable: function () {
        return this.getStyle('link.handler.shadowable');
    }
});

//need to test
twaver.vector.IconsAttachment = function(elementUI, showInAttachmentDiv) {
    twaver.vector.IconsAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.IconsAttachment', twaver.vector.Attachment, {
    isShadowable : function() {
        return twaver.Defaults.ATTACHMENT_SHADOWABLE;
    },
    validate : function() {
        twaver.vector.IconsAttachment.superClass.validate.call(this);
        this.iconsNames = this._network.getIconsNames(this._element);
        if (!this.iconsNames || this.iconsNames.length == 0) {
            return;
        }
        var iconsGroups = this._makeGroup(this.iconsNames);
        var colorGroups = this._makeGroup(this._network.getIconsColors(this._element));
        var zm = this._network.zoomManager;
        len = iconsGroups.length;
        this.iconsOrientation = this._makeArray(this._element.getStyle('icons.orientation'), len,'right');
        this.iconsPosition = this._makeArray(this._element.getStyle('icons.position'), len,'topleft.bottomright');
        this.iconsXoffset = this._makeArray(this._element.getStyle('icons.xoffset'), len,0);
        this.iconsYoffset = this._makeArray(this._element.getStyle('icons.yoffset'), len,0);
        this.iconsXgap = this._makeArray(this._element.getStyle('icons.xgap'), len,1);
        this.iconsYgap = this._makeArray(this._element.getStyle('icons.ygap'), len,1);

        this.locations = [], this.iconsSizes = [];this.iconsOrientations = [];
        var iconsSize, location , iconsOrientation;
        for ( i = 0; i < len; i++) {
            var iconsNames = iconsGroups[i];
            var iconsOrientation = this.iconsOrientation[i] || "right";
            var iconsPosition = this.iconsPosition[i] || 'topleft.bottomright';
            var iconsXgap = this.iconsXgap[i] || 1;
            var iconsYgap = this.iconsYgap[i] || 1;
            var iconsXoffset = this.iconsXoffset[i] || 0;
            var iconsYoffset = this.iconsYoffset[i] || 0;

            if(this._ui._element instanceof twaver.Link){
                var points = this._ui.getLinkPoints();
                var lineLength;
                if (this._ui.getLineLength) {
                    lineLength = this._ui.getLineLength();
                } else {
                    lineLength = this._ui._element.getLineLength();
                }
                
                if (Math.abs(iconsXoffset) > 0 && Math.abs(iconsXoffset) < 1) {
                    if(iconsPosition === 'from'){
                        iconsXoffset *= lineLength;
                    }else if(iconsPosition === 'to'){
                        iconsXoffset = lineLength * (1 - iconsXoffset);
                    }else{
                        iconsXoffset /= 2;
                        iconsXoffset += 0.5;
                        iconsXoffset *= lineLength;
                    }
                }else{
                    if(iconsPosition === 'from'){
                        iconsXoffset = iconsXoffset;
                    }else if(iconsPosition === 'to'){
                        iconsXoffset = lineLength - iconsXoffset;
                    }else{
                        iconsXoffset += lineLength/2;
                    }
                }

                var pointInfo = $math.calculatePointInfoAlongLine(points, true, iconsXoffset, iconsYoffset);
                var translatePoint = pointInfo.point;
                var rotateAngle = pointInfo.angle;

                var c;
                if(iconsPosition === 'from'){
                    c = this._ui.getFromPoint();
                }else if(iconsPosition === 'to'){
                    c = this._ui.getToPoint();
                }else{
                    c = this._ui._hotSpot;
                }

                iconsXoffset = translatePoint.x - c.x;
                iconsYoffset = translatePoint.y - c.y;
            }
            
            location = null;
            iconsSize = this._getIconsSize(iconsNames, iconsOrientation, iconsXgap, iconsYgap, zm);
            if (iconsSize) {
                location = this._network.getPosition(iconsPosition, this._ui, iconsSize, iconsXoffset, iconsYoffset);
                this._iconLocation = location;
                if (iconsOrientation === 'top') {
                    location.y += iconsSize.height;
                } else if (iconsOrientation === 'left') {
                    location.x += iconsSize.width;
                }
            }

            this.locations.push(location);
            this.iconsSizes.push(iconsSize);
            this.iconsOrientations.push(iconsOrientation);
        }
        var unionRect = null;
        for ( i = 0; i < this.locations.length; i++) {
            location = this.locations[i];
            iconsSize = this.iconsSizes[i];
            iconsOrientation = this.iconsOrientations[i];

            if(location == null){
                continue;
            }
            if (unionRect == null) {
                if (iconsOrientation === 'top') {
                    unionRect = {
                        x : location.x, 
                        y : location.y - iconsSize.height,
                        width : iconsSize.width,
                        height : iconsSize.height
                    };
                } else if (iconsOrientation === 'left') {
                    unionRect = {
                        x : location.x - iconsSize.width, 
                        y : location.y,
                        width : iconsSize.width,
                        height : iconsSize.height
                    };
                }else{
                    unionRect = {
                        x : location.x , 
                        y : location.y,
                        width : iconsSize.width,
                        height : iconsSize.height
                    };
                }
            } else {
                if (iconsOrientation === 'top') {
                    unionRect = $math.unionRect(unionRect, {
                        x : location.x, 
                        y : location.y - iconsSize.height,
                        width : iconsSize.width,
                        height : iconsSize.height
                    });
                } else if (iconsOrientation === 'left') {
                    unionRect = $math.unionRect(unionRect, {
                        x : location.x - iconsSize.width, 
                        y : location.y,
                        width : iconsSize.width,
                        height : iconsSize.height
                    });
                }else{
                    unionRect = $math.unionRect(unionRect, {
                        x : location.x,
                        y : location.y,
                        width : iconsSize.width,
                        height : iconsSize.height
                    });
                }
            }
        }
        if(zm) {
           this._viewRect = unionRect || this.getElementUI().getViewRect();
       }else{
        this._viewRect = unionRect || { x : this._element.getLocation().x,y : this._element.getLocation().y,width : 0,height : 0};
    }
    this.iconsGroups = iconsGroups;
    this.colorGroups = colorGroups;
    var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.icons.rotatable');
    for ( i = 0; i < len; i++) {
        if (rotatable instanceof Array && rotatable[i] && this._viewRect) {
            var cx = this._viewRect.x + this._viewRect.width / 2,
            cy = this._viewRect.y + this._viewRect.height / 2;
            var w = Math.sqrt(this._viewRect.height * this._viewRect.height + this._viewRect.width * this._viewRect.width);
            this._viewRect = {
                x: cx - w/2,
                y: cy - w/2,
                width: w ,
                height: w
            }
        }
    }
},

_makeGroup : function(originalArray) {
    if (!Array.isArray(originalArray)) {
        return [[originalArray]];
    }
    var groups = [], group = false, i, len = originalArray.length, item, temp;
    for ( i = 0; i < len; i++) {
        item = originalArray[i];
        if (!Array.isArray(item)) {
            temp = [item];
            groups.push(temp);
        } else {
            group = true;
            groups.push(item);
        }
    }
    if (!group) {
        groups.length = 0;
        groups.push(originalArray);
    }
    return groups;
},

_makeArray : function(value, len, defaultValue) {
    if (Array.isArray(value)) {
        return value;
    } else {
        var array = [];
        for (var i = 0; i < len; i++) {
            array.push(value || defaultValue);
        }
        return array;
    }
},
paint : function(ctx) {
    twaver.vector.IconsAttachment.superClass.paint.apply(this, arguments);

    if (!this.iconsNames || this.iconsNames.length == 0 || !this.locations) {
        return;
    }
    var zoomManager = this._network.zoomManager;
    var i,location,index,iconsNames,x,y,iconsColors,iconsOrientation,iconsXgap,iconsYgap;
    for (i = 0; i < this.iconsGroups.length; i++) {
        location = this.locations[i];
        if(!location){
            continue;
        }
        x = location.x;
        y = location.y;
        iconsNames = this.iconsGroups[i];
        iconsColors = this.colorGroups[i];
        iconsOrientation = this.iconsOrientation[i];
        iconsXgap = this.iconsXgap[i] || 1;
        iconsYgap = this.iconsYgap[i] || 1;
        index = 0;
        for (var name in iconsNames) {
            var rect = null;
            var color = null;
            if (iconsColors && iconsColors.length > index) {
                color = iconsColors[index++];
            }
            var imageAsset = _twaver.getImageAsset(iconsNames[name]);
            if (imageAsset == null) {
                continue;
            }
            if(zoomManager && this._ui instanceof twaver.vector.GroupUI && this._ui._shapeRect){
                var attachmentSizeZoom = zoomManager.getAttachmentSizeZoom(this);
                var width = imageAsset.getWidth() * attachmentSizeZoom;
                var height = imageAsset.getHeight() * attachmentSizeZoom;
                if (iconsOrientation === 'right') {
                    rect = {
                        x : x,
                        y : y,
                        width : width,
                        height : height
                    };
                    x += rect.width + iconsXgap;
                } else if (iconsOrientation === 'left') {
                    rect = {
                        x : x - width,
                        y : y,
                        width : width,
                        height : height
                    };
                    x -= rect.width + iconsXgap;
                } else if (iconsOrientation === 'top') {
                    rect = {
                        x : x,
                        y : y - height,
                        width : width,
                        height : height
                    };
                    y -= rect.height + iconsYgap;
                } else if (iconsOrientation === 'bottom') {
                    rect = {
                        x : x,
                        y : y,
                        width : width,
                        height : height
                    };
                    y += rect.height + iconsYgap;
                } else {
                    throw "Can not resolve '" + iconsOrientation + "' orientation";
                }                    
            }else{
                if (iconsOrientation === 'right') {
                    rect = {
                        x : x,
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    x += rect.width + iconsXgap;
                } else if (iconsOrientation === 'left') {
                    rect = {
                        x : x - imageAsset.getWidth(),
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    x -= rect.width + iconsXgap;
                } else if (iconsOrientation === 'top') {
                    rect = {
                        x : x,
                        y : y - imageAsset.getHeight(),
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    y -= rect.height + iconsYgap;
                } else if (iconsOrientation === 'bottom') {
                    rect = {
                        x : x,
                        y : y,
                        width : imageAsset.getWidth(),
                        height : imageAsset.getHeight()
                    };
                    y += rect.height + iconsYgap;
                } else {
                    throw "Can not resolve '" + iconsOrientation + "' orientation";
                }
                rect = zoomManager._getAttachmentZoomOutLineRect(this, rect);
            }

            var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.icons.rotatable');
            if(rotatable instanceof Array && rotatable[i]) {
                ctx.save();
                // var _vewRect = this.getZoomViewRect();
                var _vewRect = rect;
                var x = _vewRect.x + _vewRect.width / 2,
                y = _vewRect.y + _vewRect.height / 2;
                ctx.translate(x, y);
                ctx.rotate(this._network.getElementUI(this._element).getAbsoluteAngle());
                ctx.translate(-x, -y);
                drawImage(ctx, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
                ctx.restore();
            }else{
                drawImage(ctx, imageAsset.getImage(color, rect.width, rect.height), color, rect, this._element, this._network);
            }
            if(this._network._debug) {
                var rect = this._viewRect;
                $g.strokeRect(ctx, rect, '#FCFC00',1);
                $g.strokeRect(ctx, rect, '#FCFC00',1);
            }
        }
    }

},
_getIconsSize : function(names, orientation, xgap, ygap, zm) {
    var x = 0;
    var y = 0;
    var rect = null;
    var imageAsset = null;
    var unionRect = null;
    for (var name in names) {
        imageAsset = _twaver.getImageAsset(names[name]);
        if (!imageAsset) {
            continue;
        }
        if (orientation === 'right') {
            rect = {
                x : x,
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            x += rect.width + xgap;
        } else if (orientation === 'left') {
            rect = {
                x : x - imageAsset.getWidth(),
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            x -= rect.width + xgap;
        } else if (orientation === 'top') {
            rect = {
                x : x,
                y : y - imageAsset.getHeight(),
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            y -= rect.height + ygap;
        } else if (orientation === 'bottom') {
            rect = {
                x : x,
                y : y,
                width : imageAsset.getWidth(),
                height : imageAsset.getHeight()
            };
            y += rect.height + ygap;
        } else {
            throw "Can not resolve '" + orientation + "' orientation";
        }
        if (unionRect == null) {
            unionRect = _twaver.clone(rect);
        } else {
            unionRect = $math.unionRect(unionRect, rect);
        }
    }
    if (unionRect) {
        if(zm && this._ui instanceof twaver.vector.GroupUI && this._ui._shapeRect){
            return {
                width : Math.abs(unionRect.width) * zm.getAttachmentSizeZoom(this),
                height : Math.abs(unionRect.height) * zm.getAttachmentSizeZoom(this)
            };
        }
        return {
            width : Math.abs(unionRect.width),
            height : Math.abs(unionRect.height)
        };
    }
    return null;
}
});

twaver.vector.EditAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.vector.EditAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
};
_twaver.ext('twaver.vector.EditAttachment', twaver.vector.Attachment, {
    paint: function (ctx) {
        twaver.vector.EditAttachment.superClass.paint.apply(this, arguments);
        this.paintResizingPoints(ctx);
        this.paintEditPoints(ctx);
        this.paintRotatePoints(ctx);
    },
    paintResizingPoints: function (ctx) {
        var size = this.resizingPoints.size();
        if (size <= 0) {
            return;
        }
        var zoom = this._element.getStyle('edit.physicalZoom') ? 1 : this._network.getGraphicsZoom();
        var resizePointSize = this.resizePointSize / zoom;
        var width = resizePointSize * 2;
        var height = resizePointSize * 2;
        var fillColor = this._network.getResizePointFillColor();
        var outlineWidth = this._network.getResizePointOutlineWidth() / zoom;
        var outlineColor = this._network.getResizePointOutlineColor();
        var angle = this._element.getAngle();
        var zoomManager = this._network.zoomManager;
        var rect = zoomManager._getElementZoomRect(this.getElementUI(), this._element.getOriginalRect());
        ctx.lineWidth = outlineWidth;
        // var zoomPoints = zoomManager._getEditZoomPoints(this.getElementUI(),this.resizingPoints);
        var zoomPoints = this.resizingPoints;

        for (var i = 0; i < size; i++) {
            var point = zoomPoints.get(i);
            var resizeRect = {
                x: point.x - resizePointSize,
                y: point.y - resizePointSize,
                width: resizePointSize * 2,
                height: resizePointSize * 2
            };
            var rotatedRect = this._getRotateRect(resizeRect, angle, {
                x: rect.x + rect.width / 2,
                y: rect.y + rect.height / 2
            });
            ctx.save();
            twaver.Util.rotateCanvas(ctx, rotatedRect, angle);
            $CanvasUtil.rect(ctx, rotatedRect.x, rotatedRect.y, width, height);
            ctx.restore();
        }
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = outlineColor;
        ctx.fill();
        ctx.stroke();

        if (this._network._debug) {
            var r = this.getViewRect('resize');
            $g.strokeRect(ctx, r, '#CCDDCC');
            var r = zoomManager._getElementZoomRect(this.getElementUI(), this.getElementUI()._viewRect);
            $g.strokeRect(ctx, r, '#FD7766');
        }
    },
    paintEditPoints: function (ctx) {
        var size = this.editPoints.size();
        if (size <= 0) {
            return;
        }
        var zoom = this._element.getStyle('edit.physicalZoom') ? 1 : this._network.getGraphicsZoom();
        var outlineColor = this._network.getEditPointOutlineColor();
        var fillColor = this._network.getEditPointFillColor();
        var outlineWidth = this._network.getEditPointOutlineWidth() / zoom;
        ctx.beginPath();
        ctx.lineWidth = outlineWidth;
        // var zoomPoints = this._network.zoomManager._getEditZoomPoints(this.getElementUI(),this.editPoints);
        var zoomPoints = this.editPoints;
        for (var i = 0; i < size; i++) {
            var p = zoomPoints.get(i);
            ctx.beginPath();
            $CanvasUtil.circle(ctx, p.x, p.y, this.editPointSize, fillColor, outlineColor);
            ctx.closePath();
        }

        if (this._network._debug) {
            var r = this.getViewRect('edit');
            $g.strokeRect(ctx, r, '#AAABBC');
        }
    },
    paintRotatePoints: function (ctx) {
        var size = this.rotatePoints.size();
        if (size <= 0) {
            return;
        }
        var zoom = this._element.getStyle('edit.physicalZoom') ? 1 : this._network.getGraphicsZoom();
        var outlineColor = this._network.getRotatePointOutlineColor();
        var fillColor = this._network.getRotatePointFillColor();
        var outlineWidth = this._network.getRotatePointOutlineWidth() / zoom;
        ctx.beginPath();
        ctx.lineWidth = outlineWidth;
        // var zoomPoints = this._network.zoomManager._getEditZoomPoints(this.getElementUI(),this.rotatePoints);
        var zoomPoints = this.rotatePoints;
        for (var i = 0; i < size; i++) {
            var p = zoomPoints.get(i);
            ctx.beginPath();
            $CanvasUtil.circle(ctx, p.x, p.y, this.rotatePointSize /zoom, fillColor, outlineColor);
            ctx.closePath();
            ctx.beginPath();
        }

        if (this._network._debug) {
            var r = this.getViewRect('rotate');
            $g.strokeRect(ctx, r, 'green');
        }
    },
    getViewRect: function (type) {
        if (type) {
            if (type === 'resize') {
                return this._resizeRect;
            } else if (type === 'rotate') {
                return this._rotateRect;
            } else if (type === 'edit') {
                return this._editRect;
            }
        }
        return this._viewRect || {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            };
    },
    validate: function () {
        twaver.vector.EditAttachment.superClass.validate.call(this);

        var zoom = this._network.getGraphicsZoom();
        this.editPointSize = this._network.getEditPointSize();
        this.resizePointSize = this._network.getResizePointSize();
        this.rotatePointSize = this._network.getRotatePointSize();

        this.resizingPoints = new twaver.List();
        this.editPoints = new twaver.List();
        this.rotatePoints = new twaver.List();

        if (this._element instanceof twaver.Node) {
            this._addResizingPoint(this._element);
        }
        if (this._network.isRotatable(this._element) && this._element instanceof $Node && !(this._element instanceof twaver.ShapeNode) && !(this._element instanceof twaver.Grid) && !(this._element instanceof twaver.Group)) {
            this._addRotatePoint(this._element);
        }
        if (this._element instanceof twaver.ShapeNode) {
            this._addResizingPoint(this._element);
            this._addShapeNodePoint(this._element);
        }
        if (this._ui instanceof twaver.vector.ShapeLinkUI) {
            this._addShapeLinkPoints(this._element);
        }
        if (this._ui instanceof twaver.vector.LinkUI) {
            this._addLinkControlPoint(this._ui);
        }
        //resize
        // var outlineWidth = this._network.getEditPointOutlineWidth();
        var outlineWidth = this._network.getResizePointOutlineWidth()/zoom;
        // var unionRect = $math.getRect(this.resizingPoints);
        var unionRect = this.getElementUI().getZoomBodyRect();
        var times = 2 * Math.sqrt(2);
        this._resizeOffset = (this.resizePointSize + outlineWidth + 1) * times;
        $math.grow(unionRect, this._resizeOffset, this._resizeOffset);
        this._resizeRect = unionRect;

        //edit
        outlineWidth = this._network.getEditPointOutlineWidth() / zoom;
        if (this.editPoints.size() > 0) {
            var editRect = $math.getRect(this.editPoints);
            $math.grow(editRect, this.editPointSize * 2 + outlineWidth * 2);
            unionRect = $math.unionRect(unionRect, editRect);
        }
        this._editRect = editRect;

        outlineWidth = this._network.getRotatePointOutlineWidth() / zoom;
        var rotatePointSize = this.rotatePointSize;
        if (this.rotatePoints.size() > 0) {
            var point = this.rotatePoints.get(0);

            var rect = {
                x: point.x - rotatePointSize - outlineWidth - 1,
                y: point.y - rotatePointSize - outlineWidth - 1,
                width: rotatePointSize * 2 + outlineWidth * 2 + 2,
                height: rotatePointSize * 2 + outlineWidth * 2 + 2,
            };
            unionRect = $math.unionRect(unionRect, rect);
            this._rotateRect = rect;
        }

        this._viewRect = unionRect;
    },
    _addResizingPoint: function (node) {
        // var rect = node.getOriginalRect();
        var rect = this._network.zoomManager._getElementZoomRect(this.getElementUI(), node.getOriginalRect());
        if (!rect) {
            return;
        }
        var size = this._network.getResizePointSize();
        if (size <= 0) {
            return;
        }
        var points = new $List([
            {x: rect.x, y: rect.y},
            {x: rect.x + rect.width / 2, y: rect.y},
            {x: rect.x + rect.width, y: rect.y},

            {x: rect.x, y: rect.y + rect.height / 2},
            {x: rect.x + rect.width, y: rect.y + rect.height / 2},

            {x: rect.x, y: rect.y + rect.height},
            {x: rect.x + rect.width / 2, y: rect.y + rect.height},
            {x: rect.x + rect.width, y: rect.y + rect.height}
        ]);
        var outlineWidth = this._network.getResizePointOutlineWidth();
        var outlineColor = this._network.getResizePointOutlineColor();
        var fillColor = this._network.getResizePointFillColor();

        this._addPoints(node.getRect(), points, outlineWidth, outlineColor, fillColor, true);
    },
    _addRotatePoint: function (node) {
        var rect = this._network.zoomManager._getElementZoomRect(this.getElementUI(), node.getOriginalRect());
        // var rect = this._ui.getZoomBodyRect();
        if (!rect) {
            return;
        }
        var size = this._network.getRotatePointSize() / this._network.getGraphicsZoom();
        if (size <= 0) {
            return;
        }
        var width = size * 2;
        var points = new twaver.List([{
            x: rect.x + rect.width / 2,
            y: rect.y - this._network.getRotatePointOffset()/ this._network.getGraphicsZoom() - size
        }]);
        var angle = node.getAngle();
        if (angle != 0) {
            // points = this._rotatePointList(points,angle,node.getOriginalRect());
            points = this._rotatePointList(points, angle, rect);
        }
        var rotatedPoint = points.get(0);
        var rotatedRect = {x: rotatedPoint.x - width / 2, y: rotatedPoint.y - width / 2, width: width, height: width};
        var outlineWidth = this._network.getRotatePointOutlineWidth();
        var offset = this.rotatePointSize + outlineWidth;
        $math.grow(rect, offset, offset);
        var unionRect = $math.unionRect(node.getRect(), rotatedRect);
        // this._viewRect = $math.unionRect(unionRect, this._viewRect);
        this.rotatePoints = points;
    },
    _addShapeNodePoint: function (shapeNode) {
        var points = this._network.zoomManager._getShapeNodeZoomPoints(this.getElementUI(), shapeNode.getPoints());
        // this._addEditPoints(shapeNode.getPoints());
        this._addEditPoints(points);
    },
    _addShapeLinkPoints: function (shapeLink) {
        var points = this._network.zoomManager._getShapeLinkZoomPoints(shapeLink.getPoints());
        // this._addEditPoints(shapeLink.getPoints());
        this._addEditPoints(points);
    },
    _addLinkControlPoint: function (linkUI) {
        var points = new twaver.List();
        var fromAgent = linkUI._element.getFromAgent();
        var fromNode;
        if (fromAgent) {
            fromNode = linkUI._element.getFromAgent();
        } else {
            fromNode = linkUI._element.getFromNode();
        }
        var fromXoffset = linkUI._element.getStyle("link.from.xoffset");
        var fromYoffset = linkUI._element.getStyle("link.from.yoffset");
        var fromNodeUI = this._network.getElementUI(fromNode);
        var fromNodeBounds = fromNodeUI.getZoomBodyRect();
        var fromCenterPoint = {
            x:fromNodeBounds.x + fromNodeBounds.width/2,
            y:fromNodeBounds.y + fromNodeBounds.height/2,
        };
        var fromPoint = {
            x: fromCenterPoint.x + fromXoffset,
            y: fromCenterPoint.y + fromYoffset
        }
        points.add(fromPoint);
        var toAgent = linkUI._element.getToAgent();
        var toNode;
        if (toAgent) {
            toNode = linkUI._element.getToAgent();
        } else {
            toNode = linkUI._element.getToNode();
        }
        var toXoffset = linkUI._element.getStyle("link.to.xoffset");
        var toYoffset = linkUI._element.getStyle("link.to.yoffset");
        var toNodeUI = this._network.getElementUI(toNode);
        var toNodeBounds = toNodeUI.getZoomBodyRect();
        var toCenterPoint = {
            x:toNodeBounds.x + toNodeBounds.width/2,
            y:toNodeBounds.y + toNodeBounds.height/2,
        };
        var toPoint = {
            x: toCenterPoint.x + toXoffset,
            y: toCenterPoint.y + toYoffset
        }
        points.add(toPoint);
        if ($link.isOrthogonalLink(linkUI._element) && linkUI.getControlPoint()) {
            var controlPoint = linkUI.getControlPoint();
            if (controlPoint) {
                points.add(controlPoint);
            }
        }
        var editPointSize = this.editPoints.size();
        if (editPointSize > 0) {
            for (var i = 0; i < editPointSize; i++) {
                points.add(this.editPoints.get(i));
            }
        }
        this._addEditPoints(points);
    },
    _addEditPoints: function (points) {
        var rect = $math.getRect(points);
        if (!rect) {
            return;
        }
        var size = this._network.getEditPointSize();
        if (size <= 0) {
            return;
        }
        var outlineWidth = this._network.getEditPointOutlineWidth();
        this._addPoints(rect, points, outlineWidth, false);
    },
    _addPoints: function (rect, points, outlineWidth, outlineColor, fillColor, isResizePoints) {
        var size = isResizePoints ? this._network.getResizePointSize() : this._network.getEditPointSize();
        if (size < 0) {
            return;
        }
        var offset = size + outlineWidth;
        $math.grow(rect, offset, offset);
        // this._viewRect = $math.unionRect(rect, this._viewRect);

        if (isResizePoints == true) {
            this.resizingPoints = points;
        } else {
            this.editPoints = points;
        }
    },
    _rotatePoint: function (point, angle, rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _rotatePointList: function (list, angle, rect) {
        var self = this;
        var newList = new twaver.List();
        list.forEach(function (p) {
            newList.add(self._rotatePoint(p, angle, rect));
        });
        return newList;
    },
    _getRotateRect: function (rect, angle, center) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, center.x, center.y);
        var centerPoint = {x: rect.x + rect.width / 2, y: rect.y + rect.height / 2};
        var point = matrix.transform(centerPoint);
        var points = new twaver.List([
            {x: point.x - rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y - rect.height / 2},
            {x: point.x + rect.width / 2, y: point.y + rect.height / 2},
            {x: point.x - rect.width / 2, y: point.y + rect.height / 2}
        ]);
        return $math.getRect(points);
    }
});
twaver.vector.HTMLLabelAttachment = function (elementUI, showInAttachmentDiv) {
    twaver.vector.HTMLLabelAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._triangleDiv = twaver.Util.createDiv();
    this._roundDiv = twaver.Util.createDiv();
    this._contentDiv = twaver.Util.createDiv();

    var self = this;
    this._network.getView().appendChild(this._roundDiv);
    this._roundDiv.appendChild(this._contentDiv);
};

_twaver.ext('twaver.vector.HTMLLabelAttachment', twaver.vector.LabelAttachment, {
    validate: function () {
        var zIndex = this._element.getStyle('attachment.zIndex');
        this.validateZIndex(zIndex);
        // var hyperlink = this._element.getStyle('attachment.htmllabel.hyperlink');
        // if (hyperlink) {
        //     twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', 'auto');
        //     twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', 'auto');
        // } else {
        //     twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', 'none');
        //     twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', 'none');
        // }
        var peFlag = this._element.getStyle('attachment.pointer.events');
        twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', peFlag);
        twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', peFlag);
        twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
        twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");

        var font = this.getFont('label.font');
        var text = this.getLabel();
        if (text !== this.text) {
            if (this.text) {
                if (typeof this.text == 'object') {
                    if (window.jquery) {
                        window.jquery(this.text).remove();
                    } else {
                        this._contentDiv.removeChild(this.text);
                    }
                } else {
                    this._contentDiv.innerHTML = '';
                }
            }
            if (text) {
                if (typeof text == 'object') {
                    if (window.jquery) {
                        window.jquery(this._contentDiv).append(text);
                    } else {
                        this._contentDiv.appendChild(text);
                    }
                } else {
                    this._contentDiv.innerHTML = text;
                }
            }
            this.text = text;
        }
        this._contentDiv.style.visibility = 'hidden';
        twaver.vector.HTMLLabelAttachment.superClass.validate.call(this);
    },
    validateZIndex: function (layerIndex) {
        this._roundDiv.style.zIndex = layerIndex  + this._network.getElementBox().getDatas().indexOf(this._element);
    },
    getContentWidth: function () {
        return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
    },
    getContentHeight: function () {
        return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
    },
    paint: function (ctx) {
        var fill = this.isFill();
        var outlineWidth = this.getOutlineWidth();
        var rect = this._contentRect;
        this.getElementUI().setGlow(this, ctx);
        this.getElementUI().setShadow(this, ctx);

        if (outlineWidth > 0 || fill) {
            $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
            if (this._pointers) {
                var pointers = this._ui.getZoomPointers(this, this._pointers);
                ctx.moveTo(pointers[0].x, pointers[0].y);
                ctx.lineTo(pointers[1].x, pointers[1].y);
                ctx.lineTo(pointers[2].x, pointers[2].y);
            }
            ctx.closePath();

            if (outlineWidth > 0) {
                ctx.lineWidth = outlineWidth;
                ctx.strokeStyle = this.getOutlineColor();
                ctx.lineCap = this.getCap();
                ctx.lineJoin = this.getJoin();
                ctx.stroke();
            }
            if (fill) {
                var fillColor = this.getFillColor();
                var gradient = this.getGradient();
                if (gradient) {
                    $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
                } else {
                    ctx.fillStyle = fillColor;
                }
                ctx.fill();
            }
        }

        var font = this.getFont('label.font');
        var text = this.getLabel();
        var cx = this._network.getViewRect().x;
        var cy = this._network.getViewRect().y;
        var zoom = this._network.getZoom();
        var cl = {
            x: this._contentRect.x + this._contentRect.width / 2,
            y: this._contentRect.y + this._contentRect.height / 2
        };
        var left = (cl.x * zoom - cx) - this._contentDiv.offsetWidth / 2 * zoom + 'px';
        var top = (cl.y * zoom - cy) - this._contentDiv.offsetHeight / 2 * zoom + 'px';

        this._contentDiv.style.left = left;
        this._contentDiv.style.top = top;
        //   this._contentDiv.style.setProperty("-webkit-transform", "scale(" + zoom + ")", null);
        // this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null);
        if ($ua.isFirefox) {
            twaver.Util.setCSSStyle(this._contentDiv, "-moz-transform", "scale(" + zoom + ")");
            twaver.Util.setCSSStyle(this._contentDiv, "-moz-transform-origin", "0 0");
        } else if ($ua.isOpera) {
            twaver.Util.setCSSStyle(this._contentDiv, "-o-transform", "scale(" + zoom + ")");
            twaver.Util.setCSSStyle(this._contentDiv, "-o-transform-origin", "0 0");
        } else if ($ua.isChrome || $ua.isSafari) {
            twaver.Util.setCSSStyle(this._contentDiv, "-webkit-transform", "scale(" + zoom + ")");
            twaver.Util.setCSSStyle(this._contentDiv, "-webkit-transform-origin", "0 0");
        } else if ($ua.isIE) {
            twaver.Util.setCSSStyle(this._contentDiv, "-ms-transform", "scale(" + zoom + ")");
            twaver.Util.setCSSStyle(this._contentDiv, "-ms-transform-origin", "0 0");
        } else {
            twaver.Util.setCSSStyle(this._contentDiv, "transform", "scale(" + zoom + ")");
            twaver.Util.setCSSStyle(this._contentDiv, "transform-origin", "0 0");
        }

        if (this._network._debug) {
            $g.strokeRect(ctx, this._contentRect, 'blue');
            $g.strokeRect(ctx, this._roundRect, 'red');
            $g.strokeRect(ctx, this._viewRect, 'green');
        }
        var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label.rotatable');
        if (rotatable) {
            var _viewRect = this.getZoomViewRect();
            var x = _viewRect.x + _viewRect.width / 2,
                y = _viewRect.y + _viewRect.height / 2;

            var angle = this._network.getElementUI(this._element).getAbsoluteAngle() * 180 / Math.PI;
            var tx = this._contentDiv.offsetWidth / 2 * zoom;
            var ty = this._contentDiv.offsetHeight / 2 * zoom;

            if ($ua.isFirefox) {
                twaver.Util.setCSSStyle(this._contentDiv, "-moz-transform", "translate(0px,0px) rotate(" + angle + "deg) scale(" + zoom + ")");
            } else if ($ua.isOpera) {
                twaver.Util.setCSSStyle(this._contentDiv, "-o-transform", "translate(0px,0px) rotate(" + angle + "deg) scale(" + zoom + ")");
            } else if ($ua.isChrome || $ua.isSafari) {
                twaver.Util.setCSSStyle(this._contentDiv, "-webkit-transform", "translate(0px, 0px) rotate(" + angle + "deg) scale(" + zoom + ")");
            } else if ($ua.isIE) {
                twaver.Util.setCSSStyle(this._contentDiv, "-ms-transform", "translate(0px,0px) rotate(" + angle + "deg) scale(" + zoom + ")");
            } else {
                twaver.Util.setCSSStyle(this._contentDiv, "transform", "translate(0px,0px) rotate(" + angle + "deg) scale(" + zoom + ")");
            }
        }
    },
    setVisibility: function (visibility) {
        this._contentDiv.style.visibility = visibility;
    },
    dispose: function () {
        this._network.getView().removeChild(this._roundDiv);
    },
    getView: function () {
        return this._roundDiv;
    },
});
  twaver.vector.HTMLLabel2Attachment = function(elementUI, showInAttachmentDiv) {
    twaver.vector.HTMLLabel2Attachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
    this._triangleDiv = twaver.Util.createDiv();
    this._roundDiv = twaver.Util.createDiv();
    this._contentDiv = twaver.Util.createDiv();
    var self = this;
    this._network.getView().appendChild(this._roundDiv);
    this._roundDiv.appendChild(this._contentDiv);
  };

  _twaver.ext('twaver.vector.HTMLLabel2Attachment', twaver.vector.LabelAttachment, {
    validate: function () {
      var zIndex = this._element.getStyle('attachment.zIndex');
      this.validateZIndex(zIndex);      
      // var hyperlink = this._element.getStyle('attachment.htmllabel2.hyperlink');
      // if(hyperlink){
      //   twaver.Util.setCSSStyle(this._triangleDiv,'pointer-events','auto');
      //   twaver.Util.setCSSStyle(this._contentDiv,'pointer-events','auto');
      // }else{
      //   twaver.Util.setCSSStyle(this._triangleDiv,'pointer-events','none');
      //   twaver.Util.setCSSStyle(this._contentDiv,'pointer-events','none');
      // }
      var peFlag = this._element.getStyle('attachment.pointer.events');
      twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', peFlag);
      twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', peFlag);
      twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
      twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");
      var font = this.getFont('label2.font');
      var text = this.getLabel();
      if (text !== this.text) {
        if (this.text) {
          if (typeof this.text == 'object') {
            if (window.jquery) {
              window.jquery(this.text).remove();
            } else {
              this._contentDiv.removeChild(this.text);
            }
          } else {
            this._contentDiv.innerHTML = '';
          }
        }
        if (text) {

          if (typeof text == 'object') {
            if (window.jquery) {
              window.jquery(this._contentDiv).append(text);
            } else {
              this._contentDiv.appendChild(text);
            }
          } else {
            this._contentDiv.innerHTML = text;
          }
        }
        this.text = text;
      }
      this._contentDiv.style.visibility = 'hidden';
      twaver.vector.HTMLLabelAttachment.superClass.validate.call(this);
    },
    validateZIndex: function(layerIndex){
      this._roundDiv.style.zIndex = layerIndex + this._network.getElementBox().getDatas().indexOf(this._element);
    }, 
    getContentWidth: function () {
      return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
    },
    getContentHeight: function () {
      return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
    },
    paint: function (ctx) {
      var fill = this.isFill();
      var outlineWidth = this.getOutlineWidth();
      var rect = this._contentRect;
      this.getElementUI().setGlow(this, ctx);
      this.getElementUI().setShadow(this, ctx);

      if (outlineWidth > 0 || fill) {
       $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
       if (this._pointers) {
         var pointers = this._ui.getZoomPointers(this,this._pointers);
         ctx.moveTo(pointers[0].x, pointers[0].y);
         ctx.lineTo(pointers[1].x, pointers[1].y);
         ctx.lineTo(pointers[2].x, pointers[2].y);
       }
       ctx.closePath();

       if (outlineWidth > 0) {
        ctx.lineWidth = outlineWidth;
        ctx.strokeStyle = this.getOutlineColor();
        ctx.lineCap = this.getCap();
        ctx.lineJoin = this.getJoin();
        ctx.stroke();
      }
      if (fill) {
        var fillColor = this.getFillColor();
        var gradient = this.getGradient();
        if (gradient) {
          $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
        } else {
          ctx.fillStyle = fillColor;
        }
        ctx.fill();
      }
    }

    var font = this.getFont('label2.font');
    var text = this.getLabel();
    var cx = this._network.getViewRect().x;
    var cy = this._network.getViewRect().y;
    var zoom = this._network.getZoom();
    var cl = {
      x: this._contentRect.x + this._contentRect.width / 2,
      y: this._contentRect.y + this._contentRect.height / 2
    };
    var left = (cl.x * zoom - cx) - this._contentDiv.offsetWidth / 2 * zoom + 'px';
    var top = (cl.y * zoom - cy) - this._contentDiv.offsetHeight / 2 * zoom + 'px';

    this._contentDiv.style.left =  left ;
    this._contentDiv.style.top =  top;
    this._contentDiv.style.setProperty("-webkit-transform", "scale("+ zoom +")", null);
    this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null);

    if(this._network._debug){
      $g.strokeRect(ctx, this._contentRect, 'blue');
      $g.strokeRect(ctx, this._roundRect, 'red');
      $g.strokeRect(ctx, this._viewRect, 'green');
    }

    var rotatable = this._element instanceof twaver.Link && this._element.getStyle('link.label2.rotatable');
    if (rotatable) {
      var _viewRect = this.getZoomViewRect();
      var x = _viewRect.x + _viewRect.width / 2,
      y = _viewRect.y + _viewRect.height / 2;

      var angle = this._network.getElementUI(this._element).getAbsoluteAngle() * 180 /Math.PI;
      var tx = this._contentDiv.offsetWidth/2 * zoom;
      var ty = this._contentDiv.offsetHeight/2 * zoom;

      if ($ua.isFirefox) {
        twaver.Util.setCSSStyle(this._contentDiv, "-moz-transform", "translate(0px,0px) rotate(" + angle + "deg) scale("+ zoom +")");
      } else if ($ua.isOpera) {
        twaver.Util.setCSSStyle(this._contentDiv, "-o-transform", "translate(0px,0px) rotate(" + angle + "deg) scale("+ zoom +")");
      } else if ($ua.isChrome || $ua.isSafari) {
        twaver.Util.setCSSStyle(this._contentDiv, "-webkit-transform", "translate(0px, 0px) rotate("+ angle + "deg) scale("+ zoom +")");
      } else if ($ua.isIE) {
        twaver.Util.setCSSStyle(this._contentDiv, "-ms-transform", "translate(0px,0px) rotate(" + angle + "deg) scale("+ zoom +")");
      } else {
        twaver.Util.setCSSStyle(this._contentDiv, "transform", "translate(0px,0px) rotate(" + angle + "deg) scale("+ zoom +")");
      }
    }
  },
  setVisibility: function(visibility){
    this._contentDiv.style.visibility = visibility;
  },
  dispose: function() {
    this._network.getView().removeChild(this._roundDiv);
  },
  getView: function () {
    return this._roundDiv;
  },
  getLabel : function() {
    return this._network.getLabel2(this._element);
  },
  getCornerRadius : function() {
    return this.getStyle('label2.corner.radius');
  },
  getPointerLength : function() {
    return this.getStyle('label2.pointer.length');
  },
  getPointerWidth : function() {
    return this.getStyle('label2.pointer.width');
  },
  getPosition : function() {
    return this.getStyle('label2.position');
  },
  getXOffset : function() {
    return this.getStyle('label2.xoffset');
  },
  getYOffset : function() {
    return this.getStyle('label2.yoffset');
  },
  getPadding : function() {
    return this.getStyle('label2.padding');
  },
  getPaddingLeft : function() {
    return this.getStyle('label2.padding.left');
  },
  getPaddingRight : function() {
    return this.getStyle('label2.padding.right');
  },
  getPaddingTop : function() {
    return this.getStyle('label2.padding.top');
  },
  getPaddingBottom : function() {
    return this.getStyle('label2.padding.bottom');
  },
  getDirection : function() {
    return this.getStyle('label2.direction');
  },
  isFill : function() {
    return this.getStyle('label2.fill');
  },
  getFillColor : function() {
    return this.getStyle('label2.fill.color');
  },
  getGradient : function() {
    return this.getStyle('label2.gradient');
  },
  getGradientColor : function() {
    return this.getStyle('label2.gradient.color');
  },
  getOutlineWidth : function() {
    return this.getStyle('label2.outline.width');
  },
  getOutlineColor : function() {
    return this.getStyle('label2.outline.color');
  },
  getCap : function() {
    return this.getStyle('label2.cap');
  },
  getJoin : function() {
    return this.getStyle('label2.join');
  },
  getAlpha : function() {
    return this.getStyle('label2.alpha');
  },
  isShadowable : function() {
    return this.getStyle('label2.shadowable');
  },
}); 
twaver.vector.HTMLAlarmAttachment = function (elementUI, showInAttachmentDiv) {
  twaver.vector.HTMLAlarmAttachment.superClass.constructor.call(this, elementUI, showInAttachmentDiv);
  this._triangleDiv = twaver.Util.createDiv();
  this._roundDiv = twaver.Util.createDiv();
  this._contentDiv = twaver.Util.createDiv();
  twaver.Util.setCSSStyle(this._triangleDiv, "border-style", "solid");
  twaver.Util.setCSSStyle(this._triangleDiv, 'pointer-events', 'none');
  twaver.Util.setCSSStyle(this._contentDiv, "white-space", "nowrap");
  twaver.Util.setCSSStyle(this._contentDiv, 'pointer-events', 'none');
  var self = this;
  this._network.getView().appendChild(this._roundDiv);
  this._roundDiv.appendChild(this._contentDiv);
};

_twaver.ext('twaver.vector.HTMLAlarmAttachment', twaver.vector.AlarmAttachment, {
  validate: function () {
    var font = this.getFont('alarm.font');
    var text = this._network.getAlarmLabel(this._element);
    this._contentDiv.innerHTML = text;
    this._contentDiv.style.visibility = 'hidden';
    twaver.vector.HTMLAlarmAttachment.superClass.validate.call(this);
  },
  getContentWidth: function () {
    return this._contentDiv.scrollWidth || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "width"));
  },
  getContentHeight: function () {
    return this._contentDiv.scrollHeight || parseInt(twaver.Util.getCSSStyle(this._contentDiv.firstChild, "height"));
  },
  paint: function (ctx) {
    var fill = this.isFill();
    var outlineWidth = this.getOutlineWidth();
    var rect = this._contentRect;
    this.getElementUI().setShadow(this, ctx);

    if (outlineWidth > 0 || fill) {
      $g.drawRoundRect(ctx, rect.x, rect.y, rect.width, rect.height, this.getCornerRadius());
      if (this._pointers) {
        var pointers = this._ui.getZoomPointers(this, this._pointers);
        ctx.moveTo(pointers[0].x, pointers[0].y);
        ctx.lineTo(pointers[1].x, pointers[1].y);
        ctx.lineTo(pointers[2].x, pointers[2].y);
      }
      ctx.closePath();

      if (outlineWidth > 0) {
        ctx.lineWidth = outlineWidth;
        ctx.strokeStyle = this.getOutlineColor();
        ctx.lineCap = this.getCap();
        ctx.lineJoin = this.getJoin();
        ctx.stroke();
      }
      if (fill) {
        var fillColor = this.getFillColor();
        var gradient = this.getGradient();
        if (gradient) {
          $g.fill(ctx, fillColor, gradient, this.getGradientColor(), this._viewRect);
        } else {
          ctx.fillStyle = fillColor;
        }
        ctx.fill();
      }
    }

    var font = this.getFont('alarm.font');
    var text = this._network.getAlarmLabel(this._element);
    var cx = this._network.getViewRect().x;
    var cy = this._network.getViewRect().y;
    var zoom = this._network.getZoom();
    var cl = {
      x: this._contentRect.x + this._contentRect.width / 2,
      y: this._contentRect.y + this._contentRect.height / 2
    };
    var left = (cl.x * zoom - cx) - this._contentDiv.offsetWidth / 2 * zoom + 'px';
    var top = (cl.y * zoom - cy) - this._contentDiv.offsetHeight / 2 * zoom + 'px';
    this._contentDiv.style.left = left;
    this._contentDiv.style.top = top;
    this._contentDiv.style.setProperty("-webkit-transform", "scale(" + zoom + ")", null);
    this._contentDiv.style.setProperty("-webkit-transform-origin", "0 0", null);

    if (this._network._debug) {
      $g.strokeRect(ctx, this._contentRect, '#DDDDDD');
    }

    twaver.vector.AlarmAttachment.superClass.paint.apply(this, arguments);
  },
  setVisibility: function (visibility) {
    this._contentDiv.style.visibility = visibility;
  },
  dispose: function () {
    this._network.getView().removeChild(this._roundDiv);
  },
  getView: function () {
    return this._roundDiv;
  },
});
twaver.vector.BaseZoomManager = function(network) {
	this.network = network;
	this.visibilityThresholds = network.visibilityThresholds;
};

_twaver.ext('twaver.vector.BaseZoomManager', Object, {

	getZoom : function() {
		return this.network.getZoom();
	},

	getGraphicsZoom : function() {
		return 1;
	},

	getSizeZoom : function(ui) {
		return 1;
	},

	getAttachmentSizeZoom : function(attachment) {
		var ui = attachment.getElementUI();
		return this.getSizeZoom(ui);
	},

	getLocationZoom : function(ui) {
		return 1;
	},

	_getZoomVisibilityThresholds : function() {
		return this.network.getZoomVisibilityThresholds();
	},

	_convertPointFromView : function(p) {
		var x = p.x * this.getGraphicsZoom() - this.network.getViewRect().x;
		var y = p.y * this.getGraphicsZoom() - this.network.getViewRect().y;
		return {
			x : x,
			y : y
		};
	},

	_getElementViewRect : function(ui, viewRect) {
		var locationZoom = this.getLocationZoom(ui);
		var sizeZoom = this.getSizeZoom(ui);

		if (locationZoom == 1 && sizeZoom == 1) {
			return viewRect;
		}

		var center = this._getZoomPoint(ui);
		var cx = center.x;
		var cy = center.y;
		if (viewRect == null) {
			console.log('View rect is null');
		}
		return {
			x : cx * locationZoom + (viewRect.x - cx) * sizeZoom,
			y : cy * locationZoom + (viewRect.y - cy) * sizeZoom,
			width : viewRect.width * sizeZoom,
			height : viewRect.height * sizeZoom
		};
	},

	_invalidateZoom : function() {
		this.network.invalidateElementUIs();
	},

	_getGroupChildrenRects : function(group) {
		var list = new $List();
		group.getChildren().forEach(function(child) {
			if ( child instanceof $Node) {
				var ui = this.network.getElementUI(child);
				if (ui) {
					var rect = ui.getZoomViewRect(this);
					if (rect) {
						list.add(rect);
					}
				}
			}
		}, this);
		return list;
	},

	_zoomGraphicsBegin : function(g) {
		var network = this.network;
		var gzoom = this.getGraphicsZoom();
		g.scale(gzoom, gzoom);
		//g.translate(Math.floor(-network.viewRect.x / gzoom), Math.floor(-network.viewRect.y / gzoom));
		g.translate(-network.viewRect.x / gzoom, -network.viewRect.y / gzoom);
	},

	_getEditZoomPoints : function(ui, points) {
		var locationZoom = this.getLocationZoom(ui);
		var sizeZoom = this.getSizeZoom(ui);
		if ((locationZoom == 1 && sizeZoom == 1) || ( ui instanceof twaver.vector.LinkUI && !(ui instanceof twaver.vector.ShapeLinkUI))) {
			return points;
		}
		var center;
		if ( ui instanceof twaver.vector.ShapeLinkUI) {
			center = $math.getCenterPoint($math.getRect(points));
		} else {
			center = this._getZoomPoint(ui);
		}
		var cx = center.x;
		var cy = center.y;
		if (points.forEach) {
			var zoomPoints = new $List(), subList;
			points.forEach(function(point) {
				if ( point instanceof $List) {
					subList = new $List();
					point.forEach(function(p) {
						subList.add({
							x : cx * locationZoom + (p.x - cx) * sizeZoom,
							y : cy * locationZoom + (p.y - cy) * sizeZoom,
						});
					});
					zoomPoints.add(subList);
				} else {
					zoomPoints.add({
						x : cx * locationZoom + (point.x - cx) * sizeZoom,
						y : cy * locationZoom + (point.y - cy) * sizeZoom,
					});
				}

			});
			return zoomPoints;
		}else if(points.x){
			return {
				x : cx * locationZoom + (points.x - cx) * sizeZoom,
			    y : cy * locationZoom + (points.y - cy) * sizeZoom,
			};
		}

	},

	_getShapeNodeZoomPoints : function(ui, points, reverseZoom) {
		var locationZoom = this.getLocationZoom(ui);
		var sizeZoom = this.getSizeZoom(ui);
		if (locationZoom == 1 && sizeZoom == 1) {
			return points;
		}
		if (reverseZoom) {
			locationZoom = 1 / locationZoom;
			sizeZoom = 1 / sizeZoom;
		}
		var rect = $math.getRect(points);
		var cx = rect.x + rect.width / 2;
		var cy = rect.y + rect.height / 2;

		var zoomPoints = new $List(), subList;
		points.forEach(function(point) {
			if ( point instanceof $List) {
				subList = new $List();
				point.forEach(function(p) {
					subList.add({
						x : cx * locationZoom + (p.x - cx) * sizeZoom,
						y : cy * locationZoom + (p.y - cy) * sizeZoom,
					});
				});
				zoomPoints.add(subList);
			} else {
				zoomPoints.add({
					x : cx * locationZoom + (point.x - cx) * sizeZoom,
					y : cy * locationZoom + (point.y - cy) * sizeZoom,
				});
			}

		});
		return zoomPoints;
	},

	_getShapeLinkZoomPoints : function(points, reverseZoom) {
		var locationZoom = this.getLocationZoom();
		var sizeZoom = locationZoom;

		if (locationZoom == 1 && sizeZoom == 1) {
			return points;
		}
		if (reverseZoom) {
			locationZoom = 1 / locationZoom;
			sizeZoom = 1 / sizeZoom;
		}

		var rect = $math.getRect(points);
		var cx = rect.x + rect.width / 2;
		var cy = rect.y + rect.height / 2;

		var zoomPoints = new $List(), subList;
		points.forEach(function(point) {
			if ( point instanceof $List) {
				subList = new $List();
				point.forEach(function(p) {
					subList.add({
						x : cx * locationZoom + (p.x - cx) * sizeZoom,
						y : cy * locationZoom + (p.y - cy) * sizeZoom,
					});
				});
				zoomPoints.add(subList);
			} else {
				zoomPoints.add({
					x : cx * locationZoom + (point.x - cx) * sizeZoom,
					y : cy * locationZoom + (point.y - cy) * sizeZoom,
				});
			}

		});
		return zoomPoints;
	},

	_getLogicalPoint : function(e,useZoom) {
	    var zoom = useZoom ? this.getZoom() : this.getGraphicsZoom();
		var point, network = this.network;
		if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
			var bound = network._view.getBoundingClientRect();
			var touch = e.changedTouches[0];
			var scrollLeft = $ua.isAndroid ? 0 : $touch.scrollLeft();
			var scrollTop = $ua.isAndroid ? 0 : $touch.scrollTop();
			point = {
				x : (touch.clientX + network.viewRect.x - bound.left - scrollLeft) / zoom,
				y : (touch.clientY + network.viewRect.y - bound.top - scrollTop) / zoom
			};
			return point;
		}

		if ($ua.isFirefox) {
			point = {
				x : (e.layerX + network.viewRect.x) / zoom,
				y : (e.layerY + network.viewRect.y) / zoom
			};
		} else {
			point = {
				x : (e.offsetX + network.viewRect.x) /zoom,
				y : (e.offsetY + network.viewRect.y) /zoom
			};
		}
		return point;
	},

	_getVisibleRect : function(viewRect) {
		return viewRect;
	},

	_getElementZoomRect : function(ui, rect) {
		// return rect;
		var locationZoom = this.getLocationZoom(ui);
		var sizeZoom = this.getSizeZoom(ui);
		if (locationZoom == 1 && sizeZoom == 1) {
			return _twaver.cloneRect(rect);
		}
		var center = ui != null ? this._getZoomPoint(ui) : {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2
		};
		var cx = center.x;
		var cy = center.y;
		return {
			x : cx * locationZoom + (rect.x - cx) * sizeZoom,
			y : cy * locationZoom + (rect.y - cy) * sizeZoom,
			width : rect.width * sizeZoom,
			height : rect.height * sizeZoom
		};
	},
	_reverseElementZoomRect : function(ui, rect) {
		// return rect;
		var locationZoom = this.getLocationZoom(ui);
		var sizeZoom = this.getSizeZoom(ui);
		if (locationZoom == 1 && sizeZoom == 1) {
			return _twaver.cloneRect(rect);
		}
		var center = ui != null ? this._getZoomPoint(ui) : {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2
		};
		var cx = center.x;
		var cy = center.y;
		return {
			x : cx + (rect.x - cx * locationZoom) / sizeZoom,
			y : cy + (rect.y - cy * locationZoom) / sizeZoom,
			width : rect.width / sizeZoom,
			height : rect.height / sizeZoom
		};
	},

	_getZoomContentRect : function(attachment, point, contentRect, center, locationZoom, index) {
		var sizeZoom = this.getSizeZoom(attachment.getElementUI());
		var attachmentSizeZoom = this.getAttachmentSizeZoom(attachment);
		var ui = attachment.getElementUI();
		if (index == undefined) {
			if(ui instanceof twaver.vector.GroupUI && ui._shapeRect){
				return {
				x : center.x * locationZoom + (point.x - center.x) * 1 + (contentRect.x - point.x) * attachmentSizeZoom,
				y : center.y * locationZoom + (point.y - center.y) * 1 + (contentRect.y - point.y) * attachmentSizeZoom,
				width : contentRect.width ,
				height : contentRect.height
			};
			}
			return {
				x : center.x * locationZoom + (point.x - center.x) * sizeZoom + (contentRect.x - point.x) * attachmentSizeZoom,
				y : center.y * locationZoom + (point.y - center.y) * sizeZoom + (contentRect.y - point.y) * attachmentSizeZoom,
				width : contentRect.width ,
				height : contentRect.height
			};
		} else {
			return {
				x : center.x * locationZoom + (point.x - center.x) * sizeZoom + (contentRect.x - point.x) * attachmentSizeZoom,
				y : center.y * locationZoom + (point.y - center.y) * sizeZoom + (contentRect.y - point.y) * attachmentSizeZoom + index * (attachment.textHeight - 4) * (attachmentSizeZoom),
				width : contentRect.width,
				height : attachment.textHeight
			};
		}
	},

	_getAttachmentZoomRect : function(attachment, _contentRect, index) {
		//return _contentRect
		var locationZoom = this.getLocationZoom(attachment.getElementUI());
		var ui = attachment.getElementUI();
		var sizeZoom = this.getSizeZoom(attachment.getElementUI());
		var attachmentSizeZoom = this.getAttachmentSizeZoom(attachment);
		var pointers = attachment._pointers;

		if (locationZoom == 1 && attachmentSizeZoom == 1 && sizeZoom == 1) {
			if (index == undefined) {
				return _contentRect;
			} else {
				return {
					x : _contentRect.x,
					y : _contentRect.y + index * (attachment.textHeight - 4),
					width : _contentRect.width,
					height : attachment.textHeight
				};
			}
		}

		var ui = attachment.getElementUI();
		var center = this._getZoomPoint(ui, attachment);
		var cx = center.x;
		var cy = center.y;
		var position = attachment.getPosition ? attachment.getPosition() : 'center';
		var fx = 0, fy = 0;
		var point = pointers ? pointers[0] : $position_zoom.get(position, _contentRect);
		if (index == undefined) {
			if ( ui instanceof twaver.vector.LinkUI || (ui instanceof twaver.vector.GroupUI && ui._shapeRect)) {
				return this._getZoomContentRect(attachment, point, _contentRect, center, 1);
			} else {
				return this._getZoomContentRect(attachment, point, _contentRect, center, locationZoom);
			}
			return {
				x : fx,
				y : fy,
				width : _contentRect.width,
				height : _contentRect.height
			};
		} else {
			return this._getZoomContentRect(attachment, point, _contentRect, center, locationZoom, index);
		}
	},

	_getZoomPoint : function(ui, attachment) {
		var element = ui._element, r = 0, c = 0, grid, rect;
		if ( element instanceof twaver.Follower && element.getHost() && element.getHost() instanceof twaver.Grid) {
			grid = element.getHost();
			rect = grid.getRect();
			return {
				x : rect.x + rect.width / 2,
				y : rect.y + rect.height / 2
			};
		} else {
			rect = ui.getBodyRect();
		}
		if(ui instanceof twaver.vector.LinkUI && attachment && attachment.getPosition ){
			var xOffset = attachment.getXOffset();
			var yOffset = attachment.getYOffset();
			if(attachment.getPosition() === 'from'){
				return ui._fromPoint;
			}else if(attachment.getPosition() === 'to'){
				return ui._toPoint;
			}
		}
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2
		};
	},

	_getZoomPointers : function(attachment, ui, pointers) {
		if (pointers) {
			var point = this._getZoomPoint(ui);
			var locationZoom = this.getLocationZoom(ui);
			var sizeZoom = this.getSizeZoom(ui);
			var attachmentSizeZoom = this.getAttachmentSizeZoom(attachment);

			var stander = pointers[0];
			if(ui instanceof twaver.vector.LinkUI){
				return [{
					x : point.x  + (stander.x - point.x) * sizeZoom,
					y : point.y  + (stander.y - point.y) * sizeZoom
				}, {
					x : point.x  + (stander.x - point.x) * sizeZoom + (pointers[1].x - stander.x) * attachmentSizeZoom,
					y : point.y  + (stander.y - point.y) * sizeZoom + (pointers[1].y - stander.y) * attachmentSizeZoom,
				}, {
					x : point.x  + (stander.x - point.x) * sizeZoom + (pointers[2].x - stander.x) * attachmentSizeZoom,
					y : point.y  + (stander.y - point.y) * sizeZoom + (pointers[2].y - stander.y) * attachmentSizeZoom,
				}];
			}else if(ui instanceof twaver.vector.GroupUI && ui._shapeRect){
				return [{
					x : point.x  + (stander.x - point.x) * 1,
					y : point.y  + (stander.y - point.y) * 1
				}, {
					x : point.x  + (stander.x - point.x) * 1 + (pointers[1].x - stander.x) * attachmentSizeZoom,
					y : point.y  + (stander.y - point.y) * 1 + (pointers[1].y - stander.y) * attachmentSizeZoom,
				}, {
					x : point.x  + (stander.x - point.x) * 1 + (pointers[2].x - stander.x) * attachmentSizeZoom,
					y : point.y  + (stander.y - point.y) * 1 + (pointers[2].y - stander.y) * attachmentSizeZoom,
				}];
			}
			return [{
				x : point.x * locationZoom + (stander.x - point.x) * sizeZoom,
				y : point.y * locationZoom + (stander.y - point.y) * sizeZoom
			}, {
				x : point.x * locationZoom + (stander.x - point.x) * sizeZoom + (pointers[1].x - stander.x) * attachmentSizeZoom,
				y : point.y * locationZoom + (stander.y - point.y) * sizeZoom + (pointers[1].y - stander.y) * attachmentSizeZoom,
			}, {
				x : point.x * locationZoom + (stander.x - point.x) * sizeZoom + (pointers[2].x - stander.x) * attachmentSizeZoom,
				y : point.y * locationZoom + (stander.y - point.y) * sizeZoom + (pointers[2].y - stander.y) * attachmentSizeZoom,
			}];
		}
	},

	_getZoomHotSpot : function(ui, hotSpot) {
		if (hotSpot) {
			var point = this._getZoomPoint(ui);
			var locationZoom = this.getLocationZoom(ui);
			var sizeZoom = this.getSizeZoom(ui);
			return {
				x : point.x * locationZoom + (hotSpot.x - point.x) * sizeZoom,
				y : point.y * locationZoom + (hotSpot.y - point.y) * sizeZoom
			};
		}
		return null;
	},

	limitZoom : function(zoom) {
		return zoom;
	},

	_isVisible : function(name) {
		var thresholds = this._getZoomVisibilityThresholds();
		var threshold = thresholds[name];
		var zoom;
		if (threshold != null) {
			var zoomName = thresholds.zoomName;
			if (zoomName == 'sizeZoom') {
				zoom = this.getSizeZoom();
			} else if (zoomName == 'locationZoom') {
				zoom = this.getLocationZoom();
			} else if (zoomName == 'graphicsZoom') {
				zoom = this.getGraphicsZoom();
			} else {
				zoom = this.getZoom();
			}
			if (zoom < threshold) {
				return false;
			}
		}
		return true;
	},

	isElementVisible : function(element) {
		var zoom = this.getZoom();
		var visible = this._isVisible('element', zoom);
		if (visible && element instanceof twaver.Link) {
			return this.isLinkVisible(element);
		}
		return visible;
	},

	isLinkVisible : function(link) {
		var zoom = this.getZoom();
		return this._isVisible('link', zoom);
	},

	isLabelVisible : function(element) {
		var zoom = this.getZoom();
		return this._isVisible('label', zoom);
	},

	isAttachmentVisible : function(element) {
		var zoom = this.getZoom();
		return this._isVisible('attachment', zoom);
	},

	isAlarmBalloonVisible : function(element) {
		var zoom = this.getZoom();
		return this._isVisible('alarmBallon', zoom);
	},

	_getAttachmentOutLineWidth : function(attachment) {
		return attachment.getOutlineWidth();
	},

	_getAttachmentZoomOutLineRect : function(attachment, _contentRect) {
		var locationZoom = this.getLocationZoom(attachment.getElementUI());
		var attachmentSizeZoom = this.getAttachmentSizeZoom(attachment);

		if (locationZoom == 1 && attachmentSizeZoom == 1) {
			return _contentRect;
		}

		var rect = this._getAttachmentZoomRect(attachment, _contentRect, null);

        var element = attachment.getElement();

        if (!this.isAttachmentVisible(element)) {
            return {
                x : rect.x,
                y : rect.x,
                width : 0,
                height : 0
            };
        }
        if ((attachment instanceof twaver.vector.LabelAttachment || attachment instanceof twaver.vector.Label2Attachment) && !this.isLabelVisible(element)) {
            return {
                x : rect.x,
                y : rect.x,
                width : 0,
                height : 0
            };
        } else if ((attachment instanceof twaver.vector.AlarmAttachment) && !this.isAlarmBalloonVisible(element)) {
            return {
                x : rect.x,
                y : rect.x,
                width : 0,
                height : 0
            };
        }

		return {
			x : rect.x,
			y : rect.y,
			width : rect.width * attachmentSizeZoom,
			height : rect.height * attachmentSizeZoom
		};
	},

	_drawText : function(attachment, ctx, text, rect, font, color, align, linespacing) {
		var locationZoom = this.getLocationZoom(attachment.getElementUI());
		var sizeZoom = this.getAttachmentSizeZoom(attachment);
		if (locationZoom != 1 && sizeZoom != 1) {
			ctx.translate(rect.x, rect.y);
			ctx.scale(sizeZoom, sizeZoom);
			$g.drawText(ctx, text, {
				x : 0,
				y : 0,
				width : rect.width,
				height : rect.height
			}, font, color, align);
			ctx.scale(1 / sizeZoom, 1 / sizeZoom);
			ctx.translate(-rect.x, -rect.y);
		} else {
			$g.drawText(ctx, text, rect, font, color,align,linespacing);
		}
	},

	_getOffset : function(newPoint, lastPoint) {
		var locationZoom = this.getLocationZoom();
		return {
			x : (newPoint.x - lastPoint.x) / locationZoom,
			y : (newPoint.y - lastPoint.y) / locationZoom
		};
	},
});

var $position_zoom = {

	'topleft.topleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height,
		};
	},
	'topleft.topright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height,
		};
	},
	'top.top' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height,
		};
	},
	'topright.topleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height,
		};
	},
	'topright.topright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height,
		};
	},
	'topleft' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2
		};
	},
	'top' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'topright' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'topleft.bottomleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y,
		};
	},
	'topleft.bottomright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y,
		};
	},
	'top.bottom' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y,
		};
	},
	'topright.bottomleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y,
		};
	},
	'topright.bottomright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y,
		};
	},
	'left.left' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height / 2,
		};
	},
	'left' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'left.right' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height / 2,
		};
	},
	'center' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'right.left' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height / 2,
		};
	},
	'right' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'right.right' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height / 2,
		};
	},
	'bottomleft.topleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height,
		};
	},
	'bottomleft.topright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height,
		};
	},
	'bottom.top' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height,
		};
	},
	'bottomright.topleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y + rect.height,
		};
	},
	'bottomright.topright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y + rect.height,
		};
	},
	'bottomleft' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'bottom' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'bottomright' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		};
	},
	'bottomleft.bottomleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y,
		};
	},
	'bottomleft.bottomright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y,
		};
	},
	'bottom.bottom' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y,
		};
	},
	'bottomright.bottomleft' : function(rect) {
		return {
			x : rect.x + rect.width,
			y : rect.y,
		};
	},
	'bottomright.bottomright' : function(rect) {
		return {
			x : rect.x,
			y : rect.y,
		};
	},
	'from' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		}
	},
	'to' : function(rect) {
		return {
			x : rect.x + rect.width / 2,
			y : rect.y + rect.height / 2,
		}
	},
	get : function(position, rect) {
		if (!rect) {
			throw "rect can not be null";
		}
		var func = $position_zoom[position];
		if (func) {
			return func(rect);
		}
		throw "Can not resolve '" + position + "' position";
	}
};

twaver.vector.PhysicalZoomManager = function(network){
	twaver.vector.PhysicalZoomManager.superClass.constructor.apply(this, arguments);	
};

_twaver.ext('twaver.vector.PhysicalZoomManager', twaver.vector.BaseZoomManager, {
	
	getGraphicsZoom : function(){
		return this.getZoom();
	},
  _invalidateZoom : function(){
    
  },
}); 
twaver.vector.LogicalZoomManager = function(network,sizeChange) {
	twaver.vector.LogicalZoomManager.superClass.constructor.apply(this, arguments);
	this.sizeChange = sizeChange;
};

_twaver.ext('twaver.vector.LogicalZoomManager', twaver.vector.BaseZoomManager, {
	
	getLocationZoom : function(ui){
		return this.getZoom();
	},
	
	getSizeZoom : function(ui){
		return this.sizeChange ? this.getZoom() : 1;
	},
});

twaver.vector.MixedZoomManager = function(network,sizeChange) {
	twaver.vector.MixedZoomManager.superClass.constructor.call(this, network,sizeChange);
};

_twaver.ext('twaver.vector.MixedZoomManager', twaver.vector.LogicalZoomManager, {});

(function mix() {
	var l = twaver.vector.LogicalZoomManager.prototype;
	var l2 = twaver.vector.PhysicalZoomManager.prototype;
	var m = twaver.vector.MixedZoomManager.prototype;

	for (var func in l2) {
		if (typeof l2[func] === 'function' && func != "constructor" && (l.hasOwnProperty(func) || l2.hasOwnProperty(func)) ) {
			mixedFunc(func);
		}
	}
	m._invalidateZoom = function() {
		this.network.invalidateElementUIs();
	};

	function mixedFunc(func) {
		m[func] = function() {
			if (this.getZoom() > 1) {
				return l[func].apply(this, arguments);
			} else {
				return l2[func].apply(this, arguments);
			}

		};
	}

})();


twaver.vector.interaction.BaseInteraction = function (network) {
    this.network = network;
};
_twaver.ext('twaver.vector.interaction.BaseInteraction', Object, {
    setUp: function () {
    },
    tearDown: function () {
    },
    repaint: function () {
        this.network.repaintTopCanvas();
    },
    getOffset:function(newPoint,lastPoint){
        return this.network.getOffset(newPoint,lastPoint);
    },
    convertPointFromView: function (p) {
        return this.network.convertPointFromView(p);
    },
    convertFromUIToMarkerRect: function (vr, xoff, yoff,node) {
    	var zm = this.network.zoomManager;
        var locationZoom = zm.getLocationZoom();
        var gzoom = zm.getGraphicsZoom();
        var sizeZoom = zm.getSizeZoom(this.network.getElementUI(node));
        return {
            x: vr.x * locationZoom * gzoom - this.network.getViewRect().x + xoff * locationZoom * gzoom,
            y: vr.y * locationZoom * gzoom - this.network.getViewRect().y + yoff * locationZoom * gzoom,
            width: vr.width * sizeZoom * gzoom,
            height: vr.height * sizeZoom * gzoom
        };
    },
    getMarkerPoint: function (e) {
        var point;

        if ($ua.isTouchable && e.changedTouches && e.changedTouches.length > 0) {
            var touch = e.changedTouches[0];
            point = {
                x: touch.clientX,
                y: touch.clientY
            };
            return point;
        }
        if ($ua.isFirefox) {
            point = {
                x: e.layerX,
                y: e.layerY
            };
        } else {
            point = {
                x: e.offsetX,
                y: e.offsetY
            };
        }
        return point;
    },
    paint: function (ctx) {
    },
    addListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            var type = arguments[i];
            $html.addEventListener(type, 'handle_' + type, this.network.getView(), this);
        }
    },
    removeListener: function () {
        for (var i = 0; i < arguments.length; i++) {
            $html.removeEventListener(arguments[i], this.network.getView(), this);
        }
    },
    _handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        this._startLogical = this.network.getLogicalPoint2(e);
        this._startClient = $html.getClientPoint(e);
        if (this._startLogical) {
            $html.handle_mousedown(this, e);
        }
    },
    _handle_mousemove: function (e) {
        this._endLogical = {
            x: this._startLogical.x + (e.clientX - this._startClient.x) / this.network.getGraphicsZoom(),
            y: this._startLogical.y + (e.clientY - this._startClient.y) / this.network.getGraphicsZoom()
        };
    },
    _handle_mouseup: function (e) {
        delete this._startClient;
        delete this._startLogical;
        delete this._endLogical;
    }
});

twaver.vector.interaction.DefaultInteraction = function(network, lazyMode) {
	twaver.vector.interaction.DefaultInteraction.superClass.constructor.call(this, network);
	this.lazyMode = lazyMode;
};
_twaver.ext('twaver.vector.interaction.DefaultInteraction', twaver.vector.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousedown', 'mouseover', 'mouseout', 'keydown');
		if ($ua.isFirefox) {
			$html.addEventListener("DOMMouseScroll", "handleMouseWheel", this.network.getView(), this);
		} else {
			$html.addEventListener("mousewheel", "handleMouseWheel", this.network.getView(), this);
		}
		$html.addEventListener("mouseup", "handle_mouseup", window, this);
		$html.addEventListener("dblclick", "handleDoubleClicked", this.network.getView(), this);
		$html.addEventListener("blur", "handle_blur", this.network.getView(), this);
		this._oldCursor = this.network.getView().style.cursor;
		this.network.addPropertyChangeListener(this.handleViewRectChange, this);
		this.validateScrollBar();
		this.network.addMarker(this);
		this.network.getView().oncontextmenu = function(e) {
			e.preventDefault();
		};
		this._createZoomDiv();
	},

	tearDown : function() {
		this.removeListener('mousedown', 'mouseover', 'mouseout', 'keydown');
		if ($ua.isFirefox) {
			$html.removeEventListener("DOMMouseScroll", this.network.getView(), this);
		} else {
			$html.removeEventListener("mousewheel", this.network.getView(), this);
		}
		$html.removeEventListener("mouseup", window, this);
		$html.removeEventListener("dblclick", this.network.getView(), this);
		$html.removeEventListener("blur", this.network.getView(), this);
		this.network.removePropertyChangeListener(this.handleViewRectChange, this);
		this.end();
		this.network.removeMarker(this);
		this._zoomDiv = null;
	},

	_createZoomDiv : function() {
		if (this._zoomDiv == null) {
			this._zoomDiv = document.createElement('div');
			this._zoomLabel = document.createElement('span');
			this._zoomLabel.style.display = 'block';
			this._zoomLabel.style.textAlign = 'center';
			var button = document.createElement('button');
			button.innerHTML = 'Reset to default';
			this._zoomDiv.appendChild(this._zoomLabel);
			this._zoomDiv.appendChild(button);

			var D = $Defaults;
			var style = this._zoomDiv.style;
			style.position = 'absolute';
			style.color = D.TOOLTIP_COLOR;
			style.background = D.TOOLTIP_BACKGROUND;
			style.fontSize = D.TOOLTIP_FONT_SIZE;
			style.padding = D.TOOLTIP_PADDING;
			style.border = D.TOOLTIP_BORDER;
			style.borderRadius = D.TOOLTIP_BORDER_RADIUS;
			style.boxShadow = D.TOOLTIP_BOX_SHADOW;
			style.zIndex = D.TOOLTIP_ZINDEX;
			if (style.setProperty) {
				style.setProperty('-webkit-box-shadow', D.TOOLTIP_BOX_SHADOW, null);
			}
			var scope = this;
			button.onclick = function(e) {
				scope.network.setZoom(1);
				scope._setZoomDivVisible(false);
			};
			var div = this._zoomDiv;
			var clearFunc = function() {
				div.style.opacity = parseFloat(div.style.opacity)  - 0.05;
				if (parseFloat(div.style.opacity) <= 0.05) {
					scope._setZoomDivVisible(false);
					div._clearTimeout = null;
					return;
				}
				div._clearTimeout = setTimeout(div._clearFunc, 100);
			};
			div._clearFunc = clearFunc;
			div.onmouseover = function(e) {
				if (!e) e = window.event;
				var reltg = e.relatedTarget ? e.relatedTarget : e.fromElement;
				while (reltg && reltg != div)
					reltg = reltg.parentNode;
				if (reltg != div) {
					if (div._clearTimeout) {
						clearTimeout(div._clearTimeout);
						div._clearTimeout = null;
					}
					div.style.opacity = 1;
				}

			};
			div.onmouseout = function(e) {
				if (!e) e = window.event;
				var reltg = e.relatedTarget ? e.relatedTarget : e.toElement;
				while (reltg && reltg != div)
					reltg = reltg.parentNode;
				if (reltg != div) {
					div._clearTimeout = setTimeout(div._clearFunc, 10);
				}
			};
		}
	},

	_isZoomDivVisible : function() {
		return this._zoomDiv != null && this._zoomDiv.parentNode != null;
	},

	_getZoomDiv : function(){
		if(!this._zoomDiv){
			this._createZoomDiv();
		}
		return this._zoomDiv;
	},
	
	_setZoomDivVisible : function(visible, e, innerHTML) {
		var div = this._getZoomDiv();
		if (visible) {
			this._zoomLabel.innerHTML = innerHTML;
			div.style.opacity = 1;
			if (!this._isZoomDivVisible()) {
				this.network.getView().appendChild(div);
			}
			div.style.left = $Defaults.TOOLTIP_XOFFSET + 'px';
			div.style.top = $Defaults.TOOLTIP_YOFFSET + 'px';
			var scope = this;
			if (div._clearTimeout) {
				clearTimeout(div._clearTimeout);
				div._clearTimeout = null;
			}
			div._clearTimeout = setTimeout(div._clearFunc, 250);
		} else {
			if (div.parentNode) {
				div.parentNode.removeChild(div);
			}
		}
	},

	handleViewRectChange : function(e) {
		if (e.property == "viewRect" || e.property == "canvasSizeChange") {
			this.validateScrollBar();
		}
	},

	getScrollBarWidth : function() {
		return this.network.getScrollBarWidth();
	},
	getScrollBarColor : function() {
		return '#cccccc';
	},
	validateScrollBar : function() {
		this.hThumbRect = null;
		this.vThumbRect = null;
		if (this.network.isScrollBarVisible() == false) {
			this.repaint();
			return;
		}

		var h = this.network.getViewRect().height;
		var w = this.network.getViewRect().width;
		var x = this.network.getViewRect().x;
		var y = this.network.getViewRect().y;
		var realSize = this.network.getCanvasSize();
		var unionBounds = this.network._unionBounds;
		var rx = unionBounds.x;
		var ry = unionBounds.y;
		var rw = unionBounds.width;
		var rh = unionBounds.height;
		var right = realSize.width;
		var bottom = realSize.height;

		var width = w;
		var height = h;

		var vScrollVisible = false;
		var hScrollVisible = false;

		if (x > rx || (w + x) < right) {
			hScrollVisible = true;
		}

		if (y > ry || (y + h) < bottom) {
			vScrollVisible = true;
		}

		var sx = 0, sy = 0, sw = 0, sh = 0, swidth = width, sheight = height, offset, offset1, offset2;
		// scroll rect
		var scrollBarSize = this.getScrollBarWidth();

		if (hScrollVisible) {
			if (vScrollVisible) {
				swidth -= scrollBarSize;
			}
			sh = scrollBarSize;
			sy = height - scrollBarSize;

			if (x > rx && (x + w) > right) {
				offset = x - rx;
				offset = offset * swidth / (offset + width);
				sx = offset;
				sw = swidth - offset;
			} else if (x < rx && (x + w) < right) {
				offset = right - (x + w);
				offset = swidth * offset / (offset + width);
				sx = 0;
				sw = swidth - offset;
			} else {
				offset1 = x - rx;
				offset2 = right - (x + w);
				offset1 = swidth * offset1 / rw;
				offset2 = swidth * offset2 / rw;
				sx = offset1;
				sw = width - offset1 - offset2;
			}
			this.hThumbRect = {
				x : sx,
				y : sy,
				width : sw,
				height : sh
			};
		}

		sx = 0, sy = 0, sw = 0, sh = 0, swidth = width, sheight = height;
		if (vScrollVisible) {
			if (hScrollVisible) {
				sheight -= scrollBarSize;
			}
			sw = scrollBarSize;
			sx = width - scrollBarSize;
			if (y > ry && (y + h) > bottom) {
				offset = y - ry;
				offset = sheight * offset / (offset + height);
				sy = offset;
				sh = sheight - offset;
			} else if (y < ry && (y + h) < bottom) {
				offset = bottom - (y + h);
				offset = sheight * offset / (offset + height);
				sy = 0;
				sh = sheight - offset;
			} else {
				offset1 = y - ry;
				offset2 = bottom - (y + h);
				offset1 = sheight * offset1 / rh;
				offset2 = sheight * offset2 / rh;
				sy = offset1;
				sh = sheight - offset1 - offset2;
			}

			this.vThumbRect = {
				x : sx,
				y : sy,
				width : sw,
				height : sh
			};
		}

		this.network.setHScrollBarVisible(this.hThumbRect != null);
		this.network.setVScrollBarVisible(this.vThumbRect != null);

		this.repaint();
	},

	scrollXOffset : function(left) {
		var h = this.network.getViewRect().height;
		var w = this.network.getViewRect().width;
		var x = this.network.getViewRect().x;
		var y = this.network.getViewRect().y;
		var xoffset = 30;
		if (left) {
			xoffset = -30;
		}
		this.network.setViewRect(x + xoffset, y, w, h);
	},
	scrollYOffset : function(up) {
		var h = this.network.getViewRect().height;
		var w = this.network.getViewRect().width;
		var x = this.network.getViewRect().x;
		var y = this.network.getViewRect().y;
		var yoffset = 30;
		if (up) {
			yoffset = -30;
		}
		this.network.setViewRect(x, y + yoffset, w, h);
	},

	handle_mouseover : function(e) {
		if (this.scrollBarVisible == true) {
			return;
		}
		this.scrollBarVisible = true;
		this.repaint();
	},
	handle_mouseout: function(e) {
		if (this.scrollBarVisible == false) {
			return;
		}
		if (this.vBarDownPoint == null && this.hBarDownPoint == null) {
			this.scrollBarVisible = false;
			this.repaint();
			this.end(e);
		}
	},

	handle_keydown : function(e) {
		this.currentKeyEvent = e;
		this.addListener('keyup');
		$network_interaction.handleKeyDown(this.network, e);
	},

	handle_keyup : function(e) {
		this.currentKeyEvent = null;
		this.removeListener('keyup');
	},

	start : function(e) {
		this.end(e, true);
		this.lastPoint = this.network.getLogicalPoint2(e);
		this.startPoint = this.network.getLogicalPoint2(e);
		this.lastPanPoint = this.getMarkerPoint(e);
		if (this.lazyMode) {
			this.pressPoint = this.lastPoint;
		}
		// this.addListener('mousemove');
		$html.addEventListener("mousemove", "handle_mousemove", window, this);
	},

	end : function(e, fromStart) {

		this.vBarDownPoint = null;
		this.hBarDownPoint = null;
		if(this.network.state.panning){
			this.network.state.panning = false;
			this.network.invalidateElementUIs(true);
		}
		if (!fromStart) {
			this.network.getView().style.cursor = this._oldCursor;
		}

		if (this.isMoving) {
			if (this.lazyMode) {
				if (this.dragPoint != null && this.pressPoint != null) {
					var self = this;
					var f = function() {
						self.network.fireInteractionEvent({
							kind : 'lazyMoveEnd',
							event : e
						});
						self.network.setMovingElement(false);
					};
					// var xoff = this.dragPoint.x - this.pressPoint.x;
					// var yoff = this.dragPoint.y - this.pressPoint.y;
					var offset = this.getOffset(this.dragPoint, this.pressPoint);
					var xoff = offset.x;
					// this.dragPoint.x - this.pressPoint.x;
					var yoff = offset.y;
					//this.dragPoint.y - this.pressPoint.y;
					this.network.moveSelectedElements(xoff, yoff, this.network.isLazyMoveAnimate(), f);
				}
			} else {
				if (this.network.isMovingElement()) {
					this.network.setMovingElement(false);
					this.network.fireInteractionEvent({
						kind : 'liveMoveEnd',
						event : e
					});
				}
			}
			if (this.isParenting()) {
				if (this.parent == null) {
					this.parent = this.network.getCurrentSubNetwork();
				}
				var self = this;
				this.network.getMovableSelectedElements().forEach(function(element) {
					element.setParent(self.parent);
				}, this.network);
			}
			this.parentProcess(e, true);
			if (this.isParenting()) {
				this.repaint();
			}
			this.network.invalidateCanvasSize();
			// this.removeListener('mousemove');
			this.lastPoint = null;
			this.dragPoint = null;
			this.pressPoint = null;
			
			
			this.repaint();
		}

		if (this.isSelecting) {
			if (this.startPoint) {
				if (this.endPoint && this.startPoint.x !== this.endPoint.x && this.startPoint.y !== this.endPoint.y) {
					var rect = $math.getRect([this.startPoint, this.endPoint]);
					var elements = this.network.getElementsAtRect(rect, this.getIntersectMode(), this.network.getRectSelectFilter());
					if (elements && elements.size() > 0) {
						var sm = this.network.getSelectionModel();
						var selections = sm.toSelection();
						elements.forEach(function(element) {
							if (sm.contains(element)) {
								selections.remove(element);
							} else {
								selections.add(element);
							}
						}, this);
						sm.setSelection(selections);
					}
					this.network.fireInteractionEvent({
						kind : 'selectEnd',
						event : e
					});
				}
				this.network.setSelectingElement(false);
				this.startPoint = null;
				this.endPoint = null;
				this.repaint();
			}
		}
		// this.lastPoint = null;
		// this.startPoint = null;
		// this.lastPanPoint = null;
		this.isMouseDown = false;
		$html.removeEventListener("mousemove", window, this);
	},
	
	_isDragToSelect : function(e){
		return !this.network._dragToPan;
	},

	handle_mousedown : function(e) {
		if (!$ua.isTouchable && e.button !== 0 &&  this.network.isSelectingElement()) {
			this.end(e);
			return;
		}
		var network = this.network;
		if(e.target != network.getView() && e.target != network._topCanvas && e.target != network._rootCanvas){
			return;
		}
		this.isMoving = false;
		this.isSelecting = false;
		this.hBarDownPoint = null;
		this.vBarDownPoint = null;
		this._setZoomDivVisible(false);
		if (!this.network.isValidEvent(e)) {
			var point = this.getMarkerPoint(e);
			this.start(e);
			if (this.vThumbRect != null) {
				if ($math.containsPoint(this.vThumbRect, point.x, point.y)) {
					this.vBarDownPoint = {
						x : e.screenX,
						y : e.screenY
					};
					this.vBarDownOffset = this.vBarDownPoint.y - this.vThumbRect.y;
				}
			}
			if (this.hThumbRect != null) {
				if ($math.containsPoint(this.hThumbRect, point.x, point.y)) {
					this.hBarDownPoint = {
						x : e.screenX,
						y : e.screenY
					};
					this.hBarDownOffset = this.hBarDownPoint.x - this.hThumbRect.x;
				}
			}
			return;
		}
		if (this.network.isFocusOnClick()) {
			twaver.Util.setFocus(this.network.getView());
		}
		var element = this.network.getElementAt(e);
		var elements = this.network.getElementsAt(e);
		if(elements && elements instanceof $List){
			for(var i = 0;i<elements.size();i++){
				var ele = elements.get(i);
				var isSelectable = this.network.getElementBox().getSelectionModel().isSelectable(ele);
				if(isSelectable){
					element = ele;
					break;
				}
			}
		}
		if (!this.network.isSelectingElement() && !this.network.isEditingElement() && element != null) {
			if (this.network.isMovable(element) && this.network.getElementBox().getSelectionModel().isSelectable(element)) {
				this.isMoving = true;
			} else {
				this.network.getView().style.cursor = 'pointer';
			}
			this.start(e);
		}
		if (!this.network.isSelectingElement() && !this.network.isEditingElement()) {
			var sm = this.network.getSelectionModel();
			if (element == null || (element && !this.network.getElementBox().getSelectionModel().isSelectable(element))) {
				if (_twaver.isCtrlDown(e)) {
					this.isSelecting = true;
				} else if(this._isDragToSelect(e)){
					this.isSelecting = true;
					sm.clearSelection();
				} else if (this.network.isRectSelectEnabled()) {
					sm.clearSelection();
					this.network.getView().style.cursor = 'pointer';
				}
				if(network._rectSelectEnabled){
           this.start(e);
         }
			} else {
				if (_twaver.isCtrlDown(e)) {
					if (sm.contains(element)) {
						sm.removeSelection(element);
					} else {
						sm.appendSelection(element);
					}
				} else {
					if (!sm.contains(element)) {
						sm.setSelection(element);
					}
				}
			}
		}
		// default handle;
		this.handleClicked(e, element);
		this.isMouseDown = true;
	},

	handle_mousemove : function(e) {
		this._setZoomDivVisible(false);
		var newPoint = this.network.getLogicalPoint2(e);
		if (!newPoint) {
			return;
		}
		var point = {
			x : e.screenX,
			y : e.screenY
		};
		var realSize = this.network.getCanvasSize();
		var h = this.network.getViewRect().height;
		var w = this.network.getViewRect().width;

		var scrollBarSize = this.getScrollBarWidth();

		if (this.hBarDownPoint != null) {
			var xoff = (point.x - this.hBarDownPoint.x);
			this.hBarDownPoint = point;
			this.network.setViewOffSet(xoff * realSize.width / (w - scrollBarSize), 0);
			return;
		}
		if (this.vBarDownPoint != null) {
			var yoff = (point.y - this.vBarDownPoint.y);
			this.vBarDownPoint = point;
			this.network.setViewOffSet(0, yoff * realSize.height / (h - scrollBarSize));
			return;
		}
		if (!this.network.isSelectingElement() && !this.network.isEditingElement() && this.isMoving && this.isMouseDown && !_twaver.isCtrlDown(e)) {

			var offset = this.getOffset(newPoint, this.lastPoint);
			this.xoffset = offset.x;
			this.yoffset = offset.y;
			if (Math.abs(this.xoffset) < 1 && Math.abs(this.yoffset) < 1) {
				return;
			}

			if (this.lazyMode) {
				if (this.dragPoint == null) {
					this.network.fireInteractionEvent({
						kind : 'lazyMoveStart',
						event : e
					});
					this.network.setMovingElement(true);
				} else {
					this.network.fireInteractionEvent({
						kind : 'lazyMoveBetween',
						event : e
					});
				}
			} else {
				this.lastPoint = newPoint;
				if (this.network.isMovingElement()) {
					this.network.fireInteractionEvent({
						kind : 'liveMoveBetween',
						event : e
					});
				} else {
					this.network.setMovingElement(true);
					this.network.fireInteractionEvent({
						kind : 'liveMoveStart',
						event : e
					});
				}
				this.network.moveSelectedElements(this.xoffset, this.yoffset);
			}
			this.parentProcess(e, false);
			if (this.lazyMode) {
				this.dragPoint = newPoint;
			}
			if (this.lazyMode || this.isParenting()) {
				this.repaint();
			}
		} else if (this.isSelecting && (_twaver.isCtrlDown(e) || this._isDragToSelect())) {
			this.network.setSelectingElement(true);
			if (this.endPoint == null) {
				this.network.fireInteractionEvent({
					kind : 'selectStart',
					event : e
				});
			} else {
				this.network.fireInteractionEvent({
					kind : 'selectBetween',
					event : e
				});
			}
			this.endPoint = newPoint;
			this.repaint();
		} else if (!this.isMoving && !this.isSelecting && this.isMouseDown) {
			if (!this.lastPanPoint || !this.network._dragToPan) {
				return;
			}
			var newPoint = this.getMarkerPoint(e);
			if (!newPoint) {
				return;
			}
			var xoffset = newPoint.x - this.lastPanPoint.x;
			var yoffset = newPoint.y - this.lastPanPoint.y;
			this.network.panByOffset(-xoffset, -yoffset);
			this.network.fireInteractionEvent({
				kind : 'panning',
				event : e
			});
			this.network.state.panning = true;
			this.lastPanPoint = newPoint;
		} else {
			this.end(e);
		}
	},

	handleMouseWheel : function(e) {
		if (document.activeElement !== this.network.getView()) {
			return;
		}
		if(!this.network._wheelToZoom){
			this._handleMouseWheelScroll(e);
			return;
		}
		$html.preventDefault(e);
		var point = {
			x : e.offsetX || e.layerX,
			y : e.offsetY || e.layerY,
		};
		var zoom = this.network.getZoom();
		if ((e.wheelDelta && e.wheelDelta > 0) || (e.detail && e.detail < 0)) {
			this.network.setZoom(zoom * 1.1, point);
		} else {
			this.network.setZoom(zoom / 1.1, point);
		}
		this._setZoomDivVisible(this.network.isZoomDivVisible(), e, "Zoom : " + (parseFloat(this.network.getZoom().toFixed(4))));
	},
	

	_handleMouseWheelScroll: function (e) {
		$html.preventDefault(e);
		var upOrLeft = false;
		var scrollDirection = this._getVisibleScrollBar();
		if (scrollDirection != null) {
			upOrLeft = e.wheelDelta ? e.wheelDelta > 0 : e.detail < 0;
			if (scrollDirection == 'v') {
				this.scrollYOffset(upOrLeft);
			}else {
				this.scrollXOffset(upOrLeft);
			}
		}

	},


	handle_mouseup : function(e) {
		this.end(e);
	},

	isParenting : function() {
		return this.pressPoint && this.currentKeyEvent != null && this.currentKeyEvent.keyCode === 80;
	},

	parentProcess : function(e, released) {
		var rect = null;
		this.parent = null;
		var self = this;
		if (!released && this.isParenting()) {
			var hitRect = {};
			var p = this.network.getLogicalPoint2(e);
			hitRect.x = p.x - 1;
			hitRect.y = p.y - 1;
			hitRect.width = 2;
			hitRect.height = 2;

			var elements = this.network.getElementsAtRect(hitRect, true);
			if (elements && elements.size() > 0) {
				var size = elements.size();
				for (var i = 0; i < size; i++) {
					var element = elements.get(i);
					if (!self.network.getElementBox().getSelectionModel().contains(element)) {
						self.parent = element;
						break;
					}
				}
			}

		} else {
			this.parent = null;
		}
		if (this.parent != null) {
			rect = this.network.getElementUI(this.parent).getViewRect();
		}
		if (rect != null && !released) {
			this.parentRect = rect;
		} else {
			this.parentRect = null;
		}
	},

	getIntersectMode : function() {
		if (this.network.getSelectMode() === 'intersect') {
			return true;
		}
		if (this.network.getSelectMode() === 'contain') {
			return false;
		}
		return this.startPoint.x > this.endPoint.x && this.startPoint.y > this.endPoint.y;
	},
	
	_getVisibleScrollBar : function(){
		if (this.network.isScrollBarVisible() == false) {
			return null;
		}
		if(this.vThumbRect != null){
			return "v";
		}
		if(this.hThumbRect != null){
			return "h";
		}
		return null;
	},

	paintScroll : function(ctx) {
		if (this.network.isScrollBarVisible() == false) {
			return;
		}
		if (this.scrollBarVisible == false) {
			if (this.hBarDownPoint == null && this.vBarDownPoint == null) {
				return;
			}
		}
		var scrollBarSize = this.getScrollBarWidth();
		var h = this.network.getViewRect().height;
		var w = this.network.getViewRect().width;

		ctx.save();
		var lingrad;
		var color = this.getScrollBarColor();
		if (this.hThumbRect != null) {
			lingrad = ctx.createLinearGradient(this.hThumbRect.x, this.hThumbRect.y, this.hThumbRect.x, this.hThumbRect.y + this.hThumbRect.height);
			lingrad.addColorStop(0, color);
			lingrad.addColorStop(1, '#666666');
			this.paintRoundRect(ctx, this.getScrollBarColor(), 0.5, 0, h - scrollBarSize, w - scrollBarSize, scrollBarSize, scrollBarSize / 2);
			this.paintRoundRect(ctx, lingrad, 0.9, this.hThumbRect.x, this.hThumbRect.y + 1, this.hThumbRect.width, this.hThumbRect.height - 2, scrollBarSize / 2);
		}
		if (this.vThumbRect != null) {
			lingrad = ctx.createLinearGradient(this.vThumbRect.x, this.vThumbRect.y, this.vThumbRect.x + this.vThumbRect.width, this.vThumbRect.y);
			lingrad.addColorStop(0, color);
			lingrad.addColorStop(1, '#666666');
			this.paintRoundRect(ctx, this.getScrollBarColor(), 0.5, w - scrollBarSize, 0, scrollBarSize, h - scrollBarSize, scrollBarSize / 2);
			this.paintRoundRect(ctx, lingrad, 0.9, this.vThumbRect.x + 1, this.vThumbRect.y, this.vThumbRect.width - 2, this.vThumbRect.height, scrollBarSize / 2);
		}
		ctx.restore();
	},

	paintRoundRect : function(ctx, fillStyle, alpha, x, y, w, h, r) {
		ctx.beginPath();
		ctx.globalAlpha = alpha;
		ctx.fillStyle = fillStyle;
		$g.drawRoundRect(ctx, x, y, w, h, r);
		ctx.fill();
	},

	paint : function(ctx) {
		this.paintScroll(ctx);
		if (this.network.isSelectingElement()) {
			if (this.startPoint == null || this.endPoint == null) {
				return;
			}
			var sp = this.convertPointFromView(this.startPoint);
			var ep = this.convertPointFromView(this.endPoint);
			var sx = sp.x;
			var sy = sp.y;
			var ex = ep.x;
			var ey = ep.y;
			var rect = $math.getRect([{
				x : sx,
				y : sy
			}, {
				x : ex,
				y : ey
			}]);
			if (rect != null) {
				ctx.beginPath();
				var lineWidth = this.network.getSelectOutlineWidth();
				var fillStyle = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
				ctx.strokeStyle = this.network.getSelectOutlineColor();
				ctx.lineWidth = lineWidth;
				$CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, fillStyle, this.network.getSelectOutlineColor());
				ctx.closePath();
			}
		} else {
			if (this.lazyMode) {
				if (this.pressPoint == null || this.dragPoint == null) {
					return;
				}
				ctx.beginPath();
				var offset = this.getOffset(this.dragPoint, this.pressPoint);
				var xoff = offset.x;
				// this.dragPoint.x - this.pressPoint.x;
				var yoff = offset.y;
				//this.dragPoint.y - this.pressPoint.y;
				var list = this.network.getMovableSelectedElements();
				var size = list.size();

				var fillColor = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null;
				var lineWidth = this.network.getLazyMoveOutlineWidth();
				var strokeColor = this.network.getLazyMoveOutlineColor();
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = lineWidth;
				ctx.fillStyle = fillColor;
				for (var i = 0; i < size; i++) {
					var n = list.get(i);
					var ui = this.network.getElementUI(n);
					if (ui) {
						var vr = this.convertFromUIToMarkerRect(ui.getViewRect(), xoff, yoff);
						$CanvasUtil.rect(ctx, vr.x, vr.y, vr.width, vr.height);
					}
				}
				ctx.fill();
				ctx.stroke();
			}
			if (this.parentRect) {
				ctx.beginPath();
				var fillColor = this.network.isLazyMoveFill() ? this.network.getLazyMoveFillColor() : null;
				var lineWidth = this.network.getLazyMoveOutlineWidth();
				var strokeColor = this.network.getLazyMoveOutlineColor();
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = lineWidth;
				ctx.fillStyle = fillColor;
				var vr = this.parentRect;
				$CanvasUtil.rect(ctx, vr.x, vr.y, vr.width, vr.height);
				ctx.fill();
				ctx.stroke();
			}
		}

	},

	handleClicked : function(e, element) {
		$network_interaction.handleClicked(this.network, e, element);
	},
	handleDoubleClicked : function(e) {
		var element = this.network.getElementAt(e);
		$network_interaction.handleDoubleClicked(this.network, e, element);
	},
	handle_blur: function (e) {
		this.end();
	}
});

twaver.vector.interaction.CreateElementInteraction = function (network, typeOrElementFunction) {
    if (!typeOrElementFunction) {
        typeOrElementFunction = twaver.Node;
    }
    if (twaver.Util.isTypeOf(typeOrElementFunction, twaver.Node)) {
        this.elementFunction = function (point) {
            var element = new typeOrElementFunction();
            if (element instanceof twaver.Node) {
                element.setCenterLocation(point);
            }
            return element;
        };
    } else {
        this.elementFunction = typeOrElementFunction;
    }
    twaver.vector.interaction.CreateElementInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.vector.interaction.CreateElementInteraction', twaver.vector.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
    },
    tearDown: function () {
        this.removeListener('mousedown');
    },
    handle_mousedown: function (e) {
        var point = this.network.getLogicalPoint2(e);
        if (point) {
            var element = this.elementFunction(point);
            if (element) {
                this.network.addElementByInteraction(element);
            }
        }
    }
});

twaver.vector.interaction.EditInteraction = function (network, lazyMode) {
    this.lazyMode = lazyMode;
    this.pointIndex = -1;
    this.linkPointsType = null;
    twaver.vector.interaction.EditInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.vector.interaction.EditInteraction', twaver.vector.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown', 'mouseup', 'mousemove');
        this.oldCursor = this.network.getView().style.cursor;
        this.network.setHasEditInteraction(true);
        this.network.addMarker(this);
    },
    tearDown: function () {
        this.removeListener('mousedown', 'mouseup', 'mousemove');
        this.network.getView().style.cursor = this.oldCursor;
        this.network.setHasEditInteraction(false);
        this.clear();
        this.network.removeMarker(this);
    },
    paint: function (ctx) {
        if (this.lazyMode == true && this.resizingRect != null) {
            ctx.lineWidth = this.network.getResizeLineWidth();
            var rect = this.convertFromUIToMarkerRect(this.resizingRect, 0, 0,this.node);
            ctx.save();
            twaver.Util.rotateCanvas(ctx, rect, this.node.getAngle());
            ctx.beginPath();
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, null, this.network.getResizeLineColor());
            ctx.restore();
        }
        if(this.isStartRotate) {
            this.showRotateScale(ctx);
        }
    },
    clear: function () {
        this.network.setEditingElement(false);
        this.network.setRotatingElement(false);
        this.isStart = false;
        this.isStartRotate = false;
        this.node = null;
        this.shapeNode = null;
        this.shapeLink = null;
        this.linkUI = null;
        this.resizingRect = null;
        this.resizeDirection = null;
        this.pointIndex = -1;
        this._removeCursor();
        this.oldCursor = null;
        this.network.repaintTopCanvas();
    },
    _removeCursor: function () {
        if (this.cursorID) {
            this.network.getView().style.cursor = this.oldCursor || 'default';
            this.cursorID = null;
        }
        this.resizeDirection = null;
        this.isCrossCursor = false;
    },
    _setCrossCursor: function () {
        if (!this.isCrossCursor) {
            this._removeCursor();
            this._setCursor("crosshair");
            this.isCrossCursor = true;
        }
    },
    _setCursor: function (cursorID) {
        this.cursorID = cursorID;
        if (this.network.getView().style.cursor !== this.cursorID) {
            this.network.getView().style.cursor = this.cursorID;
        }
    },
    isKeyDown: function(e) {
        return _twaver.isAltDown(e);
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.isKeyDown(e) && !this.network.isEditingElement()) {
            var element = this.network.getElementAt(e);
            var point = this.network.getLogicalPoint2(e);
            if (element instanceof twaver.ShapeNode) {
                var pointIndex = this.getPointIndex(this.network.getShapeNodeZoomPoints(element), point, true);
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeNode = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            if (element instanceof twaver.ShapeLink) {
                var points = new twaver.List(element.getPoints());
                var shapeLinkUI = this.network.getElementUI(element);
                points.add(shapeLinkUI.getFromPoint(), 0);
                points.add(shapeLinkUI.getToPoint());
                var pointIndex = this.getPointIndex(points, point) - 1;
                if (pointIndex > 0) {
                    this._handle_mousedown(e);
                    this.pointIndex = pointIndex;
                    this.shapeLink = element;
                    element.addPoint(point, pointIndex);
                    this._setCrossCursor();
                    this.network.setEditingElement(true);
                    this.isStart = true;
                    this.network.fireInteractionEvent({ kind: 'addPoint', event: e, element: element, pointIndex: pointIndex });
                    this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: element, pointIndex: pointIndex });
                }
            }
            return;
        }
        if (!this.network.isEditingElement() || this.isStart || this.isStartRotate) {
            return;
        }
        if (this.node && this.resizeDirection) {
            this.isStart = true;
            this._handle_mousedown(e);
            this.network.fireInteractionEvent({ kind: this.lazyMode ? 'lazyResizeStart' : 'liveResizeStart', event: e, element: this.node, resizeDirection: this.resizeDirection });
        } else if (this.shapeNode && this.pointIndex >= 0) {
            if (this.isKeyDown(e)) {
                this.shapeNode.removeAt(this.pointIndex);
                this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeNode });
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            }
        } else if (this.shapeLink) {
            if (this.isKeyDown(e)) {
                if(this.pointIndex >= 0){
                    this.shapeLink.removeAt(this.pointIndex);
                    this.network.fireInteractionEvent({ kind: 'removePoint', event: e, element: this.shapeLink });
                }
            } else {
                this.isStart = true;
                this._handle_mousedown(e);
                this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
            }
        } else if (this.linkUI) {
            this.isStart = true;
            this.network.fireInteractionEvent({ kind: 'liveMovePointStart', event: e, element: this.linkUI._element });
        } else if (this.node) {
            this.isStartRotate = true;
            this._handle_mousedown(e);
        }
    },
    handle_mouseup: function (e) {
        if (this.isStart) {
            var point = this.network.getLogicalPoint2(e);
            if (this.resizingRect) {
                if (this.lazyMode) {
                    if (this.network.isResizeAnimate()) {
                        var self = this;
                        var animate = new twaver.animate.AnimateBounds(this.node, this.resizingRect, function () {
                            self.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: self.node, resizeDirection: self.resizeDirection });
                            self.clear();
                        });
                        twaver.animate.AnimateManager.start(animate);
                    } else {
                        this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                        this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                        this.network.fireInteractionEvent({ kind: 'lazyResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                    }
                } else {
                    this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
                    this.node.setSize(this.resizingRect.width, this.resizingRect.height);
                    this.network.fireInteractionEvent({ kind: 'liveResizeEnd', event: e, element: this.node, resizeDirection: this.resizeDirection });
                }
            } else if (this.shapeNode && this.pointIndex >= 0 && point) {
                this._resetShapeNodePoints(point);  
                this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeNode, pointIndex: this.pointIndex });
            } else if(point && (this.shapeLink || this.linkUI)){
                if(this.linkPointsType === "from"){
                  this._setFromPoint(point);
              }else if(this.linkPointsType === "to"){
                  this._setToPoint(point);
              }else if(this.linkPointsType === "shapeControl"){
                  this._resetShapeLinkPoints(point);
                  this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.shapeLink, pointIndex: this.pointIndex });
              }else if(this.linkPointsType === "control"){
                  if($link.isOrthogonalLink(this.linkUI._element) && this.linkUI.getControlPoint()){
                    this._setLinkControlPoint(point);
                    this.network.fireInteractionEvent({ kind: 'liveMovePointEnd', event: e, element: this.linkUI._element });
                }
            }
        } 
    }
    this._handle_mouseup(e);
        // if (!this.lazyMode) {
            this.clear();
        // }
    },
    handle_mousemove: function (e) {
        var size = this.network.getEditPointSize();
        if (!this.network.isValidEvent(e)) {
            return;
        }
        if(this.isStartRotate) {
            if(this.node) {
                this._handleRotateElement(e,this.node);
                if(this.network.isShowRotateScale()) {
                    this.repaint();
                }
                return;
            }
        }
        if (this.isStart) {
            if (this.shapeNode && this.pointIndex >= 0) {
                this._handleMovingShapeNodePoint(e);
                return;
            }
            if (this.node && this.resizeDirection) {
                this._handleResizing(e);
                return;
            }
            if(this.shapeLink || this.linkUI){
              if(this.linkPointsType){
                if(this.linkPointsType === "from"){
                  this._handleMovingFromPoint(e);
                  return;
              }
              if(this.linkPointsType === "to"){
                  this._handleMovingToPoint(e);
                  return;
              }
              if(this.linkPointsType === "shapeControl"){
                  this._handleMovingShapeLinkPoint(e);
                  return;
              }
              if(this.linkPointsType === "control"){
                  if($link.isOrthogonalLink(this.linkUI._element) && this.linkUI.getControlPoint()){
                    this._handleMovingLinkControlPoint(e);
                    return;
                }
            }
        }
    }
}
if (this.network.isSelectingElement() || this.network.isMovingElement() || this.network.getSelectionModel().size() === 0) {
    this.clear();
    return;
}

var element = this.network.getElementAt(e);
var elementUI = this.network.getElementUI(element);
if (!elementUI || !elementUI.getEditAttachment()) {
    this.clear();
    return;
}

var point = this.network.getLogicalPoint2(e);
if (element instanceof twaver.Node) {
    this.node = element;
    if (this._isEditingShapeNode(point) || this._isResizingNode(point)) {
        this.network.setEditingElement(true);
        return;
    }
    if(this._isRotatingElement(point)) {
        this.network.setRotatingElement(true);
        this.network.setEditingElement(true);
        return;
    }
} else if(element instanceof twaver.Link){
  if(element instanceof twaver.ShapeLink){
    this.shapeLink = element;
}else if(elementUI instanceof twaver.vector.LinkUI){
    this.linkUI = elementUI;
}
var fromAgent = element.getFromAgent();
var fromNode;
if(fromAgent){
    fromNode = element.getFromAgent();
}else{
    fromNode = element.getFromNode();
}
var fromXoffset = element.getStyle("link.from.xoffset");
var fromYoffset = element.getStyle("link.from.yoffset");
var fromNodeUI = this.network.getElementUI(fromNode);
var fromNodeBounds = fromNodeUI.getZoomBodyRect();
var fromCenterPoint = {
  x:fromNodeBounds.x + fromNodeBounds.width/2,
  y:fromNodeBounds.y + fromNodeBounds.height/2,
};
var fromPoint = {
    x: fromCenterPoint.x + fromXoffset,
    y: fromCenterPoint.y + fromYoffset
}
var toAgent = element.getToAgent();
var toNode;
if(toAgent){
    toNode = element.getToAgent();
}else{
    toNode = element.getToNode();
}
var toXoffset = element.getStyle("link.to.xoffset");
var toYoffset = element.getStyle("link.to.yoffset");
var toNodeUI = this.network.getElementUI(toNode);
var toNodeBounds = toNodeUI.getZoomBodyRect();
var toCenterPoint = {
  x:toNodeBounds.x + toNodeBounds.width/2,
  y:toNodeBounds.y + toNodeBounds.height/2,
};
var toPoint = {
    x: toCenterPoint.x + toXoffset,
    y: toCenterPoint.y + toYoffset
}
if(fromPoint && this._contains(point,fromPoint,size)){
    this.linkPointsType = "from";
    this._setCrossCursor();
    this.network.setEditingElement(true);
    return;
}
if(toPoint && this._contains(point, toPoint,size)){
    this.linkPointsType = "to";
    this._setCrossCursor();
    this.network.setEditingElement(true);
    return;
}
if(element instanceof twaver.ShapeLink){
    if (this._isEditingShapeLink(point)) {
        this.linkPointsType = "shapeControl";
        this.network.setEditingElement(true);
        return;
    }
}else if(elementUI instanceof twaver.vector.LinkUI){
    if ($link.isOrthogonalLink(elementUI._element)) {
        var controlPoint = this.linkUI.getControlPoint();
        if (controlPoint && this._contains(point, controlPoint,size)) {
            this.linkPointsType ="control";
            this._setCrossCursor();
            this.network.setEditingElement(true);
            return;
        }
    }
    this.linkPointsType = null;
    return;
}
this.linkPointsType = null;
}
this.clear();
},
_isRotatingElement: function(point) {
    var size = this.network.getRotatePointSize();
    if (size <= 0) {
        return false;
    }
    var zm = this.network.zoomManager;
    var elementUI = this.network.getElementUI(this.node);
    var sizeZoom = zm.getSizeZoom(elementUI);
    var rect = zm._getElementZoomRect(elementUI,this.node.getOriginalRect());
    var angle = this.node.getAngle();
    return this._isRotating(point, "crosshair", rect, angle,sizeZoom);
},
_isRotating: function(point,cursor,rect,angle,sizeZoom) {
    var size = this.network.getRotatePointSize()/this.network.getGraphicsZoom();
        // var p = {x: rect.x + rect.width/2 , y: rect.y - this.network.getRotatePointOffset() * sizeZoom - size * sizeZoom};
        var p = {x: rect.x + rect.width/2 , y: rect.y - this.network.getRotatePointOffset()/this.network.getGraphicsZoom() - size };
        var rotatep = this._rotatePoint(p, angle, rect);
        var newrect = { x: rotatep.x - size, y: rotatep.y - size , width: size * 2, height: size * 2};
        if($math.containsPoint(newrect, point)) {
            this._removeCursor();
            this._setCursor(cursor);
            return true;
        }
        return false;
    },
    _handleRotateElement: function(e,node) {
        this._handle_mousemove(e);
        var angle = this._calculateAngle(this.network.getLogicalPoint2(e),node);
        node.setAngle(angle);
    },
    _calculateAngle: function(p,node) {
        // var c = node.getCenterLocation();
        var rect = this.network.getZoomBodyRect(node);
        var c = $math.getCenterPoint(rect);
        return Math.round(Math.atan2(c.x-p.x,p.y - c.y) * 180 / Math.PI + 180);
    },
    _resetShapeNodePoints : function(point){
    	var zoomPoints = this.network.getShapeNodeZoomPoints(this.shapeNode);
        zoomPoints.set(this.pointIndex,point);
        var ui = this.network.getElementUI(this.shapeNode);
        var points = this.network.zoomManager._getShapeNodeZoomPoints(ui,zoomPoints,true);
        this.shapeNode.setPoints(points);
    },
    _handleMovingShapeNodePoint: function (e) {
        var point = this.network.getLogicalPoint2(e);
        this._resetShapeNodePoints(point);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeNode, pointIndex: this.pointIndex });
    },
    _resetShapeLinkPoints : function(point){
    	var zoomPoints = this.network.zoomManager._getShapeLinkZoomPoints(this.shapeLink._points);
        zoomPoints.set(this.pointIndex,point);
        var points = this.network.zoomManager._getShapeLinkZoomPoints(zoomPoints,true);
        this.shapeLink.setPoints(points);
    },
    _handleMovingShapeLinkPoint: function (e) {
        var point = this.network.getLogicalPoint2(e);
        // this.shapeLink.setPoint(this.pointIndex, point);
        this._resetShapeLinkPoints(point);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.shapeLink, pointIndex: this.pointIndex });
    },
    
    _setLinkControlPoint : function(point){
    	var noZoomControlPoint = this.linkUI.getControlPoint();
    	var cp = this.linkUI.getControlPoint();
        var zm = this.network.zoomManager;
    	// var offset = {
    	// 	x : (point.x - cp.x)/zm.getLocationZoom(),
    	// 	y : (point.y - cp.y)/zm.getLocationZoom()
    	// };
        var offset = {
            x : point.x - cp.x,
            y : point.y - cp.y
        };
        noZoomControlPoint.x += offset.x;
        noZoomControlPoint.y += offset.y;
        this.linkUI.setControlPoint(noZoomControlPoint);
    },
    _handleMovingLinkControlPoint: function (e) {
        var point = this.network.getLogicalPoint2(e);
        this._setLinkControlPoint(point);
        this.network.fireInteractionEvent({ kind: 'liveMovePointBetween', e: e, element: this.linkUI._element });
    },

    _setFromPoint:function(point){
      var element;
      if(this.linkUI){
        element = this.linkUI._element;
    }else if(this.shapeLink){
        element = this.shapeLink;
    }else{
        return;
    }
    var fromAgent = element.getFromAgent();
    var fromNode;
    if (fromAgent) {
      fromNode = element.getFromAgent();
  } else {
      fromNode = element.getFromNode();
  }
  var fromNodeUI = this.network.getElementUI(fromNode);
  var fromNodeBounds = fromNodeUI.getZoomBodyRect();
  var fromCenterPoint = {
      x:fromNodeBounds.x + fromNodeBounds.width/2,
      y:fromNodeBounds.y + fromNodeBounds.height/2,
  };
  var offset = {
      x : point.x - fromCenterPoint.x,
      y : point.y - fromCenterPoint.y
  };
  element.setStyle("link.from.xoffset",offset.x);
  element.setStyle("link.from.yoffset",offset.y);
},
_handleMovingFromPoint:function(e){
  var point = this.network.getLogicalPoint2(e);
  this._setFromPoint(point);
},
_setToPoint:function(point){
  var element;
  if(this.linkUI){
    element = this.linkUI._element;
}else if(this.shapeLink){
    element = this.shapeLink;
}else{
    return;
}
var toAgent = element.getToAgent();
var toNode;
if (toAgent) {
  toNode = element.getToAgent();
} else {
  toNode = element.getToNode();
}
var toNodeUI = this.network.getElementUI(toNode);
var toNodeBounds = toNodeUI.getZoomBodyRect();
var toCenterPoint = {
  x:toNodeBounds.x + toNodeBounds.width/2,
  y:toNodeBounds.y + toNodeBounds.height/2,
};
var offset = {
  x : point.x - toCenterPoint.x,
  y : point.y - toCenterPoint.y
};
element.setStyle("link.to.xoffset",offset.x);
element.setStyle("link.to.yoffset",offset.y);
},
_handleMovingToPoint:function(e){
  var point = this.network.getLogicalPoint2(e);
  this._setToPoint(point);
},

convertFromUIToMarkerRect: function (vr, xoff, yoff,node) {
   var zm = this.network.zoomManager;
   var locationZoom = zm.getLocationZoom();
   var gzoom = zm.getGraphicsZoom();
   var ui = this.network.getElementUI(node);
   var sizeZoom = zm.getSizeZoom(ui);
   var cx = vr.x + vr.width/2,cy = vr.y + vr.height/2;
   var ox = cx - vr.x,oy = cy - vr.y;
   return {
    x: cx * locationZoom * gzoom - this.network.getViewRect().x + xoff * locationZoom * gzoom - ox * sizeZoom * gzoom,
    y: cy * locationZoom * gzoom - this.network.getViewRect().y + yoff * locationZoom * gzoom - oy * sizeZoom * gzoom,
    width: vr.width * sizeZoom * gzoom,
    height: vr.height * sizeZoom * gzoom
};
},

_getReverseZoomPoint : function(node,center,point){
   var zm = this.network.zoomManager;
   var locationZoom = zm.getLocationZoom();
   var sizeZoom = zm.getSizeZoom(this.network.getElementUI(node));
   center.x *= locationZoom;
   center.y *= locationZoom;
   return {
      x : center.x / locationZoom + (point.x - center.x) / sizeZoom,
      y : center.y / locationZoom + (point.y - center.y) / sizeZoom
  };
},

_getReverseZoomRect : function(rect,node){
   var zm = this.network.zoomManager;
   var locationZoom = zm.getLocationZoom();
   var sizeZoom = zm.getSizeZoom(ui);
   if(locationZoom == sizeZoom){
       return rect;
   }
   var ui = this.network.getElementUI(node);
   var bodyRect = ui.getBodyRect();
   var cx = bodyRect.x + bodyRect.width/2,cy = bodyRect.y + bodyRect.height/2;
   var zoomRect = {
      x : cx * locationZoom + (rect.x - cx) *sizeZoom,
      y : cy * locationZoom + (rect.y - cy) * sizeZoom,
      width : rect.width * sizeZoom,
      height : rect.height * sizeZoom
  };

  cx = zoomRect.x + zoomRect.width/2,cy = zoomRect.y + zoomRect.height/2;
  return {
   x : cx / locationZoom + (zoomRect.x - cx) * sizeZoom,
   y : cy / locationZoom + (zoomRect.y - cy) * sizeZoom,
   width : rect.width,
   height : rect.height
};
},

_handleResizing: function (e) {
    this._handle_mousemove(e);
    var angle = this.node.getAngle();
    var oldLocation = this.node.getLocation();
    var w = this.node.getWidth()/2,h = this.node.getHeight()/2;
    var center = {x : oldLocation.x + w, y : oldLocation.y + h};

        var p1 = {x: (-w),y : (-h)}; // northwest
        var p2 = {x : (-w),y : h}; //southwest
        var p3 = {x : w, y : h};//southeast
        var p4 = {x : w,y :(-h)};//northeast
        var p5 = {x:0,y:-h};//north
        var p6 = {x:w,y:0};//east
        var p7 = {x:0,y:h};//south
        var p8 ={x:-w,y:0};//west
        
        var endLogical = this._getReverseZoomPoint(this.node,_twaver.clone(center),this._endLogical);

        if (this.resizeDirection === 'northwest') {
            this._transformPoint(p3,center,angle);
            p1.x = endLogical.x;
            p1.y = endLogical.y;

            center.x = (p1.x + p3.x) / 2;
            center.y = (p1.y + p3.y) / 2;

            this._reversPoint(p1,center,angle);
            this._reversPoint(p3,center,angle);

            this.resizingRect = {x:p1.x,y:p1.y,width:p3.x-p1.x,height:p3.y - p1.y};
            if(_twaver.isShiftDown(e)){
                this._revertResizeRect(this.node, this.resizingRect, 1)
            }
        }
        if (this.resizeDirection === 'north') {
            var p= {x:endLogical.x, y:endLogical.y};

            this._reversPoint(p,center,angle);
            p5.y = p.y - center.y;
            this._transformPoint(p5,center,angle);
            this._transformPoint(p7,center,angle);


            center.x = (p5.x + p7.x) / 2;
            center.y = (p5.y + p7.y) / 2;

            this._reversPoint(p5,center,angle);
            this._reversPoint(p7,center,angle);

            this.resizingRect = {x:center.x - this.node.getWidth()/2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
        }
        if (this.resizeDirection === 'northeast') {
            this._transformPoint(p2,center,angle);
            p4.x = endLogical.x;
            p4.y = endLogical.y;

            center.x = (p2.x + p4.x) / 2;
            center.y = (p2.y + p4.y) / 2;

            this._reversPoint(p2,center,angle);
            this._reversPoint(p4,center,angle);

            this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
            if(_twaver.isShiftDown(e)){
                this._revertResizeRect(this.node, this.resizingRect, 2)
            }
        }
        if (this.resizeDirection === 'west') {
            var p= {x:endLogical.x, y:endLogical.y};

            this._reversPoint(p,center,angle);
            p8.x = p.x - center.x;
            this._transformPoint(p6,center,angle);
            this._transformPoint(p8,center,angle);


            center.x = (p6.x + p8.x) / 2;
            center.y = (p6.y + p8.y) / 2;

            this._reversPoint(p6,center,angle);
            this._reversPoint(p8,center,angle);


            this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
        }
        if (this.resizeDirection === 'east') {
            var p= {x:endLogical.x, y:endLogical.y};

            this._reversPoint(p,center,angle);
            p6.x = p.x - center.x;
            this._transformPoint(p6,center,angle);
            this._transformPoint(p8,center,angle);


            center.x = (p6.x + p8.x) / 2;
            center.y = (p6.y + p8.y) / 2;

            this._reversPoint(p6,center,angle);
            this._reversPoint(p8,center,angle);


            this.resizingRect = {x:center.x - (p6.x - p8.x) / 2,y:center.y - this.node.getHeight()/ 2,width:p6.x - p8.x,height:this.node.getHeight()};
        }
        if (this.resizeDirection === 'southwest') {
            this._transformPoint(p4,center,angle);
            p2.x = endLogical.x;
            p2.y = endLogical.y;

            center.x = (p2.x + p4.x) / 2;
            center.y = (p2.y + p4.y) / 2;

            this._reversPoint(p2,center,angle);
            this._reversPoint(p4,center,angle);

            this.resizingRect = {x:p2.x,y:p4.y,width:p4.x - p2.x,height:p2.y - p4.y};
            if(_twaver.isShiftDown(e)){
                this._revertResizeRect(this.node, this.resizingRect, 4)
            }
        }
        if (this.resizeDirection === 'south') {
            var p= {x:endLogical.x, y:endLogical.y};

            this._reversPoint(p,center,angle);
            p7.y = p.y - center.y;
            this._transformPoint(p5,center,angle);
            this._transformPoint(p7,center,angle);


            center.x = (p5.x + p7.x) / 2;
            center.y = (p5.y + p7.y) / 2;

            this._reversPoint(p5,center,angle);
            this._reversPoint(p7,center,angle);


            this.resizingRect = {x:center.x - this.node.getWidth() / 2,y:center.y - (p7.y - p5.y)/ 2,width:this.node.getWidth(),height:p7.y - p5.y};
        }
        if (this.resizeDirection === 'southeast') {
            this._transformPoint(p1,center,angle);
            p3.x = endLogical.x;
            p3.y = endLogical.y;

            center.x = (p1.x + p3.x) / 2;
            center.y = (p1.y + p3.y) / 2;

            this._reversPoint(p1,center,angle);
            this._reversPoint(p3,center,angle);

            this.resizingRect = {x:p1.x,y:p1.y,width:p3.x - p1.x,height:p3.y - p1.y};
            if(_twaver.isShiftDown(e)){
                this._revertResizeRect(this.node, this.resizingRect, 3)
            }
        }
        this.resizingRect = this._getReverseZoomRect(this.resizingRect,this.node);
        if (this.lazyMode) {
            this.repaint();
            this.network.fireInteractionEvent({ kind: 'lazyResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
        } else {
            this.node.setLocation(this.resizingRect.x, this.resizingRect.y);
            this.node.setSize(this.resizingRect.width, this.resizingRect.height);
            this.network.fireInteractionEvent({ kind: 'liveResizeBetween', event: e, element: this.node, resizeDirection: this.resizeDirection });
        }
    },
    _revertResizeRect:function(node, rect, type){
        var orgRect = node.getOriginalRect();
        var k = Math.max(rect.width / orgRect.width, rect.height / orgRect.height);
        var w = orgRect.width * k;
        var h = orgRect.height * k;
        var x = rect.x;
        var y = rect.y;
        if(type == 1){
            x += rect.width - w;
            y += rect.height - h;
        }else if(type == 2){
            y += rect.height - h;
        }else if(type == 3){

        }else if(type == 4){
            x += rect.width - w;
        }
        rect.x = x;
        rect.y = y;
        rect.width = w;
        rect.height = h;
    },
    _isEditingShapeNode: function (point) {
        var size = this.network.getEditPointSize();
        if (this.node instanceof twaver.ShapeNode) {
            this.shapeNode = this.node;
            var points = this.network.getShapeNodeZoomPoints(this.node);
            for (var i = 0, n = points.size(); i < n; i++) {
                var p = points.get(i);
                if (this._contains(point, p, size)) {
                    this._setCrossCursor();
                    this.pointIndex = i;
                    return true;
                }
            }
        }
        this.pointIndex = -1;
        return false;
    },
    _isEditingShapeLink: function (point) {
        var size = this.network.getEditPointSize();
        var points = this.network.zoomManager._getShapeLinkZoomPoints(this.shapeLink.getPoints());
        for (var i = 0, n = points.size(); i < n; i++) {
            var p = points.get(i);
            if (this._contains(point, p, size)) {
                this._setCrossCursor();
                this.pointIndex = i;
                return true;
            }
        }
        this.pointIndex = -1;
        return false;
    },
    _isResizingNode: function (point) {
        var size = this.network.getResizePointSize();
        if (size <= 0) {
            return false;
        }
        var zm = this.network.zoomManager;
        var elementUI = this.network.getElementUI(this.node);
        var rect = zm._getElementZoomRect(elementUI,this.node.getOriginalRect());
        var angle = this.node.getAngle();
        var p = {x: rect.x, y:rect.y};
        var rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x, rotatep.y, 'northwest', 'nwse-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width / 2, y: rect.y};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'north', 'ns-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y:rect.y};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,rotatep.x ,rotatep.y, 'northeast', 'nesw-resize')) {
            return true;
        }
        p = {x: rect.x, y:rect.y + rect.height / 2};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'west', 'ew-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y: rect.y + rect.height / 2};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,  rotatep.x ,rotatep.y, 'east', 'ew-resize')) {
            return true;
        }
        p = {x: rect.x, y: rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point,rotatep.x ,rotatep.y, 'southwest', 'nesw-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width / 2, y: rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'south', 'ns-resize')) {
            return true;
        }
        p = {x: rect.x + rect.width, y:rect.y + rect.height};
        rotatep = this._rotatePoint(p,angle,rect);
        if (this._isResizing(point, rotatep.x ,rotatep.y, 'southeast', 'nwse-resize')) {
            return true;
        }
        return false;
    },
    _rotatePoint: function(point,angle,rect) {
        var matrix = $math.createMatrix(angle * Math.PI / 180, rect.x + rect.width / 2, rect.y + rect.height / 2);
        var newPoint = matrix.transform(point);
        return newPoint;
    },
    _isResizing: function (point, x, y, direction, cursor) {
        var zoom = this.network.getGraphicsZoom();
        var size = this.network.getResizePointSize() / zoom;
        if (this._contains(point, { x: x, y: y },size)) {
            if (this.resizeDirection !== direction) {
                this._removeCursor();
                cursor = this._changeCursorWithAngle(direction, this.node.getAngle());
                this._setCursor(cursor);
                this.resizeDirection = direction;
            }
            return true;
        }
        return false;
    },
    _getRect: function (x1, y1, x2, y2) {
        var x = x1 < x2 ? x1 : x2;
        var y = y1 < y2 ? y1 : y2;
        var w = Math.abs(x1 - x2);
        var h = Math.abs(y1 - y2);
        return { x: x, y: y, width: w, height: h };
    },
    _contains: function (point, center, size) {
        var rect = { x: center.x - size, y: center.y - size, width: size * 2, height: size * 2 };
        return $math.containsPoint(rect, point);
    },
    getPointIndex: function (points, point, closed) {
        if(points.size() < 2){
            return 0;
        }
        var p1 = points.get(0), p2;
        for(var i=1; i<points.size(); i++){
            p2 = points.get(i);
            if(this.isPointOnLine(point, p1, p2, 6)){
                return i;
            }
            p1 = p2;
        }
        p1 = points.get(0);
        if(closed && this.isPointOnLine(point, p1, p2, 6)){
            return points.size();
        }
        return 0;
    },
    showRotateScale: function(ctx) {
        var rmpList = new twaver.List(),
        width = this.network.getRotateScaleWidth(),
        height = this.network.getRotateScaleHeight(),
        size = this.network.getRotatePointSize(),
        angle = this.node.getAngle(),
            // rect = this.node.getOriginalRect(),
            zm = this.network.zoomManager,
            elementUI = this.network.getElementUI(this.node),
            rect = zm._getElementZoomRect(elementUI,this.node.getOriginalRect()),
            point = {x: rect.x + rect.width / 2, y: rect.y - this.network.getRotatePointOffset() - size},
            rotatePoint = this._rotatePoint(point, angle, rect),
            rscaleRect,
            font = "13px Arial",
            text = angle + '\u00B0',
            p1,p2,p3,p4,
            viewRect = this.network.getViewRect();
            if(zm.getLocationZoom() === 1){
                ctx.translate(-viewRect.x, -viewRect.y);
                ctx.scale(this.network.getZoom(), this.network.getZoom());
            }

            if(this.node.getAngle() >= 0 && this.node.getAngle() <= 180) {
                p1 = {x: rotatePoint.x + size, y: rotatePoint.y};
                p2 = {x: p1.x + width, y: p1.y};
                p3 = {x: p2.x, y: p2.y -  height};
                p4 = {x: p1.x, y: p3.y};
            } else if (this.node.getAngle() > 180 && this.node.getAngle() <= 360) {
                p1 = {x: rotatePoint.x - size, y: rotatePoint.y};
                p2 = {x: p1.x - width, y: p1.y};
                p3 = {x: p2.x, y: p2.y - height};
                p4 = {x: p1.x, y: p3.y};
            }
            var rscalePointsList = new twaver.List([p1,p2,p3,p4]),
            rscaleRect = _twaver.math.getRect(rscalePointsList);
            if(zm.getLocationZoom() !== 1){
                rscaleRect.x -= viewRect.x;
                rscaleRect.y -= viewRect.y;
            }
            ctx.fillStyle = this.network.getRotateScaleFillColor();
            ctx.fillRect(rscaleRect.x, rscaleRect.y, rscaleRect.width, rscaleRect.height);
            ctx.fillStyle = this.network.getRotateScaleFontColor();
            ctx.textBaseline="middle";
            ctx.textAlign = "center";
            ctx.font = font;
            ctx.fillText(text, rscaleRect.x + rscaleRect.width / 2, rscaleRect.y + rscaleRect.height/2);

            if(zm.getLocationZoom() === 1){
             ctx.scale(1 / this.network.getZoom(), 1 / this.network.getZoom());
             ctx.translate(viewRect.x, viewRect.y);
         }

     },
     isPointOnLine: function (point, point1, point2, width) {
        if(width < 0){
            width = 0;
        }
        var distance = this.getDistanceFromPointToLine(point, point1, point2);
        return distance <= width &&
        (point.x >= Math.min(point1.x, point2.x) - width) &&
        (point.x <= Math.max(point1.x, point2.x) + width) &&
        (point.y >= Math.min(point1.y, point2.y) - width) &&
        (point.y <= Math.max(point1.y, point2.y) + width);
    },
    getDistanceFromPointToLine: function (point, point1, point2) {
        if (point1.x === point2.x) {
            return Math.abs(point.x - point1.x);
        }
        var lineK = (point2.y - point1.y) / (point2.x - point1.x);
        var lineC = (point2.x * point1.y - point1.x * point2.y) / (point2.x - point1.x);
        return Math.abs(lineK * point.x - point.y + lineC) / (Math.sqrt(lineK * lineK + 1));
    },
    _transformPoint : function(p,center,angle){
        var cos = Math.cos(angle * Math.PI / 180);
        var sin = Math.sin(angle * Math.PI / 180);
        var x = p.x;
        var y = p.y;

        var newX = x * cos - y *sin;
        var newY = x * sin + y *cos;

        p.x = newX + center.x;
        p.y = newY + center.y;
    },

    _reversPoint : function(p,center,angle){
        angle *= -1;
        var cos = Math.cos(angle * Math.PI / 180);
        var sin = Math.sin(angle * Math.PI / 180);
        var x = p.x - center.x;
        var y = p.y - center.y;

        var newX = x * cos - y *sin;
        var newY = x * sin + y *cos;

        p.x = newX + center.x;
        p.y = newY + center.y;
    },
    _changeCursorWithAngle: function(direction, angle) {
        var flag,cursorArray = ['auto','nwse-resize','ns-resize','nesw-resize','ew-resize','nwse-resize','ns-resize','nesw-resize','ew-resize'];
        switch(direction)
        {
            case 'northwest':
            flag = 1;
            break;
            case 'north':
            flag = 2
            break;
            case 'northeast':
            flag = 3
            break;
            case 'east':
            flag = 4;
            break;
            case 'southeast':
            flag = 5;
            break;
            case 'south':
            flag = 6;
            break;
            case 'southwest':
            flag = 7;
            break;
            case 'west':
            flag = 8;
            break;
            default:
            flag = 0;
        }
        if(angle >= 360 || angle <= -360) {
            angle = angle % 360;
        }
        if(angle > 45 / 2 && angle <= 135 / 2) {
            flag = flag + 1;
        }
        if(angle < -45/2 && angle >= -135/2) {
            flag = flag - 1;
        }
        if(angle > 135 / 2 && angle <= 225 / 2) {
            flag = flag + 2;
        }
        if(angle < -135 / 2 && angle >= -225 / 2) {
            flag = flag - 2;
        }
        if(angle > 225 / 2 && angle <= 315 / 2) {
            flag = flag + 3;
        }
        if(angle < -225 / 2 && angle >= -315 / 2) {
            flag = flag - 3;
        }
        if(angle > 315 / 2 && angle <= 405 / 2) {
            flag = flag + 4;
        }
        if(angle < -315 / 2 && angle >= -405 / 2) {
            flag = flag - 4;
        }
        if(angle > 405 / 2 && angle <= 495 / 2) {
            flag = flag + 5;
        }
        if(angle < -405 / 2 && angle >= -495 / 2) {
            flag = flag - 5;
        }
        if(angle > 495 / 2 && angle <= 585 / 2) {
            flag = flag + 6;
        }
        if(angle < -495 / 2 && angle >= -585 / 2) {
            flag = flag - 6;
        }
        if(angle > 585 / 2 && angle <= 675 / 2) {
            flag = flag + 7;
        }
        if(angle < -585 / 2 && angle >= -675 / 2) {
            flag = flag - 7;
        }
        if(flag > 8) {
            flag = flag - 8;
        }
        if(flag <= 0) {
            flag = flag + 8;
        }
        return cursorArray[flag];
    }
});

twaver.vector.interaction.MoveLinkInteraction = function(network, lazyMode) {
	twaver.vector.interaction.MoveLinkInteraction.superClass.constructor.call(this, network);
	//this.lazyMode = lazyMode;
	this.xoffset = 0;
	this.yoffset = 0;
};
_twaver.ext('twaver.vector.interaction.MoveLinkInteraction', twaver.vector.interaction.BaseInteraction, {
    setUp: function () {
        this.addListener('mousedown');
        this.oldCursor = this.network.getView().style.cursor;
    },
    tearDown: function () {
        this.removeListener('mousedown'/*, 'mousemove'*/);
        this.network.getView().style.cursor = this.oldCursor;
        this.end();
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        if (this.network.isSelectingElement() || this.network.isEditingElement()) {
            return;
        }
        var element = this.network.getElementAt(e);
        if (!(element instanceof twaver.Link)) {
            return;
        }
        this.element = element;
        this.end(e);
        this._handle_mousedown(e);
    },
    handle_mouseup: function (e) {
        this.end(e);
    },
    handle_mousemove: function (e) {
        if (!this._startLogical
                || this.network.isSelectingElement()
				|| this.network.isEditingElement()) {
            this.end(e);
            return;
        }
        this._handle_mousemove(e);

        this.xoffset = this._endLogical.x - this._startLogical.x;
        this.yoffset = this._endLogical.y - this._startLogical.y;

        if (this.lazyMode) {
            if (this.mark) {
                this.network.fireInteractionEvent({
                    kind: 'lazyMoveBetween',
                    event: e,
                    element: this.element
                });
            } else {
                this.mark = $html.createCanvas();

                var rect;
                this.network.getMovableSelectedElements().forEach(
						function (element) {
						    var ui = this.getElementUI(element);
						    if (ui) {
						        rect = $math.unionRect(rect, ui.getViewRect());
						    }
						}, this.network);

                this.network.getTopDiv().appendChild(this.mark);
                this.network.setMovingElement(true);

                $html.setDiv(this.mark, rect, this.network
								.isLazyMoveFill() ? this.network
								.getLazyMoveFillColor() : null,
						this.network.getLazyMoveOutlineWidth(),
						this.network.getLazyMoveOutlineColor());

                this.network.fireInteractionEvent({
                    kind: 'lazyMoveStart',
                    event: e,
                    element: this.element
                });
            }
            this.mark.style.left = this.xoffset + this.mark._viewRect.x + "px";
            this.mark.style.top = this.yoffset + this.mark._viewRect.y + "px";
        } else {
            var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
            twaver.Util.moveElements(elements, this.xoffset, this.yoffset);
            this._startLogical = this._endLogical;
            this._startClient = $html.getClientPoint(e);
            if (this.network.isMovingElement()) {
                this.network.fireInteractionEvent({
                    kind: 'liveMoveBetween',
                    event: e,
                    element: this.element
                });
            } else {
                this.network.setMovingElement(true);
                this.network.fireInteractionEvent({
                    kind: 'liveMoveStart',
                    event: e,
                    element: this.element
                });
            }
        }
    },
    end: function (e) {
        if (this._startLogical) {
            if (this.lazyMode) {
                if (this.mark) {
                    var self = this;
                    var f = function () {
                        self.network.fireInteractionEvent({
                            kind: 'lazyMoveEnd',
                            event: e,
                            element: this.element
                        });
                        if (self.mark) {
                            self.network.getTopDiv().removeChild(self.mark);
                            self.mark = null;
                            self.network.setMovingElement(false);
                        }
                    };
                    var elements = new twaver.List([this.element.getFromNode(), this.element.getToNode()]);
                    twaver.Util.moveElements(elements, this.xoffset, this.yoffset, this.network.isLazyMoveAnimate(), f);
                }
            } else {
                if (this.network.isMovingElement()) {
                    this.network.setMovingElement(false);
                    this.network.fireInteractionEvent({
                        kind: 'liveMoveEnd',
                        event: e,
                        element: this.element
                    });

                }
            }
            this._handle_mouseup(e);
        delete this.element;
        }
    }
});

twaver.vector.interaction.CreateLinkInteraction = function(network, typeOrLinkFunction) {
	if (!typeOrLinkFunction) {
		typeOrLinkFunction = twaver.Link;
	}
	if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.Link)) {
		this.linkFunction = function(fromNode, toNode) {
			var link = new typeOrLinkFunction();
			if ( link instanceof twaver.Link) {
				link.setFromNode(fromNode);
				link.setToNode(toNode);
			}
			return link;
		};
	} else {
		this.linkFunction = typeOrLinkFunction;
	}
	twaver.vector.interaction.CreateLinkInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.vector.interaction.CreateLinkInteraction', twaver.vector.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousedown', 'mousemove');
		this.network.addMarker(this);
	},
	tearDown : function() {
		this.removeListener('mousedown', 'mousemove');
		this.clear();
		this.network.removeMarker(this);
	},
	paint : function(ctx) {
		ctx.beginPath();
		var rect;
		var r;
		ctx.lineWidth = this.network.getEditLineWidth();
		var lineColor = this.network.getEditLineColor();
		if (this.currentNode && this.currentNode !== this.fromNode) {
			rect = this.network.getElementUI(this.currentNode).getZoomViewRect(true);
			r = this.convertFromUIToMarkerRect(rect, 0, 0);
			$CanvasUtil.rect(ctx, r.x, r.y, r.width, r.height, null, lineColor);
		}
		if (this.fromNode) {
			rect = this.network.getElementUI(this.fromNode).getZoomViewRect(true);
			r = this.convertFromUIToMarkerRect(rect, 0, 0);
			$CanvasUtil.rect(ctx, r.x, r.y, r.width, r.height, null, lineColor);
		}
		if (this.currentPoint) {
			this.paintLine(ctx);
		}
		ctx.closePath();
	},

	convertFromUIToMarkerRect : function(vr, xoff, yoff) {
		var zm = this.network.zoomManager;
		var gzoom = zm.getGraphicsZoom();
		return {
			x : vr.x  * gzoom - this.network.getViewRect().x + xoff  * gzoom,
			y : vr.y  * gzoom - this.network.getViewRect().y + yoff  * gzoom,
			width : vr.width  * gzoom,
			height : vr.height  * gzoom
		};
	},
	
	getZoomNodeRectOrPoint : function(node,returnPoint){
		var rect = this.network.getElementUI(node).getZoomBodyRect();
		if(returnPoint){
			return {
				x : rect.x + rect.width/2,
				y : rect.y + rect.height/2
			};
		}
		return rect;
	},

	paintLine : function(ctx) {
		var lineColor = this.network.getEditLineColor();
		var rect = this.network.getElementUI(this.fromNode).getZoomBodyRect();
		var center = this.convertPointFromView({
			x : rect.x + rect.width/2,
			y : rect.y + rect.height/2,
		});
		var x1 = center.x, y1 = center.y;
		var x2 = this.currentPoint.x, y2 = this.currentPoint.y;
		ctx.strokeStyle = lineColor;
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
	},
	clear : function() {
		this.currentPoint = null;
		this.currentNode = null;
		this.fromNode = null;
		this.toNode = null;
	},
	createLink : function() {
		return this.linkFunction(this.fromNode, this.toNode);
	},
	handle_mousedown : function(e) {
		if (!this.network.isValidEvent(e)) {
			return;
		}
		if (this.fromNode) {
			this.toNode = this.currentNode;
			if (this.toNode) {
				var link = this.createLink();
				if (link) {
					this.network.addElementByInteraction(link);
				}
			}
			this.clear();
		} else {
			this.fromNode = this.currentNode;
			this.currentNode = null;
			this.currentPoint = null;
			this.repaint();
		}
	},
	handle_mousemove : function(e) {
		var point = this.getMarkerPoint(e);
		if (!point) {
			return;
		}
		if (this.network.isMovingElement() || this.network.isEditingElement()) {
			this.clear();
			return;
		}
		var node = null;
		if (this.fromNode) {
			this.currentNode = this.getToNode(e, this.fromNode);
			this.currentPoint = point;
			this.repaint();
		} else {
			node = this.getFromNode(e);
			if (this.currentNode !== node) {
				this.currentNode = node;
				this.repaint();
			}
		}
	},
	getFromNode : function(e) {
		return this.getNode(e);
	},
	getToNode : function(e, fromNode) {
		return this.getNode(e, fromNode);
	},
	getNode: function (e, fromNode) {
        var node = this.network.getElementAt(e);
        if (node instanceof $Node && this.network.isLinkable(node, fromNode) && this.network.getElementBox().getSelectionModel().isSelectable(node)) {
            return node;
        }
        return null;
    }
});

twaver.vector.interaction.CreateShapeLinkInteraction = function (network, typeOrLinkFunction) {
    twaver.vector.interaction.CreateShapeLinkInteraction.superClass.constructor.call(this, network);
    if (!typeOrLinkFunction) {
        typeOrLinkFunction = twaver.ShapeLink;
    }
    if (twaver.Util.isTypeOf(typeOrLinkFunction, twaver.ShapeLink)) {
        this.linkFunction = function (fromNode, toNode, points) {
            var link = new typeOrLinkFunction();
            if (link instanceof twaver.ShapeLink) {
                link.setFromNode(fromNode);
                link.setToNode(toNode);
                if (points) {
                	var zm = this.network.zoomManager;
                    link.setPoints(zm._getShapeLinkZoomPoints(points,true));
                }
            }
            return link;
        };
    } else {
        this.linkFunction = typeOrLinkFunction;
    }
};
_twaver.ext('twaver.vector.interaction.CreateShapeLinkInteraction', twaver.vector.interaction.CreateLinkInteraction, {
    clear: function () {
        this.points = null;
        twaver.vector.interaction.CreateShapeLinkInteraction.superClass.clear.call(this);
    },
    createLink: function () {
        return this.linkFunction(this.fromNode, this.toNode, this.points);
    },
    handle_mousedown: function (e) {
        if (e.button !== 0) {
            return;
        }
        var point = this.network.getLogicalPoint2(e);
        if (!point) {
            return;
        }
        if (this.fromNode) {
            this.toNode = this.currentNode;
            if (this.toNode) {
                var shapeLink = this.createLink();
                if (shapeLink) {
                    this.network.addElementByInteraction(shapeLink);
                }
                this.clear();
            } else {
                if (!this.points) {
                    this.points = new twaver.List();
                }
                if (this.points.size() > 0) {
                    var lastPoint = this.points.get(this.points.size() - 1);
                    if (lastPoint.x === point.x && lastPoint.y === point.y) {
                        return;
                    }
                }
                this.points.add(point);
            }
        } else {
            this.fromNode = this.currentNode;
            this.points = null;
            this.currentNode = null;
            this.currentPoint = null;
        }
        this.repaint();
    },
    paintLine: function (ctx) {
        if (this.currentPoint) {
            var newPoints = new twaver.List();
            var np;
            np = this.convertPointFromView(this.getZoomNodeRectOrPoint(this.fromNode,true));
            newPoints.add(np, 0);
            if (this.points && this.points.size() > 0) {
                var size = this.points.size();
                for (var i = 0; i < size; i++) {
                    np = this.convertPointFromView(this.points.get(i));
                    newPoints.add(np);
                }
            }
            // np = this.convertPointFromView(this.currentPoint);
            np = this.currentPoint;
            newPoints.add(np);
            ctx.lineWidth = this.network.getEditLineWidth();
            ctx.strokeStyle = this.network.getEditLineColor();
            ctx.beginPath();
            $g.drawLinePoints(ctx, newPoints);
            ctx.stroke();
        }
    }
});

twaver.vector.interaction.CreateShapeNodeInteraction = function(network, typeOrShapeNodeFunction) {
	if (!typeOrShapeNodeFunction) {
		typeOrShapeNodeFunction = twaver.ShapeNode;
	}
	if (twaver.Util.isTypeOf(typeOrShapeNodeFunction, twaver.ShapeNode)) {
		this.shapeNodeFunction = function(points) {
			var shapeNode = new typeOrShapeNodeFunction();
			if ( shapeNode instanceof twaver.ShapeNode) {
				var zm = this.network.zoomManager;
				var ui = this.network.createElementUI(shapeNode);
				if (points) {
					var ps = zm._getShapeNodeZoomPoints(ui, points,true);
					ui.invalidateZoom();
					shapeNode.setPoints(ps);
				}
			}
			return shapeNode;
		};
	} else {
		this.shapeNodeFunction = typeOrShapeNodeFunction;
	}
	twaver.vector.interaction.CreateShapeNodeInteraction.superClass.constructor.call(this, network);
	this.timeStamp = -1; 
};
_twaver.ext('twaver.vector.interaction.CreateShapeNodeInteraction', twaver.vector.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousedown', 'mousemove');
		this.network.addMarker(this);
	},
	tearDown : function() {
		this.removeListener('mousedown', 'mousemove');
		this.clear();
		this.network.removeMarker(this);
		this.network.setEditingElement(false);
	},
	clear : function() {
		this.points = null;
		this.currentPoint = null;
	},
	paint : function(ctx) {
		if (this.points && this.points.size() > 0) {
			if (this.currentPoint) {
				var newPoints = new twaver.List();
				var size = this.points.size();
				var np;
				for (var i = 0; i < size; i++) {
					np = this.convertPointFromView(this.points.get(i));
					newPoints.add(np);
				}
				np = this.convertPointFromView(this.currentPoint);
				newPoints.add(np);
				ctx.lineWidth = this.network.getEditLineWidth();
				ctx.strokeStyle = this.network.getEditLineColor();
				ctx.beginPath();
				$g.drawLinePoints(ctx, newPoints);
				ctx.stroke();
			}
		}
	},
	handle_mousedown : function(e) {
    if (e.button !== 0) {
        return;
    }
		var point = this.network.getLogicalPoint2(e);
		if (!point) {
			return;
		}
		if (e.detail === 2 || e.timeStamp - this.timeStamp < 300) {
			if (this.points) {
				var shapeNode = this.shapeNodeFunction(this.points);
				this.network.addElementByInteraction(shapeNode);
				this.clear();
				var self = this;
				setTimeout(function() {
					self.network.setEditingElement(false);
				}, 0);
			}
		} else {
			if (!this.network.isEditingElement()) {
				this.network.setEditingElement(true);
			}
			if (!this.points) {
				this.points = new twaver.List();
			}
			if (this.points.size() > 0) {
				var lastPoint = this.points.get(this.points.size() - 1);
				if (lastPoint.x === point.x && lastPoint.y === point.y) {
					return;
				}
			}
			this.points.add(point);
		}
		this.timeStamp = e.timeStamp;
		this.repaint();
	},
	handle_mousemove : function(e) {
		if (this.points) {
			this.currentPoint = this.network.getLogicalPoint2(e);
			this.repaint();
		}
	}
});

twaver.vector.interaction.MagnifyInteraction = function(network, scale, xRadius, yRadius, shape) {
	twaver.vector.interaction.MagnifyInteraction.superClass.constructor.call(this, network);
	this.scale = scale || 2;
	this.xRadius = xRadius || 100;
	this.yRadius = yRadius || 100;
	this.shape = shape || 'circle';
	this.borderColor = 'black';
	this.borderWidth = 1;
	this.backgroundColor = 'white';
	this.markCanvas = $html.createCanvas();
};
_twaver.ext('twaver.vector.interaction.MagnifyInteraction', twaver.vector.interaction.BaseInteraction, {
	setUp : function() {
		this.addListener('mousemove');
		this.addListener('mousewheel');
		this.network.addMarker(this);
	},
	tearDown : function() {
		this.removeListener('mousemove');
		this.removeListener('mousewheel');
		this.network.removeMarker(this);
	},
	paint : function(ctx) {
		if (this.point) {
			var zm = this.network.zoomManager;
			var locationZoom = zm.getLocationZoom();
			var gzoom = zm.getGraphicsZoom();
			var sizeZoom = zm.getSizeZoom();
			var zoom = this.network.getZoom();
			var halfWidth = this.xRadius / this.scale / gzoom;
			var halfHeight = this.yRadius / this.scale / gzoom;

			if(this.mouseFlag === "mousewheel"){
				var rect = {
					x : this.zoomPoint.x - halfWidth,
					y : this.zoomPoint.y - halfHeight,
					width : halfWidth * 2,
					height : halfHeight * 2
				};
				this.network.toCanvasByRegion(rect, this.scale * gzoom, this.markCanvas,'white');
				var r = {
					x: this.zoomPoint.x  - this.xRadius - this.network.viewRect.x, 
					y: this.zoomPoint.y  - this.yRadius - this.network.viewRect.y,
					width: this.markCanvas.width,
					height: this.markCanvas.height
				}
			}else {
				var rect = {
					x : this.point.x * locationZoom - halfWidth,
					y : this.point.y * locationZoom  - halfHeight,
					width : halfWidth * 2,
					height : halfHeight * 2
				};
				this.network.toCanvasByRegion(rect, this.scale * gzoom, this.markCanvas,'white');
				var r = {
					x: this.point.x * locationZoom * gzoom - this.xRadius - this.network.viewRect.x, 
					y: this.point.y * locationZoom * gzoom - this.yRadius - this.network.viewRect.y,
					width: this.markCanvas.width,
					height: this.markCanvas.height
				}
			}
			ctx.save();
      ctx.beginPath();
      $g.drawVector(ctx, this.shape, null, r.x , r.y, 2 * rect.width * gzoom, 2 * rect.height * gzoom);
      ctx.clip();
      ctx.fillStyle =this.backgroundColor;
      ctx.beginPath();
      ctx.rect(r.x,r.y,r.width,r.height);
      ctx.fill();
      ctx.drawImage(this.markCanvas, r.x, r.y);
      ctx.restore();

      ctx.beginPath();
      ctx.lineWidth = this.borderWidth;
      $g.drawVector(ctx, this.shape, null, r.x + this.borderWidth/2 , r.y + this.borderWidth/2 , 2 * rect.width * gzoom - this.borderWidth, 2 * rect.height * gzoom - this.borderWidth);
      ctx.strokeStyle = this.borderColor;
      ctx.stroke();
      this.mouseFlag = null;
		}
	},
	handle_mousemove : function(e) {
		this.point = this.network.getLogicalPoint(e);
		if (!this.point) {
			return;
		}
		this.mouseFlag = "mousemove";
		this.repaint();
	},
	handle_mousewheel : function(e) {
		var zm = this.network.zoomManager;
		var locationZoom = zm.getLocationZoom();
		if(locationZoom !== 1){
			this.zoomPoint = this.network.getLogicalPoint2(e);
		}
		if (!this.zoomPoint) {
			return;
		}
		this.mouseFlag = "mousewheel";
		this.repaint();
	},
	getScale: function () {
	    return this.scale;
	},
	setScale: function (value) {
	    this.scale = value;
	    this.network.repaintTopCanvas();
	},
	getShape: function () {
	    return this.shape;
	},
	setShape: function (value) {
	    this.shape = value;
	    this.network.repaintTopCanvas();
	},
	getXRadius: function () {
	    return this.xRadius;
	},
	setXRadius: function (value) {
	    this.xRadius = value;
	    this.network.repaintTopCanvas();
	},
	getYRadius: function () {
	    return this.yRadius;
	},
	setYRadius: function (value) {
	    this.yRadius = value;
	    this.network.repaintTopCanvas();
	},
	getBorderColor: function () {
	    return this.borderColor;
	},
	setBorderColor: function (value) {
	    this.borderColor = value;
	    this.network.repaintTopCanvas();
	},
	getBorderWidth: function () {
	    return this.borderWidth;
	},
	setBorderWidth: function (value) {
	    this.borderWidth = value;
	    this.network.repaintTopCanvas();
	},
	getBackgroundColor: function () {
	    return this.backgroundColor;
	},
	setBackgroundColor: function (value) {
	    this.backgroundColor = value;
	    this.network.repaintTopCanvas();
	}
});

twaver.vector.interaction.TouchInteraction = function (network) {
    twaver.vector.interaction.TouchInteraction.superClass.constructor.call(this, network);
};
_twaver.ext('twaver.vector.interaction.TouchInteraction', twaver.vector.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener('touchstart', 'handleTouchstart', view, this);
        $html.addEventListener('touchmove', 'handleTouchmove', view, this);
        $html.addEventListener('touchend', 'handleTouchend', view, this);
        $html.addEventListener('touchcancel', 'handleTouchend', view, this);
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener('touchstart', view, this);
        $html.removeEventListener('touchmove', view, this);
        $html.removeEventListener('touchend', view, this);
        $html.removeEventListener('touchcancel', view, this);
    },
    _isDragToSelect : function(e){
        return !this.network._dragToPan;
    },
    handleTouchstart: function (e) {
        $html.preventDefault(e);
        this.isMoving = false;
        this.isSelecting = false;
        if (e.touches.length == 1) {
            var point = this.network.getLogicalPoint2(e);
            var element = this._element = this.network.getElementAt(point);
            this._startTouchTime = new Date();
            this._currentTouchPoint = point;
            this._startTouchClient = this._currentTouchClient = this.getMarkerPoint(e);

            if (element) {
                if (!this.network.getSelectionModel().contains(element)) {
                    this.network.getSelectionModel().setSelection(element);
                    var sm = this.network.getSelectionModel();
                    if(sm.contains(element)){
                        this.isSelecting = true;
                    }
                }else{
                    this.isSelecting = true;
                }
            } else {
                this.isSelecting = false;
                this.network.getSelectionModel().clearSelection();
            }

            $network_interaction.handleClicked(this.network, e, element);

            if (this._endTouchTime
                && (this._startTouchTime.getTime() - this._endTouchTime.getTime()) <= 500
                && $math.getDistance(this._endTouchClient, this._startTouchClient) <= 20) {
                delete this._endTouchTime;
            delete this._endTouchClient;
            $network_interaction.handleDoubleClicked(this.network, e, element);
        } else {
            this._endTouchTime = this._startTouchTime;
            this._endTouchClient = this._startTouchClient;
        }

    } else {
        this._distance = $touch.getDistance(e);
        this._zoom = this.network.getZoom();
    }
},
handleTouchmove: function (e) {
    $html.preventDefault(e);
    if (e.touches.length > 1) {
        var newDistance = $touch.getDistance(e);
        if (Math.abs(newDistance - this._distance) < 20) {
            return;
        }
        var scale = newDistance / this._distance;
        this.network.setZoom(this._zoom * scale, false);
    } else if (this._zoom == null) {
        var newClientPoint = this.getMarkerPoint(e);
        if ($math.getDistance(this._startTouchClient, newClientPoint) < 20) {
            return;
        }
        if (this._element) {
            if(!this.isSelecting && !this._isDragToSelect(e)){
                //pan
                var xoffset = this._currentTouchClient.x - newClientPoint.x;
                var yoffset = this._currentTouchClient.y - newClientPoint.y;
                this.network.panByOffset(xoffset, yoffset);
                this._currentTouchClient = newClientPoint;
            }else{
                var newPoint = this.network.getLogicalPoint2(e);
                //drag element
                var offset = this.getOffset(newPoint, this._currentTouchPoint);
                var xoffset = offset.x;
                var yoffset = offset.y;
                this._currentTouchPoint = newPoint;
                this.network.moveSelectedElements(xoffset, yoffset);
                if (this.network.isMovingElement()) {
                    this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                } else {
                    this.network.setMovingElement(true);
                    this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                }
            }
        } else {
                //pan
                var xoffset = this._currentTouchClient.x - newClientPoint.x;
                var yoffset = this._currentTouchClient.y - newClientPoint.y;
                this.network.panByOffset(xoffset, yoffset);
                this._currentTouchClient = newClientPoint;
            }
        }
    },
    handleTouchend: function (e) {
        $html.preventDefault(e);
        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        }
        if (e.touches.length === 0) {
            this._distance = null;
            this._zoom = null;
            this._element = null;
            this._startTouchTime = null;
            this._currentTouchPoint = null;
            this._startTouchClient = this._currentTouchClient = null;
        }
    }
});
twaver.vector.interaction.MSTouchInteraction = function (network) {
    twaver.vector.interaction.MSTouchInteraction.superClass.constructor.call(this, network);
    this._pointerMap = {};
    this._pointerIdArray = [];
};
_twaver.ext('twaver.vector.interaction.MSTouchInteraction', twaver.vector.interaction.BaseInteraction, {
    setUp: function () {
        var view = this.network.getView();
        $html.addEventListener("MSPointerDown", "handleTouchstart", view, this);
        $html.addEventListener("MSPointerMove", "handleTouchmove", view, this);
        $html.addEventListener("MSPointerUp", "handleTouchend", view, this);
        $html.addEventListener("MSPointerCancel", "handleTouchend", view, this);
        this.network.addMarker(this);
    },
    tearDown: function () {
        var view = this.network.getView();
        $html.removeEventListener("MSPointerDown", view, this);
        $html.removeEventListener("MSPointerMove", view, this);
        $html.removeEventListener("MSPointerUp", view, this);
        $html.removeEventListener("MSPointerCancel", view, this);
        this.network.removeMarker(this);
    },
    handleTouchstart: function (e) {
        if (this.network.isFocusOnClick()) {
            twaver.Util.setFocus(this.network._view);
        }

        if (this.network.isSelectingElement() && e.pointerType == e.MSPOINTER_TYPE_MOUSE) {
            return;
        }

        var currentTouchPoint = this.network.getLogicalPoint2(e);
        var currentTouchTime = new Date();


        if (e.isPrimary && this._pointerIdArray.length > 0) {
            this.handle_mouseup(e);
        }

        if (!this._pointerMap[e.pointerId]) {
            this._pointerIdArray.push(e.pointerId);
            this._pointerMap[e.pointerId] = e;
        }
        if (this._pointerIdArray.length == 1) {
            var element = this.network.getElementAt(currentTouchPoint);
            this._startTouchElement = element;
            this._startClientPoint = { x: e.clientX, y: e.clientY };

            var sm = this.network.getSelectionModel();
            if (element) {
                if (_twaver.isCtrlDown(e)) {
                    if (sm.contains(element)) {
                        sm.removeSelection(element);
                    } else {
                        sm.appendSelection(element);
                    }
                } else {
                    if (!sm.contains(element)) {
                        sm.setSelection(element);
                    }
                }
            } else {
                if (!_twaver.isCtrlDown(e)) {
                    sm.clearSelection();
                }
            }

            //this._startClientPoint = this.getMarkerPoint(e);
            $network_interaction.handleClicked(this.network, e, element); //click
            if (this._startTouchTime
                && this._startTouchPoint
                && currentTouchTime.getTime() - this._startTouchTime.getTime() <= 500
                && $math.getDistance(this._startTouchPoint, currentTouchPoint) <= 20) {
                $network_interaction.handleDoubleClicked(this.network, e, element); //double click
                this._doubleClick = true;
            } else {
                $html.handle_mousedown(this, e);
                this._startTouchPoint = currentTouchPoint;
                this._startTouchTime = currentTouchTime;
            }
        } else if (this._pointerIdArray.length == 2) {
            this._distance = this._getDistance();
            this._zoom = this.network.getZoom();
        }

    },
    handleTouchmove: function (e) {
        if (this._startTouchPoint == null || this._pointerIdArray.length == 0 || !this._pointerMap[e.pointerId] || $math.getDistance({ x: this._pointerMap[e.pointerId].pageX, y: this._pointerMap[e.pointerId].pageY }, { x: e.pageX, y: e.pageY }) <= 10) {
            return;
        }
        this._pointerMap[e.pointerId] = e;
        if (this._pointerIdArray.length == 2) {
            var scale = this._getDistance() / this._distance;
            this.network.setZoom(this._zoom * scale, false);
        }
    },
    handleTouchend: function (e) {
        if (this.network.isMovingElement()) {
            this.network.setMovingElement(false);
            this.network.fireInteractionEvent({ kind: 'liveMoveEnd', event: e });
        }
        if (this.network.isSelectingElement()) {
            var rect = $math.getRect([this._startTouchPoint, this._moveTouchPoint]);
            var elements = this.network.getElementsAtRect(rect, this.getIntersectMode(), this.network.getRectSelectFilter());
            if (elements && elements.size() > 0) {
                var sm = this.network.getSelectionModel();
                var selections = sm.toSelection();
                elements.forEach(function (element) {
                    if (sm.contains(element)) {
                        selections.remove(element);
                    } else {
                        selections.add(element);
                    }
                }, this);
                sm.setSelection(selections);
            }
            this.network.fireInteractionEvent({ kind: 'selectEnd', event: e });
            this._moveTouchPoint = null;
            this.network.setSelectingElement(false);
            this.repaint();
        }
        if (this._doubleClick) {
            delete this._doubleClick;
            delete this._startTouchPoint;
            delete this._startTouchTime;
        }
        var index = -1;
        for (var i = 0; i < this._pointerIdArray.length; i++) {
            if (this._pointerIdArray[i] == e.pointerId) {
                index = i;
                break;
            }
        }
        if (index >= 0) this._pointerIdArray.splice(index, 1);
        delete this._pointerMap[e.pointerId];
        this._moveTouchPoint = null;
    },
    _getDistance: function () {
        return $math.getDistance({ x: this._pointerMap[this._pointerIdArray[0]].pageX, y: this._pointerMap[this._pointerIdArray[0]].pageY }, { x: this._pointerMap[this._pointerIdArray[1]].pageX, y: this._pointerMap[this._pointerIdArray[1]].pageY });
    },
    getIntersectMode: function () {
        if (this.network.getSelectMode() === 'intersect') {
            return true;
        }
        if (this.network.getSelectMode() === 'contain') {
            return false;
        }
        return this._startTouchPoint.x > this._moveTouchPoint.x && this._startTouchPoint.y > this._moveTouchPoint.y;
    },
    handle_mousemove: function (e) {

        //e.buttons >= 1 &&
        var newClientPoint = { x: e.clientX, y: e.clientY };
        if ($math.getDistance(this._startClientPoint, newClientPoint) < 3) return;
        if (this._startTouchPoint && this._pointerIdArray.length == 1) {
            this._moveTouchPoint = {
                x: this._startTouchPoint.x + (newClientPoint.x - this._startClientPoint.x) / this.network.getZoom(),
                y: this._startTouchPoint.y + (newClientPoint.y - this._startClientPoint.y) / this.network.getZoom()
            };
            if (this._startTouchElement == null && this.network.isRectSelectEnabled()) {
                var point = this.network.getLogicalPoint2(e);
                if (!point) {
                    return;
                }
                //rect select
                this.network.setSelectingElement(true);
                if (this._moveTouchPoint) {
                    this.network.fireInteractionEvent({ kind: 'selectBetween', event: e });
                } else {
                    this.network.fireInteractionEvent({ kind: 'selectStart', event: e });
                }
                //this._moveTouchPoint = point;
                this.repaint();
            } else {
                var element = this.network.getElementAt(this._moveTouchPoint);

                if (this._startTouchElement == null && !this.network.isRectSelectEnabled()) {
                    var xoffset = this._startClientPoint.x - newClientPoint.x;
                    var yoffset = this._startClientPoint.y - newClientPoint.y;
                    this.network.panByOffset(xoffset, yoffset);
                } else if (this.network.isMovingElement() || (this._startTouchElement != null && element == this._startTouchElement && this.network.getMovableSelectedElements().contains(element))) {
                    var xoffset = this._moveTouchPoint.x - this._startTouchPoint.x;
                    var yoffset = this._moveTouchPoint.y - this._startTouchPoint.y;
                    this.network.moveSelectedElements(xoffset, yoffset);
                    if (this.network.isMovingElement()) {
                        this.network.fireInteractionEvent({ kind: 'liveMoveBetween', event: e });
                    } else {
                        this.network.setMovingElement(true);
                        this.network.fireInteractionEvent({ kind: 'liveMoveStart', event: e });
                    }
                }
                this._startClientPoint = newClientPoint;
            }
        }
    },
    handle_mouseup: function (e) {
        this.handleTouchend(e);
        this._pointerIdArray = [];
        this._pointerMap = {};
    },
    paint: function (ctx) {
        if (!this._startTouchPoint || !this._moveTouchPoint || this._startTouchElement || !this.network.isRectSelectEnabled()) {
            return;
        }
        var sp = this.convertPointFromView(this._startTouchPoint);
        var ep = this.convertPointFromView(this._moveTouchPoint);
        var sx = sp.x;
        var sy = sp.y;
        var ex = ep.x;
        var ey = ep.y;
        var rect = $math.getRect([{ x: sx, y: sy }, { x: ex, y: ey}]);
        if (rect != null) {
            ctx.beginPath();
            var lineWidth = this.network.getSelectOutlineWidth();
            var fillStyle = this.getIntersectMode() ? this.network.getSelectFillColor() : null;
            ctx.strokeStyle = this.network.getSelectOutlineColor();
            ctx.lineWidth = lineWidth;
            $CanvasUtil.rect(ctx, rect.x, rect.y, rect.width, rect.height, fillStyle, this.network.getSelectOutlineColor());
            ctx.closePath();
        }
    }
});
twaver.XmlSerializer = function (dataBox, settings, filterFunction) {
    this.dataBox = dataBox;
    this.settings = settings ? settings : new twaver.SerializationSettings();
    this.filterFunction = filterFunction;
    this.ref = 0;
    this.refMap = {};
    this.idMap = {};
    this.xmlString = '';
};
_twaver.ext('twaver.XmlSerializer', Object, {
    serialize: function () {
        this.xmlString = "<twaver version='" + twaver.Util.getVersion() + "' platform='html5'>\n";
        this.serializeBody();
        this.xmlString += "</twaver>\n";
        return this.xmlString;
    },
    serializeBody: function () {
        this.ref = 0;
        this.dataBox.getRoots().forEach(this.initRefs, this);

        if (this.settings.isDataBoxSerializable) {
            this.xmlString += "<dataBox class='" + this.dataBox.getClassName() + "'>\n";
            this.dataBox.serializeXml(this, this.dataBox.newInstance());
            this.xmlString += "</dataBox>\n";
        }

        this.dataBox.getRoots().forEach(this.serializeData, this);
    },
    initRefs: function (data) {
        this.refMap[data.getId()] = this.ref++;
        data.getChildren().forEach(this.initRefs, this);
    },
    isSerializable: function (data) {
        if (!this.dataBox.contains(data)) {
            return false;
        }
        if (this.filterFunction && !this.filterFunction(data)) {
            return false;
        }
        return true;
    },
    serializeData: function (data) {
        if (this.isSerializable(data)) {
            var newInstance = data.newInstance();
            var ref = this.refMap[data.getId()];

            this.xmlString += "<data class='" + data.getClassName() + "' ref='" + ref + "'";
            if (this.settings.getPropertyType("id") != null) {
                this.xmlString += " id='" + data.getId() + "'";
            }
            this.xmlString += ">\n";
            data.serializeXml(this, newInstance);
            this.xmlString += "</data>\n";
        }
        data.getChildren().forEach(this.serializeData, this);
    },
    serializePropertyXml: function (instance, property, newInstance) {
        var type = this.settings.getPropertyType(property);
        if (type) {
            var value = _twaver.getValue(instance, property, type);
            var newInstanceValue = _twaver.getValue(newInstance, property, type);
            if (value !== newInstanceValue) {
                this.serializeValue("p", property, value, newInstanceValue, type);
            }
        }
    },
    serializeStyleXml: function (instance, style, newInstance) {
        var type = this.settings.getStyleType(style);
        if (type) {
            var value = instance.getStyle(style);
            var newInstanceValue = newInstance.getStyle(style);
            if (value != newInstanceValue) {
                this.serializeValue("s", style, value, newInstanceValue, type);
            }
        }
    },
    serializeClientXml: function (instance, client, newInstance) {
        var type = this.settings.getClientType(client);
        if (type != null) {
            var value = instance.getClient(client);
            var newInstanceValue = newInstance.getClient(client);
            if (value != newInstanceValue) {
                this.serializeValue("c", client, value, newInstanceValue, type);
            }
        }
    },
    serializeValue: function (c, property, value, newInstanceValue, type) {
        if (value == null) {
            this.xmlString += "\t<" + c + " n='" + property + "' none=''/>\n";
        }
        else if (type === 'cdata') {
            this.xmlString += "\t<" + c + " n='" + property + "'><![CDATA[" + value + "]]></" + c + ">\n";
        }
        else if (type === 'data') {
            var dataRef = this.refMap[value.getId()];
            if (dataRef != null) {
                this.xmlString += "\t<" + c + " n='" + property + "' ref='" + dataRef + "'/>\n";
            }
        }
        else if (type === 'point') {
            if (!newInstanceValue || value.x !== newInstanceValue.x || value.y !== newInstanceValue.y) {
                this.xmlString += "\t<" + c + " n='" + property + "' x='" + value.x + "' y='" + value.y + "'/>\n";
            }
        }
        else if (type === 'list.point') {
            this.xmlString += "\t<" + c + " n='" + property + "'>\n";
            value.forEach(function (point) {
                this.xmlString += "\t\t<p x='" + point.x + "' y='" + point.y + "'/>\n";
            }, this);
            this.xmlString += "\t</" + c + ">\n";
        }
        else if (type === 'list.string' || type === 'list.number') {
            this.xmlString += "\t<" + c + " n='" + property + "'>\n";
            value.forEach(function (item) {
                this.xmlString += "\t\t<s>" + item + "</s>\n";
            }, this);
            this.xmlString += "\t</" + c + ">\n";
        }
        else if (type === 'rectangle') {
            this.xmlString += "\t<" + c + " n='" + property + "' x='" + value.x + "' y='" + value.y + "' w='" + value.width + "' h='" + value.height + "'/>\n";
        }
        else {
            this.xmlString += "\t<" + c + " n='" + property + "'>" + value + "</" + c + ">\n";
        }
    },
    deserialize: function (xmlString, rootParent) {
        _twaver.isDeserializing = true;
        this.xmlString = xmlString;
        var xml = _twaver.xml(xmlString).documentElement;

        this.refMap = {};
        this.idMap = {};

        var list = new $List(),
        xmlList = new $List(),
        data, dataXml, i,
        // create datas
        datas = xml.getElementsByTagName('data'),
        count = datas.length;

        for (i = 0; i < count; i++) {
            dataXml = datas[i];
            var type = dataXml.getAttribute('class');
            var idType = this.settings.getPropertyType('id');
            if (idType && dataXml.hasAttribute('id')) {
                // create id value
                var id = null;
                if (idType === 'string') {
                    id = dataXml.getAttribute('id');
                }
                else if (idType === 'int') {
                    id = parseInt(dataXml.getAttribute('id'));
                }
                else if (idType === 'number') {
                    id = parseFloat(dataXml.getAttribute('id'));
                }
                else {
                    throw "Unsupported id type '" + idType + "'";
                }
                // remove old data
                if (dataXml.getAttribute('action') === "remove") {
                    this.dataBox.removeById(id);
                    continue;
                }
                // update old data
                data = this.dataBox.getDataById(id);
                // create new data
                if (!data) {
                    data = _twaver.newInstance(type, id);
                }
            } else {
                data = _twaver.newInstance(type);
            }
            if (dataXml.hasAttribute('ref')) {
                var ref = dataXml.getAttribute('ref');
                this.refMap[ref] = data;
            }
            list.add(data);
            xmlList.add(dataXml);
            this.idMap[data.getId()] = data;
        }

        // add all datas to idmap
        this.dataBox.forEach(function (data) {
            this.idMap[data.getId()] = data;
        }, this);

        // fill all datas properties
        count = list.size();
        for (i = 0; i < count; i++) {
            data = list.get(i);
            dataXml = xmlList.get(i);
            data.deserializeXml(this, dataXml);
        }

        // add all datas into box
        for (i = 0; i < count; i++) {
            data = list.get(i);
            if (this.dataBox.containsById(data.getId())) {
                continue;
            }
            if (rootParent && !data.getParent()) {
                data.setParent(rootParent);
            }
            this.dataBox.add(data);
        }
        // fill databox properties
        if (this.settings.isDataBoxSerializable && xml.getElementsByTagName("dataBox").length === 1) {
            this.dataBox.deserializeXml(this, xml.getElementsByTagName("dataBox")[0]);
        }
        _twaver.isDeserializing = false;
    },
    deserializePropertyXml: function (instance, xml, property) {
        var type = this.settings.getPropertyType(property);
        if (type) {
            _twaver.setValue(instance, property, this.deserializeValue(xml, type));
        }
    },
    deserializeStyleXml: function (instance, xml, property) {
        var type = this.settings.getStyleType(property);
        if (type) {
            instance.setStyle(property, this.deserializeValue(xml, type));
        }
    },
    deserializeClientXml: function (instance, xml, property) {
        var type = this.settings.getClientType(property);
        if (type) {
            instance.setClient(property, this.deserializeValue(xml, type));
        }
    },
    deserializeValue: function (xml, type) {
        if (xml.hasAttribute("@none")) {
            return null;
        }
        if (type === 'string') {
            return xml.textContent;
        }
        if (type === 'number') {
            return parseFloat(xml.textContent);
        }
        if (type === 'boolean') {
            return xml.textContent === "true";
        }
        if (type === 'int') {
            return parseInt(xml.textContent);
        }
        if (type === 'point') {
            return { x: parseFloat(xml.getAttribute('x')), y: parseFloat(xml.getAttribute('y')) };
        }
        if (type === 'data') {
            var ref = xml.getAttribute('ref');
            var data = this.refMap[ref];
            if (data) {
                return data;
            } else {
                return this.idMap[ref];
            }
        }
        var count, numbers, ss, i;
        if (type === 'list.point') {
            var points = new $List();
            var ps = xml.getElementsByTagName('p');
            count = ps.length;
            for (i = 0; i < count; i++) {
                var p = ps[i];
                points.add({ x: parseFloat(p.getAttribute('x')), y: parseFloat(p.getAttribute('y')) });
            }
            return points;
        }
        if (type === 'list.string') {
            var strings = new $List();
            ss = xml.getElementsByTagName('s');
            count = ss.length;
            for (i = 0; i < count; i++) {
                strings.add(ss[i].textContent);
            }
            return strings;
        }
        if (type === 'list.number') {
            numbers = new $List();
            ss = xml.getElementsByTagName('s');
            count = ss.length;
            for (i = 0; i < count; i++) {
                numbers.add(parseFloat(ss[i].textContent));
            }
            return numbers;
        }
        if (type === 'array.string') {
            return xml.textContent.split(',');
        }
        if (type === 'array.number') {
            numbers = xml.textContent.split(',');
            count = numbers.length;
            for (i = 0; i < count; i++) {
                numbers[i] = parseFloat(numbers[i]);
            }
            return numbers;
        }
        if (type === 'rectangle') {
            return {
                x: parseFloat(xml.getAttribute('x')),
                y: parseFloat(xml.getAttribute('y')),
                width: parseFloat(xml.getAttribute('w')),
                height: parseFloat(xml.getAttribute('h'))
            };
        }
        return xml.textContent;
    }

});


_twaver.addMethod(twaver.Data, {
    serializeXml: function (serializer, newInstance) {
        if (serializer.settings.isClientSerializable && this._clientMap) {
            for (var clientProp in this._clientMap) {
                this.serializeClientXml(serializer, clientProp, newInstance);
            }
        }
        this.serializePropertyXml(serializer, "name", newInstance);
        this.serializePropertyXml(serializer, "icon", newInstance);
        this.serializePropertyXml(serializer, "toolTip", newInstance);
        this.serializePropertyXml(serializer, "parent", newInstance);
    },
    serializePropertyXml: function (serializer, property, newInstance) {
        serializer.serializePropertyXml(this, property, newInstance);
    },
    serializeClientXml: function (serializer, clientPrope, newInstance) {
        serializer.serializeClientXml(this, clientPrope, newInstance);
    },
    deserializeXml: function (serializer, xml) {
        var ps = xml.getElementsByTagName('p'),
        	count = ps.length,
        	i, p, cs, c;
        for (i = 0; i < count; i++) {
            p = ps[i];
            if (p.hasAttribute('n')) {
                this.deserializePropertyXml(serializer, p, p.getAttribute('n'));
            }
        }

        if (serializer.settings.isClientSerializable) {
            cs = xml.getElementsByTagName('c');
            count = cs.length;
            for (i = 0; i < count; i++) {
                c = cs[i];
                if (c.hasAttribute('n')) {
                    this.deserializeClientXml(serializer, c, c.getAttribute('n'));
                }
            }
        }
    },
    deserializePropertyXml: function (serializer, propertyXml, property) {
        serializer.deserializePropertyXml(this, propertyXml, property);
    },
    deserializeClientXml: function (serializer, clientXml, clientProp) {
        serializer.deserializeClientXml(this, clientXml, clientProp);
    }
});

_twaver.addMethod(twaver.Element, {
    serializeXml: function (serializer, newInstance) {
        if (serializer.settings.isStyleSerializable && this._styleMap) {
            for (var styleProp in this._styleMap) {
                this.serializeStyleXml(serializer, styleProp, newInstance);
            }
        }

        twaver.Element.superClass.serializeXml.call(this, serializer, newInstance);

        this.serializePropertyXml(serializer, "layerId", newInstance);

        if (this._alarmState.getHighestNativeAlarmSeverity() &&
            serializer.settings.getPropertyType("alarmState") === 'alarmstate') {

            serializer.xmlString += "\t<p n='alarmState'>\n";

            twaver.AlarmSeverity.forEach(function (severity) {
                var count = this.getNewAlarmCount(severity);
                if (count > 0) {
                    serializer.xmlString += "\t\t<n n='" + severity.name + "' c='" + count + "'/>\n";
                }
            }, this._alarmState);

            twaver.AlarmSeverity.forEach(function (severity) {
                var count = this.getAcknowledgedAlarmCount(severity);
                if (count > 0) {
                    serializer.xmlString += "\t\t<a n='" + severity.name + "' c='" + count + "'/>\n";
                }
            }, this._alarmState);

            serializer.xmlString += "\t</p>\n";
        }
    },
    serializeStyleXml: function (serializer, stylePrope, newInstance) {
        serializer.serializeStyleXml(this, stylePrope, newInstance);
    },
    deserializeXml: function (serializer, xml) {
        twaver.Element.superClass.deserializeXml.call(this, serializer, xml);

        if (serializer.settings.isStyleSerializable) {
            var ss = xml.getElementsByTagName('s'),
            	count = ss.length, i, s;
            for (i = 0; i < count; i++) {
                s = ss[i];
                if (s.hasAttribute('n')) {
                    this.deserializeStyleXml(serializer, s, s.getAttribute('n'));
                }
            }
        }
    },
    deserializeStyleXml: function (serializer, styleXml, styleProp) {
        serializer.deserializeStyleXml(this, styleXml, styleProp);
    },
    deserializePropertyXml: function (serializer, propertyXml, property) {
        if (property === "alarmState") {
            if (serializer.settings.getPropertyType("alarmState") === 'alarmstate') {
                var alarm, severity, i, s,
					ss = propertyXml.getElementsByTagName('n');
                for (i = 0; i < ss.length; i++) {
                    s = ss[i];
                    severity = twaver.AlarmSeverity.getByName(s.getAttribute('n'));
                    this._alarmState.setNewAlarmCount(severity, parseInt(s.getAttribute('c')));
                }
                ss = propertyXml.getElementsByTagName('a');
                for (i = 0; i < ss.length; i++) {
                    s = ss[i];
                    severity = twaver.AlarmSeverity.getByName(s.getAttribute('n'));
                    this._alarmState.setAcknowledgedAlarmCount(severity, parseInt(s.getAttribute('c')));
                }
            }
        }
        else {
            twaver.Element.superClass.deserializePropertyXml.call(this, serializer, propertyXml, property);
        }
    }
});

_twaver.addMethod($Node, {
    serializeXml: function (serializer, newInstance) {
        $Node.superClass.serializeXml.call(this, serializer, newInstance);

        this.serializePropertyXml(serializer, "image", newInstance);
        this.serializePropertyXml(serializer, "location", newInstance);

        if (_twaver.num(this._width) && this._width >= 0) {
            this.serializePropertyXml(serializer, "width", newInstance);
        }
        if (_twaver.num(this._height) && this._height >= 0) {
            this.serializePropertyXml(serializer, "height", newInstance);
        }
    }
});
_twaver.addMethod(twaver.Link, {
    serializeXml: function (serializer, newInstance) {
        twaver.Link.superClass.serializeXml.call(this, serializer, newInstance);

        this.serializePropertyXml(serializer, "fromNode", newInstance);
        this.serializePropertyXml(serializer, "toNode", newInstance);
    }
});
_twaver.addMethod(twaver.Follower, {
    serializeXml: function (serializer, newInstance) {
        twaver.Follower.superClass.serializeXml.call(this, serializer, newInstance);

        this.serializePropertyXml(serializer, "host", newInstance);
    }
});
_twaver.addMethod($Group, {
    serializeXml: function (serializer, newInstance) {
        $Group.superClass.serializeXml.call(this, serializer, newInstance);
        this.serializePropertyXml(serializer, "expanded", newInstance);
    }
});
_twaver.addMethod(twaver.ShapeNode, {
    serializeXml: function (serializer, newInstance) {
        twaver.ShapeNode.superClass.serializeXml.call(this, serializer, newInstance);
        this.serializePropertyXml(serializer, "points", newInstance);
        this.serializePropertyXml(serializer, "segments", newInstance);
    }
});
_twaver.addMethod(twaver.ShapeLink, {
    serializeXml: function (serializer, newInstance) {
        twaver.ShapeLink.superClass.serializeXml.call(this, serializer, newInstance);
        this.serializePropertyXml(serializer, "points", newInstance);
    }
});
_twaver.addMethod(twaver.RotatableNode, {
    serializeXml: function (serializer, newInstance) {
        twaver.RotatableNode.superClass.serializeXml.call(this, serializer, newInstance);

        this.serializePropertyXml(serializer, "angle", newInstance);
    }
});
_twaver.addMethod(twaver.DataBox, {
    serializeXml: function (serializer, newInstance) {
        if (serializer.settings.isClientSerializable && this._clientMap) {
            for (var clientProp in this._clientMap) {
                this.serializeClientXml(serializer, clientProp, newInstance);
            }
        }
        this.serializePropertyXml(serializer, "name", newInstance);
        this.serializePropertyXml(serializer, "icon", newInstance);
        this.serializePropertyXml(serializer, "toolTip", newInstance);
    },
    serializePropertyXml: function (serializer, property, newInstance) {
        serializer.serializePropertyXml(this, property, newInstance);
    },
    serializeClientXml: function (serializer, clientPrope, newInstance) {
        serializer.serializeClientXml(this, clientPrope, newInstance);
    },
    deserializeXml: function (serializer, xml) {
        var ps = xml.getElementsByTagName('p'),
        	count = ps.length, i, p, cs, c;
        for (i = 0; i < count; i++) {
            p = ps[i];
            if (p.hasAttribute('n')) {
                this.deserializePropertyXml(serializer, p, p.getAttribute('n'));
            }
        }
        if (serializer.settings.isClientSerializable) {
            cs = xml.getElementsByTagName('c');
            count = cs.length;
            for (i = 0; i < count; i++) {
                c = cs[i];
                if (c.hasAttribute('n')) {
                    this.deserializeClientXml(serializer, c, c.getAttribute('n'));
                }
            }
        }
    },
    deserializePropertyXml: function (serializer, propertyXml, property) {
        serializer.deserializePropertyXml(this, propertyXml, property);
    },
    deserializeClientXml: function (serializer, clientXml, clientProp) {
        serializer.deserializeClientXml(this, clientXml, clientProp);
    }
});

_twaver.addMethod(twaver.ElementBox, {

    serializeXml: function (serializer, newInstance) {

        if (serializer.settings.isLayerBoxSerializable) {
            serializer.xmlString += "\t<layerBox>\n";

            this._layerBox.forEachByDepthFirst(function (layer) {
                if (this._layerBox.getDefaultLayer() === layer) {
                    serializer.xmlString += "\t\t<layer ";
                } else {
                    serializer.xmlString += "\t\t<layer id='" + layer.getId() + "' ";
                }
                if (layer.getName()) {
                    serializer.xmlString += "name='" + layer.getName() + "' ";
                }
                serializer.xmlString += "visible='" + layer.isVisible() +
									    "' editable='" + layer.isEditable() +
									    "' movable='" + layer.isMovable() + "'/>\n";
            }, null, this);

            serializer.xmlString += "\t</layerBox>\n";

        }

        if (serializer.settings.isStyleSerializable && this._styleMap) {
            for (var styleProp in this._styleMap) {
                this.serializeStyleXml(serializer, styleProp, newInstance);
            }
        }

        twaver.ElementBox.superClass.serializeXml.call(this, serializer, newInstance);

    },
    serializeStyleXml: function (serializer, stylePrope, newInstance) {
        serializer.serializeStyleXml(this, stylePrope, newInstance);
    },
    deserializeStyleXml: function (serializer, styleXml, styleProp) {
        serializer.deserializeStyleXml(this, styleXml, styleProp);
    },
    deserializeXml: function (serializer, xml) {
        twaver.ElementBox.superClass.deserializeXml.call(this, serializer, xml);

        if (serializer.settings.isLayerBoxSerializable && xml.getElementsByTagName("layerBox").length == 1) {

            var layers = xml.getElementsByTagName("layerBox")[0].getElementsByTagName('layer');
            for (var i = 0; i < layers.length; i++) {
                var layerXml = layers[i];
                var layer;
                if (layerXml.hasAttribute("id")) {
                    var idType = serializer.settings.getPropertyType("layerId");
                    if (idType === 'string') {
                        layer = new twaver.Layer(layerXml.getAttribute('id'));
                    }
                    else if (idType === 'int') {
                        layer = new twaver.Layer(parseInt(layerXml.getAttribute('id')));
                    }
                    else if (idType === 'number') {
                        layer = new twaver.Layer(parseFloat(layerXml.getAttribute('id')));
                    }
                    else {
                        throw "Unsupported layer id type '" + idType + "'";
                    }
                    if (this._layerBox.getDataById(layer.getId())) {
                        layer = this._layerBox.getDataById(layer.getId());
                    } else {
                        this._layerBox.add(layer);
                    }
                } else {
                    layer = this._layerBox.getDefaultLayer();
                    this._layerBox.moveToBottom(layer);
                }
                if (layerXml.hasAttribute("name")) {
                    layer.setName(layerXml.getAttribute('name'));
                }
                if (layerXml.hasAttribute("visible")) {
                    layer.setVisible(layerXml.getAttribute('visible') === "true");
                }
                if (layerXml.hasAttribute("editable")) {
                    layer.setEditable(layerXml.getAttribute('editable') === "true");
                }
                if (layerXml.hasAttribute("movable")) {
                    layer.setMovable(layerXml.getAttribute('movable') === "true");
                }
            }
        }

        if (serializer.settings.isStyleSerializable) {
            var ss = xml.getElementsByTagName('s');
            var count = ss.length;
            for (var i = 0; i < count; i++) {
                var s = ss[i];
                if (s.hasAttribute('n')) {
                    this.deserializeStyleXml(serializer, s, s.getAttribute('n'));
                }
            }
        }
    }
});
twaver.JsonSerializer = function (dataBox, settings, filterFunction) {
    this.dataBox = dataBox;
    this.settings = settings ? settings : new twaver.SerializationSettings();
    this.filterFunction = filterFunction;
    this.ref = 0;
    this.refMap = {};
    this.idMap = {};
    this.jsonObject = {};
};
_twaver.ext('twaver.JsonSerializer', Object, {
    serialize: function () {
        this.jsonObject = {
            version: twaver.Util.getVersion(),
            platform: 'html5'
        };
        if (this.settings.isImageSerializable) {
            this.jsonObject.images = {};
        }
        this.serializeBody();
        return JSON.stringify(this.jsonObject);
    },
    serializeBody: function () {
        this.ref = 0;
        this.dataBox.getRoots().forEach(this.initRefs, this);

        if (this.settings.isDataBoxSerializable) {
            var dataBoxObject = {
                'class': this.dataBox.getClassName(),
                p: {},
                s: {},
                c: {}
            };
            this.jsonObject.dataBox = dataBoxObject;
            this.dataBox.serializeJson(this, this.dataBox.newInstance(), dataBoxObject);
            if (_twaver.isEmptyObject(dataBoxObject.p)) {
                delete dataBoxObject.p;
            }
            if (_twaver.isEmptyObject(dataBoxObject.s)) {
                delete dataBoxObject.s;
            }
            if (_twaver.isEmptyObject(dataBoxObject.c)) {
                delete dataBoxObject.c;
            }
        }

        this.jsonObject.datas = [];
        this.dataBox.getRoots().forEach(this.serializeData, this);
    },
    initRefs: function (data) {
        this.refMap[data.getId()] = this.ref++;
        data.getChildren().forEach(this.initRefs, this);
    },
    isSerializable: function (data) {
        if (!this.dataBox.contains(data)) {
            return false;
        }
        if (this.filterFunction && !this.filterFunction(data)) {
            return false;
        }
        return true;
    },
    serializeData: function (data) {
        if (this.isSerializable(data)) {
            var newInstance = data.newInstance();
            var ref = this.refMap[data.getId()];
            var dataObject = {
                'class': data.getClassName(),
                ref: ref,
                p: {},
                s: {},
                c: {}
            };
            if (this.settings.getPropertyType("id")) {
                dataObject.id = data.getId();
            }
            this.jsonObject.datas.push(dataObject);
            data.serializeJson(this, newInstance, dataObject);
            if (_twaver.isEmptyObject(dataObject.p)) {
                delete dataObject.p;
            }
            if (_twaver.isEmptyObject(dataObject.s)) {
                delete dataObject.s;
            }
            if (_twaver.isEmptyObject(dataObject.c)) {
                delete dataObject.c;
            }
            if (this.settings.isImageSerializable && data.getImage) {
                var imageName = data.getImage();
                if (typeof imageName === 'string' && !_defaultImages[imageName] && !this.jsonObject.images[imageName]) {
                    var imageAssert = _twaver.getImageAsset(imageName);
                    var image = imageAssert && imageAssert.getImage();
                    if (image && !isImage(image)) {
                        this.jsonObject.images[imageName] = image;
                    }
                }
            }
        }
        data.getChildren().forEach(this.serializeData, this);
    },
    serializePropertyJson: function (instance, property, newInstance, dataObject) {
        var type = this.settings.getPropertyType(property);
        if (type) {
            var value = _twaver.getValue(instance, property, type);
            var newInstanceValue = _twaver.getValue(newInstance, property, type);
            if (value !== newInstanceValue) {
                this.serializeValue(property, value, newInstanceValue, type, dataObject.p);
            }
        }
    },
    serializeStyleJson: function (instance, style, newInstance, dataObject) {
        var type = this.settings.getStyleType(style);
        if (type) {
            var value = instance.getStyle(style);
            var newInstanceValue = newInstance.getStyle(style);
            if (value != newInstanceValue) {
                this.serializeValue(style, value, newInstanceValue, type, dataObject.s);
            }
        }
    },
    serializeClientJson: function (instance, client, newInstance, dataObject) {
        var type = this.settings.getClientType(client);
        if (type != null) {
            var value = instance.getClient(client);
            var newInstanceValue = newInstance.getClient(client);
            if (value != newInstanceValue) {
                this.serializeValue(client, value, newInstanceValue, type, dataObject.c);
            }
        }
    },
    serializeValue: function (property, value, newInstanceValue, type, dataObject) {
        if (value == null) {
            dataObject[property] = null;
        }
        else if (value instanceof $List) {
            dataObject[property] = value._as;
        }
        else if (type === 'data') {
            var dataRef = this.refMap[value.getId()];
            if (dataRef != null) {
                dataObject[property] = dataRef;
            }
        } else {
            dataObject[property] = value;
        }
    },
    deserialize: function (jsonString, rootParent) {
        _twaver.isDeserializing = true;
        this.jsonObject = JSON.parse(jsonString);

        var images = this.jsonObject.images;
        if (this.settings.isImageSerializable && images) {
            Object.keys(images).forEach(function (imageName) {
                _twaver.registerImage(imageName, images[imageName]);
            });
        }

        this.refMap = {};
        this.idMap = {};

        var list = new $List();
        var objectList = new $List();
        var data;

        // create datas
        var count = this.jsonObject.datas.length;
        for (var i = 0; i < count; i++) {
            var dataObject = this.jsonObject.datas[i];
            var type = dataObject['class'];
            var idType = this.settings.getPropertyType('id');
            if (idType && dataObject.id != null) {
                // remove old data
                if (dataObject.action === "remove") {
                    this.dataBox.removeById(dataObject.id);
                    continue;
                }
                // update old data
                data = this.dataBox.getDataById(dataObject.id);
                // create new data
                if (!data) {
                    data = _twaver.newInstance(type, dataObject.id);
                }
            } else {
                data = _twaver.newInstance(type);
            }
            if (dataObject.ref != null) {
                this.refMap[dataObject.ref] = data;
            }
            list.add(data);
            objectList.add(dataObject);
            this.idMap[data.getId()] = data;
        }

        // add all datas to idmap
        this.dataBox.forEach(function (data) {
            this.idMap[data.getId()] = data;
        }, this);

        // fill all datas properties
        count = list.size();
        for (i = 0; i < count; i++) {
            data = list.get(i);
            data.deserializeJson(this, objectList.get(i));
        }

        // add all datas into box
        for (i = 0; i < count; i++) {
            data = list.get(i);
            if (this.dataBox.containsById(data.getId())) {
                continue;
            }
            if (rootParent && !data.getParent()) {
                data.setParent(rootParent);
            }
            this.dataBox.add(data);
        }
        // fill databox properties
        if (this.settings.isDataBoxSerializable && this.jsonObject.dataBox) {
            this.dataBox.deserializeJson(this, this.jsonObject.dataBox);
        }
        _twaver.isDeserializing = false;
    },
    deserializePropertyJson: function (instance, json, property) {
        var type = this.settings.getPropertyType(property);
        if (type) {
            _twaver.setValue(instance, property, this.deserializeValue(json, type));
        }
    },
    deserializeStyleJson: function (instance, json, property) {
        var type = this.settings.getStyleType(property);
        if (type) {
            instance.setStyle(property, this.deserializeValue(json, type));
        }
    },
    deserializeClientJson: function (instance, json, property) {
        var type = this.settings.getClientType(property);
        if (type) {
            instance.setClient(property, this.deserializeValue(json, type));
        }
    },
    deserializeValue: function (json, type) {
        if (type === 'data') {
            var data = this.refMap[json];
            if (data) {
                return data;
            } else {
                return this.idMap[json];
            }
        }
        if (type === 'array.number') {
            return json;
        }
        if (json instanceof Array) {
            return new $List(json);
        }
        return json;
    }

});


_twaver.addMethod(twaver.Data, {
    serializeJson: function (serializer, newInstance, dataObject) {
        if (serializer.settings.isClientSerializable && this._clientMap) {
            for (var clientProp in this._clientMap) {
                this.serializeClientJson(serializer, clientProp, newInstance, dataObject);
            }
        }
        this.serializePropertyJson(serializer, "name", newInstance, dataObject);
        this.serializePropertyJson(serializer, "icon", newInstance, dataObject);
        this.serializePropertyJson(serializer, "toolTip", newInstance, dataObject);
        this.serializePropertyJson(serializer, "parent", newInstance, dataObject);
    },
    serializePropertyJson: function (serializer, property, newInstance, dataObject) {
        serializer.serializePropertyJson(this, property, newInstance, dataObject);
    },
    serializeClientJson: function (serializer, clientPrope, newInstance, dataObject) {
        serializer.serializeClientJson(this, clientPrope, newInstance, dataObject);
    },
    deserializeJson: function (serializer, json) {
        var name;
        for (name in json.p) {
            this.deserializePropertyJson(serializer, json.p[name], name);
        }
        if (serializer.settings.isClientSerializable) {
            for (name in json.c) {
                this.deserializeClientJson(serializer, json.c[name], name);
            }
        }
    },
    deserializePropertyJson: function (serializer, json, property) {
        serializer.deserializePropertyJson(this, json, property);
    },
    deserializeClientJson: function (serializer, json, clientProp) {
        serializer.deserializeClientJson(this, json, clientProp);
    }
});

_twaver.addMethod(twaver.Element, {
    serializeJson: function (serializer, newInstance, dataObject) {
        if (serializer.settings.isStyleSerializable && this._styleMap) {
            for (var styleProp in this._styleMap) {
                this.serializeStyleJson(serializer, styleProp, newInstance, dataObject);
            }
        }
        twaver.Element.superClass.serializeJson.call(this, serializer, newInstance, dataObject);

        this.serializePropertyJson(serializer, "layerId", newInstance, dataObject);

        if (this._alarmState.getHighestNativeAlarmSeverity() &&
            serializer.settings.getPropertyType("alarmState") === 'alarmstate') {

            var as = {
                n: {},
                a: {}
            };
            dataObject.p.alarmState = as;

            twaver.AlarmSeverity.forEach(function (severity) {
                var count = this.getNewAlarmCount(severity);
                if (count > 0) {
                    as.n[severity.name] = count;
                }
            }, this._alarmState);

            twaver.AlarmSeverity.forEach(function (severity) {
                var count = this.getAcknowledgedAlarmCount(severity);
                if (count > 0) {
                    as.a[severity.name] = count;
                }
            }, this._alarmState);

            if (_twaver.isEmptyObject(as.n)) {
                delete as.n;
            }
            if (_twaver.isEmptyObject(as.a)) {
                delete as.a;
            }
            if (_twaver.isEmptyObject(as)) {
                delete dataObject.p.alarmState;
            }
        }
    },
    serializeStyleJson: function (serializer, stylePrope, newInstance, dataObject) {
        serializer.serializeStyleJson(this, stylePrope, newInstance, dataObject);
    },
    deserializeJson: function (serializer, json) {
        twaver.Element.superClass.deserializeJson.call(this, serializer, json);

        if (serializer.settings.isStyleSerializable) {
            for (var name in json.s) {
                this.deserializeStyleJson(serializer, json.s[name], name);
            }
        }
    },
    deserializeStyleJson: function (serializer, json, styleProp) {
        serializer.deserializeStyleJson(this, json, styleProp);
    },
    deserializePropertyJson: function (serializer, json, property) {
        if (property === "alarmState") {
            if (serializer.settings.getPropertyType("alarmState") === 'alarmstate') {
                var name;
                for (name in json.n) {
                    this._alarmState.setNewAlarmCount(twaver.AlarmSeverity.getByName(name), json.n[name]);
                }
                for (name in json.a) {
                    this._alarmState.setAcknowledgedAlarmCount(twaver.AlarmSeverity.getByName(name), json.a[name]);
                }
            }
        }
        else {
            twaver.Element.superClass.deserializePropertyJson.call(this, serializer, json, property);
        }
    }
});

_twaver.addMethod($Node, {
    serializeJson: function (serializer, newInstance, dataObject) {
        $Node.superClass.serializeJson.call(this, serializer, newInstance, dataObject);

        this.serializePropertyJson(serializer, "image", newInstance, dataObject);
        this.serializePropertyJson(serializer, "location", newInstance, dataObject);

        if (_twaver.num(this._width) && this._width >= 0) {
            this.serializePropertyJson(serializer, "width", newInstance, dataObject);
        }
        if (_twaver.num(this._height) && this._height >= 0) {
            this.serializePropertyJson(serializer, "height", newInstance, dataObject);
        }
    }
});
_twaver.addMethod(twaver.Link, {
    serializeJson: function (serializer, newInstance, dataObject) {
        twaver.Link.superClass.serializeJson.call(this, serializer, newInstance, dataObject);

        this.serializePropertyJson(serializer, "fromNode", newInstance, dataObject);
        this.serializePropertyJson(serializer, "toNode", newInstance, dataObject);
    }
});
_twaver.addMethod(twaver.Follower, {
    serializeJson: function (serializer, newInstance, dataObject) {
        twaver.Follower.superClass.serializeJson.call(this, serializer, newInstance, dataObject);

        this.serializePropertyJson(serializer, "host", newInstance, dataObject);
    }
});
_twaver.addMethod($Group, {
    serializeJson: function (serializer, newInstance, dataObject) {
        $Group.superClass.serializeJson.call(this, serializer, newInstance, dataObject);
        this.serializePropertyJson(serializer, "expanded", newInstance, dataObject);
    }
});
_twaver.addMethod(twaver.ShapeNode, {
    serializeJson: function (serializer, newInstance, dataObject) {
        twaver.ShapeNode.superClass.serializeJson.call(this, serializer, newInstance, dataObject);
        this.serializePropertyJson(serializer, "points", newInstance, dataObject);
        this.serializePropertyJson(serializer, "segments", newInstance, dataObject);
    }
});
_twaver.addMethod(twaver.ShapeLink, {
    serializeJson: function (serializer, newInstance, dataObject) {
        twaver.ShapeLink.superClass.serializeJson.call(this, serializer, newInstance, dataObject);
        this.serializePropertyJson(serializer, "points", newInstance, dataObject);
    }
});
_twaver.addMethod(twaver.RotatableNode, {
    serializeJson: function (serializer, newInstance, dataObject) {
        twaver.RotatableNode.superClass.serializeJson.call(this, serializer, newInstance, dataObject);

        this.serializePropertyJson(serializer, "angle", newInstance, dataObject);
    }
});
_twaver.addMethod(twaver.DataBox, {
    serializeJson: function (serializer, newInstance, dataObject) {
        if (serializer.settings.isClientSerializable && this._clientMap) {
            for (var clientProp in this._clientMap) {
                this.serializeClientJson(serializer, clientProp, newInstance, dataObject);
            }
        }
        this.serializePropertyJson(serializer, "name", newInstance, dataObject);
        this.serializePropertyJson(serializer, "icon", newInstance, dataObject);
        this.serializePropertyJson(serializer, "toolTip", newInstance, dataObject);
    },
    serializePropertyJson: function (serializer, property, newInstance, dataObject) {
        serializer.serializePropertyJson(this, property, newInstance, dataObject);
    },
    serializeClientJson: function (serializer, clientPrope, newInstance, dataObject) {
        serializer.serializeClientJson(this, clientPrope, newInstance, dataObject);
    },
    deserializeJson: function (serializer, json) {
        var name;
        for (name in json.p) {
            this.deserializePropertyJson(serializer, json.p[name], name);
        }
        if (serializer.settings.isClientSerializable) {
            for (name in json.c) {
                this.deserializeClientJson(serializer, json.c[name], name);
            }
        }
    },
    deserializePropertyJson: function (serializer, json, property) {
        serializer.deserializePropertyJson(this, json, property);
    },
    deserializeClientJson: function (serializer, json, clientProp) {
        serializer.deserializeClientJson(this, json, clientProp);
    }
});

_twaver.addMethod(twaver.ElementBox, {
    serializeJson: function (serializer, newInstance, dataObject) {
        if (serializer.settings.isLayerBoxSerializable) {
            dataObject.layers = [];
            this._layerBox.forEachByDepthFirst(function (layer) {
                var layerObject = {};
                dataObject.layers.push(layerObject);
                if (this._layerBox.getDefaultLayer() !== layer) {
                    layerObject.id = layer.getId();
                }
                if (layer.getName()) {
                    layerObject.name = layer.getName();
                }
                layerObject.visible = layer.isVisible();
                layerObject.editable = layer.isEditable();
                layerObject.movable = layer.isMovable();
            }, null, this);
        }
        if (serializer.settings.isStyleSerializable && this._styleMap) {
            for (var styleProp in this._styleMap) {
                this.serializeStyleJson(serializer, styleProp, newInstance, dataObject);
            }
        }
        twaver.ElementBox.superClass.serializeJson.call(this, serializer, newInstance, dataObject);
    },
    serializeStyleJson: function (serializer, stylePrope, newInstance, dataObject) {
        serializer.serializeStyleJson(this, stylePrope, newInstance, dataObject);
    },
    deserializeStyleJson: function (serializer, json, styleProp) {
        serializer.deserializeStyleJson(this, json, styleProp);
    },
    deserializeJson: function (serializer, json) {
        twaver.ElementBox.superClass.deserializeJson.call(this, serializer, json);

        if (serializer.settings.isLayerBoxSerializable && json.layers) {

            if (json.layers) {
                var count = json.layers.length;
                for (var i = 0; i < count; i++) {
                    var layer;
                    var layerJson = json.layers[i];
                    if (layerJson.id != null) {
                        layer = new twaver.Layer(layerJson.id);
                        if (this._layerBox.getDataById(layer.getId())) {
                            layer = this._layerBox.getDataById(layer.getId());
                        } else {
                            this._layerBox.add(layer);
                        }
                    } else {
                        layer = this._layerBox.getDefaultLayer();
                        this._layerBox.moveToBottom(layer);
                    }
                    if (layerJson.name) {
                        layer.setName(layerJson.name);
                    }
                    if (layerJson.visible != null) {
                        layer.setVisible(layerJson.visible);
                    }
                    if (layerJson.editable != null) {
                        layer.setEditable(layerJson.editable);
                    }
                    if (layerJson.movable != null) {
                        layer.setMovable(layerJson.movable);
                    }
                }
            }
        }

        if (serializer.settings.isStyleSerializable) {
            for (var name in json.s) {
                this.deserializeStyleJson(serializer, json.s[name], name);
            }
        }
    }
});

twaver.layout.SpringLayouter = function (network) {
    this._network = network;
    this._damper = 1;
    this._maxMotion = 0;
    this._motionRatio = 0;
    this._isAdjusting = false;
    this._timer = null;
    this._snodeMap = {};
    this._snodes = new $List();
    this._slinks = new $List();

    this._network.getElementBox().addDataBoxChangeListener(this._handleDataBoxChange, this);
    this._network.getElementBox().addDataPropertyChangeListener(this._handleDataPropertyChange, this);
    this._network.addPropertyChangeListener(this._handleNetworkPropertyChange, this);
};
_twaver.ext('twaver.layout.SpringLayouter', Object, {
    _nodeRepulsionFactor: 0.6,
    _linkRepulsionFactor: 0.6,
    _limitBounds: null,
    _interval: 50,
    _stepCount: 10,
    _motionLimit: 0.01,
    start: function () {
        if (this._timer) {
            return;
        }
        var self = this;
        var code = function () { self.relax.call(self); }
        this._timer = window.setInterval(code, this._interval);
        this._damper = 1;
    },
    stop: function () {
        if (this._timer) {
            window.clearInterval(this._timer);
            this._timer = null;
        }
    },
    relax: function () {
        if (this._damper < 0.1 && this._maxMotion < this._motionLimit) {
            return;
        }

        this._rebuild();

        var nodeCount = this._snodes.size();
        for (var i = 0; i < this._stepCount; i++) {
            this._slinks.forEach(this._relaxLink, this);

            for (var m = 0; m < nodeCount; m++) {
                for (var n = 0; n < nodeCount; n++) {
                    var n1 = this._snodes.get(m);
                    var n2 = this._snodes.get(n);
                    if (n1 != n2) {
                        this._relaxNodePair(n1, n2);
                    }
                }
            }
            this._moveNodes();
        }

        this._isAdjusting = true;
        for (var i = 0; i < nodeCount; i++) {
            var node = this._snodes.get(i);
            if (!node.fix) {
                node.element.setLocation(node.x, node.y);
            }
        }
        this._isAdjusting = false;
    },
    isRunning: function () {
        return !!this._timer;
    },
    getNetwork: function () {
        return this._network;
    },
    isVisible: function (element) {
        return this._network.isVisible(element);
    },
    isMovable: function (node) {
        if (!this._network.isMovable(node)) {
            return false;
        }
        if (this._network.getSelectionModel().contains(node)) {
            return false;
        }
        if (node instanceof $Group) {
            return false;
        }
        return true;
    },
    getNodeRepulsionFactor: function () {
        return this._nodeRepulsionFactor;
    },
    setNodeRepulsionFactor: function (nodeRepulsionFactor) {
        if (nodeRepulsionFactor < 0.02) {
            nodeRepulsionFactor = 0.02;
        }
        this._nodeRepulsionFactor = nodeRepulsionFactor;
        this._damper = 1;
    },
    getLinkRepulsionFactor: function () {
        return this._linkRepulsionFactor;
    },
    setLinkRepulsionFactor: function (linkRepulsionFactor) {
        if (linkRepulsionFactor < 0.02) {
            linkRepulsionFactor = 0.02;
        }
        this._linkRepulsionFactor = linkRepulsionFactor;
        this._damper = 1;
    },
    getStepCount: function () {
        return this._stepCount;
    },
    setStepCount: function (stepCount) {
        this._stepCount = stepCount;
        this._damper = 1;
    },
    getInterval: function () {
        return this._interval;
    },
    setInterval: function (interval) {
        if (this._interval === interval) {
            return;
        }
        this._interval = interval;
        if (this._timer) {
            window.clearInterval(this._timer);
            var self = this;
            var code = function () { self.relax.call(self); }
            this._timer = window.setInterval(code, this._interval);
        }
    },
    getLimitBounds: function () {
        return this._limitBounds;
    },
    setLimitBounds: function (limitBounds) {
        this._limitBounds = limitBounds;
        this._damper = 1;
    },
    _handleDataPropertyChange: function (evt) {
        if (!this._isAdjusting) {
            this._damper = 1;
        }
    },
    _handleDataBoxChange: function (evt) {
        if (this._network.getElementBox().size() === 0) {
            this._damper = 0;
        }
        else {
            this._damper = 1;
        }
    },
    _handleNetworkPropertyChange: function (evt) {
        if (evt.property === "elementBox") {
            var oldValue = evt.oldValue;
            if (oldValue != null) {
                oldValue.removeDataBoxChangeListener(this._handleDataBoxChange, this);
                oldValue.removeDataPropertyChangeListener(this._handleDataPropertyChange, this);
            }
            this._network.getElementBox().addDataBoxChangeListener(this._handleDataBoxChange, this);
            this._network.getElementBox().addDataPropertyChangeListener(this._handleDataPropertyChange, this);
        }
    },
    _relaxLink: function (link) {
        var vx = link.toNode.x - link.fromNode.x;
        var vy = link.toNode.y - link.fromNode.y;
        var len = Math.sqrt(vx * vx + vy * vy);

        var dx = vx * 0.25;
        var dy = vy * 0.25;
        dx /= (link.length * 100);
        var length = link.length;
        var div = length * 100;
        var ddy = dy;
        dy = dy / div;
        ddy /= (link.length * 100);

        link.toNode.dx = link.toNode.dx - dx * len;
        link.toNode.dy = link.toNode.dy - dy * len;

        link.fromNode.dx = link.fromNode.dx + dx * len;
        link.fromNode.dy = link.fromNode.dy + dy * len;
    },
    _relaxNodePair: function (n1, n2) {
        var dx = 0;
        var dy = 0;
        var vx = n1.x - n2.x;
        var vy = n1.y - n2.y;
        var len = vx * vx + vy * vy;
        if (len === 0) {
            dx = twaver.Util.random();
            dy = twaver.Util.random();
        }
        else if (len < 360000) {
            dx = vx / len;
            dy = vy / len;
        }

        var repSum = n1.repulsion * n2.repulsion / 100;
        var factor = repSum * 0.25;

        n1.dx += dx * factor;
        n1.dy += dy * factor;

        n2.dx -= dx * factor;
        n2.dy -= dy * factor;
    },
    _moveNodes: function () {
        var lastMaxMotion = this._maxMotion;
        var maxMotionA = 0;

        for (var i = 0, nodeSize = this._snodes.size(); i < nodeSize; i++) {
            var n = this._snodes.get(i);

            var dx = n.dx;
            var dy = n.dy;
            dx *= this._damper;
            dy *= this._damper;

            n.dx = dx / 2;
            n.dy = dy / 2;

            var distMoved = Math.sqrt(dx * dx + dy * dy);
            if (!n.fix) {
                n.x = n.x + Math.max(-30, Math.min(30, dx));
                n.y = n.y + Math.max(-30, Math.min(30, dy));
                if (!this._limitBounds) {
                    if (n.x < 1) {
                        this._adjustLocation(1, 0);
                    }
                    if (n.y < 1) {
                        this._adjustLocation(0, 1);
                    }
                }
                else {
                    if (n.x < this._limitBounds.x) {
                        n.x = this._limitBounds.x;
                        this._adjustLocation(1, 0);
                    }
                    if (n.y < this._limitBounds.y) {
                        n.y = this._limitBounds.y;
                        this._adjustLocation(0, 1);
                    }
                    var rect;
                    var ui = this._network.getElementUI(n.element);
                    if (ui) {
                        rect = ui._viewRect;
                    } else {
                        rect = n.element.getRect();
                    }
                    if (rect) {
                        if (n.x + rect.width > this._limitBounds.x + this._limitBounds.width) {
                            n.x = this._limitBounds.x + this._limitBounds.width - rect.width;
                            this._adjustLocation(-1, 0);
                        }
                        if (n.y + rect.height > this._limitBounds.y + this._limitBounds.height) {
                            n.y = this._limitBounds.y + this._limitBounds.height - rect.height;
                            this._adjustLocation(0, -1);
                        }
                    }
                }
            }
            maxMotionA = Math.max(distMoved, maxMotionA);
        }

        this._maxMotion = maxMotionA;
        if (this._maxMotion > 0) this._motionRatio = lastMaxMotion / this._maxMotion - 1;
        else this._motionRatio = 0;

        this._damp();
    },
    _damp: function () {
        if (this._motionRatio <= 0.001) {
            if ((this._maxMotion < 0.2 || (this._maxMotion > 1 && this._damper < 0.9)) && this._damper > 0.01) this._damper -= 0.01;
            else if (this._maxMotion < 0.4 && this._damper > 0.003) this._damper -= 0.003;
            else if (this._damper > 0.0001) this._damper -= 0.0001;
        }
        if (this._maxMotion < this._motionLimit) {
            this._damper = 0;
        }
    },
    _rebuild: function () {
        this._snodeMap = {};
        this._snodes.clear();
        this._slinks.clear();

        this._network.getElementBox().forEach(function (element) {
            if (this.isVisible(element)) {
                if (element instanceof twaver.Link) {
                    this._addLink(element);
                }
                else if (element instanceof $Node) {
                    this._addNode(element);
                }
            }
        }, this);
    },
    _addNode: function (element) {
        var node = this._snodeMap[element.getId()];
        if (!!node) {
            return node;
        }
        node = {};
        node.element = element;
        node.repulsion = this._getRepulsion(element);
        node.x = element.getX();
        node.y = element.getY();
        node.dx = 0;
        node.dy = 0;
        node.fix = !this.isMovable(element);
        this._snodeMap[element.getId()] = node;
        this._snodes.add(node);
        return node;
    },
    _addLink: function (element) {
        var link = {};
        link.fromNode = this._addNode(element.getFromNode());
        link.toNode = this._addNode(element.getToNode());
        link.element = element;

        var toUI = this._network.getElementUI(element.getToNode());
        var fromUI = this._network.getElementUI(element.getFromNode());
        var w, h;
        if (toUI && toUI._viewRect && fromUI && fromUI._viewRect) {
            w = (toUI._viewRect.width + fromUI._viewRect.width);
            h = (toUI._viewRect.height + fromUI._viewRect.height);
        } else {
            w = element.getToNode().getWidth() + element.getFromNode().getWidth();
            h = element.getToNode().getHeight() + element.getFromNode().getHeight();
        }
        link.length = Math.floor(Math.sqrt(w * w + h * h) * this._linkRepulsionFactor);
        if (link.length <= 0) {
            link.length = 100;
        }
        this._slinks.add(link);
    },
    _getRepulsion: function (node) {
        var ui = this._network.getElementUI(node);
        var result;
        if (ui && ui._viewRect) {
            var rect = ui._viewRect;
            result = Math.floor(Math.sqrt(rect.width * rect.width + rect.height * rect.height) * this._nodeRepulsionFactor);
        } else {
            result = 100;
        }
        if (result <= 0) {
            result = 100;
        }
        return result;
    },
    _adjustLocation: function (xoffset, yoffset) {
        for (var i = 0, nodeSize = this._snodes.size(); i < nodeSize; i++) {
            var n = this._snodes.get(i);
            var rect;
            var ui = this._network.getElementUI(n.element);
            if (ui) {
                rect = ui._viewRect;
            } else {
                rect = n.element.getRect();
            }
            if (!rect) {
                return;
            }
            if (xoffset > 0) {
                if (!this._limitBounds || n.x + rect.width + xoffset < this._limitBounds.x + this._limitBounds.width) {
                    n.x += xoffset;
                }
            } else {
                if (!this._limitBounds || n.x + xoffset > this._limitBounds.x) {
                    n.x += xoffset;
                }
            }
            if (yoffset > 0) {
                if (!this._limitBounds || n.y + rect.height + yoffset < this._limitBounds.y + this._limitBounds.height) {
                    n.y += yoffset;
                }
            } else {
                if (!this._limitBounds || n.y + yoffset > this._limitBounds.y) {
                    n.y += yoffset;
                }
            }
        }
    }
});

twaver.layout.CloudLayouter = function (network) {
    twaver.layout.CloudLayouter.superClass.constructor.apply(this, arguments);
    this._network = network;
    this._centerX = 0;
    this._centerY = 0;
    this._radius = 1;
    this._rect = null;
    this._localPoint = null;
    this._lastWidth = -1000;
    this._lastHeight = -1000;
    this._nodes = new $List();
    this._sa = 0;
    this._ca = 0;
    this._sb = 0;
    this._cb = 0;
    this._sc = 0;
    this._cc = 0;
    this._lasta = 0;
    this._lastb = 0;
    this._active = false;
    this._horizontalElliptical = 1;
    this._verticalElliptical = 1;
    this._timer = null;
    this._centering = false;
    this._centeringNode = null;
    this._freeze = false;

    if (this._network.getClassName() === 'twaver.network.Network') {
        this._network.setInteractions([new twaver.network.interaction.SelectInteraction(this._network)]);
    } else {
        this._network.setInteractions([new twaver.canvas.interaction.SelectInteraction(this._network)]);
    }
};
_twaver.ext('twaver.layout.CloudLayouter', twaver.PropertyChangeDispatcher, {
    __accessor: ['updateNodeFunction', 'mouseMoveFunction', 'mouseOverFunction',
			'percentPadding', 'ceaseRate', 'ceaseLimit'],
    __bool: ['elliptical', 'active', 'updateLayoutRectOnResized', 'reloadOnDataBoxChanged'],
    _moveSpeed: 2,
    _ceaseRate: 0.90,
    _ceaseLimit: 0.01,
    _percentPadding: 0.20,
    _elliptical: true,
    _interval: 50,
    _reloadOnDataBoxChanged: true,
    _updateLayoutRectOnResized: true,
    getNetwork: function () {
        return this._network;
    },
    isLayoutable: function (node) {
        return this._network.isVisible(node) && this._network.isMovable(node);
    },
    start: function (needToReset) {
        if (arguments.length === 0) {
            needToReset = true;
        }
        if (this._timer) {
            return;
        }
        this._installListeners();
        if (needToReset) {
            this.updateLayoutRect(true);
        }
        var self = this;
        var code = function () { self._update.call(self); }
        this._timer = window.setInterval(code, this._interval);
        this._update();
    },
    stop: function () {
        if (this._timer) {
            window.clearInterval(this._timer);
            this._timer = null;
        }
    },
    isRunning: function () {
        return !!this._timer;
    },
    getInterval: function () {
        return this._interval;
    },
    setInterval: function (interval) {
        if (this._interval === interval) {
            return;
        }
        var ov = this._interval;
        this._interval = interval;
        if (this._timer) {
            window.clearInterval(this._timer);
            var self = this;
            var code = function () { self._update.call(self); }
            this._timer = window.setInterval(code, this._interval);
        }
        this.firePropertyChange('interval', ov, interval);
    },
    getMoveSpeed: function () {
        return this._moveSpeed;
    },
    setMoveSpeed: function (v) {
        var ov = this._moveSpeed;
        this._moveSpeed = v;
        this.firePropertyChange('moveSpeed', ov, v);
    },
    getLayoutRect: function () {
        var w = this._network.getView().offsetWidth / this._network.getZoom();
        var h = this._network.getView().offsetHeight / this._network.getZoom();
        var wp = w * this._percentPadding;
        var hp = h * this._percentPadding;
        return { x: wp, y: hp, width: w - 2 * wp, height: h - 2 * hp };
    },
    getCount: function () {
        return this._nodes.size();
    },
    updateLayoutRect: function (needToReload) {
        var last = this._radius;

        this._rect = this.getLayoutRect();
        if (this._rect.width <= 2) {
            this._rect.width = 2;
        }
        if (this._rect.height <= 2) {
            this._rect.height = 2;
        }
        this._radius = Math.min(this._rect.width / 2, this._rect.height / 2);
        if (this.isElliptical()) {
            this._horizontalElliptical = this._rect.width / 2 / this._radius;
            this._verticalElliptical = this._rect.height / 2 / this._radius;
        } else {
            this._horizontalElliptical = 1;
            this._verticalElliptical = 1;
        }

        this._centerX = this._rect.x + this._rect.width / 2;
        this._centerY = this._rect.y + this._rect.height / 2

        if (needToReload) {
            this.reload();
        }
        else {
            this._lasta = 1;
            this._lastb = 1;
            var max = this._nodes.size();
            for (var i = 0; i < max; i++) {
                var node = this._nodes.get(i);
                node.cx *= this._radius / last;
                node.cy *= this._radius / last;
                node.cz *= this._radius / last;
            }
            if (this._freeze) {
                this._updateNodes(0, 0, 0);
            } else {
                this._update();
            }
        }

        this._lastWidth = this._network.getView().offsetWidth;
        this._lastHeight = this._network.getView().offsetHeight;
    },
    reload: function () {
        this._freeze = false;
        this._centeringNode = null;
        this._localPoint = null;
        this._centering = false;
        this._nodes = new $List();
        this._box.forEach(function (e) {
            if (e && this.isLayoutable(e)) {
                var o = {};
                o.node = e;
                this._nodes.add(o);
            }
        }, this);

        this._sineCosine(0, 0, 0);
        this._active = false;
        this._lasta = 1;
        this._lastb = 1;

        var phi = 0;
        var theta = 0;
        var max = this._nodes.size();
        for (var i = 0; i < max; i++) {
            phi = Math.acos(-1 + (2 * (i + 1) - 1) / max);
            theta = Math.sqrt(max * Math.PI) * phi;
            var node = this._nodes.get(i);
            node.cx = this._radius * Math.cos(theta) * Math.sin(phi);
            node.cy = this._radius * Math.sin(theta) * Math.sin(phi);
            node.cz = this._radius * Math.cos(phi);
        }
    },
    _sineCosine: function (a, b, c) {
        var sineCosineDtr = Math.PI / 180;
        this._sa = Math.sin(a * sineCosineDtr);
        this._ca = Math.cos(a * sineCosineDtr);
        this._sb = Math.sin(b * sineCosineDtr);
        this._cb = Math.cos(b * sineCosineDtr);
        this._sc = Math.sin(c * sineCosineDtr);
        this._cc = Math.cos(c * sineCosineDtr);
    },
    handleSelectionChange: function (e) {
        this.centerNode(this._network.getSelectionModel().getLastData());
    },
    handleDataBoxChange: function (e) {
        if (this._reloadOnDataBoxChanged || e.kind === 'clear') {
            this.reload();
        }
    },
    handleMouseMove: function (e) {
        if (!this._centering) {
            this._updateLogicalPoint(e);
        }
        if (!this._mouseMoveFunction) {
            this._active = true;
        } else {
            this._active = this._mouseMoveFunction(e);
        }
    },
    handleMouseOver: function (e) {
        if (!this._centering) {
            this._updateLogicalPoint(e);
        }
        if (!this._mouseOverFunction) {
            this._active = true;
        } else {
            this._active = this._mouseOverFunction(e);
        }
    },
    _updateLogicalPoint: function (e) {
        this._localPoint = this._network.getLogicalPoint(e);
    },
    handleRollOut: function (e) {
        this._active = false;
    },
    handleResize: function (e) {
        if (e.kind === 'validateEnd') {
            if (!this._updateLayoutRectOnResized) {
                return;
            }
            if (Math.abs(this._network.getView().offsetWidth - this._lastWidth) <= 2 &&
				Math.abs(this._network.getView().offsetHeight - this._lastHeight) <= 2) {
                return;
            }
            this.updateLayoutRect();
        }
    },
    handleNetworkPropertyChange: function (e) {
        if (e.property === 'elementBox') {
            this._box.removeDataBoxChangeListener(this.handleDataBoxChange, this);
            this._box = this._network.getElementBox();
            this._box.addDataBoxChangeListener(this.handleDataBoxChange, this);
            this.reload();
        }
        if (e.property === 'zoom') {
            this._localPoint = null;
            this.updateLayoutRect();
        }
    },
    _adjustIndex: function () {
        this._nodes.sort(this._sortFunction);
        var count = this._nodes.size();
        for (var i = 0; i < count; i++) {
            var node = this._nodes.get(i).node;
            var oldIndex = this._box.getDatas().indexOf(node);
            this._box.getDatas().removeAt(oldIndex);
            this._box.getDatas().add(node, i);
            this._box.fireIndexChange(node, oldIndex, i);

            this.updateNode(node, i, count, this._nodes.get(i).alpha);
        }
    },
    _sortFunction: function (e1, e2) {
        if (e2.cz > e1.cz) {
            return 1;
        } else if (e2.cz < e1.cz) {
            return -1;
        } else {
            return 0;
        }
    },
    updateNode: function (node, zIndex, count, alpha) {
        if (this._updateNodeFunction) {
            this._updateNodeFunction(node, zIndex, count, alpha);
        }
    },
    _update: function () {
        if (this._freeze) {
            return;
        }
        var a;
        var b;
        if (this._centering) {
            if (this._centeringNode) {
                var atCenter = this.isAtCenter(this._centeringNode.node, this._centeringNode.perspective, this._centeringNode.cx, this._centeringNode.cy, this._centeringNode.cz);
                if (atCenter) {
                    this._freeze = true;
                    this._centering = false;
                    this._centeringNode = null;
                    return;
                }
            }
        }
        if (!this._freeze && (this._active || this._centering) && this._localPoint) {
            if (!this.isElliptical()) {
                a = (this._centerY - this._localPoint.y) / this._radius * this._moveSpeed;
                b = (this._localPoint.x - this._centerX) / this._radius * this._moveSpeed;
            } else {
                a = (this._centerY - this._localPoint.y) / (this._rect.height / 2) * this._moveSpeed;
                b = (this._localPoint.x - this._centerX) / (this._rect.width / 2) * this._moveSpeed;
            }
        } else {
            a = this._lasta * this._ceaseRate;
            b = this._lastb * this._ceaseRate;
        }

        this._lasta = a;
        this._lastb = b;

        if (Math.abs(a) > this._ceaseLimit || Math.abs(b) > this._ceaseLimit) {
            var c = 0;
            this._sineCosine(a, b, c);
            for (var j = 0, nodeSize = this._nodes.size(); j < nodeSize; j++) {
                var nodeStruct = this._nodes.get(j);
                // multiply positions by a x-rotation matrix
                var rx1 = nodeStruct.cx;
                var ry1 = nodeStruct.cy * this._ca + nodeStruct.cz * -this._sa;
                var rz1 = nodeStruct.cy * this._sa + nodeStruct.cz * this._ca;
                // multiply new positions by a y-rotation matrix
                var rx2 = rx1 * this._cb + rz1 * this._sb;
                var ry2 = ry1;
                var rz2 = rx1 * -this._sb + rz1 * this._cb;
                // multiply new positions by a z-rotation matrix
                var rx3 = rx2 * this._cc + ry2 * -this._sc;
                var ry3 = rx2 * this._sc + ry2 * this._cc;
                var rz3 = rz2;
                // set arrays to new positions
                nodeStruct.cx = rx3;
                nodeStruct.cy = ry3;
                nodeStruct.cz = rz3;
                // add perspective
                var perspective = this._radius * 2;
                perspective = perspective / (perspective + rz3);
                nodeStruct.perspective = perspective;
                nodeStruct.alpha = (this._radius - rz3) / (this._radius * 2);
                var x = (this._horizontalElliptical * rx3 * perspective) - (this._horizontalElliptical * 2) + this._centerX;
                var y = ry3 * perspective * this._verticalElliptical + this._centerY;
                nodeStruct.node.setCenterLocation(x, y);
            }

            this._adjustIndex();
        }
    },
    centerNode: function (node) {
        if (node && this.isLayoutable(node)) {
            if (this._centeringNode && node === this._centeringNode.node && this._freeze) {
                return;
            }
            for (var i = 0, nodeSize = this._nodes.size(); i < nodeSize; i++) {
                var nodeStruct = this._nodes.get(i);
                if (nodeStruct && node === nodeStruct.node) {
                    this._centering = true;
                    this._freeze = false;
                    this._active = true;
                    this._centeringNode = nodeStruct;
                    this._localPoint = this.createControlPoint(this._centeringNode.node);
                    break;
                }
            }
        } else {
            this._centering = false;
            this._freeze = false;
            this._active = false;
            this._localPoint = null;
        }
    },
    createControlPoint: function (node) {
        var nodePoint = node.getCenterLocation();
        var layoutRect = this.getLayoutRect();
        var layoutCenterX = layoutRect.x + layoutRect.width / 2;
        var layoutCenterY = layoutRect.y + layoutRect.height / 2;
        var angle = Math.atan2(nodePoint.y - layoutCenterY, nodePoint.x - layoutCenterX);
        var distance = layoutRect.width + layoutRect.height;
        return { x: layoutCenterX + distance * Math.cos(angle), y: layoutCenterY + distance * Math.sin(angle) };
    },
    isAtCenter: function (node, perspective, cx, cy, cz) {
        if (this._moveSpeed <= 0) {
            return true;
        }
        var z2r = 16 / this._moveSpeed;
        if (z2r > 20) {
            z2r = 20;
        } else if (z2r < 2) {
            z2r = 2;
        }
        return -cz / Math.sqrt(cx * cx + cy * cy) > z2r;
    },
    _updateNodes: function (a, b, c) {
        this._sineCosine(a, b, c);
        for (var j = 0, nodeSize = this._nodes.size(); j < nodeSize; j++) {
            var nodeStruct = this._nodes.get(j);
            // multiply positions by a x-rotation matrix
            var rx1 = nodeStruct.cx;
            var ry1 = nodeStruct.cy * this._ca + nodeStruct.cz * -this._sa;
            var rz1 = nodeStruct.cy * this._sa + nodeStruct.cz * this._ca;
            // multiply new positions by a y-rotation matrix
            var rx2 = rx1 * this._cb + rz1 * this._sb;
            var ry2 = ry1;
            var rz2 = rx1 * -this._sb + rz1 * this._cb;
            // multiply new positions by a z-rotation matrix
            var rx3 = rx2 * this._cc + ry2 * -this._sc;
            var ry3 = rx2 * this._sc + ry2 * this._cc;
            var rz3 = rz2;
            // set arrays to new positions
            nodeStruct.cx = rx3;
            nodeStruct.cy = ry3;
            nodeStruct.cz = rz3;
            // add perspective
            var perspective = this._radius * 2;
            perspective = perspective / (perspective + rz3);
            nodeStruct.perspective = perspective;

            var x = (this._horizontalElliptical * rx3 * perspective) - (this._horizontalElliptical * 2) + this._centerX;
            var y = ry3 * perspective * this._verticalElliptical + this._centerY;
            nodeStruct.node.setCenterLocation(x, y);
        }
        this._adjustIndex();
    },
    _installListeners: function () {
        this._box = this._network.getElementBox();
        this._box.addDataBoxChangeListener(this.handleDataBoxChange, this);
        this._network.getSelectionModel().addSelectionChangeListener(this.handleSelectionChange, this);
        this._network.addViewListener(this.handleResize, this);
        $html.addEventListener('mouseout', 'handleRollOut', this._network.getView(), this);
        $html.addEventListener('mousemove', 'handleMouseMove', this._network.getView(), this);
        $html.addEventListener('mouseover', 'handleMouseOver', this._network.getView(), this);
        this._network.addPropertyChangeListener(this.handleNetworkPropertyChange, this);
    },
    _uninstallListeners: function () {
        this._box.removeDataBoxChangeListener(this.handleDataBoxChange, this);
        this._network.getSelectionModel().removeSelectionChangeListener(this.handleSelectionChange, this);
        this._network.removeViewListener(this.handleResize, this);
        $html.removeEventListener('mouseout', this._network.getView(), this);
        $html.removeEventListener('mousemove', this._network.getView(), this);
        $html.removeEventListener('mouseover', this._network.getView(), this);
        this._network.removePropertyChangeListener(this.handleNetworkPropertyChange, this);
    }
});

twaver.layout.AutoLayouter = function (elementBox, network) {
    this._box = elementBox;
    this._network = network;
};
_twaver.ext('twaver.layout.AutoLayouter', Object, {
    _expandGroup: false,
    _repulsion: 1,
    _type: null,
    _animate: true,
    _explicitXOffset: Number.NaN,
    _explicitYOffset: Number.NaN,
    _xOffset: 0,
    _yOffset: 0,
    isExpandGroup: function () {
        return this._expandGroup;
    },
    setExpandGroup: function (value) {
        this._expandGroup = value;
    },
    getRepulsion: function () {
        return this._repulsion;
    },
    setRepulsion: function (value) {
        this._repulsion = value;
    },
    getType: function () {
        return this._type;
    },
    isAnimate: function () {
        return this._animate;
    },
    setAnimate: function (value) {
        this._animate = value;
    },
    getElementBox: function () {
        return this._box;
    },
    getExplicitXOffset: function () {
        return this._explicitXOffset;
    },
    setExplicitXOffset: function (value) {
        this._explicitXOffset = value;
    },
    getExplicitYOffset: function () {
        return this._explicitYOffset;
    },
    setExplicitYOffset: function (value) {
        this._explicitYOffset = value;
    },
    getNodeRect: function(node) {
        var self = this;
        if (node instanceof twaver.Group && node.isExpanded() && node.getChildrenSize() > 0) {
            var rect = null;
            for (var i = 0, n = node.getChildrenSize(); i < n; i++) {
                var child = node.getChildAt(i);
                if (child instanceof twaver.Node) {
                    rect = twaver.Util.unionRect(rect, self.getNodeRect(child));
                }
            }
            var padding = node.s('group.padding'),
            top = node.s('group.padding.top'),
            bottom = node.s('group.padding.bottom'),
            left = node.s('group.padding.left'),
            right = node.s('group.padding.right');
            if (padding) {
                twaver.Util.grow(rect, padding, padding);
            }
            if (top) {
                rect.y -= top;
                rect.height += top;
            }
            if (bottom) {
                rect.height += top;
            }
            if (left) {
                rect.x -= left;
                rect.width += left;
            }
            if (right) {
                rect.width += right;
            }
            return rect;
        } else {
            if(this._network){
                var ui = this._network.getElementUI(node);
                ui.invalidate();
                ui.validate();
                return ui.getViewRect();
            }else {
                return null;
            }
        }
    },
    getDimension: function (node) {
        var bounds = this.getNodeRect(node);
        if(bounds) {
            return {width: bounds.width, height: bounds.height};
        }
        return {width: node.getWidth(), height: node.getHeight()};
    },
    isVisible: function (element) {
        return true;
    },
    isMovable: function (element) {
        return true;
    },
    getGroupLayoutType: function (group) {
        return this._type;
    },
    getElements: function () {
        var list, box = this._box;
        var hasSelected = box.getSelectionModel().size() > 1;
        if (hasSelected) {
            list = box.getSelectionModel().getSelection();
        } else {
            list = new $List();
            box.forEachByBreadthFirst(list.add, null, list);
        }
        this._xOffset = -1;
        this._yOffset = -1;
        var elements = new $List();
        for (var i = 0, n = list.size(); i < n; i++) {
            var element = list.get(i);
            if (this.isVisible(element)) {
                if (element instanceof twaver.Link) {
                    elements.add(element);
                }
                else if (this.isMovable(element) && element instanceof $Node) {
                    elements.add(element);
                    if (hasSelected) {
                        if (this._xOffset < 0 || element.getX() < this._xOffset) {
                            this._xOffset = element.getX();
                        }
                        if (this._yOffset < 0 || element.getY() < this._yOffset) {
                            this._yOffset = element.getY();
                        }
                    }
                }
            }
        }
        if (!hasSelected) {
            if (!isNaN(this._explicitXOffset)) {
                this._xOffset = this._explicitXOffset;
            } else {
                this._xOffset = 50 / this._repulsion;
            }
            if (!isNaN(this._explicitYOffset)) {
                this._yOffset = this._explicitYOffset;
            } else {
                this._yOffset = 50 / this._repulsion;
            }
        }
        return elements;
    },
    getLayoutResult: function (type) {
        var result = {};
        this.doLayoutImpl(type, null, result);
        return result;
    },
    doLayout: function (type, finishFunction) {
        return this.doLayoutImpl(type, finishFunction);
    },
    doLayoutImpl: function (type, finishFunction, result) {
        var self = this;
        var oldFinishFunction = finishFunction;
        finishFunction = function (success) {
            self._box._layoutMovingElements = false;
            if (oldFinishFunction) oldFinishFunction(success);
        }
        this._type = type;
        var layout = null;
        if ('round' === type) {
            layout = new $A70();
        } else if ('symmetry' === type) {
            layout = new $A87();
        } else if ('hierarchic' === type) {
            layout = new $A89();
        } else if (type === 'topbottom' || type === 'bottomtop' || type === 'rightleft' || type === 'leftright') {
            layout = new $A52();
        }
        if (layout == null) {
            return false;
        }
        self._box._layoutMovingElements = true;
        var newLocations = {};
        var elements = this.getElements();
        var preProcessor = new $A88(this, elements, true, null);
        elements = preProcessor.process();
        var data = new $A82(this, elements, type, true, null);

        try {
            layout.i2(data);
        } catch (ex) {
            preProcessor.resetGroup();
            if (finishFunction != null) {
                finishFunction(false);
            }
            return false;
        }

        // get location result.
        var id, yNode;
        for (id in data._a) {
            yNode = data._a[id];
            var p = data.g4(yNode);
            newLocations[id] = { x: p.x + this._xOffset, y: p.y + this._yOffset };
        }
        var newLocation;
        if (type === "rightleft" || type === "leftright" || type === "bottomtop") {
            var matrix = $A88.createMatrix(type);

            var mx = Number.MAX_VALUE;
            var my = Number.MAX_VALUE;
            for (id in newLocations) {
                yNode = data._a[id];
                newLocation = newLocations[id];
                var p2 = matrix.transform(newLocation);
                newLocation.x = p2.x;
                newLocation.y = p2.y;

                var v;
                if (type === "rightleft" || type === "leftright") {
                    v = p2.x - data.g9(yNode) / 2 / this._repulsion;
                    if (v < mx) {
                        mx = v;
                    }
                    v = p2.y - data.gj(yNode) / 2 / this._repulsion;
                    if (v < my) {
                        my = v;
                    }
                } else {
                    v = p2.x - data.gj(yNode) / 2 / this._repulsion;
                    if (v < mx) {
                        mx = v;
                    }
                    v = p2.y - data.g9(yNode) / 2 / this._repulsion;
                    if (v < my) {
                        my = v;
                    }
                }
            }

            for (id in newLocations) {
                yNode = data._a[id];
                newLocation = newLocations[id];
                newLocation.x = newLocation.x - mx + this._xOffset;
                newLocation.y = newLocation.y - my + this._yOffset;
            }
        }

        if (result == null && this._animate) {
            var objs = new $List();
            var locs = new $List();
            for (id in newLocations) {
                objs.add(data._a[id].node);
                locs.add(newLocations[id]);
            }
            twaver.animate.AnimateManager.endAnimate();
            self._box._dataBoxChangeDispatcher.fire({ kind: 'layouting'});
            twaver.animate.AnimateManager.start(new twaver.animate.AnimateCenterLocation(objs, locs, function () {
                preProcessor.resetGroup();
                self._box._dataBoxChangeDispatcher.fire({ kind: 'layoutEnd'});
                if (finishFunction != null) {
                    _twaver.callLater(finishFunction, null, [true]);
                }
            }));
        } else {
            self._box._dataBoxChangeDispatcher.fire({ kind: 'layouting'});
            for (id in newLocations) {
                yNode = data._a[id];
                newLocation = newLocations[id];
                if (result == null) {
                    yNode.node.setCenterLocation(newLocation.x, newLocation.y);
                } else {
                    result[yNode.node.getId()] = newLocation;
                }
            }
            preProcessor.resetGroup();
            self._box._dataBoxChangeDispatcher.fire({ kind: 'layoutEnd' });
            if (finishFunction != null) {
                _twaver.callLater(finishFunction, null, [true]);
            }
        }

        return true;
    }
});

var $A00 = function (x, y) {
    this.x = x;
    this.y = y;
};
_twaver.ext($A00, Object, {
    equals: function (obj) {
        if (this === obj)
            return true;
        if (!(obj instanceof $A00)) {
            return false;
        } else {
            return obj.x == this.x && obj.y == this.y;
        }
    }
});

var $A01 = function (width, height) {
    this.width = width;
    this.height = height;
};
_twaver.ext($A01, Object, {

});

var $A02 = function (d, d1) {
    this.x = d;
    this.y = d1;
};
_twaver.ext($A02, Object, {

});

var $A03 = function () {
    if (arguments.length === 2) {
        $A03.superClass.constructor.call(this, arguments[1].width, arguments[1].height);
        this.x = arguments[0].x;
        this.y = arguments[0].y;
    } else {
        $A03.superClass.constructor.call(this, arguments[2], arguments[3]);
        this.x = arguments[0];
        this.y = arguments[1];
    }
};
_twaver.ext($A03, $A01, {

});

var $A04 = function (ypoint, ypoint1) {
    if ($A04.a2(ypoint.x, ypoint1.x)) {
        this._a = 1.0;
        this._b = 0.0;
        this._c = -ypoint.x;
    } else {
        this._b = -1;
        var d1 = (ypoint1.y - ypoint.y) / (ypoint1.x - ypoint.x);
        var d2 = ypoint.y - ypoint.x * d1;
        this._a = d1;
        this._c = d2;
    }
};
_twaver.ext($A04, Object, {
    a3: function () {
        return this._a;
    },
    a4: function () {
        return this._b;
    },
    a5: function () {
        return this._c;
    }
});
$A04.a6 = function (affineline, affineline1) {
    if ($A04.a1(affineline.a3()) && $A04.a1(affineline1.a3()))
        return null;
    if ($A04.a1(affineline.a4()) && $A04.a1(affineline1.a4()))
        return null;
    if ($A04.a1(affineline1.a4())) {
        var affineline2 = affineline;
        affineline = affineline1;
        affineline1 = affineline2;
    }
    var d3 = affineline.a3();
    var d4 = affineline.a4();
    var d5 = -affineline.a5();
    var d6;
    var d7;
    if (!$A04.a1(affineline.a3())) {
        d6 = affineline1.a4() - (affineline1.a3() / affineline.a3()) * affineline.a4();
        d7 = -affineline1.a5() - (affineline1.a3() / affineline.a3()) * -affineline.a5();
    } else {
        d6 = affineline1.a4();
        d7 = -affineline1.a5();
    }
    var d2 = d7 / d6;
    var d1 = (d5 - d2 * d4) / d3;
    return new $A00(d1, d2);
};
$A04.a1 = function (d1) {
    return $A04.a2(d1, 0.0);
};
$A04.a2 = function (d1, d2) {
    return Math.abs(d1 - d2) < 1.0000000000000001E-005;
};
var $A05 = function (vector) {
    this._a = new $A35();
    if (vector) {
        for (var i = 0; i < vector.size(); i++)
            this._a.aa(vector.get(i));
    }
};
_twaver.ext($A05, Object, {
    c: function () {
        return this._a.ah();
    },
    d: function () {
        return this._a.ah();
    },
    a: function () {
        var vector = new $List();
        for (var ycursor = this.c(); ycursor.i1(); ycursor.i2())
            vector.add(ycursor.i6(), 0);

        return new $A05(vector);
    },
    b: function () {
        return this._a.ay();
    }
});

var $A06 = function (x, y) {
    this.x = x;
    this.y = y;
};
_twaver.ext($A06, Object, {
    a: function (x, y) {
        this.x = x;
        this.y = y;
    }
});

var $A07 = function (d, d1) {
    this.x = d || 0;
    this.y = d1 || 0;
};
_twaver.ext($A07, Object, {
    b: function () {
        return new $A07(this.x, this.y);
    },
    a: function (edgerealizer) {
        this.z = edgerealizer;
    },
    c: function () {
        return this.x;
    },
    d: function () {
        return this.y;
    },
    f: function (d, d1) {
        this.x = d;
        this.y = d1;
    }
});

var $A08 = function (edgerealizer) {
    this._c = new $A35();
    if (edgerealizer) {
        this.ac(edgerealizer.a8().b());
        this.ad(edgerealizer.a9().b());
    } else {
        this.ac(new $A07());
        this.ad(new $A07());
    }
};
_twaver.ext($A08, Object, {
    a6: function () {
        return this.a5(this);
    },
    ac: function (port) {
        port.a(this);
        this._a = port;
    },
    ad: function (port) {
        port.a(this);
        this._b = port;
    },
    a8: function () {
        return this._a;
    },
    a9: function () {
        return this._b;
    },
    a1: function (d1, d2) {
        return this.a4(d1, d2, this.aa());
    },
    a2: function () {
        return this._c.ay();
    },
    a7: function (i1) {
        return this._c.ak(i1);
    },
    aa: function () {
        if (this._c.ay() === 0)
            return null;
        else
            return this._c.as();
    },
    a3: function () {
        this._c.af();
    },
    i2: function (i1) {
        var bend = this.a7(i1);
        if (bend != null)
            return new $A00(bend.x, bend.y);
        else
            return null;
    },
    i1: function () {
        return this.a2();
    },
    i6: function () {
        var port = this.a8();
        return new $A00(port.c(), port.d());
    },
    i7: function () {
        var port = this.a9();
        return new $A00(port.c(), port.d());
    },
    i8: function (ypoint) {
        this.a8().f(ypoint.x, ypoint.y);
    },
    i9: function (ypoint) {
        this.a9().f(ypoint.x, ypoint.y);
    },
    i3: function (i1, d1, d2) {
        var bend = this.a7(i1);
        if (bend != null)
            bend.a(d1, d2);
    },
    i4: function (d1, d2) {
        this.a1(d1, d2);
    },
    i5: function () {
        this.a3();
    }
});

var $A09 = function (edgerealizer) {
    $A09.superClass.constructor.call(this, edgerealizer);
};
_twaver.ext($A09, $A08, {
    a5: function (edgerealizer) {
        return new $A09(edgerealizer);
    },
    a4: function (d, d1, bend) {
        var bend1 = new $A06(d, d1);
        this.ab(bend1, bend);
        return bend1;
    },
    ab: function (bend, bend1) {
        this._c.an(bend, this._c.al(bend1));
    }
});

var $A11 = function () {
    if (arguments.length === 2) {
        var d1 = arguments[0], d2 = arguments[1];
        this._s = false;
        this._w = 30;
        this._h = 30;
        this._x = d1 - this._w / 2;
        this._y = d2 - this._h / 2;
    } else {
        var noderealizer = arguments[0];
        this._s = noderealizer._s;
        this._w = noderealizer._w;
        this._h = noderealizer._h;
        this._x = noderealizer._x;
        this._y = noderealizer._y;
    }
};
_twaver.ext($A11, Object, {
    m3: function () {
        return this.m2(this);
    },
    m4: function () {
        return this._x + this._w / 2;
    },
    m5: function () {
        return this._y + this._h / 2;
    },
    m6: function (d1, d2) {
        this._x = d1 - this._w / 2;
        this._y = d2 - this._h / 2;
    },
    i1: function () {
        return this._x;
    },
    i2: function () {
        return this._y;
    },
    i5: function (d1, d2) {
        this._x = d1;
        this._y = d2;
    },
    i3: function () {
        return this._w;
    },
    i4: function () {
        return this._h;
    },
    i6: function (d1, d2) {
        var d3 = (this._w - d1) / 2;
        var d4 = (this._h - d2) / 2;
        this._x += d3;
        this._y += d4;
        this._w = d1;
        this._h = d2;
    },
    m1: function (rectangle2d) {
        var d1, d2, d3, d4;
        if (rectangle2d.width <= 0.0) {
            d1 = this._x;
            d2 = this._x + this._w;
            d3 = this._y;
            d4 = this._y + this._h;
        } else {
            d1 = Math.min(this._x, rectangle2d.x);
            d2 = Math.max(this._x + this._w, rectangle2d.x + rectangle2d.width);
            d3 = Math.min(this._y, rectangle2d.y);
            d4 = Math.max(this._y + this._h, rectangle2d.y + rectangle2d.height);
        }

        rectangle2d.x = d1;
        rectangle2d.y = d3;
        rectangle2d.width = d2 - d1;
        rectangle2d.height = d4 - d3;
    }
});

var $A10 = function (noderealizer) {
    if (noderealizer) {
        $A10.superClass.constructor.call(this, noderealizer);
    } else {
        $A10.superClass.constructor.call(this, 0, 0);
    }
};
_twaver.ext($A10, $A11, {
    m2: function (noderealizer) {
        return new $A10(noderealizer);
    }
});

var $A12 = {};
$A12.a2 = function (graph) {
    var nodemap = $A49.a2($A53.a(graph.xa()));
    return $A12.a4(graph, nodemap, $A12.a3(graph, nodemap));
};
$A12.a3 = function (graph, nodemap) {
    for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2())
        nodemap.i7(nodecursor.i9(), -1);

    var i = 0;
    var boundedstack = new $A30(graph.xa());
    for (var nodecursor1 = graph.x9(); nodecursor1.i1(); nodecursor1.i2()) {
        var node = nodecursor1.i9();
        if (nodemap.i2(node) === -1)
            $A12.a(node, boundedstack, nodemap, i++);
    }

    return i;
};
$A12.a6 = function (graph) {
    var edgelist = new $A25();
    var anodelist = $A12.a2(graph);
    for (var i = 0; i < anodelist.length - 1; i++) {
        var edge = graph.xo(anodelist[i].x2(), anodelist[i + 1].x3());
        edgelist.aa(edge);
    }

    return edgelist;
};
$A12.a4 = function (graph, nodemap, i) {
    var anodelist = [];
    for (var j = 0; j < i; j++)
        anodelist[j] = new $A46();

    for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2())
        anodelist[nodemap.i2(nodecursor.i9())].ae(nodecursor.i9());

    return anodelist;
};
$A12.a = function (node, boundedstack, nodemap, i) {
    boundedstack.c(node);
    nodemap.i7(node, i);
    while (!boundedstack.a()) {
        node = boundedstack.b();
        for (var edge = node.ag(); edge != null; edge = edge.a8()) {
            var node1 = edge.a3();
            if (nodemap.i2(node1) === -1) {
                nodemap.i7(node1, i);
                boundedstack.c(node1);
            }
        }

        for (var edge1 = node.ae(); edge1 != null; edge1 = edge1.a7()) {
            var node2 = edge1.a2();
            if (nodemap.i2(node2) === -1) {
                nodemap.i7(node2, i);
                boundedstack.c(node2);
            }
        }
    }
};
$A12.a1 = function (graph, edgemap, nodemap) {
    var _la = new $A21(edgemap, nodemap);
    _la.a8(graph);
    return _la._i;
};
$A12.a5 = function (graph, edgemap, i) {
    var aedgelist = [];
    for (var j = 0; j < i; j++)
        aedgelist[j] = new $A25();

    for (var edgecursor = graph.xf(); edgecursor.i1(); edgecursor.i2())
        aedgelist[edgemap.i2(edgecursor.i8())].aa(edgecursor.i8());

    return aedgelist;
};
$A12.a7 = function (graph) {
    var edgelist = new $A25();
    var nodemap = $A49.a3($A53.b(graph.xa()));
    var edgemap = $A49.a4($A53.a(graph.xh()));
    var i = $A12.a1(graph, edgemap, nodemap);
    var aedgelist = $A12.a5(graph, edgemap, i);
    if (aedgelist.length > 1) {
        var nodelist = new $A46();
        for (var j = 0; j < aedgelist.length; j++) {
            var edgelist1 = aedgelist[j];
            var node2 = null;
            if (edgelist1.ay() === 1) {
                var edge = edgelist1.c2();
                if (edge.a2().ad() === 1)
                    node2 = edge.a2();
                else if (edge.a3().ad() === 1)
                    node2 = edge.a3();
            } else {
                for (var edgecursor = edgelist1.c1(); edgecursor.i1(); edgecursor.i2()) {
                    var edge1 = edgecursor.i8();
                    if (nodemap.i4(edge1.a2()))
                        if (node2 == null)
                            node2 = edge1.a2();
                        else if (node2 !== edge1.a2()) {
                            node2 = null;
                            break;
                        }
                    if (!nodemap.i4(edge1.a3()))
                        continue;
                    if (node2 == null) {
                        node2 = edge1.a3();
                        continue;
                    }
                    if (node2 === edge1.a3())
                        continue;
                    node2 = null;
                    break;
                }

                if (node2 != null) {
                    var edge2 = edgelist1.c2();
                    if (edge2.a2() !== node2)
                        node2 = edge2.a2();
                    else
                        node2 = edge2.a3();
                }
            }
            if (node2 != null)
                nodelist.aa(node2);
        }

        var node1;
        for (var node = nodelist.x4(); !nodelist.ar(); node = node1) {
            node1 = nodelist.x4();
            edgelist.ac(graph.xo(node, node1));
        }

    }
    return edgelist;
};

var $A19 = function () {
    this._c = 0;
    this._d = 0;
    this._e = 0;
    this._b = true;
    this._f = false;
};
_twaver.ext($A19, Object, {
    a6: function (flag) {
        this._f = flag;
    },
    a7: function (flag) {
        this._b = flag;
    },
    a8: function (graph) {
        if (graph.x0() !== 0) {
            this.a9(graph, graph.x9().i9());
        }
    },
    a9: function (graph, node) {
        this._xx = graph.xk();
        this._c = graph.xl();
        this._d = 0;
        this._e = 0;
        this.a0(node);
        if (this._b) {
            for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
                var node1 = nodecursor.i9();
                if (this._xx.i1(node1) == null) {
                    this.a1(node1);
                    this.a0(node1);
                }
            }

        }
        graph.xi(this._xx);
        graph.xj(this._c);
    },
    a0: function (node) {
        var i = ++this._d;
        this._xx.z1(node, $A19._B);
        this.a5(node, i);
        for (var edgecursor = this._f ? node.ap() : node.af(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            if (!this._c.i4(edge)) {
                this._c.i7(edge, true);
                var node1 = edge.a1(node);
                if (this._xx.i1(node1) == null) {
                    this.a3(edge, node1, true);
                    this.a0(node1);
                    this.a2(edge, node1);
                } else {
                    this.a3(edge, node1, false);
                }
            }
        }

        this.a4(node, i, ++this._e);
        this._xx.z1(node, $A19._C);
    },
    a5: function (node, i) {
    },
    a4: function (node, i, j) {
    },
    a3: function (edge, node, flag) {
    },
    a2: function (edge, node) {
    },
    a1: function (node) {
    }
});
$A19._B = {};
$A19._C = {};

var $A13 = function (a) {
    this._a = a;
};
_twaver.ext($A13, $A19, {
    a5: function (node1, j1) {
        var k1 = this._a._ah.i2(node1);
        this._a._ad[k1].ae(node1);
    }
});

var $A14 = function (a) {
    this._a = a;
};
_twaver.ext($A14, $A19, {
    a2: function (edge2, node3) {
        var node4 = edge2.a1(node3);
        var _la1 = this._a[node4.al()];
        var _la2 = this._a[node3.al()];
        if (_la2._a + 1 > _la1._a) {
            _la1._c = _la1._a;
            _la1._b = _la1._d;
            _la1._a = _la2._a + 1;
            _la1._d = edge2;
        } else if (_la2._a + 1 > _la1._c) {
            _la1._c = _la2._a + 1;
            _la1._b = edge2;
        }
    }
});

var $A15 = function (a) {
    this._a = a;
};
_twaver.ext($A15, $A19, {
    a3: function (edge, node1, flag) {
        if (flag && edge.a2() === node1)
            this._a.ac(edge);
    }
});

var $A16 = function () {
    this._a = 0;
    this._c = 0;
};
_twaver.ext($A16, Object, {

});

var $A17 = function () {
    this._a = 0;
};
_twaver.ext($A17, Object, {
    a1: function (graph, ai) {
        this._a = 0;
        for (var i = ai.length - 1; i >= 0; i--)
            ai[i] = -1;

        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (node.ak() !== 0)
                continue;
            this.a2(node, node.al(), ai);
            break;
        }
        for (var nodecursor1 = graph.x9(); nodecursor1.i1(); nodecursor1.i2()) {
            var node1 = nodecursor1.i9();
            var j = node1.al();
            if (ai[j] === -1)
                this.a2(node1, j, ai);
        }
    },
    a2: function (node, i, ai) {
        ai[i] = -2;
        for (var edge = node.ag(); edge != null; ) {
            var node1 = edge.a3();
            var j = node1.al();
            switch (ai[j]) {
                case -1:
                    this.a2(node1, j, ai);
                case -2:
                default:
                    edge = edge.a8();
                    break;
            }
        }

        ai[i] = this._a++;
    }
});

var $A18 = {};
$A18.a1 = function (graph) {
    var _la = new $A20();
    _la.a8(graph);
    return _la._n;
};
$A18.a2 = function (graph) {
    var nodecursor = graph.x9();
    var node = null;
    var i = 0;
    nodecursor.i4();
    for (; nodecursor.i1(); nodecursor.i2())
        if (nodecursor.i9().ak() === 0) {
            node = nodecursor.i9();
            i++;
        }

    if (i === 1)
        return node;
    i = 0;
    nodecursor.i4();
    for (; nodecursor.i1(); nodecursor.i2())
        if (nodecursor.i9().ao() === 0) {
            node = nodecursor.i9();
            i++;
        }

    if (i === 1)
        return node;
    else
        return $A18.a8(graph);
};
$A18.a8 = function (graph) {
    var ai = $A53.a(graph.x0());
    var nodemap = $A49.a2(ai);
    return $A18.a6(graph, nodemap);
};
$A18.a6 = function (graph, nodemap) {
    var node = graph.xd();
    var anode = $A53.d(1);
    var ai = $A53.a(graph.x0(), -1);
    var edgelist = $A18.a4(graph, node);
    $A18.a7(node, nodemap, anode, ai, -1);
    for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2())
        graph.x3(edgecursor.i8());

    return anode[0];
};
$A18.a7 = function (node, nodemap, anode, ai, i) {
    var j = 0;
    for (var edge = node.ag(); edge != null; edge = edge.a8()) {
        var node1 = edge.a3();
        var l = $A18.a7(node1, nodemap, anode, ai, i);
        if (l > i)
            i = l;
        j += ai[node1.al()];
    }

    var k = j * (node._g.xa() - 1 - j);
    for (var edge1 = node.ag(); edge1 != null; edge1 = edge1.a8()) {
        var node2 = edge1.a3();
        for (var edge2 = edge1.a8(); edge2 != null; edge2 = edge2.a8()) {
            var node3 = edge2.a3();
            k += ai[node2.al()] * ai[node3.al()];
        }

    }

    nodemap.i7(node, k);
    ai[node.al()] = j + 1;
    if (k > i) {
        i = k;
        anode[0] = node;
    }
    return i;
};
$A18.a4 = function (graph, node) {
    var reversed = new $A25();
    var dfs = new $A15(reversed);
    dfs.a6(false);
    dfs.a9(graph, node);
    for (var edgecursor = reversed.c1(); edgecursor.i1(); edgecursor.i2())
        graph.x3(edgecursor.i8());

    return reversed;
};
$A18.a3 = function (graph) {
    return $A18.a4(graph, $A18.a2(graph));
};

var $A20 = function () {
    this._n = true;
    this.a6(false);
};
_twaver.ext($A20, $A19, {
    a3: function (edge, node, flag) {
        if (!flag)
            this._n = false;
    },
    a1: function (node) {
        this._n = false;
    }
});

var $A21 = function (edgemap, nodemap) {
    this._i = 0;
    this._m = nodemap;
    this._j = edgemap;
    this._l = false;
};
_twaver.ext($A21, $A19, {
    a8: function (graph) {
        this._h = $A53.a(graph.x0());
        this._k = $A53.a(graph.x0());
        this._g = new $A30(graph.xh());
        $A21.superClass.a8.call(this, graph);
    },
    a5: function (node, i1) {
        this._k[node.al()] = this._h[node.al()] = i1;
    },
    a3: function (edge, node, flag) {
        this._g.c(edge);
        if (!flag) {
            var node1 = edge.a1(node);
            this._h[node1.al()] = Math.min(this._h[node1.al()], this._k[node.al()]);
        }
    },
    a1: function (node) {
        this._l = false;
    },
    a2: function (edge, node) {
        var node1 = edge.a1(node);
        if (this._h[node.al()] >= this._k[node1.al()]) {
            for (; this._g.d() !== edge; this._j.i5(this._g.b(), this._i))
                ;
            this._j.i5(this._g.b(), this._i);
            this._i++;
            if (this._g.a()) {
                if (this._l)
                    this._m.i5(node1, true);
                else
                    this._l = true;
            } else {
                this._m.i5(node1, true);
            }
        }
        this._h[node1.al()] = Math.min(this._h[node1.al()], this._h[node.al()]);
    }
});

var $A22 = function (j, for1) {
    this._h = false;
    this._i = j;
    this._g = for1;
};
_twaver.ext($A22, Object, {
    z1: function (obj, obj1) {
        obj._c[this._i] = obj1;
    },
    i1: function (obj) {
        return obj._c[this._i];
    },
    i5: function (obj, flag) {
        obj._c[this._i] = flag;
    },
    i4: function (obj) {
        return obj._c[this._i];
    },
    i7: function (obj, j) {
        obj._c[this._i] = j;
    },
    i2: function (obj) {
        var obj1 = obj._c[this._i];
        if (obj1 == null)
            return 0;
        return obj1;
    },
    i6: function (obj, d1) {
        obj._c[this._i] = d1;
    },
    i3: function (obj) {
        var obj1 = obj._c[this._i];
        if (obj1 == null)
            return 0;
        return obj1;
    },
    c: function () {
        return this._h;
    },
    d: function () {
        this._h = true;
    }
});

var $A23 = function (i, for1) {
    this._c = false;
    this._d = i;
    this._b = for1;
};
_twaver.ext($A23, Object, {
    i8: function (obj, obj1) {
        obj._c[this._d] = obj1;
    },
    i1: function (obj) {
        return obj._c[this._d];
    },
    i7: function (obj, flag) {
        obj._c[this._d] = flag;
    },
    i4: function (obj) {
        var obj1 = obj._c[this._d];
        if (obj1 == null)
            return false;
        return obj1;
    },
    i5: function (obj, i) {
        obj._c[this._d] = i;
    },
    i2: function (obj) {
        var obj1 = obj._c[this._d];
        if (obj1 == null)
            return 0;
        return obj1;
    },
    i6: function (obj, d1) {
        obj._c[this._d] = d1;
    },
    i3: function (obj) {
        var obj1 = obj._c[this._d];
        if (obj1 == null)
            return 0.0;
        return obj1;
    },
    a: function () {
        return this._c;
    },
    b: function () {
        this._c = true;
    }
});

var $A32 = function (list) {
    this._bb = list;
    this.i4();
};
_twaver.ext($A32, Object, {
    i1: function () {
        return this._aa != null;
    },
    i2: function () {
        this._aa = this._aa._a;
    },
    i3: function () {
        this._aa = this._aa._b;
    },
    i4: function () {
        this._aa = this._bb._b;
    },
    i5: function () {
        this._aa = this._bb._c;
    },
    i7: function () {
        return this._bb.ay();
    },
    i6: function () {
        return this._aa._c;
    }
});

var $A24 = function (list) {
    $A24.superClass.constructor.call(this, list);
};
_twaver.ext($A24, $A32, {
    i8: function () {
        return this.i6();
    }
});

var $A35 = function (ycursor) {
    this._id = _twaver.id();
    this._a = 0;
    if (ycursor) {
        ycursor.i4();
        for (; ycursor.i1(); ycursor.i2())
            this.ae(ycursor.i6());
    }
};
_twaver.ext($A35, Object, {
    ac: function (obj) {
        var listcell = this.ag(obj);
        if (this._b == null) {
            this._b = this._c = listcell;
        } else {
            this._b._b = listcell;
            listcell._a = this._b;
            this._b = listcell;
        }
        this._a++;
        return listcell;
    },
    ae: function (obj) {
        var listcell = this.ag(obj);
        if (this._c == null) {
            this._b = this._c = listcell;
        } else {
            this._c._a = listcell;
            listcell._b = this._c;
            this._c = listcell;
        }
        this._a++;
        return listcell;
    },
    z1: function (listcell) {
        listcell._b = null;
        listcell._a = null;
        if (this._c == null) {
            this._b = this._c = listcell;
        } else {
            this._c._a = listcell;
            listcell._b = this._c;
            this._c = listcell;
        }
        this._a++;
    },
    ad: function (listcell) {
        listcell._b = null;
        listcell._a = null;
        if (this._b == null) {
            this._b = this._c = listcell;
        } else {
            this._b._b = listcell;
            listcell._a = this._b;
            this._b = listcell;
        }
        this._a++;
    },
    aa: function (obj) {
        this.ae(obj);
        return true;
    },
    ab: function (ycursor) {
        for (; ycursor.i1(); ycursor.i2())
            this.ae(ycursor.i6());
    },
    ao: function (obj, listcell) {
        if (listcell === this._b)
            return this.ac(obj);
        if (listcell == null) {
            return this.ae(obj);
        } else {
            var listcell1 = this.ag(obj);
            this.aq(listcell1, listcell);
            return listcell1;
        }
    },
    aq: function (listcell, listcell1) {
        if (listcell1 == null)
            this.ad(listcell);
        else if (listcell1 === this._b) {
            this.ad(listcell);
        } else {
            if (this._c == null) {
                listcell._b = null;
                listcell._a = null;
                this._b = this._c = listcell;
            } else {
                var listcell2 = listcell1._b;
                listcell1._b = listcell;
                listcell._a = listcell1;
                listcell2._a = listcell;
                listcell._b = listcell2;
            }
            this._a++;
        }
    },
    ap: function (listcell, listcell1) {
        if (listcell1 == null)
            this.z1(listcell);
        else if (listcell1 === this._c) {
            this.z1(listcell);
        } else {
            if (this._b == null) {
                listcell._b = null;
                listcell._a = null;
                this._b = this._c = listcell;
            } else {
                var listcell2 = listcell1._a;
                listcell1._a = listcell;
                listcell._a = listcell2;
                listcell2._b = listcell;
                listcell._b = listcell1;
            }
            this._a++;
        }
    },
    an: function (obj, listcell) {
        if (listcell === this._c)
            return this.ae(obj);
        if (listcell == null) {
            return this.ac(obj);
        } else {
            var listcell1 = this.ag(obj);
            this.ap(listcell1, listcell);
            return listcell1;
        }
    },
    ay: function () {
        return this._a;
    },
    ar: function () {
        return this._a === 0;
    },
    af: function () {
        this._b = this._c = null;
        this._a = 0;
    },
    am: function () {
        return this._b._c;
    },
    at: function () {
        var obj = this.am();
        this.aw(this._b);
        return obj;
    },
    as: function () {
        return this._c._c;
    },
    au: function () {
        return this.aw(this._c);
    },
    ak: function (i) {
        var j = 0;
        for (var listcell = this._b; listcell != null; ) {
            if (i === j)
                return listcell._c;
            listcell = listcell._a;
            j++;
        }
        return null;
    },
    aj: function (listcell) {
        if (listcell._a == null)
            return this._b;
        else
            return listcell._a;
    },
    ai: function (listcell) {
        if (listcell._b == null)
            return this._c;
        else
            return listcell._b;
    },
    aw: function (listcell) {
        if (listcell !== this._b)
            listcell._b._a = listcell._a;
        else
            this._b = listcell._a;
        if (listcell !== this._c)
            listcell._a._b = listcell._b;
        else
            this._c = listcell._b;
        this._a--;
        return listcell._c;
    },
    av: function (ycursor) {
        return this.aw(ycursor._aa);
    },
    ah: function () {
        return new $A32(this);
    },
    al: function (obj) {
        var listcell = this._b;
        while (listcell != null) {
            if (listcell._c == null && obj == null) {
                return listcell;
            }
            if (listcell._c === obj) {
                return listcell;
            }
            listcell = listcell._a;
        }
        return null;
    },
    a0: function () {
        var aobj = $A53.d(this._a);
        var i = 0;
        for (var listcell = this._b; listcell != null; ) {
            aobj[i] = listcell._c;
            listcell = listcell._a;
            i++;
        }
        return aobj;
    },
    ax: function () {
        for (var listcell2 = this._b; listcell2 != null; listcell2 = listcell2._b) {
            var listcell = listcell2._a;
            listcell2._a = listcell2._b;
            listcell2._b = listcell;
        }

        var listcell1 = this._b;
        this._b = this._c;
        this._c = listcell1;
    },
    a1: function (comparator) {
        var aobj = this.a0();
        aobj.sort(comparator);
        var i = 0;
        for (var listcell = this._b; listcell != null; ) {
            listcell._c = aobj[i];
            listcell = listcell._a;
            i++;
        }
    },
    a2: function () {
        var aobj = this.a0();
        aobj.sort($A53.c);
        var i = 0;
        for (var listcell = this._b; listcell != null; ) {
            listcell._c = aobj[i];
            listcell = listcell._a;
            i++;
        }
    },
    az: function (ylist) {
        if (this._b == null) {
            this._b = ylist._b;
            this._c = ylist._c;
        } else if (ylist._b != null) {
            this._c._a = ylist._b;
            ylist._b._b = this._c;
            this._c = ylist._c;
        }
        this._a += ylist._a;
        ylist._b = ylist._c = null;
        ylist._a = 0;
    },
    ag: function (obj) {
        return new $A28(obj);
    }
});

var $A25 = function (edgecursor) {
    $A25.superClass.constructor.call(this, edgecursor);
};
_twaver.ext($A25, $A35, {
    c1: function () {
        return new $A24(this);
    },
    c2: function () {
        return this.am();
    },
    c3: function () {
        return this.at();
    }
});

var $A26 = function () {
    this._c = 0;
};
_twaver.ext($A26, Object, {
    a: function (entry) {
        this._c++;
        entry._b = this._b;
        entry._a = null;
        if (this._b != null) {
            this._b._a = entry;
            this._b = entry;
        } else {
            this._b = this._a = entry;
        }
    },
    b: function (entry, target) {
        if (target == null) {
            this.a(entry);
            return;
        }
        var if3 = target._b;
        if (if3 != null)
            if3._a = entry;
        else
            this._a = entry;
        entry._b = if3;
        entry._a = target;
        target._b = entry;

        this._c++;
    },
    c: function (entry) {
        var next = entry._a;
        var prev = entry._b;
        this._c--;
        if (next != null)
            next._b = prev;
        else
            this._b = prev;
        if (prev != null)
            prev._a = next;
        else
            this._a = next;
    }
});

var $A27 = function (node, i) {
    this._p = node;
    this._j = i;
    this._o = node._o[i];
};
_twaver.ext($A27, Object, {
    i1: function () {
        return this._o != null;
    },
    i2: function () {
        this._o = this._o._k[this._j];
    },
    i3: function () {
        this._o = this._o._f[this._j];
    },
    i4: function () {
        this._o = this._p._o[this._j];
    },
    i5: function () {
        this._o = this._p._q[this._j];
    },
    i7: function () {
        return this._p._n[this._j];
    },
    i6: function () {
        return this._o;
    },
    i8: function () {
        return this._o;
    }
});

var $A28 = function (obj) {
    this._c = obj;
};
_twaver.ext($A28, Object, {
    a: function () {
        return this._a;
    },
    b: function () {
        return this._b;
    },
    c: function (element) {
        this._c = element;
    },
    d: function () {
        return this._c;
    }
});

var $A29 = function (ad, ai, aflag, aobj) {
    this._r = ad;
    this._s = ai;
    this._q = aflag;
    this._p = aobj;
};
_twaver.ext($A29, Object, {
    i1: function (obj) {
        return this._p[obj.a5()];
    },
    i3: function (obj) {
        return this._r[obj.a5()];
    },
    i2: function (obj) {
        return this._s[obj.a5()];
    },
    i4: function (obj) {
        return this._q[obj.a5()];
    },
    i8: function (obj, obj1) {
        this._p[obj.a5()] = obj1;
    },
    i6: function (obj, d) {
        this._r[obj.a5()] = d;
    },
    i5: function (obj, i) {
        this._s[obj.a5()] = i;
    },
    i7: function (obj, flag) {
        this._q[obj.a5()] = flag;
    }
});

var $A30 = function (count) {
    this._a = $A53.d(count);
    this._b = -1;
};
_twaver.ext($A30, Object, {
    d: function () {
        return this._a[this._b];
    },
    b: function () {
        return this._a[this._b--];
    },
    c: function (item) {
        this._a[++this._b] = item;
    },
    a: function () {
        return this._b < 0;
    }
});

var $A33 = function () {

};
_twaver.ext($A33, Object, {
    a0: function (i) {
        this._c = $A53.d(i);
    }
});

var $A34 = function (graph, node, edge, node1, edge1, l, i1) {
    this._g = 0;
    graph.xt(this, node, edge, node1, edge1, l, i1);
};
_twaver.ext($A34, $A33, {
    a5: function () {
        if (this._h._u)
            this._h.b1();
        return this._g;
    },
    a2: function () {
        return this._d;
    },
    a3: function () {
        return this._e;
    },
    a1: function (node) {
        return this._d !== node ? this._d : this._e;
    },
    a4: function () {
        for (var l = 0; l <= 1; l++) {
            this._k[l] = null;
            this._f[l] = null;
        }
    },
    a8: function () {
        return this._k[0];
    },
    a7: function () {
        return this._k[1];
    },
    a6: function (graph, node, node1, l) {
        this.a0(l);
        this._h = graph;
        this._k = $A53.d(2);
        this._f = $A53.d(2);
        this._d = node;
        this._e = node1;
    }
});

var $A36 = function (node) {
    this._j = 0;
    this._h = node;
    this.i4();
};
_twaver.ext($A36, Object, {
    i2: function () {
        this._k = this._k._k[this._j];
        if (this._k == null && this._j === 0) {
            this._k = this._h._o[1];
            this._j = 1;
        }
    },
    i3: function () {
        this._k = this._k._f[this._j];
        if (this._k == null && this._j === 1) {
            this._k = this._h._q[0];
            this._j = 0;
        }
    },
    i4: function () {
        this._k = this._h._o[0];
        if (this._k == null) {
            this._k = this._h._o[1];
            this._j = 1;
        } else {
            this._j = 0;
        }
    },
    i5: function () {
        this._k = this._h._q[1];
        if (this._k == null) {
            this._k = this._h._q[0];
            this._j = 0;
        } else {
            this._j = 1;
        }
    },
    i1: function () {
        return this._k != null;
    },
    i6: function () {
        return this._k;
    },
    i8: function () {
        return this._k;
    },
    i7: function () {
        return this._h.ad();
    }
});

var $A37 = function () {
    this._a = $A72._A;
    this._b = $A72._A;
    this._c = new $List();
};
_twaver.ext($A37, Object, {
    i1: function () {
        return this._c.size();
    },
    i2: function (i) {
        return this._c.get(i);
    },
    i3: function (i, d, d1) {
        this._c.set(i, new $A00(d, d1));
    },
    i4: function (d, d1) {
        this._c.add(new $A00(d, d1));
    },
    i5: function () {
        this._c.clear();
    },
    i6: function () {
        return this._a;
    },
    i7: function () {
        return this._b;
    },
    i8: function (ypoint) {
        this._a = ypoint;
    },
    i9: function (ypoint) {
        this._b = ypoint;
    }
});

var $A38 = function () {
    this._x = 0;
    this._y = 0;
    this._w = 0;
    this._h = 0;
};
_twaver.ext($A38, Object, {
    i5: function (d, d1) {
        this._x = d;
        this._y = d1;
    },
    i6: function (d, d1) {
        this._w = d;
        this._h = d1;
    },
    i4: function () {
        return this._h;
    },
    i3: function () {
        return this._w;
    },
    i1: function () {
        return this._x;
    },
    i2: function () {
        return this._y;
    }
});

var $A39 = function (ad, ai, aflag, aobj) {
    this._m = ad;
    this._n = ai;
    this._l = aflag;
    this._k = aobj;
};
_twaver.ext($A39, Object, {
    i1: function (obj) {
        return this._k[obj.al()];
    },
    i3: function (obj) {
        return this._m[obj.al()];
    },
    i2: function (obj) {
        return this._n[obj.al()];
    },
    i4: function (obj) {
        return this._l[obj.al()];
    },
    z1: function (obj, obj1) {
        this._k[obj.al()] = obj1;
    },
    i6: function (obj, d) {
        this._m[obj.al()] = d;
    },
    i7: function (obj, i) {
        this._n[obj.al()] = i;
    },
    i5: function (obj, flag) {
        this._l[obj.al()] = flag;
    }
});

var $A40 = function (i, j) {
    this._b = i;
    this._r = j;
    this._a = [];
    for (var k = this._b - 1; k >= 0; k--)
        this._a.push(k);

    this._c = new $List();
};
_twaver.ext($A40, Object, {
    a1: function (int1) {
        var i;
        if (this._a.length === 0) {
            this.a2(int1, this._b, this._b + this._r);
            for (var j = (this._b + this._r) - 1; j > this._b; j--)
                this._a.push(j);

            i = this._b;
            this._b += this._r;
        } else {
            i = this._a.pop();
        }
        return i;
    },
    b: function (int1) {
        var i = this.a1(int1);
        var do1 = new $A22(i, this);
        this._c.add(do1);
        this.a4(int1, i);
        return do1;
    },
    c: function (int1) {
        var i = this.a1(int1);
        var new1 = new $A23(i, this);
        this._c.add(new1);
        this.a4(int1, i);
        return new1;
    },
    a2: function (int1, i, j) {
        for (var if1 = int1._a; if1 != null; if1 = if1._a) {
            var aobj = $A53.d(j);
            $A53.f(if1._c, aobj, i);
            if1._c = aobj;
        }
    },
    a3: function (if1, i, j) {
        var aobj = $A53.d(j);
        $A53.f(if1._c, aobj, i);
        if1._c = aobj;
    },
    a4: function (int1, i) {
        for (var if1 = int1._a; if1 != null; if1 = if1._a)
            if1._c[i] = null;
    },
    a5: function (nodemap, int1) {
        if (nodemap instanceof $A22) {
            var do1 = nodemap;
            if (do1.c())
                throw 'Error';
            do1.d();
            var i = nodemap._i;
            if (this._a.indexOf(i) < 0) {
                this.a4(int1, i);
                this._a.push(i);
                this._c.remove(nodemap);
            }
        }
    },
    a6: function (edgemap, int1) {
        if (edgemap instanceof $A23) {
            var new1 = edgemap;
            if (new1.a())
                throw 'Error';
            new1.b();
            var i = new1._d;
            if (this._a.indexOf(i) < 0) {
                this.a4(int1, i);
                this._a.push(i);
                this._c.remove(edgemap);
            }
        }
    }
});

var $A41 = function (graph) {
    this._id = _twaver.id();
    this._p = 0;
    graph.xs(this);
};
_twaver.ext($A41, $A33, {
    ad: function () {
        return this._n[0] + this._n[1];
    },
    ak: function () {
        return this._n[1];
    },
    ao: function () {
        return this._n[0];
    },
    al: function () {
        if (this._g._y)
            this._g.c();
        return this._p;
    },
    ag: function () {
        return this._o[0];
    },
    ae: function () {
        return this._o[1];
    },
    af: function () {
        return new $A36(this);
    },
    am: function () {
        return new $A27(this, 1);
    },
    ap: function () {
        return new $A27(this, 0);
    },
    an: function () {
        return new $A43(this);
    },
    aq: function () {
        return new $A42(this, 1);
    },
    aw: function () {
        return new $A42(this, 0);
    },
    ah: function (node) {
        for (var edge = this._o[0]; edge != null; edge = edge._k[0])
            if (edge.a3() === node)
                return edge;

        return null;
    },
    ai: function (node) {
        for (var edge = this._o[1]; edge != null; edge = edge._k[1])
            if (edge.a2() === node)
                return edge;

        return null;
    },
    aj: function (node) {
        var edge = this.ah(node);
        if (edge == null)
            edge = this.ai(node);
        return edge;
    },
    au: function (comparator) {
        this.at(comparator, 1, $A53.d(this.ak()));
    },
    av: function (comparator) {
        this.at(comparator, 0, $A53.d(this.ao()));
    },
    as: function (graph, i) {
        this.a0(i);
        this._g = graph;
        this._o = $A53.d(2);
        this._q = $A53.d(2);
        this._n = $A53.a(2);
    },
    ab: function (edge, edge1, i, j, k) {
        if (edge1 == null) {
            this.aa(edge, i, j);
            return;
        }
        var l;
        if (edge1._d === edge1._e)
            l = j;
        else
            l = this !== edge1._d ? 1 : 0;
        if (k === 0) {
            var edge2 = edge1._k[l];
            edge._f[j] = edge1;
            edge._k[j] = edge2;
            edge1._k[l] = edge;
            if (edge2 == null)
                this._q[i] = edge;
            else if (edge2._d === edge2._e)
                edge2._f[j] = edge;
            else
                edge2._f[this !== edge2._d ? 1 : 0] = edge;
        } else {
            var edge3 = edge1._f[l];
            edge._k[j] = edge1;
            edge._f[j] = edge3;
            edge1._f[l] = edge;
            if (edge3 == null)
                this._o[i] = edge;
            else if (edge3._d === edge3._e)
                edge3._k[j] = edge;
            else
                edge3._k[this !== edge3._d ? 1 : 0] = edge;
        }
        this._n[i]++;
    },
    aa: function (edge, i, j) {
        var edge1 = this._q[i];
        edge._k[j] = null;
        if (edge1 == null) {
            this._o[i] = edge;
            edge._f[j] = null;
        } else {
            edge._f[j] = edge1;
            if (edge1._d === edge1._e) {
                edge1._k[j] = edge;
            } else {
                edge1._k[this !== edge1._d ? 1 : 0] = edge;
            }
        }
        this._q[i] = edge;
        this._n[i]++;
    },
    ar: function (edge, i, j) {
        var edge1;
        var edge2;
        edge1 = edge._k[j];
        edge2 = edge._f[j];

        if (edge1 == null) {
            this._q[i] = edge2;
        } else {
            edge1._f[!(edge1._d === this) ? 1 : 0] = edge2;
        }

        if (edge2 == null) {
            this._o[i] = edge1;
        } else {
            edge2._k[!(edge2._d === this) ? 1 : 0] = edge1;
        }

        this._n[i]--;
    },
    ac: function () {
        for (var i = 0; i <= 1; i++) {
            this._o[i] = null;
            this._q[i] = null;
            this._n[i] = 0;
        }
    },
    at: function (comparator, i, aedge) {
        if (this._n[i] < 2)
            return;
        var l = this._n[i];
        var j = 0;
        var edge;
        for (edge = this._o[i]; edge != null; edge = edge._k[i]) {
            aedge[j] = edge;
            j++;
        }

        $A53.s(aedge, l, comparator);
        var edge1 = this._o[i] = aedge[0];
        edge1._f[i] = null;
        for (var k = 1; k < l; ) {
            edge = aedge[k];
            edge._f[i] = edge1;
            edge1._k[i] = edge;
            k++;
            edge1 = edge;
        }

        this._q[i] = edge;
        edge._k[i] = null;
    }
});

var $A42 = function (node, i) {
    $A42.superClass.constructor.call(this, node, i);
    this._h = i !== 1 ? 1 : 0;
};
_twaver.ext($A42, $A27, {
    i6: function () {
        return this.i9();
    },
    i9: function () {
        return this._h !== 0 ? this._o._e : this._o._d;
    }
});

var $A43 = function (node) {
    $A43.superClass.constructor.call(this, node);
};
_twaver.ext($A43, $A36, {
    i6: function () {
        return this._k.a1(this._h);
    },
    i9: function () {
        return this._k.a1(this._h);
    }
});

var $A44 = function (list) {
    $A44.superClass.constructor.call(this, list);
};
_twaver.ext($A44, $A32, {
    i9: function () {
        return this.i6();
    }
});

var $A45 = function (o) {
    this._o = o;
    this._c = o._a;
};
_twaver.ext($A45, Object, {
    i1: function () {
        return this._c != null;
    },
    i2: function () {
        this._c = this._c._a;
    },
    i3: function () {
        this._c = this._c._b;
    },
    i5: function () {
        this._c = this._o._b;
    },
    i4: function () {
        this._c = this._o._a;
    },
    i7: function () {
        return this._o._c;
    },
    i6: function () {
        return this._c;
    },
    i9: function () {
        return this._c;
    },
    i8: function () {
        return this._c;
    }
});

var $A46 = function (nodecursor) {
    if (nodecursor && nodecursor.length) {
        $A46.superClass.constructor.call(this);
        for (var i = 0; i < nodecursor.length; i++)
            this.ae(nodecursor[i]);
    } else {
        $A46.superClass.constructor.call(this, nodecursor);
    }
};
_twaver.ext($A46, $A35, {
    x1: function () {
        return new $A44(this);
    },
    x2: function () {
        return this.am();
    },
    x3: function () {
        return this.as();
    },
    x4: function () {
        return this.at();
    }
});

var $A31 = function (i) {
    this._d = i;
    $A31.superClass.constructor.call(this);
};
_twaver.ext($A31, $A46, {

});

var $A47 = function (graph) {
    this._a = graph;
    this._b = new $A25();
    this._c = new $A46();
};
_twaver.ext($A47, Object, {
    a: function () {
        for (var nodecursor = this._a.x9(); nodecursor.i1(); nodecursor.i2())
            this.e(nodecursor.i9());
    },
    b: function () {
        this.c();
        this.d();
    },
    c: function () {
        while (!this._c.ar()) {
            var node = this._c.x4();
            if (!this._a.xq(node))
                this.g(node);
        }
    },
    d: function () {
        while (!this._b.ar()) {
            var edge = this._b.c3();
            if (!this._a.xp(edge))
                this.f(edge);
        }
    },
    e: function (node) {
        for (var edgecursor = node.af(); edgecursor.i1(); edgecursor.i2()) {
            this._b.ac(edgecursor.i8());
            this._a.h1(edgecursor.i8());
        }

        this._c.ac(node);
        this._a.h2(node);
    },
    f: function (edge) {
        this._a.u1(edge);
    },
    g: function (node) {
        this._a.h3(node);
    }
});
$A47.h = function (graph, edgecursor) {
    edgecursor.i4();
    for (; edgecursor.i1(); edgecursor.i2()) {
        var edge = edgecursor.i8();
        if (!graph.xq(edge.a2()))
            graph.h3(edge.a2());
        if (!graph.xq(edge.a3()))
            graph.h3(edge.a3());
        if (!graph.xp(edge))
            graph.u1(edge);
    }
};
$A47.i = function (graph, edgecursor) {
    edgecursor.i4();
    for (; edgecursor.i1(); edgecursor.i2()) {
        var edge = edgecursor.i8();
        if (graph.xp(edge))
            graph.h1(edge);
        if (edge.a2().ad() === 0)
            graph.h2(edge.a2());
        if (edge.a3().ad() === 0)
            graph.h2(edge.a3());
    }
};

var $A48 = function () {
    this._g = arguments[0];
    this._f = this._g.xk();
    this._h = this._g.xk();
    this._d = new $A35();
    this._e = 0;
    if (arguments.length !== 1) {
        this.a(arguments[1], arguments[2], arguments[3], arguments[4]);
    }
};
_twaver.ext($A48, Object, {
    a: function (dataprovider, i, j, dataprovider1) {
        var anodelist = $A53.d((j - i) + 1);
        for (var k = i; k <= j; k++)
            anodelist[k] = new $A31(k);

        for (var nodecursor = this._g.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (dataprovider1 == null || dataprovider1.i4(node)) {
                this._f.z1(node, anodelist[dataprovider.i2(node) - i].ac(node));
                this._e++;
            }
        }

        for (var l = 0; l < anodelist.length; l++) {
            var nodelist = anodelist[l];
            var listcell = this._d.ae(nodelist);
            for (var nodecursor1 = nodelist.x1(); nodecursor1.i1(); nodecursor1.i2())
                this._h.z1(nodecursor1.i9(), listcell);

        }
    },
    c: function () {
        this._g.xi(this._h);
        this._g.xi(this._f);
    },
    e: function () {
        return this._e === 0;
    },
    g: function () {
        for (; this._d.am().ar(); this._d.at())
            ;
        this._e--;
        var node = this._d.am().x4();
        this._h.z1(node, null);
        this._f.z1(node, null);
        return node;
    },
    f: function () {
        for (; this._d.as().ar(); this._d.au())
            ;
        this._e--;
        var node = this._d.as().x4();
        this._h.z1(node, null);
        this._f.z1(node, null);
        return node;
    },
    d: function (node) {
        var listcell = this._f.i1(node);
        var listcell1 = this._h.i1(node);
        var _lif = listcell1.d();
        var obj = null;
        var listcell2 = listcell1.a();
        if (listcell2 != null) {
            obj = listcell2.d();
            this._h.z1(node, listcell2);
        } else {
            obj = new $A31(_lif._d + 1);
            this._h.z1(node, this._d.ae(obj));
        }
        _lif.aw(listcell);
        this._f.z1(node, obj.ac(node));
    },
    b: function (node) {
        var listcell = this._f.i1(node);
        var listcell1 = this._h.i1(node);
        var _lif = listcell1.d();
        var obj = null;
        var listcell2 = listcell1.b();
        if (listcell2 != null) {
            obj = listcell2.d();
            this._h.z1(node, listcell2);
        } else {
            obj = new $A31(_lif._d - 1);
            this._h.z1(node, this._d.ac(obj));
        }
        _lif.aw(listcell);
        this._f.z1(node, obj.ac(node));
    }
});

var $A49 = {};
$A49.a1 = function (ad) {
    return new $A39(ad, null, null, null);
};
$A49.a2 = function (ai) {
    return new $A39(null, ai, null, null);
};
$A49.a3 = function (aflag) {
    return new $A39(null, null, aflag, null);
};
$A49.a4 = function (ai) {
    return new $A29(null, ai, null, null);
};
$A49.a5 = function (aflag) {
    return new $A29(null, null, aflag, null);
};
$A49.a6 = function (aobj) {
    return new $A29(null, null, null, aobj);
};

var $A50 = function () {
    if (arguments.length === 2) {
        this._a = new $A35();
        this._b = new $A35();
        this._c = 0.0;
        var e = arguments[0];
        var node = arguments[1];
        var _la = new $A51(e._j2.gj(node) / 2, 0.0);
        this._a.ac(_la);
        _la = new $A51(e._j2.gj(node) / 2, 0.0);
        this._b.ac(_la);
    } else {
        this._a = arguments[1];
        this._b = arguments[2];
        this._c = arguments[3];
    }
};
_twaver.ext($A50, Object, {

});

var $A51 = function (d, d1) {
    this._b = d;
    this._a = d1;
};
_twaver.ext($A51, Object, {

});

var $A67 = function () {
    this._cx = true;
    this._cs = new $A65();
    this._ct = new $A63();
    this._cw = new $A64();
};
_twaver.ext($A67, Object, {
    i5: function (flag) {
        this._cx = flag;
    },
    k: function () {
        var obj = new $A66(this);

        if (this._cx) {
            this._cs.w1(obj);
            obj = this._cs;
        }

        this._cw.w1(obj);
        obj = this._cw;

        this._ct.w1(obj);
        obj = this._ct;

        return obj;
    },
    i2: function (layoutgraph) {
        this.k().i2(layoutgraph);
    },
    i1: function (layoutgraph) {
        return this.k().i1(layoutgraph);
    }
});

var $A52 = function () {
    $A52.superClass.constructor.call(this);
    this._jv = 20;
    this._jw = 40;
    this._jx = function (a, b) {
        var node = a.a3();
        var node1 = b.a3();
        var layoutgraph = node._g;
        return Math.floor(100 * (layoutgraph.g5(node) - layoutgraph.g5(node1)));
    };
};
_twaver.ext($A52, $A67, {
    i4: function (layoutgraph) {
        return $A18.a1(layoutgraph);
    },
    i3: function (layoutgraph) {
        if (!this.i4(layoutgraph))
            throw 'Error';
        var edgelist = $A18.a3(layoutgraph);
        this._j2 = layoutgraph;
        this._j3 = new $A54(layoutgraph);
        $A83.c(layoutgraph);
        this._jy = layoutgraph.xk();
        if (!layoutgraph.xb()) {
            this.bu();
            var node = this._j3.c1();
            this.f(node);
            this.b(this._j3);
            this.c(this._j3);
        }
        var edge;
        for (; !edgelist.ar(); layoutgraph.x3(edge)) {
            edge = edgelist.c3();
            $A83.b(layoutgraph.g2(edge));
        }
    },
    bu: function () {
        if (this._jx != null) {
            for (var nodecursor = this._j2.x9(); nodecursor.i1(); nodecursor.i2())
                nodecursor.i9().av(this._jx);
        }
    },
    c: function (if1) {
        var aylist = this.a2(if1);
        var ad = $A53.a(aylist.length);
        for (var i = 0; i < aylist.length; i++) {
            var ylist = aylist[i];
            var d = 0.0;
            for (var ycursor = ylist.ah(); ycursor.i1(); ycursor.i2()) {
                var node = ycursor.i6();
                d = Math.max(d, this._j2.g9(node));
            }
            ad[i] = d;
        }
        var d1 = -this._jw;
        for (var j = 0; j < aylist.length; j++) {
            d1 += this._jw + ad[j];
            var ylist1 = aylist[j];
            for (var ycursor1 = ylist1.ah(); ycursor1.i1(); ycursor1.i2()) {
                var node1 = ycursor1.i6();
                this._j2.s2(node1, this._j2.g5(node1), d1 - ad[j] / 2);
            }
        }
    },
    a2: function (if1) {
        var aylist = $A53.d(if1.b());
        for (var i = 0, n = if1.b(); i < n; i++)
            aylist[i] = new $A35();

        if1.c1();
        this.a1(if1.c1(), 0, aylist);
        return aylist;
    },
    a1: function (node, i, aylist) {
        aylist[i].ae(node);
        for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2())
            this.a1(nodecursor.i9(), i + 1, aylist);
    },
    b: function (if1) {
        var node = if1.c1();
        this._j2.s2(node, 0.0, this._j2.g6(node));
        this.g(node);
    },
    g: function (node) {
        for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2()) {
            var node1 = nodecursor.i9();
            var _lif = this._jy.i1(node1);
            this._j2.s2(node1, this._j2.g5(node) + _lif._c, this._j2.g6(node1));
            this.g(node1);
        }
    },
    f: function (node) {
        if (this._j3.c2(node)) {
            this._jy.z1(node, new $A50(this, node));
            return;
        }
        var nodecursor = node.aw();
        var node1 = nodecursor.i9();
        nodecursor.i2();
        this.f(node1);
        var _lif1 = this._jy.i1(node1);
        var _lif = new $A50(this, _lif1._a, _lif1._b, 0.0);
        if (!nodecursor.i1()) {
            _lif._a.ac(new $A51(this._j2.gj(node) / 2, 0.0));
            _lif._b.ac(new $A51(this._j2.gj(node) / 2, 0.0));
            this._jy.z1(node, _lif);
            return;
        }
        while (nodecursor.i1()) {
            node1 = nodecursor.i9();
            nodecursor.i2();
            this.f(node1);
            _lif1 = this._jy.i1(node1);
            var ycursor = _lif._b.ah();
            var ycursor1 = _lif1._a.ah();
            var d1 = 2147483647;
            var d2 = 0.0;
            var d3 = 0.0;
            while (ycursor.i1() && ycursor1.i1()) {
                var _la4 = ycursor.i6();
                ycursor.i2();
                var _la = ycursor1.i6();
                ycursor1.i2();
                d3 += _la4._a;
                d2 += _la._a;
                d1 = Math.min(d1, d2 - d3 - _la4._b - _la._b);
            }
            _lif1._c = this._jv - d1;
            d2 += _lif1._c;
            var _la1 = _lif1._b.am();
            _la1._a = _lif1._c;
            if (ycursor.i1() && !ycursor1.i1()) {
                for (var d4 = d3 - this.a3(_lif1._b); ycursor.i1(); d4 = 0.0) {
                    var _la5 = ycursor.i6();
                    ycursor.i2();
                    _lif1._b.ae(new $A51(_la5._b, _la5._a + d4));
                }

            } else if (!ycursor.i1() && ycursor1.i1()) {
                var d5 = this.a3(_lif._a);
                for (d5 = d2 - d5; ycursor1.i1(); d5 = 0.0) {
                    var _la2 = ycursor1.i6();
                    ycursor1.i2();
                    _lif._a.ae(new $A51(_la2._b, _la2._a + d5));
                }

            }
            _lif._b = _lif1._b;
        }
        this._jy.z1(node, _lif);
        var d = -_lif1._c / 2;
        for (var nodecursor1 = node.aw(); nodecursor1.i1(); ) {
            var node2 = nodecursor1.i9();
            nodecursor1.i2();
            var _lif2 = this._jy.i1(node2);
            _lif2._c += d;
            var _la3 = _lif2._b.am();
            _la3._a += d;
            _la3 = _lif2._a.am();
            _la3._a += d;
        }

        _lif._a.ac(new $A51(this._j2.gj(node) / 2, 0.0));
        _lif._b.ac(new $A51(this._j2.gj(node) / 2, 0.0));
    },
    a3: function (ylist) {
        var d = 0.0;
        for (var ycursor = ylist.ah(); ycursor.i1(); ycursor.i2()) {
            var _la = ycursor.i6();
            d += _la._a;
        }
        return d;
    }
});

var $A54 = function (layoutgraph) {
    this._b = layoutgraph;
    this.a();
};
_twaver.ext($A54, Object, {
    c1: function () {
        if (this._a == null)
            this.a();
        return this._a;
    },
    b: function () {
        if (this._a == null)
            return -1;
        else
            return this.d(this._a);
    },
    d: function (node) {
        var i = 0;
        for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2())
            i = Math.max(i, this.d(nodecursor.i9()));
        return i + 1;
    },
    c2: function (node) {
        return node.ao() === 0;
    },
    a: function () {
        for (var nodecursor = this._b.x9(); nodecursor.i1(); nodecursor.i2())
            if (nodecursor.i9().ak() === 0) {
                this._a = nodecursor.i9();
                return;
            }
    }
});

var $A55 = function (d) {
    this._d = 0;
    this._e = 0;
    this._f = 0;
    this._a = 0;
    this._b = 0;
    this._g = d;
    this._c = new $A35();
};
_twaver.ext($A55, Object, {
    a: function () {
        return this._d + this._e + this._f;
    }
});

var $A57 = function () {
    $A57.superClass.constructor.call(this);
    this._kl = 340;
    this._km = 360;
    this._kk = 40;
    this._ko = 0.5;
};
_twaver.ext($A57, $A67, {
    ic: function () {
        return this._km;
    },
    ia: function () {
        return this._kl;
    },
    i9: function () {
        return this._ko;
    },
    i3: function (layoutgraph) {
        if (!$A18.a1(layoutgraph))
            throw 'Error';
        this._a = layoutgraph;
        var node = this.i8();
        var edgelist = $A18.a4(layoutgraph, node);
        $A83.c(layoutgraph);
        this._kn = $A53.d(layoutgraph.x0());
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node1 = nodecursor.i9();
            if (node1 !== node)
                this.aa(node1, new $A55(this._kk + this.q(node1.aq().i9())));
            else
                this.aa(node1, new $A55(this._kk));
        }

        this.s(node);
        layoutgraph.s2(node, 0.0, 0.0);
        this.t(node);
        var edge;
        for (; !edgelist.ar(); layoutgraph.x3(edge))
            edge = edgelist.c3();
    },
    i4: function (layoutgraph) {
        return $A18.a1(layoutgraph);
    },
    i0: function (node) {
        return this._kn[node.al()];
    },
    i8: function () {
        return $A18.a2(this._a);
    },
    i7: function (node) {
        var d = this.ib(node);
        var d1;
        do {
            d1 = this.i6(node);
            if (d1 <= d)
                break;
            for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2()) {
                var node1 = nodecursor.i9();
                this.i0(node1)._g *= 1.0 + this._ko;
            }

        } while (true);
        var d2 = (d - d1) / (2 * node.ao());
        d1 = 0.0;
        for (var nodecursor1 = node.aw(); nodecursor1.i1(); nodecursor1.i2()) {
            var nodeinfo1 = this.i0(nodecursor1.i9());
            nodeinfo1._d += d2;
            nodeinfo1._e += d2;
            d1 += nodeinfo1._d + nodeinfo1._e;
        }

        this.id(node);
    },
    id: function (node) {
        var aedge = $A53.d(node.ao());
        var i = 0;
        for (var edgecursor = node.ap(); edgecursor.i1(); ) {
            aedge[i] = edgecursor.i8();
            edgecursor.i2();
            i++;
        }

        var self = this;
        aedge.sort(function (obj, obj1) {
            var node = obj.a3();
            var node1 = obj1.a3();
            var d = self.i0(node).a() - self.i0(node1).a();
            if (d > 0.0)
                return 1;
            return d >= 0.0 ? 0 : -1;
        });
        for (var j = 0; j < aedge.length; j++)
            this._a.h1(aedge[j]);

        for (var k = 0; k < aedge.length; k += 2)
            this._a.u1(aedge[k]);

        i = aedge.length - 1;
        if (i % 2 === 0)
            i--;
        for (; i > 0; i -= 2)
            this._a.u1(aedge[i]);
    },
    ib: function (node) {
        if (node.ak() === 0)
            return this._km;
        if (node.ao() === 2)
            return Math.min(180, this._kl);
        else
            return this._kl;
    },
    i6: function (node) {
        var d = 0.0;
        for (var edgecursor = node.ap(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var node1 = edge.a3();
            var nodeinfo = this.i0(node1);
            var d2 = -nodeinfo._g;
            var d3 = nodeinfo._b;
            var ylist = nodeinfo._c;
            var d4 = 0.0;
            var d5 = d4 + 1.0;
            var listcell = ylist._b;
            var ypoint = listcell.d();
            var ypoint1;
            for (; d5 > d4; d5 = (ypoint1.y - d3) / (ypoint1.x - d2)) {
                ypoint1 = ypoint;
                listcell = ylist.ai(listcell);
                ypoint = listcell.d();
                d4 = (ypoint.y - ypoint1.y) / (ypoint.x - ypoint1.x);
            }

            nodeinfo._d = -Math.atan(d5) * 180.0 / Math.PI;
            d4 = 0.0;
            d5 = d4 - 1.0;
            listcell = ylist._b;
            for (ypoint = listcell.d(); listcell.a().d().x === ypoint.x; ypoint = listcell.d())
                listcell = listcell.a();

            var ypoint2;
            for (; d5 < d4; d5 = (ypoint2.y - d3) / (ypoint2.x - d2)) {
                ypoint2 = ypoint;
                listcell = ylist.aj(listcell);
                ypoint = listcell.d();
                d4 = (ypoint.y - ypoint2.y) / (ypoint.x - ypoint2.x);
            }

            nodeinfo._e = Math.atan(d5) * 180.0 / Math.PI; ;
            d += nodeinfo._d + nodeinfo._e;
        }

        return d;
    },
    aa: function (node, nodeinfo) {
        this._kn[node.al()] = nodeinfo;
    },
    p: function (node) {
        var nodeinfo = this.i0(node);
        var ylist = new $A35();
        var d = 2 * this.q(node);
        ylist.aa(new $A00(0.0, 0.0));
        ylist.aa(new $A00(0.0, d));
        ylist.aa(new $A00(d, d));
        ylist.aa(new $A00(d, 0.0));
        nodeinfo._c = ylist;
        nodeinfo._a = d / 2;
        nodeinfo._b = d / 2;
    },
    r: function (node) {
        if (node.ao() === 0) {
            this.p(node);
        } else {
            var nodeinfo = this.i0(node);
            var d = this.q(node);
            var ylist = new $A35();
            ylist.aa(new $A00(-d, -d));
            ylist.aa(new $A00(-d, d));
            ylist.aa(new $A00(d, -d));
            ylist.aa(new $A00(d, d));
            for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2()) {
                var nodeinfo1 = this.i0(nodecursor.i9());
                ylist.az(nodeinfo1._c);
            }

            var ylist1 = $A72.h(ylist);
            var d1 = Number.MAX_VALUE;
            var d2 = Number.MAX_VALUE;
            var d3 = Number.MIN_VALUE;
            var d4 = Number.MIN_VALUE;
            for (var ycursor = ylist1.ah(); ycursor.i1(); ycursor.i2()) {
                var ypoint = ycursor.i6();
                if (ypoint.x < d1)
                    d1 = ypoint.x;
                if (ypoint.x > d3)
                    d3 = ypoint.x;
                if (ypoint.y < d2)
                    d2 = ypoint.y;
                if (ypoint.y > d4)
                    d4 = ypoint.y;
            }

            var ylist2 = new $A35();
            for (var ycursor1 = ylist1.ah(); ycursor1.i1(); ycursor1.i2()) {
                var ypoint1 = ycursor1.i6();
                ylist2.aa(new $A00(ypoint1.x - d1, ypoint1.y - d2));
            }

            nodeinfo._c = ylist2;
            nodeinfo._a = -d1;
            nodeinfo._b = -d2;
        }
    },
    s: function (node) {
        if (node.ao() === 0) {
            this.r(node);
        } else {
            for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2())
                this.s(nodecursor.i9());
            this.i7(node);
            var d = 0.0;
            for (var nodecursor1 = node.aw(); nodecursor1.i1(); nodecursor1.i2()) {
                var node1 = nodecursor1.i9();
                var nodeinfo = this.i0(node1);
                var d1 = 180 - (360 - this.ib(node)) / 2 - d - (nodeinfo._e + nodeinfo._f);
                d += nodeinfo.a();
                d1 = d1 / 180.0 * Math.PI;
                var d2 = Math.sin(d1);
                var d3 = Math.cos(d1);
                for (var listcell = nodeinfo._c._b; listcell != null; listcell = listcell.a()) {
                    var ypoint = listcell.d();
                    var d4 = ypoint.x + nodeinfo._g;
                    var d6 = ypoint.y - nodeinfo._b;
                    var ypoint1 = new $A00(d4 * d3 - d2 * d6, d4 * d2 + d3 * d6);
                    listcell.c(ypoint1);
                }

                var d5 = nodeinfo._a + nodeinfo._g;
                nodeinfo._a = d5 * d3;
                nodeinfo._b = d5 * d2;
            }
            this.r(node);
        }
    },
    t: function (node) {
        var ypoint = this._a.g4(node);
        var d = 0.0;
        if (node.ak() > 0) {
            var node1 = node.aq().i9();
            var ypoint1 = this._a.g4(node1);
            d = Math.PI + Math.atan2(ypoint1.y - ypoint.y, ypoint1.x - ypoint.x);
        }
        for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2()) {
            var node2 = nodecursor.i9();
            var nodeinfo = this.i0(node2);
            if (d !== 0.0) {
                var d1 = Math.cos(d);
                var d2 = Math.sin(d);
                var d3 = nodeinfo._a * d1 - d2 * nodeinfo._b;
                var d4 = nodeinfo._a * d2 + d1 * nodeinfo._b;
                nodeinfo._a = d3;
                nodeinfo._b = d4;
            }
            this._a.s2(node2, ypoint.x + nodeinfo._a, ypoint.y + nodeinfo._b);
            this.t(node2);
        }
    },
    q: function (node) {
        return 1.4099999999999999 * (Math.max(this._a.gj(node), this._a.g9(node)) / 2);
    }
});

var $A58 = function () {

};
_twaver.ext($A58, Object, {
    i2: function (obj) {
        return obj.ad();
    },
    i1: function (obj) {
        throw 'Error';
    },
    i3: function (obj) {
        throw 'Error';
    },
    i4: function (obj) {
        throw 'Error';
    }
});

var $A59 = function (nodemap) {
    this._a = nodemap;
};
_twaver.ext($A59, Object, {
    i2: function (obj) {
        var i = 0;
        for (var nodecursor = obj.an(); nodecursor.i1(); nodecursor.i2())
            if (this._a.i1(nodecursor.i9()) != null)
                i++;

        return i;
    },
    i4: function (obj) {
        return this._a.i1(obj) == null;
    },
    i1: function (obj) {
        throw 'Error';
    },
    i3: function (obj) {
        throw 'Error';
    }
});

var $A60 = function () {
    $A60.superClass.constructor.call(this);
    this._kq = false;
    this._kp = 90;
};
_twaver.ext($A60, $A57, {
    a: function (edgemap, nodemap) {
        this._kr = nodemap;
        this._ks = edgemap;
        this._kq = true;
    },
    i7: function (node) {
        if (!this.u(node)) {
            $A60.superClass.i7.call(this, node);
            return;
        }
        var d = this.i9();
        var d1 = this.ib(node);
        var d2 = (360 - d1) / 2 + d1;
        var edgelist = new $A25(node.ap());
        do {
            var d3 = this.i6(node);
            d3 = (360 - d1) / 2;
            var listcell = null;
            var nodeinfo = null;
            for (var listcell1 = edgelist._b; listcell1 != null; listcell1 = listcell1.a()) {
                var edge = listcell1.d();
                var node1 = edge.a3();
                var nodeinfo1 = this.i0(node1);
                var d6 = this._ks.i3(edge);
                var d7 = d6 - (d3 + nodeinfo1._e);
                if (d7 >= 0.0 && d6 + nodeinfo1._d >= d2)
                    if (d3 + nodeinfo1.a() <= d2)
                        d7 = d2 - d3 - nodeinfo1.a();
                    else
                        d7 = 2 * (d2 - (d6 + nodeinfo1._d));
                nodeinfo1._f = 0.0;
                if (d7 >= 0.0) {
                    nodeinfo1._f = d7;
                    listcell = listcell1;
                    nodeinfo = nodeinfo1;
                } else {
                    if (-d7 > nodeinfo1._d + nodeinfo1._e)
                        d7 = (nodeinfo1._d + nodeinfo1._e) / 2;
                    else
                        d7 /= -2;
                    d3 -= d7;
                    if (d3 <= d2 && d3 + nodeinfo1.a() > d2) {
                        d3 += d7;
                        d7 = (d3 + nodeinfo1.a()) - d2;
                        d3 -= d7;
                    }
                    for (; listcell != null && d7 > nodeinfo._f; nodeinfo = this.i0(listcell.d().a3())) {
                        d7 -= nodeinfo._f;
                        nodeinfo._f = 0.0;
                        listcell = listcell.b();
                        if (listcell != null)
                            continue;
                        nodeinfo = null;
                        break;
                    }
                    if (listcell != null)
                        nodeinfo._f -= d7;
                    else
                        d3 += d7;
                }
                d3 += nodeinfo1.a();
            }
            if (d3 <= d2) {
                var d5 = 0.0;
                var d4 = (360 - d1) / 2;
                for (var edgecursor = node.ap(); edgecursor.i1(); edgecursor.i2()) {
                    var edge1 = edgecursor.i8();
                    var node3 = edge1.a3();
                    var d8 = this._ks.i3(edge1);
                    var nodeinfo2 = this.i0(node3);
                    var d9 = d4 + nodeinfo2._f + nodeinfo2._e;
                    if (d5 < Math.abs(d9 - d8))
                        d5 = Math.abs(d9 - d8);
                    d4 += nodeinfo2.a();
                }
                if (d5 <= this._kp)
                    break;
            }
            for (var nodecursor = node.aw(); nodecursor.i1(); nodecursor.i2()) {
                var node2 = nodecursor.i9();
                this.i0(node2)._g *= 1.0 + d;
            }
        } while (true);
    },
    ib: function (node) {
        if (!this.u(node))
            return $A60.superClass.ib.call(this, node);
        if (node.ak() === 0)
            return this.ic();
        else
            return this.ia();
    },
    u: function (node) {
        if (!this._kq || node.ao() === 0)
            return false;
        else
            return this._ks.i1(node.ag()) != null;
    }
});

var $A61 = function (dataprovider) {
    this._a = dataprovider;
};
_twaver.ext($A61, Object, {
    i1: function (obj) {
        return this._a.i1(obj);
    },
    i2: function (obj) {
        throw 'Error';
    },
    i3: function (obj) {
        throw 'Error';
    },
    i4: function (obj) {
        throw 'Error';
    }
});

var $A62 = function () {

};
_twaver.ext($A62, Object, {
    w1: function (layouter) {
        this._bb = layouter;
    },
    w2: function () {
        return this._bb;
    },
    w4: function (layoutgraph) {
        if (this._bb != null)
            this._bb.i2(layoutgraph);
    },
    w3: function (layoutgraph) {
        if (this._bb != null)
            return this._bb.i1(layoutgraph);
        else
            return true;
    }
});

var $A63 = function () {
    this._cg = 45;
    this._ce = 400;
    this._ch = 400;
    this._cf = 0;
};
_twaver.ext($A63, $A62, {
    i1: function (layoutgraph) {
        if (this.w2() != null) {
            var flag = true;
            var nodemap = layoutgraph.xk();
            var i = $A12.a3(layoutgraph, nodemap);
            var anodelist = $A53.d(i);
            var aedgelist = $A53.d(i);
            for (var j = 0; j < i; j++) {
                anodelist[j] = new $A46();
                aedgelist[j] = new $A25();
            }

            for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
                var edge = edgecursor.i8();
                aedgelist[nodemap.i2(edge.a2())].aa(edge);
                layoutgraph.h1(edge);
            }

            for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
                var node = nodecursor.i9();
                anodelist[nodemap.i2(node)].aa(node);
                layoutgraph.h2(nodecursor.i9());
            }

            for (var k = 0; k < i; k++) {
                for (var nodecursor1 = anodelist[k].x1(); nodecursor1.i1(); nodecursor1.i2())
                    layoutgraph.h3(nodecursor1.i9());

                for (var edgecursor1 = aedgelist[k].c1(); edgecursor1.i1(); edgecursor1.i2())
                    layoutgraph.u1(edgecursor1.i8());

                flag = this.w3(layoutgraph);
                for (var edgecursor2 = aedgelist[k].c1(); edgecursor2.i1(); edgecursor2.i2())
                    layoutgraph.h1(edgecursor2.i8());

                for (var nodecursor3 = anodelist[k].x1(); nodecursor3.i1(); nodecursor3.i2())
                    layoutgraph.h2(nodecursor3.i9());

                if (!flag)
                    break;
            }

            for (var l = 0; l < i; l++) {
                for (var nodecursor2 = anodelist[l].x1(); nodecursor2.i1(); nodecursor2.i2())
                    layoutgraph.h3(nodecursor2.i9());
            }

            for (var i1 = 0; i1 < i; i1++) {
                for (var edgecursor3 = aedgelist[i1].c1(); edgecursor3.i1(); edgecursor3.i2())
                    layoutgraph.u1(edgecursor3.i8());
            }

            layoutgraph.xi(nodemap);
            return flag;
        } else {
            return true;
        }
    },
    i2: function (layoutgraph) {
        if (layoutgraph.xb())
            return;
        var nodemap = layoutgraph.xk();
        var i = $A12.a3(layoutgraph, nodemap);
        var anodelist = $A53.d(i);
        var aedgelist = $A53.d(i);
        var ayrectangle = $A53.d(i);
        var arectangle2d = $A53.d(i);
        for (var j = 0; j < i; j++) {
            anodelist[j] = new $A46();
            aedgelist[j] = new $A25();
        }

        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            aedgelist[nodemap.i2(edge.a2())].aa(edge);
            layoutgraph.h1(edge);
        }

        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            anodelist[nodemap.i2(node)].aa(node);
            layoutgraph.h2(nodecursor.i9());
        }

        for (var k = 0; k < i; k++) {
            for (var nodecursor1 = anodelist[k].x1(); nodecursor1.i1(); nodecursor1.i2())
                layoutgraph.h3(nodecursor1.i9());

            for (var edgecursor1 = aedgelist[k].c1(); edgecursor1.i1(); edgecursor1.i2())
                layoutgraph.u1(edgecursor1.i8());

            this.w4(layoutgraph);
            var rectangle = layoutgraph.g3();
            ayrectangle[k] = new $A03(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
            var dd = {};
            arectangle2d[k] = dd;
            if (this._cf > 0.0) {
                var d = this._cg + Math.ceil((rectangle.width + 1.0) / this._cf) * this._cf;
                var d1 = this._cg + Math.ceil((rectangle.height + 1.0) / this._cf) * this._cf;
                dd.x = rectangle.x;
                dd.y = rectangle.y;
                dd.width = d;
                dd.height = d1;
            } else {
                dd.x = rectangle.x;
                dd.y = rectangle.y;
                dd.width = rectangle.width + this._cg;
                dd.height = rectangle.height + this._cg;
            }
            for (var edgecursor2 = aedgelist[k].c1(); edgecursor2.i1(); edgecursor2.i2())
                layoutgraph.h1(edgecursor2.i8());

            for (var nodecursor3 = anodelist[k].x1(); nodecursor3.i1(); nodecursor3.i2())
                layoutgraph.h2(nodecursor3.i9());
        }

        for (var l = 0; l < i; l++) {
            for (var nodecursor2 = anodelist[l].x1(); nodecursor2.i1(); nodecursor2.i2())
                layoutgraph.h3(nodecursor2.i9());
        }

        for (var i1 = 0; i1 < i; i1++) {
            for (var edgecursor3 = aedgelist[i1].c1(); edgecursor3.i1(); edgecursor3.i2())
                layoutgraph.u1(edgecursor3.i8());
        }

        $A83.a(arectangle2d, null, this._ce / this._ch);
        if (this._cf <= 0.0) {
            for (var j1 = 0; j1 < arectangle2d.length; j1++)
                this.w5(layoutgraph, anodelist[j1], aedgelist[j1], new $A00(arectangle2d[j1].x, arectangle2d[j1].y), ayrectangle[j1]);
        } else {
            for (var k1 = 0; k1 < arectangle2d.length; k1++) {
                var d2 = Math.floor((arectangle2d[k1].x - ayrectangle[k1].x) / this._cf) * this._cf;
                var d3 = Math.floor((arectangle2d[k1].y - ayrectangle[k1].y) / this._cf) * this._cf;
                var d4 = ayrectangle[k1].x + d2;
                var d5 = ayrectangle[k1].y + d3;
                this.w5(layoutgraph, anodelist[k1], aedgelist[k1], new $A00(d4, d5), ayrectangle[k1]);
            }

        }
        layoutgraph.xi(nodemap);
    },
    w5: function (layoutgraph, nodelist, edgelist, ypoint, yrectangle) {
        var d = -yrectangle.x + ypoint.x;
        var d1 = -yrectangle.y + ypoint.y;
        for (var nodecursor = nodelist.x1(); nodecursor.i1(); nodecursor.i2()) {
            var ypoint1 = layoutgraph.ga(nodecursor.i9());
            layoutgraph.s4(nodecursor.i9(), new $A00(ypoint1.x + d, ypoint1.y + d1));
        }

        for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var vector = new $List();
            for (var ycursor = layoutgraph.gp(edge).c(); ycursor.i1(); ycursor.i2()) {
                var ypoint2 = ycursor.i6();
                vector.add(new $A00(ypoint2.x + d, ypoint2.y + d1));
            }

            layoutgraph.s5(edge, new $A05(vector));
        }
    }
});

var $A64 = function () {

};
_twaver.ext($A64, $A62, {
    i1: function (layoutgraph) {
        return this.w3(layoutgraph);
    },
    i2: function (layoutgraph) {
        this.w7(layoutgraph);
        if (this.w2() != null)
            this.w4(layoutgraph);
        this.w6(layoutgraph);
    },
    w7: function (layoutgraph) {
        this.e(layoutgraph);
        this.k(layoutgraph);
        this.i(layoutgraph);
    },
    e: function (layoutgraph) {
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var ypoint = layoutgraph.g4(nodecursor.i9());
            layoutgraph.s1(nodecursor.i9(), ypoint);
        }
    },
    w6: function (layoutgraph) {
        this.l(layoutgraph);
        this.j(layoutgraph);
        this.f(layoutgraph);
    },
    l: function (layoutgraph) {
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var ypoint = layoutgraph.g4(nodecursor.i9());
            layoutgraph.s1(nodecursor.i9(), ypoint);
        }
    },
    j: function (layoutgraph) {
        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edgelayout = layoutgraph.g7(edgecursor.i8());
            var ypoint = edgelayout.i6();
            edgelayout.i8(ypoint);
            ypoint = edgelayout.i7();
            edgelayout.i9(ypoint);
            for (var i1 = 0; i1 < edgelayout.i1(); i1++) {
                var ypoint1 = edgelayout.i2(i1);
                edgelayout.i3(i1, ypoint1.x, ypoint1.y);
            }
        }
    },
    k: function (layoutgraph) {
        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edgelayout = layoutgraph.g7(edgecursor.i8());
            var ypoint = edgelayout.i6();
            edgelayout.i8(ypoint);
            ypoint = edgelayout.i7();
            edgelayout.i9(ypoint);
            for (var i1 = 0; i1 < edgelayout.i1(); i1++) {
                var ypoint1 = edgelayout.i2(i1);
                edgelayout.i3(i1, ypoint1.x, ypoint1.y);
            }
        }
    },
    f: function (layoutgraph) {
        if (this._ca != null) {
            layoutgraph.x1("A", this._ca);
            this._ca = null;
            this._b6 = null;
        }
        if (this._b8 != null) {
            layoutgraph.x1("B", this._b8);
            this._b8 = null;
            this._b9 = null;
        }
    },
    i: function (layoutgraph) {
        this._ca = layoutgraph.xc("A");
        if (this._ca != null) {
            this._b6 = new $A61(this._ca);
            layoutgraph.x1("A", this._b6);
        }
        this._b8 = layoutgraph.xc("B");
        if (this._b8 != null) {
            this._b9 = new $A61(this._b8);
            layoutgraph.x1("B", this._b9);
        }
    }
});

var $A65 = function () {
    this._a = new $A25();
    this._c = 10;
};
_twaver.ext($A65, $A62, {
    i2: function (layoutgraph) {
        this._b = layoutgraph.xl();
        this.w9(layoutgraph);
        this.w4(layoutgraph);
        this.c(layoutgraph);
        this.w8(layoutgraph, this._b);
        layoutgraph.xj(this._b);
    },
    i1: function (layoutgraph) {
        if (this.w2() == null) {
            return true;
        } else {
            this._b = layoutgraph.xl();
            this.w9(layoutgraph);
            var flag = this.w3(layoutgraph);
            this.c(layoutgraph);
            layoutgraph.xj(this._b);
            return flag;
        }
    },
    w8: function (layoutgraph, edgemap) {
        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            if (edgemap.i1(edge) != null) {
                var edgelist = edgemap.i1(edge);
                $A83.g(layoutgraph, edge, edgelist, this._c);
            }
        }
    },
    w9: function (graph) {
        var nodemap = graph.xk();
        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            for (var edgecursor = node.af(); edgecursor.i1(); edgecursor.i2()) {
                var edge = edgecursor.i8();
                var node1 = edge.a1(node);
                var edge2 = nodemap.i1(node1);
                if (edge2 !== edge)
                    if (edge2 == null) {
                        nodemap.z1(node1, edge);
                    } else {
                        if (this._b.i1(edge2) == null)
                            this._b.i8(edge2, new $A25());
                        var edgelist = this._b.i1(edge2);
                        edgelist.aa(edge);
                        this._a.ac(edge);
                        graph.h1(edge);
                    }
            }

            for (var edgecursor1 = node.af(); edgecursor1.i1(); edgecursor1.i2()) {
                var edge1 = edgecursor1.i8();
                var node2 = edge1.a1(node);
                nodemap.z1(node2, null);
            }
        }
        graph.xi(nodemap);
    },
    c: function (graph) {
        for (; !this._a.ar(); graph.u1(this._a.c3()))
            ;
    }
});

var $A66 = function (a) {
    this._a = a;
};
_twaver.ext($A66, Object, {
    i2: function (layoutgraph) {
        this._a.i3(layoutgraph);
    },
    i1: function (layoutgraph) {
        return this._a.i4(layoutgraph);
    }
});

var $A68 = function () {
    $A68.superClass.constructor.call(this);
    this._jo = 30;
    this._jp = new $A76();
    this._jt = 5;
};
_twaver.ext($A68, $A67, {
    i4: function (layoutgraph) {
        return true;
    },
    i3: function (layoutgraph) {
        this._ju = layoutgraph;
        $A83.c(layoutgraph);
        var nodecursor = this._jp.i1(layoutgraph);
        var d = 0.0;
        for (var nodecursor1 = layoutgraph.x9(); nodecursor1.i1(); nodecursor1.i2())
            d = Math.max(d, this.e(nodecursor1.i9()));

        if (d < this._jt)
            d = this._jt;
        this.a(nodecursor, d);
    },
    a: function (nodecursor, d) {
        var i = nodecursor.i7();
        var d1 = 2 * Math.PI / i;
        var d4 = 0.0;
        var ad = $A53.a(i);
        nodecursor.i4();
        for (var j = 0; j < i; ) {
            ad[j] = this.e(nodecursor.i9()) + this._jo;
            d4 += ad[j];
            j++;
            nodecursor.i2();
        }

        var d5 = d4 / i;
        var d3 = d4 / (Math.PI * 2);
        if (d3 < d)
            d3 = d;
        nodecursor.i4();
        var d6 = 0.0;
        for (var k = 0; k < i; ) {
            var d2 = (d1 / d5) * ad[k];
            d6 += d2 / 2;
            var d7 = Math.cos(d6) * d3;
            var d8 = Math.sin(d6) * d3;
            d6 += d2 / 2;
            this._ju.s2(nodecursor.i9(), d7, d8);
            k++;
            nodecursor.i2();
        }
        return d3;
    },
    e: function (node) {
        var d = this._ju.gj(node);
        var d1 = this._ju.g9(node);
        return d <= d1 ? d1 : d;
    }
});

var $A70 = function () {
    $A70.superClass.constructor.call(this);
    this._jm = new $A68();
    this._jk = new $A60();
};
_twaver.ext($A70, $A67, {
    i4: function (layoutgraph) {
        return true;
    },
    i3: function (layoutgraph) {
        if (layoutgraph.x0() < 2)
            return;
        this._jn = layoutgraph;

        $A83.c(this._jn);
        $A83.e(this._jn);
        var if1 = new $A81(this._jn);
        if1.a1();
        if1.h();
        var graphhider = new $A47(this._jn);
        graphhider.a();
        for (var nodecursor = if1.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var nodelist = if1.c2(node);
            if (nodelist.ay() > 1) {
                var edgelist = if1.d1(node);
                $A47.h(this._jn, edgelist.c1());
                this._jm.i3(this._jn);
                var rectangle = this._jn.g3();
                if1.s7(node, rectangle.width, rectangle.height);
            } else if (nodelist.ay() === 1) {
                var node2 = nodelist.x2();
                if1.s8(node, this._jn.gm(node2));
                this._jn.s2(node2, 0.0, 0.0);
            } else {
                if1.s7(node, 1.0, 1.0);
            }
            $A47.i(this._jn, this._jn.xf());
        }

        graphhider.b();
        var node1 = this.a7(if1);
        $A18.a4(if1, node1);
        var nodemap = if1.xk();
        var edgemap = if1.xl();
        this.a2(if1, edgemap, nodemap);
        this.a1(if1, edgemap);
        this.a3(if1, node1, edgemap);
        this._jk.a(edgemap, nodemap);
        this._jk.i3(if1);
        this.a5(if1, node1, nodemap);
        for (var nodecursor1 = if1.x9(); nodecursor1.i1(); nodecursor1.i2()) {
            var node3 = nodecursor1.i9();
            var ypoint = if1.g4(node3);
            for (var nodecursor2 = if1.c2(node3).x1(); nodecursor2.i1(); nodecursor2.i2()) {
                var node4 = nodecursor2.i9();
                this._jn.s2(node4, ypoint.x + this._jn.g5(node4), ypoint.y + this._jn.g6(node4));
            }
        }
    },
    a7: function (if1) {
        var i = -1;
        var node = null;
        for (var nodecursor = if1.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node1 = nodecursor.i9();
            if (if1.c2(node1).ay() > i) {
                node = node1;
                i = if1.c2(node1).ay();
            }
        }
        return node;
    },
    a1: function (graph, edgemap) {
        var _la = function (edge, edge1) {
            var d = edgemap.i3(edge) - edgemap.i3(edge1);
            if (d > 0.0)
                return 1;
            return d >= 0.0 ? 0 : -1;
        };
        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2())
            nodecursor.i9().av(_la);
    },
    a2: function (if1, edgemap, nodemap) {
        var ai = $A53.a(this._jn.x0());
        for (var nodecursor = if1.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var nodelist = if1.c2(node);
            for (var nodecursor1 = nodelist.x1(); nodecursor1.i1(); nodecursor1.i2()) {
                var node2 = nodecursor1.i9();
                ai[node2.al()] = node.al();
            }
        }
        var node1 = $A18.a2(if1);
        this.a4(if1, node1, ai, edgemap, nodemap);
    },
    a3: function (if1, node, edgemap) {
        if (if1.c2(node).ay() > 1) {
            var d = 0.0;
            var d1 = 0.0;
            var d2 = 0.0;
            for (var edgecursor = node.ap(); edgecursor.i1(); edgecursor.i2()) {
                var edge = edgecursor.i8();
                var d3 = edgemap.i3(edge);
                if (d3 - d > d1) {
                    d1 = d3 - d;
                    d2 = (d + d3) / 2;
                }
                d = d3;
            }

            if (360 - d > d1)
                d2 = (360 + d) / 2;
            this.a6(if1, node, d2);
            for (var edgecursor1 = node.ap(); edgecursor1.i1(); edgecursor1.i2()) {
                var edge1 = edgecursor1.i8();
                var d4 = edgemap.i3(edge1);
                for (d4 -= d2; d4 < 0.0; d4 += 360)
                    ;
                edgemap.i6(edge1, d4);
            }

            node.av(function (edge, edge1) {
                var d = edgemap.i3(edge) - edgemap.i3(edge1);
                if (d > 0.0)
                    return 1;
                return d >= 0.0 ? 0 : -1;
            });
        }
    },
    a4: function (if1, node, ai, edgemap, nodemap) {
        var i = node.al();
        var d = nodemap.i3(node);
        for (var edgecursor = node.ap(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var edgelist = if1.b(edge);
            var d1 = 0.0;
            var d2 = 0.0;
            var d3 = 0.0;
            var d4 = 0.0;
            for (var edgecursor1 = edgelist.c1(); edgecursor1.i1(); edgecursor1.i2()) {
                var edge1 = edgecursor1.i8();
                var node1 = null;
                var node2 = null;
                if (ai[edge1.a2().al()] === i) {
                    node1 = edge1.a2();
                    node2 = edge1.a3();
                } else {
                    node1 = edge1.a3();
                    node2 = edge1.a2();
                }
                d3 -= this._jn.g5(node1);
                d4 += this._jn.g6(node1);
                d1 -= this._jn.g5(node2);
                d2 += this._jn.g6(node2);
            }

            if (d3 !== 0.0 || d4 !== 0.0) {
                var d5;
                for (d5 = Math.atan2(d4, d3) * 180.0 / Math.PI - d; d5 < 0.0; d5 += 360)
                    ;
                edgemap.i6(edge, d5);
            }
            if (d1 !== 0.0 && d2 !== 0.0) {
                var d6 = Math.atan2(d2, d1) * 180.0 / Math.PI;
                if (d6 < 0.0)
                    d6 += 360;
                nodemap.i6(edge.a3(), d6);
            }
            this.a4(if1, edge.a3(), ai, edgemap, nodemap);
        }
    },
    a5: function (if1, node, nodemap) {
        var ypoint = if1.g4(node);
        for (var edgecursor = node.ap(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var node1 = edge.a3();
            var ypoint1 = if1.g4(node1);
            var d = ypoint1.x - ypoint.x;
            var d1 = ypoint1.y - ypoint.y;
            var d2 = Math.atan2(d1, d) * 180.0 / Math.PI;
            if (nodemap.i1(node1) != null) {
                var d3 = nodemap.i3(node1);
                d2 += d3;
            }
            this.a6(if1, node1, d2);
            this.a5(if1, node1, nodemap);
        }
    },
    a6: function (if1, node, d) {
        d = d / 180.0 * Math.PI;
        var nodelist = if1.c2(node);
        if (nodelist.ay() <= 1)
            return;
        for (var nodecursor = nodelist.x1(); nodecursor.i1(); nodecursor.i2()) {
            var node1 = nodecursor.i9();
            var d1 = this._jn.g5(node1);
            var d2 = this._jn.g6(node1);
            var d3 = Math.cos(d);
            var d4 = Math.sin(d);
            var d5 = d1 * d3 - d4 * d2;
            var d6 = d1 * d4 + d3 * d2;
            this._jn.s2(node1, d5, d6);
        }
    }
});

var $A71 = function () {
    this._a = new Date().getTime();
};
_twaver.ext($A71, Object, {
    b: function () {
        return new Date().getTime() - this._a;
    }
});

var $A72 = {};
$A72._A = new $A00(0.0, 0.0);
$A72.b = function (ypoint, ypoint1, ypoint2) {
    return $A72.c(ypoint.x, ypoint.y, ypoint1.x, ypoint1.y, ypoint2.x, ypoint2.y);
};
$A72.c = function (d, d1, d2, d3, d4, d5) {
    d2 -= d;
    d3 -= d1;
    d4 -= d;
    d5 -= d1;
    var d6 = d4 * d3 - d5 * d2;
    if (Math.abs(d6) < 0.00001) {
        return 0;
    }
    return d6 >= 0.0 ? d6 <= 0.0 ? 0 : -1 : 1;
};
$A72.d = function (ypoint, ypoint1, ypoint2) {
    return $A72.b(ypoint, ypoint1, ypoint2) > 0;
};
$A72.f = function (ypoint, ypoint1, ypoint2) {
    return $A72.b(ypoint, ypoint1, ypoint2) < 0;
};
$A72.g = function (ypoint, ypoint1, ypoint2) {
    return $A72.b(ypoint, ypoint1, ypoint2) === 0;
};
$A72.h = function (ylist) {
    return $A72.i(ylist);
};
$A72.i = function (ylist) {
    var ylist1 = new $A35(ylist.ah());
    var ylist2 = new $A35();
    ylist1.a2();
    if (ylist1.ar())
        return ylist2;
    var ypoint = ylist1.at();
    ylist2.ae(ypoint);
    for (; !ylist1.ar() && ypoint.equals(ylist1.am()); ylist1.at())
        ;
    if (ylist1.ar())
        return ylist2;
    ypoint = ylist1.at();
    var listcell = ylist2.ae(ypoint);
    for (var ycursor = ylist1.ah(); ycursor.i1(); ycursor.i2()) {
        var ypoint1 = ycursor.i6();
        if (!ypoint1.equals(ypoint)) {
            ypoint = ypoint1;
            if (ylist2.ay() === 2 && $A72.g(ylist2.am(), ylist2.as(), ypoint1)) {
                listcell.c(ypoint1);
            } else {
                var listcell1;
                for (listcell1 = listcell; !$A72.f(ylist2.ai(listcell1).d(), listcell1.d(), ypoint1); listcell1 = ylist2.ai(listcell1))
                    ;
                var listcell2;
                for (listcell2 = listcell; !$A72.d(ylist2.aj(listcell2).d(), listcell2.d(), ypoint1); listcell2 = ylist2.aj(listcell2))
                    ;
                for (; listcell2 !== ylist2.aj(listcell1); ylist2.aw(ylist2.aj(listcell1)))
                    ;
                listcell = ylist2.an(ypoint1, listcell1);
            }
        }
    }
    return ylist2;
};
$A72.j = function () {
    return $A72.k(Number.MAX_VALUE);
};
$A72.k = function (value) {
    return Math.floor(twaver.Util.random() * value);
};
$A72.l = function (d, d1) {
    return twaver.Util.random() * (d1 - d) + d;
};

var $A76 = function () {

};
_twaver.ext($A76, Object, {
    i1: function (graph) {
        this._b = graph;
        var edgelist = new $A25();
        edgelist = $A12.a6(graph);
        edgelist.az($A12.a7(graph));
        var nodelist = this.a1();
        for (; !edgelist.ar(); graph.x5(edgelist.c3()))
            ;
        return nodelist.x1();
    },
    a1: function () {
        if (this._b.x0() < 3)
            return new $A46(this._b.x9());
        var nodemap = this._b.xk();
        var nodemap1 = this._b.xk();
        var edgemap = this._b.xl();
        var listintnodepq = new $A48(this._b, new $A58(), 0, this.a3(this._b));
        var i = this._b.x0();
        var edgelist = new $A25();
        var edgelist1 = new $A25();
        var graphhider = new $A47(this._b);
        for (; i > 3; i--) {
            var node = listintnodepq.g();
            for (var nodecursor = node.an(); nodecursor.i1(); nodecursor.i2()) {
                nodemap.z1(nodecursor.i9(), i);
                nodemap1.i5(nodecursor.i9(), false);
            }

            for (var nodecursor1 = node.an(); nodecursor1.i1(); nodecursor1.i2()) {
                var node1 = nodecursor1.i9();
                for (var edgecursor1 = node1.ap(); edgecursor1.i1(); edgecursor1.i2()) {
                    var edge3 = edgecursor1.i8();
                    if (nodemap.i2(edge3.a3()) === i) {
                        edgelist1.aa(edge3);
                        nodemap1.i5(edge3.a2(), true);
                        nodemap1.i5(edge3.a3(), true);
                    }
                }
            }

            if (edgelist1.ay() < node.ad() - 1) {
                var node2 = null;
                for (var nodecursor3 = node.an(); nodecursor3.i1(); nodecursor3.i2()) {
                    var node4 = nodecursor3.i9();
                    if (nodemap.i2(node4) === i && !nodemap1.i4(node4))
                        if (node2 == null) {
                            node2 = node4;
                        } else {
                            var edge5 = this._b.xo(node2, node4);
                            edgemap.i7(edge5, true);
                            edgelist1.aa(edge5);
                            node2 = null;
                        }
                }

                if (node2 != null) {
                    for (var nodecursor4 = node.an(); nodecursor4.i1(); nodecursor4.i2()) {
                        var node5 = nodecursor4.i9();
                        if (node5 === node2 || node5.aj(node2) != null)
                            continue;
                        var edge7 = this._b.xo(node2, node5);
                        edgemap.i7(edge7, true);
                        edgelist1.aa(edge7);
                        break;
                    }
                }
                if (edgelist1.ay() < node.ad() - 1) {
                    var j = 0x7fffffff;
                    var node6 = null;
                    for (var nodecursor5 = node.an(); nodecursor5.i1(); nodecursor5.i2()) {
                        var node7 = nodecursor5.i9();
                        if (node7.ad() < j) {
                            node6 = node7;
                            j = node7.ad();
                        }
                    }

                    for (var nodecursor6 = node.an(); nodecursor6.i1(); nodecursor6.i2()) {
                        var node8 = nodecursor6.i9();
                        if (node6.aj(node8) != null || node6 === node8)
                            continue;
                        var edge9 = this._b.xo(node6, node8);
                        edgemap.i7(edge9, true);
                        edgelist1.aa(edge9);
                        if (edgelist1.ay() >= node.ad() - 1)
                            break;
                    }
                }
            }
            for (var nodecursor2 = node.an(); nodecursor2.i1(); nodecursor2.i2())
                listintnodepq.b(nodecursor2.i9());

            for (var edgecursor2 = edgelist1.c1(); edgecursor2.i1(); edgecursor2.i2()) {
                var edge4 = edgecursor2.i8();
                if (edgemap.i4(edge4)) {
                    listintnodepq.d(edge4.a2());
                    listintnodepq.d(edge4.a3());
                }
            }

            edgelist.az(edgelist1);
            graphhider.e(node);
        }

        graphhider.b();
        listintnodepq.c();
        for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            if (edge._h != null)
                if (edgemap.i4(edge))
                    this._b.x5(edge);
                else
                    this._b.h1(edge);
        }

        var edgelist2 = this.a4(this._b);
        var nodelist = new $A46();
        var edge1 = edgelist2.ak(0);
        var edge2 = edgelist2.ak(1);
        var node3 = null;
        if (edge1.a2() === edge2.a2() || edge1.a2() === edge2.a3())
            node3 = edge1.a3();
        else
            node3 = edge1.a2();
        nodelist.aa(node3);
        for (var edgecursor3 = edgelist2.c1(); edgecursor3.i1(); edgecursor3.i2()) {
            var edge6 = edgecursor3.i8();
            node3 = edge6.a1(node3);
            nodelist.aa(node3);
        }

        for (var edgecursor4 = edgelist.c1(); edgecursor4.i1(); edgecursor4.i2()) {
            var edge8 = edgecursor4.i8();
            if (!edgemap.i4(edge8) && edge8._h == null)
                this._b.u1(edge8);
        }

        this._b.xi(nodemap1);
        this._b.xj(edgemap);
        this._b.xi(nodemap);
        this.a2(nodelist);
        return nodelist;
    },
    a2: function (nodelist) {
        if (nodelist.ay() < this._b.x0()) {
            var nodemap = this._b.xk();
            for (var listcell = nodelist._b; listcell != null; listcell = listcell.a()) {
                var node = listcell.d();
                nodemap.z1(node, listcell);
            }

            var listintnodepq;
            for (listintnodepq = new $A48(this._b, new $A59(nodemap), 0, nodelist.ay(), new $A59(nodemap)); !listintnodepq.e(); ) {
                var node1 = listintnodepq.f();
                for (var nodecursor = node1.an(); nodecursor.i1(); nodecursor.i2()) {
                    var node2 = nodecursor.i9();
                    if (nodemap.i1(node2) == null)
                        continue;
                    var listcell1 = nodemap.i1(node2);
                    var node4 = nodelist.ai(listcell1).d();
                    var listcell2 = null;
                    if (node1.aj(node4) != null)
                        listcell2 = nodelist.ao(node1, listcell1);
                    else
                        listcell2 = nodelist.an(node1, listcell1);
                    nodemap.z1(node1, listcell2);
                    break;
                }

                for (var nodecursor1 = node1.an(); nodecursor1.i1(); nodecursor1.i2()) {
                    var node3 = nodecursor1.i9();
                    if (nodemap.i1(node3) == null)
                        listintnodepq.d(node3);
                }
            }

            this._b.xi(nodemap);
            listintnodepq.c();
        }
    },
    a3: function (graph) {
        var i = 0;
        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2())
            i = Math.max(i, nodecursor.i9().ad());
        return i;
    },
    a4: function (graph) {
        var infoArray = [];
        for (var i = 0, n = graph.x0(); i < n; i++)
            infoArray[i] = new $A16();

        var dfs = new $A14(infoArray);
        dfs.a6(false);
        dfs.a8(graph);
        var j = -1;
        var node = null;
        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node1 = nodecursor.i9();
            var _la = infoArray[node1.al()];
            if (_la._a + _la._c > j) {
                j = _la._a + _la._c;
                node = node1;
            }
        }

        var edgelist = new $A25();
        var node2 = node;
        for (var edge = infoArray[node2.al()]._d; edge != null; edge = infoArray[node2.al()]._d) {
            edgelist.ac(edge);
            node2 = edge.a1(node2);
        }

        node2 = node;
        for (var edge1 = infoArray[node2.al()]._b; edge1 != null; edge1 = infoArray[node2.al()]._d) {
            edgelist.ae(edge1);
            node2 = edge1.a1(node2);
        }

        return edgelist;
    }
});

var $A77 = function () {
    this._v = new $A26();
    this._x = new $A26();
    this._z = new $A40(3, 5);
    this._w = new $A40(3, 5);
    this._y = false;
    this._u = false;
    this._t = {};
};
_twaver.ext($A77, Object, {
    xm: function () {
        var node = new $A41(this);
        return node;
    },
    xo: function (node, node1) {
        return this.xn(node, null, node1, null, 0, 0);
    },
    xn: function (node, edge, node1, edge1, i, j) {
        return new $A34(this, node, edge, node1, edge1, i, j);
    },
    x4: function (node) {
        this.b3(node);
    },
    b3: function (node) {
        var edge;
        while ((edge = node._o[0]) != null)
            this.x5(edge);
        while ((edge = node._o[1]) != null)
            this.x5(edge);
        this._v.c(node);
        node._g = null;
        this._y = true;
    },
    x5: function (edge) {
        this.a11(edge);
    },
    a11: function (edge) {
        if (edge._h !== this)
            throw 'Error';
        var node = edge.a2();
        var node1 = edge.a3();
        this.a12(edge, node, node1);
        this._x.c(edge);
        edge._h = null;
        this._u = true;
    },
    x7: function (node) {
        node._p = this._v._c;
        node._g = this;
        node.ac();
        if (node._c.length < this._z._b)
            this._z.a3(node, node._c.length, this._z._b);
        this._v.a(node);
        this._y = true;
    },
    x8: function (edge) {
        if (edge._h != null)
            throw 'Error';
        if (edge._c.length < this._w._b)
            this._w.a3(edge, edge._c.length, this._w._b);
        if (edge._a == null || edge._a._h !== this)
            this._x.a(edge);
        else
            this._x.b(edge, edge._a);
        edge._h = this;
        edge.a4();
        this.b2(edge, edge.a2(), null, edge.a3(), null, 0, 0);
        this._u = true;
    },
    xr: function (edge, node, node1) {
        var node2 = edge.a2();
        var node3 = edge.a3();
        if (edge._h == null) {
            edge._d = node;
            edge._e = node1;
        } else {
            if (node2 !== node) {
                node2.ar(edge, 0, 0);
                edge._d = node;
                node.ab(edge, null, 0, 0, 0);
            }
            if (node3 !== node1) {
                node3.ar(edge, 1, 1);
                edge._e = node1;
                node1.ab(edge, null, 1, 1, 0);
            }
        }
    },
    x3: function (edge) {
        this.xr(edge, edge.a3(), edge.a2());
    },
    h1: function (edge) {
        this.a11(edge);
    },
    u1: function (edge) {
        this.x8(edge);
    },
    h2: function (node) {
        this.x4(node);
    },
    h3: function (node) {
        this.x7(node);
    },
    xa: function () {
        return this._v._c;
    },
    x0: function () {
        return this._v._c;
    },
    xh: function () {
        return this._x._c;
    },
    xg: function () {
        return this._x._c;
    },
    xb: function () {
        return this._v._c === 0;
    },
    xq: function (node) {
        return node._g === this;
    },
    xp: function (edge) {
        return edge._h === this;
    },
    xd: function () {
        return this._v._a;
    },
    x9: function () {
        return new $A45(this._v);
    },
    xf: function () {
        return new $A45(this._x);
    },
    x2: function (comparator, comparator1) {
        var aedge = $A53.d(this.xh());
        if (comparator != null && comparator1 != null) {
            for (var nodecursor = this.x9(); nodecursor.i1(); nodecursor.i2()) {
                nodecursor.i9().at(comparator, 1, aedge);
                nodecursor.i9().at(comparator1, 0, aedge);
            }

        } else if (comparator1 == null && comparator != null) {
            for (var nodecursor1 = this.x9(); nodecursor1.i1(); nodecursor1.i2())
                nodecursor1.i9().at(comparator, 1, aedge);

        } else if (comparator1 != null && comparator == null) {
            for (var nodecursor2 = this.x9(); nodecursor2.i1(); nodecursor2.i2())
                nodecursor2.i9().at(comparator1, 0, aedge);
        }
    },
    xk: function () {
        return this._z.b(this._v);
    },
    xl: function () {
        return this._w.c(this._x);
    },
    xi: function (nodemap) {
        this._z.a5(nodemap, this._v);
    },
    xj: function (edgemap) {
        this._w.a6(edgemap, this._x);
    },
    xc: function (obj) {
        return this._t[obj];
    },
    x1: function (obj, dataprovider) {
        this._t[obj] = dataprovider;
    },
    x6: function (obj) {
        delete this._t[obj];
    },
    b2: function (edge, node, edge1, node1, edge2, i, j) {
        node.ab(edge, edge1, 0, 0, i);
        node1.ab(edge, edge2, 1, 1, j);
    },
    a12: function (edge, node, node1) {
        node.ar(edge, 0, 0);
        node1.ar(edge, 1, 1);
    },
    c: function () {
        var i = 0;
        for (var nodecursor = this.x9(); nodecursor.i1(); nodecursor.i2())
            nodecursor.i9()._p = i++;
        this._y = false;
    },
    b1: function () {
        var i = 0;
        for (var edgecursor = this.xf(); edgecursor.i1(); edgecursor.i2())
            edgecursor.i8()._g = i++;
        this._u = false;
    },
    xs: function (node) {
        node.as(this, this._z._b);
        node._p = this._v._c;
        this._v.a(node);
    },
    xt: function (edge, node, edge1, node1, edge2, i, j) {
        edge.a6(this, node, node1, this._w._b);
        edge._g = this._x._c;
        this._x.a(edge);
        this.b2(edge, edge.a2(), edge1, edge.a3(), edge2, i, j);
    }
});

var $A78 = function () {
    $A78.superClass.constructor.call(this);
};
_twaver.ext($A78, $A77, {
    gb: function (obj) {
        return this.g1(obj);
    },
    g7: function (obj) {
        return this.g2(obj);
    },
    g5: function (node) {
        var nodelayout = this.g1(node);
        return nodelayout.i1() + nodelayout.i3() / 2;
    },
    g6: function (node) {
        var nodelayout = this.g1(node);
        return nodelayout.i2() + nodelayout.i4() / 2;
    },
    g4: function (node) {
        return new $A00(this.g5(node), this.g6(node));
    },
    gi: function (node) {
        return this.g1(node).i1();
    },
    gh: function (node) {
        return this.g1(node).i2();
    },
    ga: function (node) {
        var nodelayout = this.g1(node);
        return new $A00(nodelayout.i1(), nodelayout.i2());
    },
    gj: function (node) {
        return this.g1(node).i3();
    },
    g9: function (node) {
        return this.g1(node).i4();
    },
    gm: function (node) {
        return new $A01(this.gj(node), this.g9(node));
    },
    s1: function (node, ypoint) {
        this.s2(node, ypoint.x, ypoint.y);
    },
    s2: function (node, d, d1) {
        var nodelayout = this.g1(node);
        nodelayout.i5(d - nodelayout.i3() / 2, d1 - nodelayout.i4() / 2);
    },
    s7: function (node, d, d1) {
        this.g1(node).i6(d, d1);
    },
    s8: function (node, ydimension) {
        this.s7(node, ydimension.width, ydimension.height);
    },
    s3: function (node, d, d1) {
        this.g1(node).i5(d, d1);
    },
    s4: function (node, ypoint) {
        this.s3(node, ypoint.x, ypoint.y);
    },
    gp: function (edge) {
        var edgelayout = this.g2(edge);
        var vector = new $List();
        for (var i = 0; i < edgelayout.i1(); i++)
            vector.add(edgelayout.i2(i));
        return new $A05(vector);
    },
    gf: function (edge) {
        var edgelayout = this.g2(edge);
        var ylist = new $A35();
        for (var i = 0; i < edgelayout.i1(); i++)
            ylist.aa(edgelayout.i2(i));
        return ylist;
    },
    gc: function (edge) {
        var vector = new $List();
        vector.add(this.gs(edge));
        for (var ypointcursor = this.gp(edge).d(); ypointcursor.i1(); ypointcursor.i2())
            vector.add(ypointcursor.i6());
        vector.add(this.gl(edge));
        return new $A05(vector);
    },
    gd: function (edge) {
        var ylist = new $A35();
        ylist.aa(this.gs(edge));
        for (var ypointcursor = this.gp(edge).d(); ypointcursor.i1(); ypointcursor.i2())
            ylist.aa(ypointcursor.i6());
        ylist.aa(this.gl(edge));
        return ylist;
    },
    m1: function (edge, ylist) {
        var edgelayout = this.g2(edge);
        edgelayout.i5();
        var ycursor = ylist.ah();
        var ypoint = ycursor.i6();
        this.gx(edge, ypoint);
        var ypoint2 = ylist.as();
        ycursor.i2();
        for (; ycursor.i6() !== ypoint2; ycursor.i2()) {
            var ypoint1 = ycursor.i6();
            edgelayout.i4(ypoint1.x, ypoint1.y);
        }
        this.gy(edge, ypoint2);
    },
    s5: function (edge, ypointpath) {
        var edgelayout = this.g2(edge);
        edgelayout.i5();
        for (var ypointcursor = ypointpath.d(); ypointcursor.i1(); ypointcursor.i2()) {
            var ypoint = ypointcursor.i6();
            edgelayout.i4(ypoint.x, ypoint.y);
        }
    },
    s6: function (edge, ylist) {
        var edgelayout = this.g2(edge);
        edgelayout.i5();
        for (var ycursor = ylist.ah(); ycursor.i1(); ycursor.i2()) {
            var ypoint = ycursor.i6();
            edgelayout.i4(ypoint.x, ypoint.y);
        }
    },
    m2: function (edge, ypoint, ypoint1) {
        this.gx(edge, ypoint);
        this.gy(edge, ypoint1);
    },
    gn: function (edge) {
        return this.g2(edge).i6();
    },
    gk: function (edge) {
        return this.g2(edge).i7();
    },
    gt: function (edge, ypoint) {
        this.g2(edge).i8(ypoint);
    },
    gz: function (edge, ypoint) {
        this.g2(edge).i9(ypoint);
    },
    gs: function (edge) {
        var ypoint = this.g2(edge).i6();
        if (ypoint == null) {
            return this.g4(edge.a2());
        } else {
            var ypoint1 = new $A00(this.g5(edge.a2()) + ypoint.x, this.g6(edge.a2()) + ypoint.y);
            return ypoint1;
        }
    },
    gl: function (edge) {
        var ypoint = this.g2(edge).i7();
        if (ypoint == null) {
            return this.g4(edge.a3());
        } else {
            var ypoint1 = new $A00(this.g5(edge.a3()) + ypoint.x, this.g6(edge.a3()) + ypoint.y);
            return ypoint1;
        }
    },
    gx: function (edge, ypoint) {
        var ypoint1 = new $A00(ypoint.x - this.g5(edge.a2()), ypoint.y - this.g6(edge.a2()));
        this.g2(edge).i8(ypoint1);
    },
    gy: function (edge, ypoint) {
        var ypoint1 = new $A00(ypoint.x - this.g5(edge.a3()), ypoint.y - this.g6(edge.a3()));
        this.g2(edge).i9(ypoint1);
    },
    g8: function () {
        var edgelist = new $A25();
        for (var edgecursor = this.xf(); edgecursor.i1(); edgecursor.i2())
            edgelist.aa(edgecursor.i8());
        return edgelist;
    },
    g3: function () {
        var d1;
        var d = d1 = Number.MAX_VALUE;
        var d3;
        var d2 = d3 = Number.MIN_VALUE;
        for (var nodecursor = this.x9(); nodecursor.i1(); nodecursor.i2()) {
            var ypoint = this.ga(nodecursor.i9());
            var ydimension = this.gm(nodecursor.i9());
            d = Math.min(ypoint.x, d);
            d1 = Math.min(ypoint.y, d1);
            d2 = Math.max(ypoint.x + ydimension.width, d2);
            d3 = Math.max(ypoint.y + ydimension.height, d3);
        }
        for (var edgecursor = this.xf(); edgecursor.i1(); edgecursor.i2()) {
            for (var ycursor = this.gp(edgecursor.i8()).c(); ycursor.i1(); ycursor.i2()) {
                var ypoint1 = ycursor.i6();
                d = Math.min(ypoint1.x, d);
                d1 = Math.min(ypoint1.y, d1);
                d2 = Math.max(ypoint1.x, d2);
                d3 = Math.max(ypoint1.y, d3);
            }
        }
        return { x: Math.floor(d), y: Math.floor(d1), width: Math.floor(d2 - d), height: Math.floor(d3 - d1) };
    }
});

var $A79 = function () {
    $A79.superClass.constructor.call(this);
    this.a(new $A10(), new $A09());
};
_twaver.ext($A79, $A78, {
    a: function (noderealizer, edgerealizer) {
        this._a3 = noderealizer;
        this._a4 = edgerealizer;
    },
    xo: function (node, node1) {
        return this.l2(node, node1, this._a4.a6());
    },
    l2: function (node, node1, edgerealizer) {
        return this.l1(node, null, node1, null, 0, 0, edgerealizer);
    },
    xn: function (node, edge, node1, edge1, i, j) {
        return this.l1(node, edge, node1, edge1, i, j, this._a4.a6());
    },
    l1: function (node, edge, node1, edge1, i, j, edgerealizer) {
        var result = new $A34(this, node, edge, node1, edge1, i, j);
        result._l = edgerealizer;
        return result;
    },
    xm: function () {
        var node = new $A41(this);
        node._r = this._a3.m3();
        return node;
    },
    g3: function () {
        var rectangle = { x: 0, y: 0, width: -1, height: -1 };
        for (var nodecursor = this.x9(); nodecursor.i1(); nodecursor.i2())
            nodecursor.i9()._r.m1(rectangle);
        return rectangle;
    },
    g1: function (node) {
        return node._r;
    },
    g2: function (edge) {
        return edge._l;
    },
    g5: function (node) {
        return node._r.m4();
    },
    g6: function (node) {
        return node._r.m5();
    },
    gi: function (node) {
        return node._r.i1();
    },
    gh: function (node) {
        return node._r.i2();
    },
    gj: function (node) {
        return node._r.i3();
    },
    g9: function (node) {
        return node._r.i4();
    },
    s2: function (node, d, d1) {
        node._r.m6(d, d1);
    },
    s7: function (node, d, d1) {
        node._r.i6(d, d1);
    },
    s3: function (node, d, d1) {
        node._r.i5(d, d1);
    }
});

var $A80 = function () {
    $A80.superClass.constructor.call(this);
    this._ap = this.xk();
    this._as = this.xl();
};
_twaver.ext($A80, $A78, {
    g1: function (node) {
        var nodelayout = this._ap.i1(node);
        if (nodelayout == null) {
            nodelayout = new $A38();
            this._ap.z1(node, nodelayout);
        }
        return nodelayout;
    },
    g2: function (edge) {
        var edgelayout = this._as.i1(edge);
        if (edgelayout == null) {
            edgelayout = new $A37();
            this._as.i8(edge, edgelayout);
        }
        return edgelayout;
    }
});

var $A81 = function (graph) {
    $A81.superClass.constructor.call(this);
    this._ay = graph;
    this._a0 = this.xk();
    this._au = this.xl();
};
_twaver.ext($A81, $A80, {
    c2: function (node) {
        var nodelist = this._a0.i1(node);
        return nodelist;
    },
    a2: function (node, nodelist) {
        this._a0.z1(node, nodelist);
    },
    h: function () {
        if (this._az == null)
            this._az = this.xk();
        var ai = $A53.a(this._ay.x0() + 1);
        var i = 1;
        for (var nodecursor = this.x9(); nodecursor.i1(); ) {
            var nodelist = this.c2(nodecursor.i9());
            for (var nodecursor1 = nodelist.x1(); nodecursor1.i1(); nodecursor1.i2()) {
                var node = nodecursor1.i9();
                ai[node.al()] = i;
            }

            var edgelist = new $A25();
            for (var nodecursor2 = nodelist.x1(); nodecursor2.i1(); nodecursor2.i2()) {
                var node1 = nodecursor2.i9();
                var j = ai[node1.al()];
                for (var edgecursor = node1.ap(); edgecursor.i1(); edgecursor.i2()) {
                    var edge = edgecursor.i8();
                    var node2 = edge.a3();
                    var k = ai[node2.al()];
                    if (k === j)
                        edgelist.ac(edge);
                }
            }
            this._az.z1(nodecursor.i9(), edgelist);
            nodecursor.i2();
            i++;
        }
    },
    d1: function (node) {
        return this._az.i1(node);
    },
    b: function (edge) {
        return this._au.i1(edge);
    },
    a3: function (edge, edgelist) {
        this._au.i8(edge, edgelist);
    },
    a1: function () {
        var nodemap = this._ay.xk();
        var edgemap = $A49.a4($A53.a(this._ay.xh()));
        var i = $A12.a1(this._ay, edgemap, nodemap);
        var aedgelist = $A12.a5(this._ay, edgemap, i);
        this.d2(nodemap, aedgelist);
        this._ay.xi(nodemap);
    },
    c1: function (aedgelist) {
        var edgelist = null;
        var i = -1;
        for (var j = 0, n = aedgelist.length; j < n; j++) {
            var edgelist1 = aedgelist[j];
            if (edgelist1.ay() > i) {
                edgelist = edgelist1;
                i = edgelist1.ay();
            }
        }
        return edgelist;
    },
    d2: function (nodemap, aedgelist) {
        var edgemap = this._ay.xl();
        var nodemap1 = this._ay.xk();
        var n = aedgelist.length;
        for (var i = 0; i < n; i++) {
            var edgelist = aedgelist[i];
            for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2())
                edgemap.i8(edgecursor.i8(), edgelist);
        }

        var edgelist1 = this.c1(aedgelist);
        this.a4(edgelist1, nodemap, edgemap, new $List(), nodemap1);

        var hashtable = {};
        n = aedgelist.length;
        for (var j = 0; j < n; j++) {
            var edgelist3 = aedgelist[j];
            if (edgelist3.ay() > 1) {
                var node1 = this.xm();
                hashtable[edgelist3._id] = node1;
            }
        }

        for (var nodecursor1 = this._ay.x9(); nodecursor1.i1(); nodecursor1.i2()) {
            var node2 = nodecursor1.i9();
            if (nodemap.i4(node2) && nodemap1.i1(node2) == null) {
                var node3 = this.xm();
                hashtable[node2._id] = node3;
                var nodelist = new $A46();
                nodelist.aa(node2);
                this.a2(node3, nodelist);
            }
        }

        var anode = $A53.d(2);
        n = aedgelist.length;
        for (var k = 0; k < n; k++) {
            var edgelist4 = aedgelist[k];
            if (edgelist4.ay() === 1) {
                var edge = edgelist4.c2();
                anode[0] = edge.a2();
                anode[1] = edge.a3();
                for (var i1 = 0; i1 < 2; i1++) {
                    var node10 = anode[i1];
                    if (node10.ad() === 1) {
                        var node5 = this.xm();
                        hashtable[node10._id] = node5;
                        var nodelist1 = new $A46();
                        nodelist1.aa(node10);
                        this.a2(node5, nodelist1);
                    }
                }
            }
        }

        for (var nodecursor2 = this._ay.x9(); nodecursor2.i1(); nodecursor2.i2()) {
            var node4 = nodecursor2.i9();
            if (nodemap1.i1(node4) != null) {
                var edgelist5 = nodemap1.i1(node4);
                var node8 = hashtable[edgelist5._id];
                for (var edgecursor2 = node4.af(); edgecursor2.i1(); edgecursor2.i2()) {
                    var edge4 = edgecursor2.i8();
                    if (edgemap.i1(edge4) !== edgelist5) {
                        var node13 = hashtable[edgemap.i1(edge4)._id];
                        if (node13 == null) {
                            var node15 = edge4.a1(node4);
                            var edgelist8 = nodemap1.i1(node15);
                            if (edgelist8 != null)
                                node13 = hashtable[edgelist8._id];
                            else
                                node13 = hashtable[node15._id];
                        }
                        var edge5 = node8.aj(node13);
                        var edgelist9 = null;
                        if (edge5 == null) {
                            edge5 = this.xo(node8, node13);
                            edgelist9 = new $A25();
                        } else {
                            edgelist9 = this.b(edge5);
                        }
                        edgelist9.aa(edge4);
                        this.a3(edge5, edgelist9);
                    }
                }
            } else if (nodemap.i4(node4)) {
                var node6 = hashtable[node4._id];
                for (var edgecursor1 = node4.af(); edgecursor1.i1(); edgecursor1.i2()) {
                    var edge2 = edgecursor1.i8();
                    var node11 = edge2.a1(node4);
                    var node14 = hashtable[node11._id];
                    if (node14 != null) {
                        var edge6 = node6.aj(node14);
                        if (edge6 == null) {
                            var edge7 = this.xo(node6, node14);
                            var edgelist10 = new $A25();
                            edgelist10.aa(edge2);
                            this.a3(edge7, edgelist10);
                        }
                    }
                }
            }
        }

        if (this._ay.x0() === 2 && this._ay.xg() === 1) {
            var edge1 = this._ay.xf().i8();
            var node7 = hashtable[edge1.a2()._id];
            var node9 = hashtable[edge1.a3()._id];
            if (node9 != null && node7 != null && node9.aj(node7) == null) {
                var edge3 = this.xo(node7, node9);
                var edgelist7 = new $A25();
                edgelist7.aa(edge1);
                this.a3(edge3, edgelist7);
            }
        }
        var ai = $A53.a(this._ay.x0());
        var l = 1;
        n = aedgelist.length;
        for (var j1 = 0; j1 < n; j1++) {
            var edgelist6 = aedgelist[j1];
            var node12 = hashtable[edgelist6._id];
            if (node12 != null) {
                var nodelist2 = this.c2(node12);
                if (nodelist2 == null) {
                    nodelist2 = new $A46();
                    this.a2(node12, nodelist2);
                }
                for (var edgecursor3 = edgelist6.c1(); edgecursor3.i1(); edgecursor3.i2()) {
                    var edge8 = edgecursor3.i8();
                    var node16 = edge8.a2();
                    if (ai[node16.al()] !== l && (!nodemap.i4(node16) || nodemap1.i1(node16) === edgelist6)) {
                        ai[node16.al()] = l;
                        nodelist2.aa(node16);
                    }
                    node16 = edge8.a3();
                    if (ai[node16.al()] !== l && (!nodemap.i4(node16) || nodemap1.i1(node16) === edgelist6)) {
                        ai[node16.al()] = l;
                        nodelist2.aa(node16);
                    }
                }
            }
        }

        this._ay.xj(edgemap);
        this._ay.xi(nodemap1);
    },
    a4: function (edgelist, nodemap, edgemap, hashtable, nodemap1) {
        if (hashtable.contains(edgelist))
            return;
        hashtable.add(edgelist);
        var anode = [];
        for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            anode[0] = edge.a2();
            anode[1] = edge.a3();
            for (var i = 0; i < 2; i++) {
                var node = anode[i];
                if (nodemap.i4(node) && nodemap1.i1(node) == null) {
                    if (edgelist.ay() > 1)
                        nodemap1.z1(node, edgelist);
                    for (var edgecursor1 = node.af(); edgecursor1.i1(); edgecursor1.i2()) {
                        var edgelist1 = edgemap.i1(edgecursor1.i8());
                        this.a4(edgelist1, nodemap, edgemap, hashtable, nodemap1);
                    }
                }
            }
        }
    }
});

var $A82 = function (autoLayouter, elements, type, handleGroup, parentGroup) {
    this._a = {};
    $A82.superClass.constructor.call(this);
    var links = new $List(), i, n;
    for (i = 0, n = elements.size(); i < n; i++) {
        var element = elements.get(i);
        if (element instanceof twaver.Link) {
            links.add(element);
        } else {
            var expandGroup = handleGroup && parentGroup == null && element instanceof $Group;
            if (expandGroup) {
                element.setExpanded(true);
            }
            var size = autoLayouter.getDimension(element);
            if (expandGroup) {
                element.setExpanded(false);
            }
            if (size == null) {
                continue;
            }
            var yNode = this.xm();
            var r = autoLayouter._repulsion;
            if (type === "rightleft" || type === "leftright") {
                this.s7(yNode, size.height * r, size.width * r);
            } else {
                this.s7(yNode, size.width * r, size.height * r);
            }
            yNode.node = element;
            this._a[element.getId()] = yNode;
        }
    }

    for (i = 0, n = links.size(); i < n; i++) {
        var link = links.get(i);
        var aNode = link.getFromAgent();
        var zNode = link.getToAgent();
        var aYNode = this._a[aNode.getId()];
        var zYNode = this._a[zNode.getId()];
        if (aYNode == null || zYNode == null || aYNode === zYNode) {
            continue;
        }
        this.xo(aYNode, zYNode);
    }
};
_twaver.ext($A82, $A79, {
});

var $A83 = {};
$A83._D = new $A05();
$A83._E = new $A00(0.0, 0.0);
$A83.b = function (edgelayout) {
    if (edgelayout.i1() > 0) {
        var vector = new $List();
        for (var i = edgelayout.i1() - 1; i >= 0; i--)
            vector.add(edgelayout.i2(i));

        edgelayout.i5();
        for (var j = 0, n = vector.size(); j < n; j++) {
            var ypoint1 = vector.get(j);
            edgelayout.i4(ypoint1.x, ypoint1.y);
        }
    }
    var ypoint = edgelayout.i6();
    edgelayout.i8(edgelayout.i7());
    edgelayout.i9(ypoint);
};
$A83.c = function (layoutgraph) {
    $A83.d(layoutgraph, true);
};
$A83.d = function (layoutgraph, flag) {
    if (flag) {
        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            layoutgraph.gt(edge, $A83._E);
            layoutgraph.gz(edge, $A83._E);
            layoutgraph.s5(edge, $A83._D);
        }
    } else {
        for (var edgecursor1 = layoutgraph.xf(); edgecursor1.i1(); edgecursor1.i2())
            layoutgraph.s5(edgecursor1.i8(), $A83._D);
    }
};
$A83.e = function (layoutgraph) {
    var ypoint = new $A00(0.0, 0.0);
    for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
        var edge = edgecursor.i8();
        layoutgraph.gt(edge, ypoint);
        layoutgraph.gz(edge, ypoint);
    }
};
$A83.f = function (layoutgraph, edge, edge1, d) {
    var i = layoutgraph.gc(edge).b();
    var aypoint = $A53.d(i);
    var j = 0;
    for (var ycursor = layoutgraph.gc(edge).c(); ycursor.i1(); ycursor.i2()) {
        var ypoint2 = ycursor.i6();
        if (j <= 0 || !ypoint2.equals(aypoint[j - 1])) {
            aypoint[j] = new $A00(ypoint2.x, ypoint2.y);
            j++;
        }
    }

    i = j;
    if (i < 2)
        return;
    var vector = new $List();
    var yvector = new $A02(aypoint[1].x - aypoint[0].x, aypoint[1].y - aypoint[0].y);
    var yvector1 = $A83.i(yvector);
    yvector1.x *= d;
    yvector1.y *= d;
    var ypoint = $A83.h(aypoint[0], yvector1);
    var ypoint3 = $A83.h(aypoint[1], yvector1);
    var affineline = new $A04(ypoint, ypoint3);
    for (var k = 1; k < i - 1; k++) {
        var affineline1 = affineline;
        var yvector3 = $A83.i(new $A02(aypoint[k + 1].x - aypoint[k].x, aypoint[k + 1].y - aypoint[k].y));
        yvector3.x *= d;
        yvector3.y *= d;
        var ypoint4 = $A83.h(aypoint[k], yvector3);
        var ypoint5 = $A83.h(aypoint[k + 1], yvector3);
        affineline = new $A04(ypoint4, ypoint5);
        var ypoint6 = $A04.a6(affineline1, affineline);
        if (ypoint6 != null)
            vector.add(new $A00(ypoint6.x, ypoint6.y));
    }

    var yvector2 = new $A02(aypoint[i - 1].x - aypoint[i - 2].x, aypoint[i - 1].y - aypoint[i - 2].y);
    yvector2 = $A83.i(yvector2);
    yvector2.x *= d;
    yvector2.y *= d;
    var ypoint1 = $A83.h(aypoint[i - 1], yvector2);
    var ypointpath = new $A05(vector);
    if (edge.a2() === edge1.a2()) {
        layoutgraph.s5(edge1, ypointpath);
        layoutgraph.m2(edge1, ypoint, ypoint1);
    } else {
        layoutgraph.s5(edge1, ypointpath.a());
        layoutgraph.m2(edge1, ypoint1, ypoint);
    }
};
$A83.g = function (layoutgraph, edge, edgelist, d) {
    var d1 = d;
    for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
        var edge1 = edgecursor.i8();
        $A83.f(layoutgraph, edge, edge1, d1);
        if (d1 < 0.0)
            d1 -= d;
        d1 = -d1;
    }
};
$A83.a = function (arectangle2d, rectangle2d, d) {
    return $A83.j(arectangle2d, rectangle2d, d, 1);
};
$A83.l = function (arectangle2d, rectangle2d, d) {
    if (arectangle2d == null || arectangle2d.length < 1) {
        if (rectangle2d != null) {
            rectangle2d.x = 0.0;
            rectangle2d.y = 0.0;
            rectangle2d.width = 0.0;
            rectangle2d.height = 0.0;
        }
        return { width: 0, height: 0 };
    }
    var d1 = 0.0;
    var d2 = 0.0;
    for (var i = 0; i < arectangle2d.length; i++) {
        var rectangle2d1 = arectangle2d[i];
        d1 = Math.max(d1, rectangle2d1.width);
        d2 = Math.max(d2, rectangle2d1.height);
    }

    var d3 = d1 * d2 * arectangle2d.length;
    var d4 = Math.sqrt(d3 / d);
    var d5 = d3 / d4;
    var j = Math.floor(d5 / d1);
    var k = Math.ceil(d5 / d1);
    var l = Math.ceil(arectangle2d.length / j);
    var i1 = Math.ceil(arectangle2d.length / k);
    var j1;
    var k1;
    if (j * l < k * i1) {
        j1 = j;
        k1 = l;
    } else {
        j1 = k;
        k1 = i1;
    }
    var l1 = 0;
    var i2 = 0;
    var d6 = 0.0;
    var d7 = 0.0;
    var are;
    if (d1 > d2) {
        for (var j2 = 0; j2 < arectangle2d.length; j2++) {
            are = arectangle2d[j2];
            are.x = i2 * d1;
            are.y = l1 * d2;
            d6 = Math.max(d6, are.x + are.width);
            d7 = Math.max(d7, are.y + are.height);
            if (++i2 >= j1) {
                l1++;
                i2 = 0;
            }
        }
    } else {
        for (var k2 = 0; k2 < arectangle2d.length; k2++) {
            are = arectangle2d[k2];
            are.x = i2 * d1;
            are.y = l1 * d2;
            d6 = Math.max(d6, are.x + are.width);
            d7 = Math.max(d7, are.y + are.height);
            if (++l1 >= k1) {
                i2++;
                l1 = 0;
            }
        }
    }
    if (rectangle2d != null) {
        rectangle2d.x = 0.0;
        rectangle2d.y = 0.0;
        rectangle2d.width = d6;
        rectangle2d.height = d7;
    }
    return { width: k1, height: j1 };
};
$A83.j = function (arectangle2d, rectangle2d, d, i) {
    if (arectangle2d == null || arectangle2d.length < 1) {
        if (rectangle2d != null) {
            rectangle2d.x = 0.0;
            rectangle2d.y = 0.0;
            rectangle2d.width = 0.0;
            rectangle2d.height = 0.0;
        }
        return 0;
    }
    var d2;
    var d1 = d2 = arectangle2d[0].width;
    var d4;
    var d3 = d4 = arectangle2d[0].height;
    var n = arectangle2d.length;
    for (var j = 1; j < n; j++) {
        var d5 = arectangle2d[j].width;
        d1 = Math.min(d1, d5);
        d2 = Math.max(d2, d5);
        var d6 = arectangle2d[j].height;
        d3 = Math.min(d3, d6);
        d4 = Math.max(d4, d6);
    }

    if (d3 / d4 > 0.94999999999999996 && d1 / d2 > 0.94999999999999996)
        return $A83.l(arectangle2d, rectangle2d, d).width;
    var ylist = new $A35();
    var k = 0;
    for (var l = 0; l < n; l++) {
        var rectangle2d1 = arectangle2d[l];
        ylist.aa(arectangle2d[l]);
        k = Math.floor(k + rectangle2d1.width * rectangle2d1.height);
    }

    ylist.a1(function (a, b) {
        var k2 = Math.floor(b.height) - Math.floor(a.height);
        if (k2 === 0)
            return Math.floor(b.width) - Math.floor(a.width);
        else
            return k2;
    });
    var d7 = 0.0;
    var d8 = 0.0;
    var i1 = Math.floor(d * Math.sqrt(k / d));
    var i2 = i1;
    var j2 = 0;
    var ylist1 = new $A35();
    do {
        var ylist2 = new $A35();
        ylist1.aa(ylist2);
        var j1;
        var k1;
        var l1 = j1 = k1 = 0;
        for (var ycursor = ylist.ah(); ycursor.i1(); ycursor.i2()) {
            var rectangle2d2 = ycursor.i6();
            if (l1 + rectangle2d2.width > i2 && ylist2.ay() > 0) {
                k1 = Math.max(k1, l1);
                ylist2 = new $A35();
                ylist2.aa(rectangle2d2);
                ylist1.aa(ylist2);
                l1 = Math.floor(rectangle2d2.width);
            } else {
                ylist2.aa(rectangle2d2);
                l1 = Math.floor(l1 + rectangle2d2.width);
            }
            if (ylist2.ay() === 1)
                j1 = Math.floor(j1 + ylist2.am().height);
        }

        k1 = Math.max(k1, l1);
        if (d * j1 > k1 && j2 !== k1) {
            ylist1.af();
            i2 = Math.floor(i2 * 1.1);
            j2 = k1;
        }
    } while (ylist1.ar());
    var d9 = 0.0;
    for (var ycursor1 = ylist1.ah(); ycursor1.i1(); ycursor1.i2()) {
        var d10 = 0.0;
        var ylist4 = ycursor1.i6();
        for (var ycursor5 = ylist4.ah(); ycursor5.i1(); ycursor5.i2()) {
            var rectangle2d3 = ycursor5.i6();
            rectangle2d3.x = d10;
            rectangle2d3.y = d9;
            d10 += rectangle2d3.width;
        }

        d7 = Math.max(d7, d10);
        d9 += $A83.k(ylist4);
        d8 = Math.max(d8, d9);
    }

    if (rectangle2d != null) {
        rectangle2d.x = 0.0;
        rectangle2d.y = 0.0;
        rectangle2d.width = d7;
        rectangle2d.height = d8;
    }
    return ylist1.ay();
};
$A83.k = function (ylist) {
    var d = 0.0;
    for (var ycursor = ylist.ah(); ycursor.i1(); ycursor.i2())
        d = Math.max(ycursor.i6().height, d);
    return d;
};
$A83.h = function (ypoint, yvector) {
    return new $A00(ypoint.x + yvector.x, ypoint.y + yvector.y);
};
$A83.i = function (yvector) {
    var d = Math.sqrt(yvector.x * yvector.x + yvector.y * yvector.y);
    return new $A02(-yvector.y / d, yvector.x / d);
};

var $A84 = function (byte0) {
    this._a = byte0;
    this._b = false;
};
_twaver.ext($A84, Object, {
    a: function () {
        return this._b;
    },
    b: function () {
        return this._a;
    },
    c: function () {
        return this._a === 1;
    },
    d: function () {
        return this._a === 2;
    },
    e: function () {
        return this._a === 4;
    },
    f: function () {
        return this._a === 8;
    },
    g: function () {
        return this._a === 0;
    }
});
$A84.h = function (layoutgraph, edge) {
    var dataprovider = layoutgraph.xc("A");
    if (dataprovider == null)
        return null;
    else
        return dataprovider.i1(edge);
};
$A84.i = function (layoutgraph, edge) {
    var dataprovider = layoutgraph.xc("B");
    if (dataprovider == null)
        return null;
    else
        return dataprovider.i1(edge);
};
$A84.j = function (byte0) {
    switch (byte0) {
        case 1:
            return $A84.k;

        case 2:
            return $A84.l;
    }
    return null;
};
$A84.k = new $A84(1);
$A84.l = new $A84(2);

var $A85 = function (node, d10, d11, i1, layoutgraph) {
    this._o = 0;
    this._l = 0;
    this._i = 0;
    this._d = 0;
    this._f = 0;
    this._b = node;
    this._a = 0.0001;
    this._r = d10;
    this._p = 1.0;
    this._e = (layoutgraph.gj(node) + layoutgraph.g9(node)) / 4;

    var d12 = 0.45 * d11 * Math.sqrt(i1);
    this._k = $A72.l(-d12, d12);
    this._h = $A72.l(-d12, d12);
    this._g = $A72.l(-d12, d12);
};
_twaver.ext($A85, Object, {

});

var $A86 = function () {
    this._a = 0;
    this._c = 0;
    this._b = 0;
};
_twaver.ext($A86, Object, {

});

var $A87 = function () {
    $A87.superClass.constructor.call(this);
    this._dj = 0;
    this._dh = 0;
    this._dq = 0;
    this._dp = 0;
    this._dt = 0;
    this._de = 0;
    this._d3 = 0;
    this._dr = 0;
    this._ed = 0;
    this._dw = 0.65;
    this._ea = 1;
    this._dl = 80;
    this._dx = 3;
    this._d8 = true;
    this._eb = 300000;
    this._ee = 2.0;
    this._di = 2;
    this._df = 1000;
};
_twaver.ext($A87, $A67, {
    i4: function (layoutgraph) {
        return true;
    },
    i3: function (layoutgraph) {
        if (layoutgraph == null)
            return;
        this._d5 = layoutgraph;
        if (!this.s(layoutgraph))
            return;
        var _lif = new $A86();
        var l = 0;
        var l1 = Math.floor(this._dx * (this._dz.length * this._dz.length) + (20 * this._dz.length));
        l1 = Math.max(l1, 10000);
        var d10 = this._ea * this._ea * this._dz.length;
        var i1 = this._df;
        try {
            for (; this._dj > d10 && l < l1; l++) {
                var _la = this.b(l & 0x7fffffff);
                if (i1-- === 0) {
                    if (this._dy.b() > this._eb)
                        l = l1;
                    i1 = this._df;
                }

                this.h(_la, _lif);
                this.d(_la, _lif);
                this.i(_la, _lif);

                if (this._d8) {
                    this.g(_la, _lif);
                    this.j(_la, _lif);
                } else {
                    this.f(_la, _lif);
                    this.c(_la, _lif);
                }
                var d11 = Math.sqrt(_lif._a * _lif._a + _lif._c * _lif._c + _lif._b * _lif._b);
                this.ac(_la, _lif, d11);
                this.aa(_la, _lif, d11);
            }
        }catch(ex){
        } finally {
            this.r();
        }
    },
    s: function (layoutgraph) {
        if (layoutgraph == null || layoutgraph.xa() < 1)
            return false;
        this._d5 = layoutgraph;
        this._dp = 1;
        this._dy = new $A71();
        this._dt = layoutgraph.x0();
        this._d2 = $A53.d(this._dt);
        this._df = 1 + 0x186a0 / this._dt;
        this._ed = 1.0 / (2 * this._di);
        this._de = (this._ed * this._ee) / (this._dl * 0.050000000000000003);
        this._d3 = Math.pow(this._dl, -1) * this._ed;
        this._dr = Math.pow(this._dl, 3) * this._ed;
        this._dj = 0.0;
        this._du = new $A86();
        this._dq = Math.max(20 * this._dl, 10);
        var d10 = Math.max(0.10000000000000001, Math.min(this._dw * this._dl, this._dq));
        var l = this._dt;

        $A83.c(layoutgraph);

        this._dz = $A53.d(l);
        for (var nodecursor2 = layoutgraph.x9(); nodecursor2.i1(); nodecursor2.i2()) {
            var node2 = nodecursor2.i9();
            var _la = new $A85(node2, d10, this._dl, this._dt, layoutgraph);
            this._dz[--l] = _la;

            this._dj += _la._r;
            this._dh += (_la._r * _la._r);
            this._du._a += _la._k;
            this._du._c += _la._h;
            this._du._b += _la._g;
            this._d2[node2.al()] = _la;
        }

        this._d8 = false;
        return this._dz.length > 0;
    },
    b: function (l) {
        var i1 = this._dz.length;
        var j1 = i1 - l % i1 - 1;
        var k1 = $A72.k(j1 + 1);
        var _la = this._dz[k1];
        this._dz[k1] = this._dz[j1];
        this._dz[j1] = _la;
        return _la;
    },
    f: function (_pa, _pif) {
        var d11;
        var d12;
        var d10 = d11 = d12 = 0.0;
        for (var edge = _pa._b.ae(); edge != null; edge = edge.a7()) {
            var _la = this._d2[edge.a2().al()];
            var d15 = _la._k - _pa._k;
            var d17 = _la._h - _pa._h;
            var d19 = _la._g - _pa._g;
            var d13 = d15 * d15 + d17 * d17 + d19 * d19;
            var d21;
            var d23 = Math.sqrt(d13);
            var d25 = d23 - (_la._e + _pa._e);
            if (d25 <= 0.0)
                continue;
            d21 = (d25 * d25 * this._d3) / d23;

            d10 += d15 * d21;
            d11 += d17 * d21;
            d12 += d19 * d21;
        }

        for (var edge1 = _pa._b.ag(); edge1 != null; edge1 = edge1.a8()) {
            var _la1 = this._d2[edge1.a3().al()];
            var d16 = _la1._k - _pa._k;
            var d18 = _la1._h - _pa._h;
            var d20 = _la1._g - _pa._g;
            var d14 = d16 * d16 + d18 * d18 + d20 * d20;
            var d22;

            var d24 = Math.sqrt(d14);
            var d26 = d24 - (_la1._e + _pa._e);
            if (d26 <= 0.0)
                continue;
            d22 = (d26 * d26 * this._d3) / d24;

            d10 += d16 * d22;
            d11 += d18 * d22;
            d12 += d20 * d22;
        }

        _pif._a += d10;
        _pif._c += d11;
        _pif._b += d12;
    },
    g: function (_pa, _pif) {
        var d11;
        var d12;
        var d10 = d11 = d12 = 0.0;
        this._dp++;
        _pa._f = this._dp;
        for (var edge = _pa._b.ae(); edge != null; edge = edge.a7()) {
            var _la = this._d2[edge.a2().al()];
            _la._f = this._dp;
            var d13 = _la._k - _pa._k;
            var d15 = _la._h - _pa._h;
            var d17 = _la._g - _pa._g;
            var d19 = d13 * d13 + d15 * d15 + d17 * d17;
            var d23 = Math.sqrt(d19);
            if (d23 !== 0.0) {
                var d25 = Math.max(9.9999999999999995E-007, d23 - (_pa._e + _la._e));
                var d21 = -this._ef[edge.a5()] / (d25 * d25);
                d21 += d25 * d25 * this._d1[edge.a5()];
                d21 /= d23;
                d10 += d13 * d21;
                d11 += d15 * d21;
                d12 += d17 * d21;
            }
        }

        for (var edge1 = _pa._b.ag(); edge1 != null; edge1 = edge1.a8()) {
            var _la1 = this._d2[edge1.a3().al()];
            _la1._f = this._dp;
            var d14 = _la1._k - _pa._k;
            var d16 = _la1._h - _pa._h;
            var d18 = _la1._g - _pa._g;
            var d20 = d14 * d14 + d16 * d16 + d18 * d18;
            var d24 = Math.sqrt(d20);
            if (d24 !== 0.0) {
                var d26 = Math.max(9.9999999999999995E-007, d24 - (_pa._e + _la1._e));
                var d22 = -this._ef[edge1.a5()] / (d26 * d26);
                d22 += d26 * d26 * this._d1[edge1.a5()];
                d22 /= d24;
                d10 += d14 * d22;
                d11 += d16 * d22;
                d12 += d18 * d22;
            }
        }

        _pif._a += d10;
        _pif._c += d11;
        _pif._b += d12;
    },
    j: function (_pa, _pif) {
        var d11;
        var d12;
        var d10 = d11 = d12 = 0.0;
        for (var l = this._dt - 1; l >= 0; l--) {
            var _la = this._d2[l];
            if (_la._f !== _pa._f) {
                var d13 = _pa._k - _la._k;
                var d14 = _pa._h - _la._h;
                var d15 = _pa._g - _la._g;
                var d16 = d13 * d13 + d14 * d14 + d15 * d15;
                if (d16 !== 0.0) {
                    var d18 = Math.sqrt(d16);
                    var d19 = Math.max(9.9999999999999995E-007, d18 - (_pa._e + _la._e));

                    var d17 = this._dr / (d19 * d19 * d18);
                    d10 += d13 * d17;
                    d11 += d14 * d17;
                    d12 += d15 * d17;
                }
            }
        }

        _pif._a += d10;
        _pif._c += d11;
        _pif._b += d12;
    },
    c: function (_pa, _pif) {
        var d15;
        var d16;
        var d14 = d15 = d16 = 0.0;
        for (var l = this._dt - 1; l >= 0; l--) {
            var _la = this._d2[l];
            var d10 = _pa._k - _la._k;
            var d11 = _pa._h - _la._h;
            var d12 = _pa._g - _la._g;
            var d13 = d10 * d10 + d11 * d11 + d12 * d12;
            if (d13 !== 0.0) {
                var d18 = Math.sqrt(d13);
                var d17;
                var d19 = d18 - (_pa._e + _la._e);
                if (d19 <= 0.0)
                    d17 = this._dr / (1E-008 * d18);
                else
                    d17 = this._dr / (d19 * d19 * d18);

                d14 += d10 * d17;
                d15 += d11 * d17;
                d16 += d12 * d17;
            }
        }

        _pif._a += d14;
        _pif._c += d15;
        _pif._b += d16;
    },
    i: function (_pa, _pif) {
        var d10 = this._du._b / this._dt - _pa._g;
        _pif._b += (d10 * this._dl * this._dt) / this._dh;
    },
    d: function (_pa, _pif) {
        if (this._de !== 0.0) {
            var d10 = this._du._a / this._dt - _pa._k;
            var d11 = this._du._c / this._dt - _pa._h;
            var d12 = this._du._b / this._dt - _pa._g;
            _pif._a += d10 * this._de;
            _pif._c += d11 * this._de;
            _pif._b += d12 * this._de;
        }
    },
    h: function (_pa, _pif) {
        var d10 = 0.05 * (_pa._r + 2);
        if (d10 > 0.0) {
            _pif._a = $A72.l(-d10, d10);
            _pif._c = $A72.l(-d10, d10);
            _pif._b = $A72.l(-d10, d10);
        }
    },
    ac: function (_pa, _pif, d10) {
        if (d10 !== 0.0 && _pa._a !== 0.0) {
            var d13 = _pif._a * _pa._o + _pif._c * _pa._l + _pif._b * _pa._i;
            var d12 = d13 / (d10 * _pa._a);
            this._dh -= _pa._r * _pa._r;
            this._dj -= _pa._r;
            if (_pa._p * d12 > 0.0)
                _pa._r += d12 * 0.45000000000000001;
            else
                _pa._r += d12 * 0.14999999999999999;
            if (_pa._r > this._dq)
                _pa._r = this._dq;
            else if (_pa._r < 0.10000000000000001)
                _pa._r = 0.10000000000000001;
            this._dj += _pa._r;
            this._dh += _pa._r * _pa._r;
            _pa._p = d12;
        }
    },
    aa: function (_pa, _pif, d10) {
        if (d10 > 0.0) {
            var d11 = _pa._r / d10;
            var d12 = _pif._a * d11;
            var d13 = _pif._c * d11;
            var d14 = _pif._b * d11;
            _pa._k += d12;
            _pa._h += d13;
            _pa._g += d14;
            this._du._a += d12;
            this._du._c += d13;
            this._du._b += d14;
            _pa._a = d10;
            _pa._o = _pif._a;
            _pa._l = _pif._c;
            _pa._i = _pif._b;
        }
    },
    r: function () {
        for (var l = this._d2.length - 1; l >= 0; l--) {
            var _la = this._d2[l];
            this._d5.s2(_la._b, _la._k, _la._h);
        }
    }
});

var $A88 = function (
			autoLayouter,
			elements,
			handleGroup, parentGroup) {
    this._e = autoLayouter;
    this._f = elements;
    this._a = handleGroup;
    this._b = parentGroup;
    this._c = {};
};
_twaver.ext($A88, Object, {
    resetGroup: function () {
        if (!this._a || this._b != null) {
            return;
        }
        for (var id in this._c) {
            var group = this._c[id];
            if (this._e.isExpandGroup()) {
                group.group.setExpanded(true);
            } else {
                group.group.setExpanded(group.b);
            }
        }
    },
    process: function () {
        var list = new $List();
        for (var i = 0, n = this._f.size(); i < n; i++) {
            var element = this._f.get(i);
            if (element instanceof twaver.Link) {
                if (!element.isLooped()) {
                    list.add(element);
                }
            } else {
                if (this._b == null) {
                    if (element.getParent() instanceof $Group) {
                        continue;
                    }
                }
                if (this._b == null || (this._b != null && this._b !== element)) {
                    list.add(element);
                }
                if (this._b == null) {
                    if (element instanceof $Group) {
                        this.layoutGroup(element);
                    }
                }
            }
        }
        return list;
    },
    layoutGroup: function (group) {
        if (!this._a || this._c[group.getId()] != null || this._b != null) {
            return;
        }
        this._c[group.getId()] = { group: group, b: group.isExpanded() };
        var groupLayoutType = this._e.getGroupLayoutType(group);
        if (!groupLayoutType) {
            return;
        }

        // expand group
        group.setExpanded(true);

        // layout child
        var set = new $List();
        var childs = group.getChildren();
        var child;
        for (var i = 0, n = childs.size(); i < n; i++) {
            child = childs.get(i);
            if (child instanceof $Group) {
                this.layoutGroup(child);
                child.setExpanded(false);
            }
            if (!(child instanceof twaver.Link) && !set.contains(child)) {
                set.add(child);
            }
            if (child instanceof $Node) {
                var allLinks = child.getLinks();
                if (allLinks != null) {
                    for (var l = 0, c = allLinks.size(); l < c; l++) {
                        var link = allLinks.get(l);
                        if (!set.contains(link)) {
                            set.add(link);
                        }
                    }
                }
            }
        }
        var data = new $A82(this._e, set, groupLayoutType, this._a, this._b);
        try {
            var layout = null;
            if ('round' === groupLayoutType) {
                layout = new $A70();
            } else if ('symmetry' === groupLayoutType) {
                layout = new $A87();
            } else if ('hierarchic' === groupLayoutType) {
                layout = new $A89();
            } else if (groupLayoutType === 'topbottom' || groupLayoutType === 'bottomtop' || groupLayoutType === 'rightleft' || groupLayoutType === 'leftright') {
                layout = new $A52();
            }
            if (layout != null) {
                layout.i2(data);
                var matrix = $A88.createMatrix(groupLayoutType);

                var oldLocations = {};
                var newLocations = {};

                // get location result.
                for (var id in data._a) {
                    var yNode = data._a[id];
                    var element = yNode.node;
                    var p = data.g4(yNode);

                    oldLocations[id] = element.getCenterLocation();
                    if (matrix != null) {
                        var p2 = matrix.transform(p);
                        element.setCenterLocation(p2.x, p2.y);
                    } else {
                        element.setCenterLocation(p.x, p.y);
                    }
                    newLocations[id] = element.getCenterLocation();
                }
            }
        } catch (ex) {
        }

        childs = group.getChildren();
        for (i = 0, n = childs.size(); i < n; i++) {
            child = childs.get(i);
            if (child instanceof $Group) {
                child.setExpanded(true);
            }
        }
    }
});
$A88.createMatrix = function (layoutType) {
    if (layoutType === "rightleft") {
        return $math.createMatrix(Math.PI / 2, 0, 0);
    }
    if (layoutType === "leftright") {
        return $math.createMatrix(-Math.PI / 2, 0, 0);
    }
    if (layoutType === "bottomtop") {
        return $math.createMatrix(Math.PI, 0, 0);
    }
    return null;
};

var $A90 = function () {

};
_twaver.ext($A90, Object, {
    i1: function (layoutgraph, nodemap, edgelist) {
        var i = this.a1(layoutgraph, nodemap);
        this.a2(layoutgraph, nodemap, edgelist);
        return i;
    },
    a1: function (graph, nodemap) {
        var nodelist = $A90.i4(graph);
        nodelist.ax();
        var i = 0;
        for (var nodecursor = nodelist.x1(); nodecursor.i1(); nodecursor.i2())
            nodemap.i7(nodecursor.i9(), -1);

        for (var nodecursor1 = nodelist.x1(); nodecursor1.i1(); nodecursor1.i2()) {
            var node = nodecursor1.i9();
            var j = -1;
            for (var nodecursor2 = node.aq(); nodecursor2.i1(); nodecursor2.i2())
                j = Math.max(j, nodemap.i2(nodecursor2.i9()));

            nodemap.i7(node, j + 1);
            i = Math.max(i, j + 1);
        }
        return i + 1;
    },
    a2: function (graph, nodemap, edgelist) {
        edgelist.az($A90.i3(graph, nodemap));
    }
});
$A90.i3 = function (graph, nodemap) {
    var edgelist = new $A25();
    for (var edgecursor = graph.xf(); edgecursor.i1(); edgecursor.i2()) {
        var edge = edgecursor.i8();
        if (nodemap.i2(edge.a2()) > nodemap.i2(edge.a3())) {
            graph.x3(edge);
            edgelist.ac(edge);
        }
    }
    return edgelist;
};
$A90.i4 = function (graph) {
    var ai = $A53.a(graph.xa());
    (new $A17()).a1(graph, ai);
    return $A90.i2(graph, ai);
};
$A90.i2 = function (graph, ai) {
    var anode = $A53.d(graph.x0());
    for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
        var node = nodecursor.i9();
        var i = node.al();
        anode[ai[i]] = node;
    }
    return new $A46(anode);
};

var $A91 = function () {
    $A91.superClass.constructor.call(this);
    this.c0();
};
_twaver.ext($A91, $A25, {
    c0: function () {
        this._bc = 1;
        this._bd = 0.0;
    }
});

var $A93 = function () {
    this._m1 = 20;
    this._m2 = 60;
    this._m3 = 5;
    this._m4 = 0.0;
};
_twaver.ext($A93, Object, {
    i4: function (d) {
        this._m3 = d;
    },
    i5: function (d) {
        this._m4 = d;
    },
    i3: function (d) {
        this._m1 = d;
    },
    i6: function (d) {
        this._m2 = d;
    },
    i2: function (nodemap) {
        this._m5 = nodemap;
    },
    t1: function () {
        return this._m2;
    },
    a1: function (layoutgraph, anodelist) {
        var anodecursor = $A53.d(anodelist.length);
        for (var i = 0; i < anodelist.length; i++)
            anodecursor[i] = anodelist[i].x1();

        this.a2(layoutgraph, anodecursor);
    },
    a2: function (layoutgraph, anodecursor) {
        var ad = $A53.a(anodecursor.length);
        var d = 0.0;
        for (var i = 0; i < anodecursor.length; i++) {
            var d1 = 0.0;
            var nodecursor = anodecursor[i];
            nodecursor.i4();
            for (; nodecursor.i1(); nodecursor.i2())
                d1 = Math.max(d1, layoutgraph.g9(nodecursor.i9()));

            ad[i] = d1;
            nodecursor.i4();
            for (; nodecursor.i1(); nodecursor.i2()) {
                var d2 = (ad[i] - layoutgraph.g9(nodecursor.i9())) / 2;
                layoutgraph.s4(nodecursor.i9(), new $A00(layoutgraph.gi(nodecursor.i9()), d + d2));
            }
            var d3 = this.t1();
            d += ad[i] + d3;
            nodecursor.i4();
        }
    },
    i1: function (layoutgraph, anodelist, dataprovider) {
        this._m6 = layoutgraph;
        this.t2(anodelist, dataprovider);
    }
});

var $A94 = function (anodelist, dataprovider) {
    $A94.superClass.constructor.call(this);
};
_twaver.ext($A94, $A93, {
    t2: function (anodelist, dataprovider) {
        var layoutgraph = this._m6;
        this._a = layoutgraph.xc("D");
        this._h = layoutgraph.xc("C");
        this.a1(layoutgraph, anodelist);
        this.tg(layoutgraph, anodelist);
        this.tf(anodelist, $A49.a5(this._e), this._m5, this._l);
        this.tb(layoutgraph, this._f[0]);
        this.ta(anodelist);
        this.th(layoutgraph, this._f[0], anodelist);
        this.b(anodelist);
        this.tb(layoutgraph, this._f[1]);
        this.ta(anodelist);
        this.th(layoutgraph, this._f[1], anodelist);
        this.b(anodelist);
        this.a11(this._f[1]);
        this.a12(anodelist);
        this.tb(layoutgraph, this._f[2]);
        this.ta(anodelist);
        this.th(layoutgraph, this._f[2], anodelist);
        this.b(anodelist);
        this.tb(layoutgraph, this._f[3]);
        this.ta(anodelist);
        this.th(layoutgraph, this._f[3], anodelist);
        this.b(anodelist);
        this.a11(this._f[3]);
        this.a12(anodelist);
        this.tc(layoutgraph);
        this.tj();
    },
    a11: function (ad) {
        for (var i1 = 0; i1 < ad.length; i1++)
            ad[i1] = -ad[i1];

    },
    b: function (anodelist) {
        for (var i1 = 0; i1 < anodelist.length; i1++) {
            var nodelist = anodelist[i1];
            nodelist.ax();
        }

        for (var j1 = 0; j1 < anodelist.length; j1++) {
            var k1 = 0;
            var node = null;
            for (var nodecursor = anodelist[j1].x1(); nodecursor.i1(); nodecursor.i2()) {
                var node1 = nodecursor.i9();
                var l1 = node1.al();
                this._l[l1] = k1++;
                this._b[l1] = node;
                this._k[l1] = null;
                if (node != null)
                    this._k[node.al()] = node1;
                node = node1;
            }
        }

        var dataprovider = this._a;
        this._a = this._h;
        this._h = dataprovider;
        for (var edgecursor = this._m6.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var ypoint = this._m6.gn(edge);
            this._m6.gt(edge, new $A00(-ypoint.x, ypoint.y));
            var ypoint1 = this._m6.gk(edge);
            this._m6.gz(edge, new $A00(-ypoint1.x, ypoint1.y));
        }

        var l = this._l;
        var _la = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a2().al()] - l[obj1.a2().al()];
        };
        var _la1 = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a3().al()] -l[obj1.a3().al()];
        };
        this._m6.x2(_la, _la1);
    },
    a12: function (anodelist) {
        for (var edgecursor = this._m6.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            this._m6.x3(edge);
            var ypoint = this._m6.gn(edge);
            var ypoint1 = this._m6.gk(edge);
            this._m6.gz(edge, ypoint);
            this._m6.gt(edge, ypoint1);
        }

        var ylist = new $A35();
        for (var i = 0; i < anodelist.length; i++)
            ylist.ae(anodelist[i]);
        for (var i1 = 0; i1 < anodelist.length; i1++)
            anodelist[i1] = ylist.au();

        var l = this._l;
        var _la = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a2().al()] - l[obj1.a2().al()];
        };
        var _la1 = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a3().al()] -l[obj1.a3().al()];
        };
        this._m6.x2(_la, _la1);
    },
    tg: function (graph, anodelist) {
        var i1 = graph.x0();
        var j1 = graph.xg();
        this._l = $A53.a(i1);
        this._b = $A53.d(i1);
        this._k = $A53.d(i1);
        this._m = $A53.d(i1);
        this._i = $A53.d(i1);
        this._o = $A53.d(i1);
        this._f = $A53.e(4, i1);
        this._c = $A53.a(i1);
        this._g = $A53.a(i1);
        this._j = $A53.a(i1);
        this._d = $A53.b(i1);
        this._e = $A53.b(j1);
        for (var k1 = 0; k1 < anodelist.length; k1++) {
            var l1 = 0;
            var node = null;
            for (var nodecursor = anodelist[k1].x1(); nodecursor.i1(); nodecursor.i2()) {
                var node1 = nodecursor.i9();
                var i2 = node1.al();
                this._l[i2] = l1++;
                this._b[i2] = node;
                this._k[i2] = null;
                if (node != null)
                    this._k[node.al()] = node1;
                node = node1;
            }
        }
        var l = this._l;
        var _la = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a2().al()] - l[obj1.a2().al()];
        };
        var _la1 = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            return l[obj.a3().al()] -l[obj1.a3().al()];
        };
        graph.x2(_la, _la1);
    },
    tb: function (graph, ad) {
        for (var nodecursor = graph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var i1 = node.al();
            this._m[i1] = node;
            this._i[i1] = node;
            ad[i1] = Number.MAX_VALUE;
            this._o[i1] = node;
            this._c[i1] = Number.MAX_VALUE;
            this._d[i1] = false;
            this._j[i1] = this._g[i1] = 0.0;
        }
    },
    ta: function (anodelist) {
        for (var i1 = 1; i1 < anodelist.length; i1++) {
            var j1 = -1;
            for (var listcell = anodelist[i1]._b; listcell != null; listcell = listcell.a()) {
                var node = listcell.d();
                var k1 = node.al();
                var l1 = node.ak();
                if (l1 !== 0) {
                    var i2 = Math.floor((l1 + 1.0) / 2);
                    var j2 = Math.ceil((l1 + 1.0) / 2);
                    var k2 = 1;
                    var edge;
                    for (edge = node.ae(); k2 < i2; edge = edge.a7())
                        k2++;

                    for (var flag = false; k2 <= j2 && !flag; k2++) {
                        var edgelayout = this._m6.g2(edge);
                        var node1 = edge.a2();
                        var l2 = node1.al();
                        if (this._i[k1] === node && !this._e[edge.a5()] && j1 < this._l[l2]) {
                            j1 = this._l[l2];
                            this._i[l2] = node;
                            this._m[k1] = this._m[l2];
                            this._i[k1] = this._m[k1];
                            flag = true;
                            this._j[l2] = edgelayout.i6().x;
                            this._g[k1] = edgelayout.i7().x;
                        }
                        edge = edge.a7();
                    }
                }
            }
        }
    },
    th: function (layoutgraph, ad, anodelist) {
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var j1 = node.al();
            if (this._m[j1] === node)
                this.td(layoutgraph, node, ad);
        }

        for (var i1 = 0; i1 < anodelist.length; i1++) {
            var nodecursor1 = anodelist[i1].x1();
            if (nodecursor1.i1()) {
                var node1 = anodelist[i1].x1().i9();
                var k1 = node1.al();
                if (this._o[this._m[k1].al()] === node1)
                    this.tk(layoutgraph, node1, ad);
            }
        }

        for (var nodecursor2 = layoutgraph.x9(); nodecursor2.i1(); nodecursor2.i2()) {
            var node2 = nodecursor2.i9();
            var l1 = node2.al();
            var d1 = this._c[this._o[this._m[l1].al()].al()];
            if (d1 < Number.MAX_VALUE)
                ad[l1] += d1;
        }
    },
    td: function (layoutgraph, node, ad) {
        var i1 = node.al();
        if (ad[i1] === Number.MAX_VALUE) {
            ad[i1] = 0.0;
            var node1 = node;
            var d1 = 0.0;
            do {
                var j1 = node1.al();
                if (j1 !== i1)
                    d1 -= this._g[j1];
                if (this._l[j1] > 0) {
                    var node2 = this._b[j1];
                    var node3 = this._m[this._b[j1].al()];
                    var l1 = node3.al();
                    this.td(layoutgraph, node3, ad);
                    if (this._o[i1] === node)
                        this._o[i1] = this._o[l1];
                    if (this._o[i1] === this._o[l1])
                        ad[i1] = Math.max(ad[i1], (ad[node2.al()] + this.ti(layoutgraph, node2, node1)) - d1);
                }
                d1 += this._j[j1];
                node1 = this._i[j1];
            } while (node1 !== node);
            d1 = 0.0;
            node1 = node;
            do {
                var k1 = node1.al();
                if (k1 !== i1)
                    d1 -= this._g[k1];
                ad[k1] = ad[i1] + d1;
                d1 += this._j[k1];
                node1 = this._i[k1];
            } while (node1 !== node);
        }
    },
    tk: function (layoutgraph, node, ad) {
        var i1 = node.al();
        if (this._d[i1])
            return;
        this._d[i1] = true;
        var node1 = node;
        do {
            var j1 = node1.al();
            var node2 = this._k[j1];
            if (node2 != null) {
                var k1 = node2.al();
                var node3 = this._o[this._m[k1].al()];
                if (node3 !== this._o[i1]) {
                    var d1 = ad[k1] - ad[i1] - this.ti(layoutgraph, node1, node2);
                    if (this._c[node3.al()] !== Number.MAX_VALUE)
                        d1 += this._c[node3.al()];
                    this._c[this._o[i1].al()] = Math.min(this._c[this._o[i1].al()], d1);
                } else {
                    this.tk(layoutgraph, this._m[k1], ad);
                }
            }
            node1 = this._i[j1];
        } while (node1 !== node);
    },
    tc: function (layoutgraph) {
        var ad = $A53.a(4);
        var ad1 = $A53.a(4);
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var i1 = node.al();
            ad1[0] += this._f[0][i1];
            ad1[1] += this._f[1][i1];
            ad1[2] += this._f[2][i1];
            ad1[3] += this._f[3][i1];
        }

        ad1[0] /= layoutgraph.xa();
        ad1[1] /= layoutgraph.xa();
        ad1[2] /= layoutgraph.xa();
        ad1[3] /= layoutgraph.xa();
        for (var nodecursor1 = layoutgraph.x9(); nodecursor1.i1(); nodecursor1.i2()) {
            var node1 = nodecursor1.i9();
            var j1 = node1.al();
            var ypoint = layoutgraph.g4(node1);
            ad[0] = this._f[0][j1] - ad1[0];
            ad[1] = this._f[1][j1] - ad1[1];
            ad[2] = this._f[2][j1] - ad1[2];
            ad[3] = this._f[3][j1] - ad1[3];
            ad.sort($A53.n);
            var d1 = (ad[1] + ad[2]) / 2;
            layoutgraph.s1(node1, new $A00(d1, ypoint.y));
        }
    },
    ti: function (layoutgraph, node, node1) {
        var d2 = layoutgraph.gj(node);
        var d3 = layoutgraph.gj(node1);
        var d1;
        if (d2 > 1.0 && d3 > 1.0)
            d1 = this._m1 + (d2 + d3) / 2;
        else
            d1 = this._m3 + (d2 + d3) / 2;
        if (this._l[node.al()] < this._l[node1.al()]) {
            if (this._a != null)
                d1 += this._a.i3(node1);
            if (this._h != null)
                d1 += this._h.i3(node);
        } else {
            if (this._a != null)
                d1 += this._a.i3(node);
            if (this._h != null)
                d1 += this._h.i3(node1);
        }
        return d1;
    },
    tj: function () {
        this._l = null;
        this._b = null;
        this._k = null;
        this._e = null;
        this._m = null;
        this._i = null;
        this._f = null;
        this._c = null;
        this._o = null;
        this._d = null;
        this._j = null;
        this._g = null;
    },
    tf: function (anodelist, edgemap, nodemap, ai) {
        var i1 = anodelist.length;
        for (var j1 = 2; j1 < i1 - 1; j1++) {
            var k1 = -1;
            var l1 = 0;
            var i2 = 0;
            var nodecursor = anodelist[j1].x1();
            for (var nodecursor1 = anodelist[j1].x1(); nodecursor1.i1(); nodecursor1.i2()) {
                var node = nodecursor1.i9();
                var node1 = null;
                var flag = false;
                if (node.ak() === 1) {
                    node1 = node.ae().a2();
                    if (nodemap.i1(node1) != null && nodemap.i1(node) != null)
                        flag = true;
                }
                if (i2 === anodelist[j1].ay() - 1 || flag) {
                    var j2 = flag ? ai[node1.al()] : anodelist[j1 - 1].ay();
                    for (; l1 <= i2; l1++) {
                        var node2 = nodecursor.i9();
                        for (var edgecursor = node2.am(); edgecursor.i1(); edgecursor.i2()) {
                            var edge = edgecursor.i8();
                            var k2 = ai[edge.a2().al()];
                            if (k2 < k1 || k2 > j2)
                                edgemap.i7(edgecursor.i8(), true);
                        }
                        nodecursor.i2();
                    }
                    k1 = j2;
                }
                i2++;
            }
        }
    }
});

var $A95 = function (layoutgraph, a1) {
    this._b = 20;
    this._a = a1;
    this._d = layoutgraph;
    this._f = {};
};
_twaver.ext($A95, Object, {
    a3: function (d1) {
        this._b = d1;
    },
    a4: function (node, i, j, k, l) {
        if (this.a2(node)) {
            var _lif = this.b2(node);
            _lif._o = i;
            _lif._m = l;
            _lif._n = k;
            _lif._f = j;
        }
    },
    b2: function (node) {
        var _lif = this._f[node._id];
        if (_lif == null) {
            _lif = new $A74();
            this._f[node._id] = _lif;
        }
        return _lif;
    },
    a2: function (node) {
        return this._f[node._id] != null;
    },
    c: function () {
        var nodemap = $A49.a1($A53.a(this._d.xa()));
        var nodemap1 = $A49.a1($A53.a(this._d.xa()));
        for (var nodecursor = this._d.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (this.a2(node)) {
                var _lif = this.b2(node);
                nodemap.i6(node, this._b * (_lif.c() - 1));
                nodemap1.i6(node, this._b * (_lif.b() - 1));
            }
        }
        this._d.x1("D", nodemap);
        this._d.x1("C", nodemap1);
    },
    g: function () {
        this._d.x6("D");
        this._d.x6("C");
    },
    f: function () {
        for (var nodecursor = this._d.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (this.a2(node)) {
                var d1 = this._d.gi(node);
                var d2 = this._d.gh(node);
                var d3 = this._d.gj(node);
                var d4 = this._d.g9(node);
                var _lif = this.b2(node);
                var i = _lif._q.ay() + _lif._b.ay() + _lif._f;
                var j = _lif._d.ay() + _lif._g.ay() + _lif._o;
                var k = _lif._i.ay() + _lif._l.ay() + _lif._n;
                var l = _lif._h.ay() + _lif._k.ay() + _lif._m;
                var d5 = this._a.a7(d3, i);
                var d6 = this._a.a7(d3, j);
                var d7 = this._a.a7(d4, l);
                var d8 = this._a.a7(d4, k);
                _lif.a2(this._a.a8(d3, i, d5), this._a.a8(d3, j, d6), this._a.a8(d4, l, d7), this._a.a8(d4, k, d8));
                for (var edgecursor = _lif._j.c1(); edgecursor.i1(); edgecursor.i2()) {
                    var edge = edgecursor.i8();
                    var portconstraint = this.a1(edge);
                    var portconstraint1 = this.b1(edge);
                    var ylist = new $A35();
                    if (portconstraint.b() === portconstraint1.b()) {
                        if (portconstraint.c()) {
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2));
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2 - this._b));
                            _lif._g._bd++;
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2 - this._b));
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2));
                            _lif._g._bd++;
                            _lif._g._bc = Math.max(_lif._g._bc, 2);
                        } else if (portconstraint.d()) {
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4));
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4 + this._b));
                            _lif._b._bd++;
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4 + this._b));
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4));
                            _lif._b._bd++;
                            _lif._b._bc = Math.max(_lif._b._bc, 2);
                        } else if (portconstraint.f()) {
                            ylist.aa(new $A00(d1, d2 + _lif._i._bd * d8 + _lif._a));
                            ylist.aa(new $A00(d1 - this._b, d2 + _lif._i._bd * d8 + _lif._a));
                            _lif._i._bd++;
                            ylist.aa(new $A00(d1 - this._b, d2 + _lif._i._bd * d8 + _lif._a));
                            ylist.aa(new $A00(d1, d2 + _lif._i._bd * d8 + _lif._a));
                            _lif._i._bd++;
                            _lif._i._bc = Math.max(_lif._i._bc, 2);
                        } else if (portconstraint.e()) {
                            ylist.aa(new $A00(d1 + d3, d2 + _lif._h._bd * d7 + _lif._e));
                            ylist.aa(new $A00(d1 + d3 + this._b, d2 + _lif._h._bd * d7 + _lif._e));
                            _lif._h._bd++;
                            ylist.aa(new $A00(d1 + d3 + this._b, d2 + _lif._h._bd * d7 + _lif._e));
                            ylist.aa(new $A00(d1 + d3, d2 + _lif._h._bd * d7 + _lif._e));
                            _lif._h._bd++;
                            _lif._h._bc = Math.max(_lif._h._bc, 2);
                        }
                        this._d.m1(edge, ylist);
                    } else if (portconstraint.c() || portconstraint1.c()) {
                        if (portconstraint.e() || portconstraint1.e()) {
                            ylist.aa(new $A00((d1 + d3) - _lif._d._bd * d6 - _lif._c, d2));
                            ylist.aa(new $A00((d1 + d3) - _lif._d._bd * d6 - _lif._c, d2 - this._b * _lif._d._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif._h._bc, d2 - this._b * _lif._d._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif._h._bc, d2 + _lif._h._bd * d7 + _lif._e));
                            ylist.aa(new $A00(d1 + d3, d2 + _lif._h._bd * d7 + _lif._e));
                            _lif._d._bd++;
                            _lif._d._bc++;
                            _lif._h._bd++;
                            _lif._h._bc++;
                            if (portconstraint1.c())
                                ylist.ax();
                            this._d.m1(edge, ylist);
                        } else if (portconstraint.f() || portconstraint1.f()) {
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2));
                            ylist.aa(new $A00(d1 + _lif._g._bd * d6 + _lif._c, d2 - this._b * _lif._g._bc));
                            ylist.aa(new $A00(d1 - this._b * _lif._i._bc, d2 - this._b * _lif._g._bc));
                            ylist.aa(new $A00(d1 - this._b * _lif._i._bc, d2 + _lif._i._bd * d8 + _lif._a));
                            ylist.aa(new $A00(d1, d2 + _lif._i._bd * d8 + _lif._a));
                            _lif._g._bd++;
                            _lif._g._bc++;
                            _lif._i._bd++;
                            _lif._i._bc++;
                            if (portconstraint1.c())
                                ylist.ax();
                            this._d.m1(edge, ylist);
                        } else if (portconstraint.d() || portconstraint1.d()) {
                            ylist.aa(new $A00((d1 + d3) - _lif._d._bd * d6 - _lif._c, d2));
                            ylist.aa(new $A00((d1 + d3) - _lif._d._bd * d6 - _lif._c, d2 - this._b * _lif._d._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif.b(), d2 - this._b * _lif._d._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif.b(), d2 + d4 + this._b * _lif._q._bc));
                            ylist.aa(new $A00((d1 + d3) - _lif._q._bd * d5 - _lif._p, d2 + d4 + this._b * _lif._q._bc));
                            ylist.aa(new $A00((d1 + d3) - _lif._q._bd * d5 - _lif._p, d2 + d4));
                            _lif._d._bd++;
                            _lif._d._bc++;
                            _lif._k._bc++;
                            _lif._h._bc++;
                            _lif._q._bc++;
                            _lif._q._bd++;
                            if (portconstraint1.c())
                                ylist.ax();
                            this._d.m1(edge, ylist);
                        }
                    } else if (portconstraint.d() || portconstraint1.d()) {
                        if (portconstraint.e() || portconstraint1.e()) {
                            ylist.aa(new $A00((d1 + d3) - _lif._q._bd * d5 - _lif._p, d2 + d4));
                            ylist.aa(new $A00((d1 + d3) - _lif._q._bd * d5 - _lif._p, d2 + d4 + this._b * _lif._q._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif._k._bc, d2 + d4 + this._b * _lif._q._bc));
                            ylist.aa(new $A00(d1 + d3 + this._b * _lif._k._bc, (d2 + d4) - _lif._k._bd * d7 - _lif._e));
                            ylist.aa(new $A00(d1 + d3, (d2 + d4) - _lif._k._bd * d7 - _lif._e));
                            _lif._q._bd++;
                            _lif._q._bc++;
                            _lif._k._bd++;
                            _lif._k._bc++;
                            if (portconstraint1.d())
                                ylist.ax();
                            this._d.m1(edge, ylist);
                        } else if (portconstraint.f() || portconstraint1.f()) {
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4));
                            ylist.aa(new $A00(d1 + _lif._b._bd * d5 + _lif._p, d2 + d4 + this._b * _lif._b._bc));
                            ylist.aa(new $A00(d1 - this._b * _lif._l._bc, d2 + d4 + this._b * _lif._b._bc));
                            ylist.aa(new $A00(d1 - this._b * _lif._l._bc, (d2 + d4) - _lif._l._bd * d8 - _lif._a));
                            ylist.aa(new $A00(d1, (d2 + d4) - _lif._l._bd * d8 - _lif._a));
                            _lif._b._bd++;
                            _lif._b._bc++;
                            _lif._l._bd++;
                            _lif._l._bc++;
                            if (portconstraint1.d())
                                ylist.ax();
                            this._d.m1(edge, ylist);
                        }
                    } else {
                        ylist.aa(new $A00(d1, (d2 + d4) - _lif._l._bd * d8 - _lif._a));
                        ylist.aa(new $A00(d1 - this._b * _lif._l._bc, (d2 + d4) - _lif._l._bd * d8 - _lif._a));
                        ylist.aa(new $A00(d1 - this._b * _lif._l._bc, d2 + d4 + this._b * _lif.a1()));
                        ylist.aa(new $A00(d1 + d3 + this._b * _lif._k._bc, d2 + d4 + this._b * _lif.a1()));
                        ylist.aa(new $A00(d1 + d3 + this._b * _lif._k._bc, (d2 + d4) - _lif._k._bd * d7 - _lif._e));
                        ylist.aa(new $A00(d1 + d3, (d2 + d4) - _lif._k._bd * d7 - _lif._e));
                        _lif._l._bd++;
                        _lif._l._bc++;
                        _lif._b._bc++;
                        _lif._q._bc++;
                        _lif._k._bc++;
                        _lif._k._bd++;
                        if (portconstraint1.f())
                            ylist.ax();
                        this._d.m1(edge, ylist);
                    }
                }
            }
        }
    },
    a5: function (anodelist, afor) {
        for (var i = 0; i < anodelist.length; i++) {
            var nodelist = anodelist[i];
            var for1 = afor[i];
            for (var nodecursor = nodelist.x1(); nodecursor.i1(); nodecursor.i2()) {
                var node = nodecursor.i9();
                if (this.a2(node)) {
                    var _lif = this.b2(node);
                    for1._g = Math.max(for1._g, this._b * (_lif.d() - 1));
                    for1._j = Math.max(for1._j, this._b * (_lif.a1() - 1));
                }
            }
        }
    },
    a1: function (edge) {
        var dataprovider = this._d.xc("A");
        var portconstraint = null;
        if (dataprovider != null)
            portconstraint = dataprovider.i1(edge);
        if (portconstraint == null || portconstraint.g()) {
            var dataprovider1 = this._d.xc("B");
            if (dataprovider1 == null)
                return $A84.j(1);
            var portconstraint1 = dataprovider1.i1(edge);
            if (portconstraint1 == null || portconstraint1.g())
                return $A84.j(1);
            if (portconstraint1.c())
                return $A84.j(8);
            if (portconstraint1.f())
                return $A84.j(1);
            if (portconstraint1.d())
                return $A84.j(4);
            if (portconstraint1.e())
                return $A84.j(2);
        }
        return portconstraint;
    },
    b1: function (edge) {
        var dataprovider = this._d.xc("B");
        var portconstraint = null;
        if (dataprovider != null)
            portconstraint = dataprovider.i1(edge);
        if (portconstraint == null || portconstraint.g()) {
            var dataprovider1 = this._d.xc("A");
            if (dataprovider1 == null)
                return $A84.j(8);
            var portconstraint1 = dataprovider1.i1(edge);
            if (portconstraint1 == null || portconstraint1.g())
                return $A84.j(8);
            if (portconstraint1.c())
                return $A84.j(8);
            if (portconstraint1.f())
                return $A84.j(1);
            if (portconstraint1.d())
                return $A84.j(4);
            if (portconstraint1.e())
                return $A84.j(2);
        }
        return portconstraint;
    }
});

var $A74 = function () {
    this._o = 0;
    this._f = 0;
    this._n = 0;
    this._m = 0;
    this._c = 0;
    this._p = 0;
    this._e = 0;
    this._a = 0;
    this._j = new $A25();
    this._g = new $A91();
    this._d = new $A91();
    this._b = new $A91();
    this._q = new $A91();
    this._h = new $A91();
    this._k = new $A91();
    this._i = new $A91();
    this._l = new $A91();
};
_twaver.ext($A74, Object, {
    a1: function () {
        return Math.max(this._q._bc, this._b._bc);
    },
    d: function () {
        return Math.max(this._d._bc, this._g._bc);
    },
    b: function () {
        return Math.max(this._k._bc, this._h._bc);
    },
    c: function () {
        return Math.max(this._l._bc, this._i._bc);
    },
    a2: function (d1, d2, d3, d4) {
        this._c = d2;
        this._a = d4;
        this._p = d1;
        this._e = d3;
        this._g.c0();
        this._d.c0();
        this._b.c0();
        this._q.c0();
        this._k.c0();
        this._h.c0();
        this._l.c0();
        this._i.c0();
    }
});

var $A96 = function (layoutgraph, nodemap, nodemap1, edgemap) {
    this._k = 20;
    this._r = 0.5;
    this._d = layoutgraph;
    this._c = nodemap;
    this._j = nodemap1;
    this._m = edgemap;
    this._i = layoutgraph.xc("A") != null || layoutgraph.xc("B") != null;
    this._t = new $A75(layoutgraph, nodemap, nodemap1, edgemap);
    this._b = new $A95(layoutgraph, this);
};
_twaver.ext($A96, Object, {
    a6: function (d1) {
        this._k = d1;
        this._t.a1(d1);
        this._b.a3(d1);
    },
    g1: function () {
        return this._k;
    },
    a9: function (i1) {
        this.c1();
        return i1;
    },
    a5: function (anodelist) {
        this.a1();
        return anodelist;
    },
    b3: function (anodelist) {
        this.c1();
        anodelist = this.c4(anodelist);
        this._b.c();
        return anodelist;
    },
    g2: function (anodelist) {
        this._b.g();
        return anodelist;
    },
    e2: function (anodelist) {
        anodelist = this.f(anodelist);
        this._b.f();
    },
    e1: function () {
        this._t.d();
        if (this._n != null)
            this._d.xi(this._n);
        this.a1();
        this._d = null;
    },
    a1: function () {
        if (!this._i)
            return;
        if (this._q != null) {
            this._d.x1("A", this._q);
            this._q = null;
        }
        if (this._p != null) {
            this._d.x1("B", this._p);
            this._p = null;
        }
        if (this._h != null) {
            this._d.xj(this._h);
            this._h = null;
        }
        if (this._l != null) {
            this._d.xj(this._l);
            this._l = null;
        }
    },
    c1: function () {
        if (!this._i)
            return;
        if (this._h == null)
            this._h = this._d.xl();
        if (this._l == null)
            this._l = this._d.xl();
        for (var edgecursor = this._d.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var flag = this._j.i1(edge.a2()) != null;
            var flag1 = this._j.i1(edge.a3()) != null;
            if (flag && !flag1) {
                var edge1 = this._j.i1(edge.a2());
                if (this._m.i4(edge1))
                    this._l.i8(edge, $A84.h(this._d, edge1));
                else
                    this._l.i8(edge, $A84.i(this._d, edge1));
            } else if (!flag && flag1) {
                var edge2 = this._j.i1(edge.a3());
                if (this._m.i4(edge2))
                    this._h.i8(edge, $A84.i(this._d, edge2));
                else
                    this._h.i8(edge, $A84.h(this._d, edge2));
            } else if (!flag && !flag1)
                if (this._m.i4(edge)) {
                    this._h.i8(edge, $A84.i(this._d, edge));
                    this._l.i8(edge, $A84.h(this._d, edge));
                } else {
                    this._h.i8(edge, $A84.h(this._d, edge));
                    this._l.i8(edge, $A84.i(this._d, edge));
                }
        }
        this._q = this._d.xc("A");
        this._p = this._d.xc("B");
        this._d.x1("A", this._h);
        this._d.x1("B", this._l);
    },
    c4: function (anodelist) {
        this._n = this._d.xk();
        this._a = this._d.xl();
        this._g = this._d.xl();
        var edgelist = new $A25();
        var edgelist1 = new $A25();
        var edgelist2 = new $A25();
        var edgelist3 = new $A25();
        var edgelist4 = new $A25();
        var edgelist5 = new $A25();
        var edgelist6 = new $A25();
        var edgelist7 = new $A25();
        var edgelist8 = new $A25();
        var nodemap = this._d.xk();
        for (var i1 = 0; i1 < anodelist.length; i1++) {
            var d1 = 0.0;
            for (var nodecursor = anodelist[i1].x1(); nodecursor.i1(); ) {
                nodemap.i6(nodecursor.i9(), d1);
                nodecursor.i2();
                d1++;
            }

        }

        var comparator = function (obj, obj1) {
            var d = nodemap.i3(obj.a3()) - nodemap.i3(obj1.a3());
            return d <= 0.0 ? d >= 0.0 ? 0 : -1 : 1;
        };
        var comparator1 = function (obj, obj1) {
            var d = nodemap.i3(obj.a2()) - nodemap.i3(obj1.a2());
            return d <= 0.0 ? d >= 0.0 ? 0 : -1 : 1;
        };
        for (var j1 = 0; j1 < anodelist.length; j1++) {
            var nodelist = anodelist[j1];
            for (var listcell = nodelist._b; listcell != null; listcell = listcell.a()) {
                var node = listcell.d();
                node.av(comparator);
                node.au(comparator1);
                var k1 = 0;
                edgelist.af();
                edgelist1.af();
                edgelist2.af();
                edgelist3.af();
                edgelist4.af();
                edgelist5.af();
                edgelist6.af();
                edgelist7.af();
                edgelist8.af();
                for (var edgecursor = node.ap(); edgecursor.i1(); ) {
                    var edge = edgecursor.i8();
                    var portconstraint = this.b1(edge);
                    if (portconstraint == null || portconstraint.d() || portconstraint.g())
                        edgelist2.aa(edge);
                    else if (portconstraint.e())
                        edgelist.aa(edge);
                    else if (portconstraint.f()) {
                        edgelist1.aa(edge);
                        edgelist8.aa(edge);
                    } else if (portconstraint.c()) {
                        edgelist7.aa(edge);
                        edgelist8.aa(edge);
                    }
                    edgecursor.i2();
                    k1++;
                }

                k1 = 0;
                for (var edgecursor1 = node.am(); edgecursor1.i1(); ) {
                    var edge1 = edgecursor1.i8();
                    var portconstraint1 = this.a2(edge1);
                    if (portconstraint1 == null || portconstraint1.c() || portconstraint1.g())
                        edgelist3.aa(edge1);
                    else if (portconstraint1.e())
                        edgelist.aa(edge1);
                    else if (portconstraint1.f()) {
                        edgelist1.aa(edge1);
                        edgelist8.aa(edge1);
                    } else if (portconstraint1.d()) {
                        edgelist5.aa(edge1);
                        edgelist8.aa(edge1);
                    }
                    edgecursor1.i2();
                    k1++;
                }

                var d2 = nodemap.i3(node);
                if (!edgelist8.ar()) {
                    var d5 = 0.10000000000000001 / edgelist8.ay();
                    for (var d8 = d2 - 0.40000000000000002; !edgelist8.ar(); d8 += d5) {
                        var edge2 = edgelist8.c3();
                        if (edge2.a2() === node) {
                            var node1 = this._d.xm();
                            this._n.z1(node1, edge2.a2());
                            this._d.s7(node1, 1.0, 1.0);
                            this._c.z1(node1, this._c.i1(node));
                            nodemap.i6(node1, d8);
                            this._a.i8(edge2, this._d.gn(edge2));
                            this._d.gt(edge2, $A72._A);
                            this._d.xr(edge2, node1, edge2.a3());
                            nodelist.ao(node1, listcell);
                        } else {
                            var node2 = this._d.xm();
                            this._n.z1(node2, edge2.a3());
                            this._d.s7(node2, 1.0, 1.0);
                            this._c.z1(node2, this._c.i1(node));
                            nodemap.i6(node2, d8);
                            this._g.i8(edge2, this._d.gk(edge2));
                            this._d.gz(edge2, $A72._A);
                            this._d.xr(edge2, edge2.a2(), node2);
                            nodelist.ao(node2, listcell);
                        }
                    }

                }
                if (!edgelist.ar()) {
                    var d6 = 0.10000000000000001 / edgelist.ay();
                    for (var d9 = d2 + 0.10000000000000001; !edgelist.ar(); d9 += d6) {
                        var edge3 = edgelist.c3();
                        if (edge3.a2() === node) {
                            var node3 = this._d.xm();
                            this._n.z1(node3, edge3.a2());
                            this._d.s7(node3, 1.0, 1.0);
                            this._c.z1(node3, this._c.i1(node));
                            nodemap.i6(node3, d9);
                            this._a.i8(edge3, this._d.gn(edge3));
                            this._d.gt(edge3, $A72._A);
                            this._d.xr(edge3, node3, edge3.a3());
                            listcell = nodelist.an(node3, listcell);
                        } else {
                            var node4 = this._d.xm();
                            this._n.z1(node4, edge3.a3());
                            this._d.s7(node4, 1.0, 1.0);
                            this._c.z1(node4, this._c.i1(node));
                            nodemap.i6(node4, d9);
                            this._g.i8(edge3, this._d.gk(edge3));
                            this._d.gz(edge3, $A72._A);
                            this._d.xr(edge3, edge3.a2(), node4);
                            listcell = nodelist.an(node4, listcell);
                        }
                    }

                }
                var _lif = $A96._z;
                if (this._b.a2(node))
                    _lif = this._b.b2(node);
                var l1 = _lif._b.ay() + edgelist5.ay() + node.ao() + edgelist4.ay() + _lif._q.ay();
                if (l1 > 0) {
                    var d7 = this._d.g9(node) / 2;
                    var d10 = this._d.gj(node);
                    var d11 = this.a7(d10, l1);
                    var d13 = -0.5 * d10 + this.a8(this._d.gj(node), l1, d11) + d11 * (_lif._b.ay() + edgelist5.ay());
                    for (var edgecursor2 = node.ap(); edgecursor2.i1(); edgecursor2.i2()) {
                        var edge4 = edgecursor2.i8();
                        if (!this.c2(edge4) && this._j.i1(edge4.a2()) == null) {
                            this._d.g2(edge4).i8(new $A00(d13, d7));
                            d13 += d11;
                        }
                    }
                }
                var _la = this._t.a3(node);
                var i2 = 0;
                var j2 = 0;
                var k2 = 0;
                var l2 = 0;
                if (_la != null) {
                    i2 = _la._e.ay();
                    j2 = _la._c.ay();
                    k2 = _la._b.ay();
                    l2 = _la._d.ay();
                }
                l1 = _lif._g.ay() + i2 + edgelist7.ay() + node.ak() + edgelist6.ay() + j2 + _lif._d.ay();
                if (l1 > 0) {
                    var d12 = this._d.gj(node);
                    var d14 = this.a7(d12, l1);
                    var d15 = this.a8(d12, l1, d14);
                    var d16 = -0.5 * d12 + d15 + d14 * (_lif._g.ay() + i2 + edgelist7.ay());
                    var d18 = -this._d.g9(node) / 2;
                    for (var edgecursor3 = node.am(); edgecursor3.i1(); edgecursor3.i2()) {
                        var edge5 = edgecursor3.i8();
                        if (!this.d1(edge5) && this._j.i1(edge5.a3()) == null) {
                            this._d.g2(edge5).i9(new $A00(d16, d18));
                            d16 += d14;
                        }
                    }

                    if (_la != null) {
                        var d17 = -0.5 * d12 + d15 + d14 * ((_lif._g.ay() + edgelist7.ay() + _la._e.ay()) - 1);
                        for (var edgecursor4 = _la._e.c1(); edgecursor4.i1(); edgecursor4.i2()) {
                            var edge6 = edgecursor4.i8();
                            this._d.u1(edge6);
                            if (edge6.a2() === node && !this.c2(edge6)) {
                                this._d.g2(edgecursor4.i8()).i8(new $A00(d17, d18));
                                d17 -= d14;
                            } else if (!this.d1(edge6)) {
                                this._d.g2(edgecursor4.i8()).i9(new $A00(d17, d18));
                                d17 -= d14;
                            }
                            this._d.h1(edge6);
                        }

                        d17 = 0.5 * d12 - d15 - d14 * (_lif._d.ay() + edgelist6.ay());
                        for (var edgecursor5 = _la._c.c1(); edgecursor5.i1(); edgecursor5.i2()) {
                            var edge7 = edgecursor5.i8();
                            this._d.u1(edge7);
                            if (edge7.a2() === node && !this.c2(edge7)) {
                                this._d.g2(edgecursor5.i8()).i8(new $A00(d17, d18));
                                d17 -= d14;
                            } else if (!this.d1(edge7)) {
                                this._d.g2(edgecursor5.i8()).i9(new $A00(d17, d18));
                                d17 -= d14;
                            }
                            this._d.h1(edge7);
                        }

                    }
                }
                if (this._b.a2(node))
                    this._b.a4(node, i2 + edgelist7.ay() + node.ak() + edgelist6.ay() + j2, edgelist5.ay() + node.ao() + edgelist4.ay(), k2 + edgelist1.ay(), l2 + edgelist.ay());
            }

        }

        this._d.xi(nodemap);
        return anodelist;
    },
    a7: function (d1, i1) {
        if (i1 <= 1)
            return 0.0;
        else
            return d1 / ((i1 - 1) + 2 * this._r);
    },
    a8: function (d1, i1, d2) {
        if (i1 <= 1)
            return d1 * 0.5;
        else
            return (d1 - d2 * (i1 - 1)) * 0.5;
    },
    f: function (anodelist) {
        var d1 = this.g1();
        this._f = this._d.xk();
        for (var i1 = 0; i1 < anodelist.length; i1++) {
            var nodelist = anodelist[i1];
            for (var listcell = nodelist._b; listcell != null; ) {
                var node = listcell.d();
                var node1 = this._n.i1(node);
                if (node1 != null || this._t.b2(node)) {
                    listcell = listcell.a();
                } else {
                    var nodelist2 = new $A46();
                    var nodelist5 = new $A46();
                    var nodelist6 = new $A46();
                    var nodelist7 = new $A46();
                    var nodelist8 = new $A46();
                    var nodelist9 = new $A46();
                    var edgelist = new $A25();
                    var edgelist1 = new $A25();
                    var _lfor1 = new $A56(nodelist2, nodelist5, nodelist6, nodelist7, nodelist8, nodelist9, edgelist, edgelist1);
                    this._f.z1(node, _lfor1);
                    edgelist.ab(node.am());
                    edgelist1.ab(node.ap());
                    for (var listcell2 = listcell.b(); listcell2 != null && this._n.i1(listcell2.d()) === node; listcell2 = listcell2.b()) {
                        var node6 = listcell2.d();
                        var portconstraint = this.c3(node6);
                        if (portconstraint.f())
                            nodelist5.ac(node6);
                        else if (portconstraint.c())
                            nodelist7.ac(node6);
                        else if (portconstraint.d())
                            nodelist9.ac(node6);
                    }

                    var listcell3;
                    for (listcell3 = listcell.a(); listcell3 != null && this._n.i1(listcell3.d()) === node; listcell3 = listcell3.a()) {
                        var node8 = listcell3.d();
                        var portconstraint1 = this.c3(node8);
                        if (portconstraint1.e())
                            nodelist2.aa(node8);
                        else if (portconstraint1.c())
                            nodelist6.aa(node8);
                        else if (portconstraint1.d())
                            nodelist8.aa(node8);
                    }

                    listcell = listcell3;
                }
            }

        }

        var afor = this.d2(anodelist);
        var d2 = 0.0;
        for (var j1 = 0; j1 < anodelist.length; j1++) {
            var for1 = afor[j1];
            if (j1 > 0)
                d2 += afor[j1 - 1]._j + afor[j1 - 1]._h + afor[j1 - 1]._b;
            d2 += for1._g + for1._f + for1._a + for1._d;
            for (var nodecursor = anodelist[j1].x1(); nodecursor.i1(); nodecursor.i2()) {
                var node2 = nodecursor.i9();
                this._d.s3(node2, this._d.gi(node2), this._d.gh(node2) + d2);
            }

            for1._c += d2;
            for1._i += d2;
        }

        for (var l1 = 0; l1 < anodelist.length; l1++) {
            var nodelist4 = anodelist[l1];
            for (var nodecursor1 = nodelist4.x1(); nodecursor1.i1(); nodecursor1.i2()) {
                var node3 = nodecursor1.i9();
                if (this._n.i1(node3) != null)
                    nodelist4.av(nodecursor1);
            }
        }

        var self = this;
        var _la = function (node, node1) {
            if (self.a3(node))
                if (self.a3(node1))
                    return self._d.gi(node) >= self._d.gi(node1) ? -1 : 1;
                else
                    return 1;
            if (self.a3(node1))
                return -1;
            else
                return self._d.gi(node) >= self._d.gi(node1) ? 1 : -1;
        };
        var _lif = function (node, node1) {
            if (self.a3(node))
                if (self.a3(node1))
                    return self._d.gi(node) >= self._d.gi(node1) ? 1 : -1;
                else
                    return 1;
            if (self.a3(node1))
                return -1;
            else
                return self._d.gi(node) >= self._d.gi(node1) ? -1 : 1;
        };
        for (var i2 = 0; i2 < anodelist.length; i2++) {
            var for4 = afor[i2];
            for (var nodecursor2 = anodelist[i2].x1(); nodecursor2.i1(); nodecursor2.i2()) {
                var node4 = nodecursor2.i9();
                if (!this._t.b2(node4)) {
                    var _lfor = this._f.i1(node4);
                    var nodelist11 = _lfor._d;
                    var nodelist12 = _lfor._a;
                    var nodelist13 = _lfor._b;
                    var nodelist14 = _lfor._h;
                    var nodelist15 = _lfor._f;
                    var nodelist16 = _lfor._c;
                    var edgelist2 = _lfor._g;
                    var edgelist3 = _lfor._e;
                    var k2 = 0;
                    var l2 = 0;
                    var i3 = 0;
                    var j3 = 0;
                    var l4 = node4.ao();
                    var i5 = node4.ak();
                    var d22 = this._d.gi(node4);
                    var d23 = this._d.gh(node4);
                    var d24 = this._d.gj(node4);
                    var d25 = this._d.g9(node4);
                    var _la2 = this._t.a3(node4);
                    var _lif1 = $A96._z;
                    if (this._b.a2(node4))
                        _lif1 = this._b.b2(node4);
                    if (_la2 != null) {
                        k2 = _la2._d.ay();
                        l2 = _la2._b.ay();
                        i3 = _la2._e.ay();
                        j3 = _la2._c.ay();
                        if (k2 > 0) {
                            var k3 = _lif1._h.ay() + nodelist11.ay() + k2 + _lif1._k.ay();
                            var d10 = this.a7(d25, k3);
                            var d18 = this.a8(d25, k3, d10);
                            var d14 = d23 + d18 + d10 * (_lif1._h.ay() + this.a4(nodelist11));
                            for (var edgecursor3 = _la2._d.c1(); edgecursor3.i1(); edgecursor3.i2()) {
                                var edge3 = edgecursor3.i8();
                                this._d.u1(edge3);
                                if (edge3.a2() === node4) {
                                    if (!this.c2(edge3))
                                        this._d.gx(edge3, new $A00(d22 + d24, d14));
                                } else {
                                    if (this.d1(edge3)) {
                                    }
                                    this._d.gy(edge3, new $A00(d22 + d24, d14));
                                }
                                d14 += d10;
                                this._d.h1(edge3);
                            }

                        }
                        if (l2 > 0) {
                            var l3 = _lif1._i.ay() + nodelist12.ay() + l2 + _lif1._l.ay();
                            var d11 = this.a7(d25, l3);
                            var d19 = this.a8(d25, l3, d11);
                            var d15 = d23 + d19 + d11 * (_lif1._i.ay() + this.a4(nodelist12));
                            for (var edgecursor4 = _la2._b.c1(); edgecursor4.i1(); edgecursor4.i2()) {
                                var edge4 = edgecursor4.i8();
                                this._d.u1(edge4);
                                if (edge4.a2() === node4) {
                                    if (!this.c2(edge4))
                                        this._d.gx(edge4, new $A00(d22, d15));
                                } else if (!this.d1(edge4))
                                    this._d.gy(edge4, new $A00(d22, d15));
                                d15 += d11;
                                this._d.h1(edge4);
                            }

                        }
                    }
                    if (nodelist11.ay() > 0) {
                        nodelist11.a1(_la);
                        var i4 = _lif1._h.ay() + nodelist11.ay() + k2 + _lif1._k.ay();
                        var d12 = this.a7(d25, i4);
                        var d20 = this.a8(d25, i4, d12);
                        var d16 = d23 + d20 + d12 * _lif1._h.ay();
                        var flag = true;
                        while (!nodelist11.ar()) {
                            var node9 = nodelist11.x4();
                            if (this.a3(node9)) {
                                if (flag) {
                                    flag = false;
                                    d16 += d12 * k2;
                                }
                                var edge5 = node9.ag();
                                var ylist = this._d.gd(edge5);
                                var ypoint6 = ylist.at();
                                ylist.ac(new $A00(ypoint6.x, for4.b()));
                                if (this.c2(edge5)) {
                                    var ypoint10 = this._a.i1(edge5);
                                    ylist.ac(new $A00(ypoint6.x, ypoint10.y + this._d.g6(node4)));
                                    ylist.ac(new $A00(ypoint10.x + this._d.g5(node4), ypoint10.y + this._d.g6(node4)));
                                } else {
                                    ylist.ac(new $A00(ypoint6.x, d16));
                                    ylist.ac(new $A00(d22 + d24, d16));
                                }
                                this._d.xr(edge5, node4, edge5.a3());
                                this._d.m1(edge5, ylist);
                            } else {
                                var edge6 = node9.ae();
                                var ylist1 = this._d.gd(edge6);
                                var ypoint7 = ylist1.au();
                                ylist1.ae(new $A00(ypoint7.x, for4.a()));
                                if (this.d1(edge6)) {
                                    var ypoint11 = this._g.i1(edge6);
                                    ylist1.ae(new $A00(ypoint7.x, ypoint11.y + this._d.g6(node4)));
                                    ylist1.ae(new $A00(ypoint11.x + this._d.g5(node4), ypoint11.y + this._d.g6(node4)));
                                } else {
                                    ylist1.ae(new $A00(ypoint7.x, d16));
                                    ylist1.ae(new $A00(d22 + d24, d16));
                                }
                                this._d.xr(edge6, edge6.a2(), node4);
                                this._d.m1(edge6, ylist1);
                            }
                            this._d.x4(node9);
                            d16 += d12;
                        }
                    }
                    if (nodelist12.ay() > 0) {
                        nodelist12.a1(_lif);
                        var j4 = _lif1._i.ay() + nodelist12.ay() + l2 + _lif1._l.ay();
                        var d13 = this.a7(d25, j4);
                        var d21 = this.a8(d25, j4, d13);
                        var d17 = d23 + d21 + d13 * _lif1._i.ay();
                        var flag1 = true;
                        while (!nodelist12.ar()) {
                            var node10 = nodelist12.x4();
                            if (this.a3(node10)) {
                                if (flag1) {
                                    flag1 = false;
                                    d17 += d13 * l2;
                                }
                                var edge7 = node10.ag();
                                var ylist2 = this._d.gd(edge7);
                                var ypoint8 = ylist2.at();
                                ylist2.ac(new $A00(ypoint8.x, for4.b()));
                                if (this.c2(edge7)) {
                                    var ypoint12 = this._a.i1(edge7);
                                    ylist2.ac(new $A00(ypoint8.x, ypoint12.y + this._d.g6(node4)));
                                    ylist2.ac(new $A00(ypoint12.x + this._d.g5(node4), ypoint12.y + this._d.g6(node4)));
                                } else {
                                    ylist2.ac(new $A00(ypoint8.x, d17));
                                    ylist2.ac(new $A00(d22, d17));
                                }
                                this._d.xr(edge7, node4, edge7.a3());
                                this._d.m1(edge7, ylist2);
                            } else {
                                var edge8 = node10.ae();
                                var ylist3 = this._d.gd(edge8);
                                var ypoint9 = ylist3.au();
                                ylist3.ae(new $A00(ypoint9.x, for4.a()));
                                if (this.d1(edge8)) {
                                    var ypoint13 = this._g.i1(edge8);
                                    ylist3.ae(new $A00(ypoint9.x, ypoint13.y + this._d.g6(node4)));
                                    ylist3.ae(new $A00(ypoint13.x + this._d.g5(node4), ypoint13.y + this._d.g6(node4)));
                                } else {
                                    ylist3.ae(new $A00(ypoint9.x, d17));
                                    ylist3.ae(new $A00(d22, d17));
                                }
                                this._d.xr(edge8, edge8.a2(), node4);
                                this._d.m1(edge8, ylist3);
                            }
                            this._d.x4(node10);
                            d17 += d13;
                        }
                    }
                    var k4 = _lif1._g.ay() + _lif1._d.ay() + i5 + nodelist14.ay() + nodelist13.ay() + i3 + j3;
                    d24 = this._d.gj(node4);
                    var d26 = this.a7(d24, k4);
                    var d27 = this.a8(d24, k4, d26);
                    k4 = _lif1._b.ay() + _lif1._q.ay() + l4 + nodelist16.ay() + nodelist15.ay();
                    var d28 = this.a7(d24, k4);
                    var d29 = this.a8(d24, k4, d28);
                    if (nodelist14.ay() > 0) {
                        var d30 = d26;
                        var d34 = d1;
                        var d38 = this._d.gi(node4) + d27 + d30 * ((_lif1._g.ay() + nodelist14.ay()) - 1);
                        var d42 = this._d.gh(node4);
                        var d46 = for4._c - for4._g - nodelist14.ay() * d34;
                        var node11;
                        for (; !nodelist14.ar(); this._d.x4(node11)) {
                            node11 = nodelist14.x4();
                            var edge11 = node11.ag();
                            var ylist5 = this._d.gd(edge11);
                            var ypoint16 = ylist5.at();
                            ylist5.ac(new $A00(ypoint16.x, for4.b()));
                            ylist5.ac(new $A00(ypoint16.x, d46));
                            if (this.c2(edge11)) {
                                var ypoint20 = this._a.i1(edge11);
                                ylist5.ac(new $A00(ypoint20.x + this._d.g5(node4), d46));
                                ylist5.ac(new $A00(ypoint20.x + this._d.g5(node4), ypoint20.y + this._d.g6(node4)));
                            } else {
                                ylist5.ac(new $A00(d38, d46));
                                ylist5.ac(new $A00(d38, d42));
                                d38 -= d30;
                            }
                            d46 += d34;
                            this._d.xr(edge11, node4, edge11.a3());
                            this._d.m1(edge11, ylist5);
                        }

                    }
                    if (nodelist13.ay() > 0) {
                        var d31 = d26;
                        var d35 = d1;
                        var d39 = (this._d.gi(node4) + this._d.gj(node4)) - d27 - d31 * _lif1._d.ay();
                        var d43 = this._d.gh(node4);
                        var d47 = for4._c - for4._g - d35;
                        var node12;
                        for (; !nodelist13.ar(); this._d.x4(node12)) {
                            node12 = nodelist13.x4();
                            var edge12 = node12.ag();
                            var ylist6 = this._d.gd(edge12);
                            var ypoint17 = ylist6.at();
                            ylist6.ac(new $A00(ypoint17.x, for4.b()));
                            ylist6.ac(new $A00(ypoint17.x, d47));
                            if (this.c2(edge12)) {
                                var ypoint21 = this._a.i1(edge12);
                                ylist6.ac(new $A00(ypoint21.x + this._d.g5(node4), d47));
                                ylist6.ac(new $A00(ypoint21.x + this._d.g5(node4), ypoint21.y + this._d.g6(node4)));
                            } else {
                                ylist6.ac(new $A00(d39, d47));
                                ylist6.ac(new $A00(d39, d43));
                                d39 -= d31;
                            }
                            d47 -= d35;
                            this._d.xr(edge12, node4, edge12.a3());
                            this._d.m1(edge12, ylist6);
                        }

                    }
                    if (nodelist16.ay() > 0) {
                        var d32 = d28;
                        var d36 = d1;
                        var d40 = this._d.gi(node4) + d29 + d32 * ((_lif1._b.ay() + nodelist16.ay()) - 1);
                        var d44 = this._d.gh(node4) + this._d.g9(node4);
                        var d48 = d44 + nodelist16.ay() * d36;
                        var node13;
                        for (; !nodelist16.ar(); this._d.x4(node13)) {
                            node13 = nodelist16.x4();
                            var edge13 = node13.ae();
                            var ylist7 = this._d.gd(edge13);
                            var ypoint18 = ylist7.au();
                            ylist7.ae(new $A00(ypoint18.x, for4.a()));
                            ylist7.ae(new $A00(ypoint18.x, d48));
                            if (this.d1(edge13)) {
                                var ypoint22 = this._g.i1(edge13);
                                ylist7.ae(new $A00(ypoint22.x + this._d.g5(node4), d48));
                                ylist7.ae(new $A00(ypoint22.x + this._d.g5(node4), ypoint22.y + this._d.g6(node4)));
                            } else {
                                ylist7.ae(new $A00(d40, d48));
                                ylist7.ae(new $A00(d40, d44));
                                d40 -= d32;
                            }
                            d48 -= d36;
                            this._d.xr(edge13, edge13.a2(), node4);
                            this._d.m1(edge13, ylist7);
                        }

                    }
                    if (nodelist15.ay() > 0) {
                        var d33 = d28;
                        var d37 = d1;
                        var d41 = (this._d.gi(node4) + this._d.gj(node4)) - d29 - d28 * _lif1._q.ay();
                        var d45 = this._d.gh(node4) + this._d.g9(node4);
                        var d49 = d45 + d37;
                        var node14;
                        for (; !nodelist15.ar(); this._d.x4(node14)) {
                            node14 = nodelist15.x4();
                            var edge14 = node14.ae();
                            var ylist8 = this._d.gd(edge14);
                            var ypoint19 = ylist8.au();
                            ylist8.ae(new $A00(ypoint19.x, for4.a()));
                            ylist8.ae(new $A00(ypoint19.x, d49));
                            if (this.d1(edge14)) {
                                var ypoint23 = this._g.i1(edge14);
                                ylist8.ae(new $A00(ypoint23.x + this._d.g5(node4), d49));
                                ylist8.ae(new $A00(ypoint23.x + this._d.g5(node4), ypoint23.y + this._d.g6(node4)));
                            } else {
                                ylist8.ae(new $A00(d41, d49));
                                ylist8.ae(new $A00(d41, d45));
                                d41 -= d33;
                            }
                            d49 += d37;
                            this._d.xr(edge14, edge14.a2(), node4);
                            this._d.m1(edge14, ylist8);
                        }

                    }
                    while (!edgelist3.ar()) {
                        var edge9 = edgelist3.c3();
                        var ypoint14 = this._d.gl(edge9);
                        if (for4.a() + 12 < ypoint14.y)
                            this._d.g7(edge9).i4(ypoint14.x, for4.a());
                    }
                    while (!edgelist2.ar()) {
                        var edge10 = edgelist2.c3();
                        var ypoint15 = this._d.gs(edge10);
                        if (for4.b() - 12 > ypoint15.y) {
                            var ylist4 = this._d.gf(edge10);
                            ylist4.ac(new $A00(ypoint15.x, for4.b()));
                            this._d.s6(edge10, ylist4);
                        }
                    }
                }
            }

        }

        for (var j2 = 0; j2 < anodelist.length; j2++) {
            var nodelist10 = anodelist[j2];
            for (var listcell1 = nodelist10._b; listcell1 != null; listcell1 = listcell1.a()) {
                var node5 = listcell1.d();
                var _la1 = this._t.a3(node5);
                if (_la1 != null && _la1._a != null) {
                    this._d.x4(_la1._a);
                    nodelist10.aw(listcell1.b());
                }
            }
        }

        this._d.xi(this._f);
        this._d.xj(this._a);
        this._d.xj(this._g);
        return anodelist;
    },
    c3: function (node) {
        if (this.a3(node))
            return this.b1(node.ag());
        else
            return this.a2(node.ae());
    },
    b1: function (edge) {
        if (this._h == null)
            return $A96.s;
        else
            return this._h.i1(edge);
    },
    a2: function (edge) {
        if (this._l == null)
            return $A96.u;
        else
            return this._l.i1(edge);
    },
    c2: function (edge) {
        if (edge == null) {
            return false;
        } else {
            var portconstraint = this.b1(edge);
            return portconstraint != null && portconstraint.a();
        }
    },
    d1: function (edge) {
        if (edge == null) {
            return false;
        } else {
            var portconstraint = this.a2(edge);
            return portconstraint != null && portconstraint.a();
        }
    },
    a3: function (node) {
        return node.ao() === 1;
    },
    b2: function (node) {
        return node.ak() === 1;
    },
    a4: function (nodelist) {
        var i1 = 0;
        for (var listcell = nodelist._b; listcell != null; listcell = listcell.a())
            if (this.b2(listcell.d()))
                i1++;

        return i1;
    },
    d2: function (anodelist) {
        var d1 = this._k;
        var afor = $A53.d(anodelist.length + 1);
        for (var i1 = 0; i1 < anodelist.length; i1++) {
            var nodelist = anodelist[i1];
            var for1 = new $A73();
            afor[i1] = for1;
            for1._c = Number.MAX_VALUE;
            for1._i = Number.MIN_VALUE;
            for (var nodecursor = nodelist.x1(); nodecursor.i1(); nodecursor.i2()) {
                var node = nodecursor.i9();
                var nodelayout = this._d.gb(node);
                for1._c = Math.min(for1._c, nodelayout.i2());
                for1._i = Math.max(for1._i, nodelayout.i2() + nodelayout.i4());
            }
        }

        this._b.a5(anodelist, afor);
        for (var j1 = 0; j1 < anodelist.length; j1++) {
            var for2 = afor[j1];
            for (var nodecursor1 = anodelist[j1].x1(); nodecursor1.i1(); nodecursor1.i2()) {
                var node1 = nodecursor1.i9();
                var _lfor = this._f.i1(node1);
                if (_lfor != null) {
                    for2._h = Math.max(for2._h, Math.max(_lfor._f.ay() * d1, _lfor._c.ay() * d1));
                    for2._f = Math.max(for2._f, Math.max(_lfor._b.ay() * d1, _lfor._h.ay() * d1));
                }
            }
        }
        return afor;
    }
});
$A96.s = $A84.j(2);
$A96.u = $A84.j(1);
$A96._z = new $A74();

var $A92 = function () {
    this._af = 0;
    this._b = 0;
};
_twaver.ext($A92, Object, {
    ib: function (l1) {
        this._af = l1;
    },
    ia: function (layoutgraph, nodemap, i1) {
        this.a6(layoutgraph, nodemap, i1);
        this.b2(false);
        var k1 = this.g();
        if (this.o() && k1 > 0) {
            var ai1 = this.r();
            for (var i2 = 0; i2 < 20 && k1 > 0 && this.o(); i2++) {
                this.b2(true);
                var j2 = this.g();
                if (j2 < k1) {
                    this.a7(ai1);
                    k1 = j2;
                }
            }

            this.b3(ai1);
            this.b1();
        }
        return this.c();
    },
    a6: function (graph, nodemap, i1) {
        this._b = new Date().getTime();
        this._ac = graph;
        this._ah = nodemap;
        var self = this;
        this._p = function (obj, obj1) {
            var d1 = self._n[obj.al()] - self._n[obj1.al()];
            if (d1 > 0.0)
                return 1;
            return d1 >= 0.0 ? 0 : -1;
        };
        this._ad = $A53.d(i1);
        for (var j1 = 0; j1 < this._ad.length; j1++)
            this._ad[j1] = new $A46();

        this._ab = $A53.a(this._ac.x0());
        this._f = $A53.d(this._ac.x0());
        this._n = $A53.a(this._ac.x0() + 1);
        var ab = this._ab;
        this._o = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            var edge = obj;
            var edge4 = obj1;
            var layoutgraph = edge._h;
            var node = edge.a2();
            var node4 = edge4.a2();
            var i = ab[node.al()] - ab[node4.al()];
            if (i === 0) {
                var i1 = $A92.b($A84.h(layoutgraph, edge), layoutgraph.gn(edge));
                var i2 = $A92.b($A84.h(layoutgraph, edge4), layoutgraph.gn(edge4));
                var k2 = i1 - i2;
                if (k2 === 0) {
                    var i3 = ab[edge.a3().al()] - ab[edge4.a3().al()];
                    if (i3 === 0) {
                        var k3 = $A92.a($A84.i(layoutgraph, edge), layoutgraph.gk(edge));
                        var i4 = $A92.a($A84.i(layoutgraph, edge4), layoutgraph.gk(edge4));
                        return k3 - i4;
                    } else {
                        return i3;
                    }
                } else {
                    return k2;
                }
            } else {
                return i;
            }
        };
        this._l = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            var edge1 = obj;
            var edge5 = obj1;
            var layoutgraph1 = edge1._h;
            var node1 = edge1.a3();
            var node5 = edge5.a3();
            var j = ab[node1.al()] - ab[node5.al()];
            if (j === 0) {
                var j1 = $A92.a($A84.i(layoutgraph1, edge1), layoutgraph1.gk(edge1));
                var j2 = $A92.a($A84.i(layoutgraph1, edge5), layoutgraph1.gk(edge5));
                var l2 = j1 - j2;
                if (l2 === 0) {
                    var j3 = ab[edge1.a2().al()] - ab[edge5.a2().al()];
                    if (j3 === 0) {
                        var l3 = $A92.b($A84.h(layoutgraph1, edge1), layoutgraph1.gn(edge1));
                        var j4 = $A92.b($A84.h(layoutgraph1, edge5), layoutgraph1.gn(edge5));
                        return l3 - j4;
                    } else {
                        return j3;
                    }
                } else {
                    return l2;
                }
            } else {
                return j;
            }
        };
        this._z = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            var edge2 = obj;
            var edge6 = obj1;
            var layoutgraph2 = edge2._h;
            var k = $A92.b($A84.h(layoutgraph2, edge2), layoutgraph2.gn(edge2));
            var k1 = $A92.b($A84.h(layoutgraph2, edge6), layoutgraph2.gn(edge6));
            return k - k1;
        };
        this._e = function (obj, obj1) {
            if (obj == null && obj1 != null) {
                return 1;
            }
            if (obj != null && obj1 == null) {
                return -1;
            }
            if (obj == null && obj1 == null) {
                return 0;
            }
            var edge3 = obj;
            var edge7 = obj1;
            var layoutgraph3 = edge3._h;
            var l = $A92.a($A84.i(layoutgraph3, edge3), layoutgraph3.gk(edge3));
            var l1 = $A92.a($A84.i(layoutgraph3, edge7), layoutgraph3.gk(edge7));
            return l - l1;
        };
        this._ac.x2(this._e, this._z);
    },
    c: function () {
        this._ah = null;
        this._aa = null;
        this._f = null;
        this._n = null;
        this._p = null;
        this._o = null;
        this._l = null;
        this._ac = null;
        var anodelist = this._ad;
        this._ad = null;
        return anodelist;
    },
    o: function () {
        var l1 = new Date().getTime() - this._b;
        return l1 <= this._af;
    },
    m: function () {
        var self = this;
        var f = function (obj, obj1) {
            return Math.ceil(self._n[obj.a3().al()]) - Math.ceil(self._n[obj1.a3().al()]);
        };
        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2()) {
            for (var nodecursor1 = nodecursor.i9().aw(); nodecursor1.i1(); nodecursor1.i2())
                this._n[nodecursor1.i9().al()] = $A72.j();
            nodecursor.i9().av(f);
        }
    },
    b2: function (flag) {
        for (var i1 = 0; i1 < this._ad.length; i1++)
            this._ad[i1].af();

        if (flag) {
            this.m();
            for (var i = 0, n = this._ab.length; i < n; i++) {
                this._ab[i] = 0;
            }
            this._ac.x2(null, this._z);
        }
        var node = this._ac.xm();
        this._ah.i7(node, 0);
        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2())
            if (nodecursor.i9().ak() === 0 && nodecursor.i9() !== node)
                this._ac.xo(node, nodecursor.i9());

        var dfs = new $A13(this);
        dfs.a6(true);
        dfs.a9(this._ac, node);
        this._ad[0].at();
        this._ac.x4(node);
        this.d();
    },
    a1: function () {
        this._ac.x2(this._o, this._l);
        var i1 = 0;
        for (var j1 = 1; j1 < this._ad.length; j1++) {
            var k1 = this.a2(this._ad[j1 - 1], this._ad[j1]);
            i1 += k1;
        }

        var l1 = 0;
        i1 += l1;
        return i1;
    },
    a2: function (ylist, ylist1) {
        var ycursor = ylist.ah();
        var ycursor1 = ylist1.ah();
        var ylist2 = new $A35();
        var ylist3 = new $A35();
        this._aa = $A53.d(this._ac.x0());
        var i1 = 0;
        for (; ycursor.i1() && ycursor1.i1(); ycursor1.i2()) {
            i1 += this.a8(ycursor.i6(), ylist2, ylist3, true);
            i1 += this.a8(ycursor1.i6(), ylist3, ylist2, false);
            ycursor.i2();
        }

        for (; ycursor.i1(); ycursor.i2())
            i1 += this.a8(ycursor.i6(), ylist2, ylist3, true);

        for (; ycursor1.i1(); ycursor1.i2())
            i1 += this.a8(ycursor1.i6(), ylist3, ylist2, false);

        return i1;
    },
    a8: function (node, ylist, ylist1, flag) {
        var j1 = 0;
        var k1 = 0;
        var l1 = 0;
        if (this._aa[node.al()] != null) {
            var listcell = this._aa[node.al()].a();
            for (var listcell1 = ylist._b; listcell1 !== listcell; listcell1 = listcell1.a()) {
                var node3 = listcell1._c;
                if (node3 === node) {
                    j1++;
                    l1 += k1;
                    ylist.aw(listcell1);
                } else {
                    k1++;
                }
            }
        }
        var i1 = j1 * ylist1.ay() + l1;
        if (flag) {
            for (var edge = node.ag(); edge != null; edge = edge.a8()) {
                var node1 = edge.a3();
                if (this._ab[node1.al()] >= this._ab[node.al()])
                    this._aa[node1.al()] = ylist1.ae(node1);
            }
        } else {
            for (var edge1 = node.ae(); edge1 != null; edge1 = edge1.a7()) {
                var node2 = edge1.a2();
                if (this._ab[node2.al()] > this._ab[node.al()])
                    this._aa[node2.al()] = ylist1.ae(node2);
            }
        }
        return i1;
    },
    g: function () {
        var ai1 = this.r();
        var i1 = this.a1();
        var flag = true;
        for (var k1 = 0; k1 < 3 && this.o() && i1 > 0; ) {
            var j1 = this.k();
            if (j1 < i1) {
                this.a7(ai1);
                i1 = j1;
            } else {
                k1++;
            }
            flag = !flag;
        }

        this.b3(ai1);
        this.b1();
        if (i1 > 0) {
            var byte0 = 1;
            for (var l1 = 0; byte0 === 1 && i1 > 0; l1++) {
                this.e();
                this.i();
                var i2 = this.a1();
                if (i2 < i1) {
                    byte0 = 1;
                    this.a7(ai1);
                } else {
                    byte0 = -1;
                }
                i1 = i2;
            }

            this.b3(ai1);
            this.b1();
        }
        return i1;
    },
    e: function () {
        var edgemap = this.l();
        var ai1 = this.r();
        var aylist = $A53.d(this._ac.x0());
        for (var l2 = this._ad.length - 1; l2 >= 0; l2--) {
            for (var ycursor = this._ad[l2].ah(); ycursor.i1(); ycursor.i2()) {
                var node4 = ycursor.i6();
                if (node4.ak() === 1 && node4.ao() === 1) {
                    var node = edgemap.i1(node4.ag());
                    if (node != null && aylist[node.al()] == null) {
                        var l1 = this.a4(node4, node);
                        var i1 = node.al();
                        var aylist1 = aylist[i1] = $A53.d(l1 + 1);
                        for (var j3 = aylist1.length - 1; j3 >= 0; j3--)
                            aylist1[j3] = new $A35();
                    }
                }
            }
        }

        for (var i3 = 0; i3 < this._ad.length; i3++) {
            for (var ycursor1 = this._ad[i3].ah(); ycursor1.i1(); ycursor1.i2()) {
                var node5 = ycursor1.i6();
                if (node5.ak() === 1 && node5.ao() === 1) {
                    var node1 = edgemap.i1(node5.ag());
                    if (node1 != null) {
                        var j1 = node1.al();
                        var i2 = this.a4(node5, node1) - 1;
                        aylist[j1][i2].ae(node5.ae());
                    }
                } else {
                    for (var edge = node5.ae(); edge != null; edge = edge.a7()) {
                        var node2 = edgemap.i1(edge);
                        if (node2 != null) {
                            var k1 = node2.al();
                            var j2 = this.a4(node5, node2) - 1;
                            aylist[k1][j2].ae(edge);
                        }
                    }
                }
            }
        }

        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node6 = nodecursor.i9();
            if (aylist[node6.al()] != null) {
                for (var edge3 = node6.ag(); edge3 != null; edge3 = edge3.a8()) {
                    var node3 = edgemap.i1(edge3);
                    if (node3 != null) {
                        for (var aylist2 = aylist[node3.al()]; aylist2[0].ay() > 0; ) {
                            var k2 = 0;
                            var edge1;
                            do {
                                edge1 = aylist2[k2].am();
                                var node7 = edge1.a3();
                                if (node7.ak() !== 1 || node7.ao() !== 1)
                                    break;
                                k2++;
                            } while (true);
                            var node9 = aylist2[k2].at().a3();
                            k2--;
                            node9 = edge1.a2();
                            edge1 = aylist2[k2].at();
                            var node8 = edge1.a3();
                            while (k2 >= 0) {
                                if (ai1[node9.al()] !== ai1[node8.al()])
                                    this._ab[node9.al()] = ai1[node8.al()];
                                node9 = node9.ae().a2();
                                if (--k2 >= 0) {
                                    var edge2 = aylist2[k2].at();
                                    node8 = edge2.a3();
                                }
                            }
                        }
                    }
                }
            }
        }
        this.b1();
        this._ac.xj(edgemap);
    },
    i: function () {
        var edgemap = this.f();
        var ai1 = this.r();
        var aylist = $A53.d(this._ac.x0());
        for (var l2 = 0; l2 < this._ad.length; l2++) {
            for (var ycursor = this._ad[l2].ah(); ycursor.i1(); ycursor.i2()) {
                var node4 = ycursor.i6();
                if (node4.ak() === 1 && node4.ao() === 1) {
                    var node = edgemap.i1(node4.ae());
                    if (node != null && aylist[node.al()] == null) {
                        var l1 = this.a4(node, node4);
                        var i1 = node.al();
                        var aylist1 = aylist[i1] = $A53.d(l1 + 1);
                        for (var j3 = aylist1.length - 1; j3 >= 0; j3--)
                            aylist1[j3] = new $A35();
                    }
                }
            }
        }

        for (var i3 = this._ad.length - 1; i3 >= 0; i3--) {
            for (var ycursor1 = this._ad[i3].ah(); ycursor1.i1(); ycursor1.i2()) {
                var node5 = ycursor1.i6();
                if (node5.ak() === 1 && node5.ao() === 1) {
                    var node1 = edgemap.i1(node5.ae());
                    if (node1 != null) {
                        var j1 = node1.al();
                        var i2 = this.a4(node1, node5) - 1;
                        aylist[j1][i2].ae(node5.ag());
                    }
                } else {
                    for (var edge = node5.ag(); edge != null; edge = edge.a8()) {
                        var node2 = edgemap.i1(edge);
                        if (node2 != null) {
                            var k1 = node2.al();
                            var j2 = this.a4(node2, node5) - 1;
                            aylist[k1][j2].ae(edge);
                        }
                    }
                }
            }
        }

        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node6 = nodecursor.i9();
            if (aylist[node6.al()] != null) {
                for (var edge3 = node6.ae(); edge3 != null; edge3 = edge3.a7()) {
                    var node3 = edgemap.i1(edge3);
                    if (node3 != null) {
                        for (var aylist2 = aylist[node3.al()]; aylist2[0].ay() > 0; ) {
                            var k2 = 0;
                            var edge1;
                            do {
                                edge1 = aylist2[k2].am();
                                var node7 = edge1.a2();
                                if (node7.ak() !== 1 || node7.ao() !== 1)
                                    break;
                                k2++;
                            } while (true);
                            var node9 = aylist2[k2].at().a2();
                            k2--;
                            node9 = edge1.a3();
                            edge1 = aylist2[k2].at();
                            var node8 = edge1.a2();
                            while (k2 >= 0) {
                                if (ai1[node9.al()] !== ai1[node8.al()])
                                    this._ab[node9.al()] = ai1[node8.al()];
                                node9 = node9.ag().a3();
                                if (--k2 >= 0) {
                                    var edge2 = aylist2[k2].at();
                                    node8 = edge2.a2();
                                }
                            }
                        }
                    }
                }
            }
        }
        this.b1();
        this._ac.xj(edgemap);
    },
    a4: function (node, node1) {
        return this._ah.i2(node) - this._ah.i2(node1);
    },
    l: function () {
        var edgemap = $A49.a6($A53.d(this._ac.xg()));
        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (node.ao() > 1) {
                var i1 = 0;
                for (var edge = node.ag(); edge != null; edge = edge.a8()) {
                    var node1 = edge.a3();
                    if (node1.ak() === 1 && node1.ao() === 1)
                        i1++;
                }
                if (i1 > 1) {
                    for (var edge1 = node.ag(); edge1 != null; edge1 = edge1.a8()) {
                        var edge2 = edge1;
                        var node2 = edge2.a3();
                        if (node2.ak() === 1 && node2.ao() === 1) {
                            for (; node2.ak() === 1 && node2.ao() === 1; node2 = edge2.a3()) {
                                edgemap.i8(edge2, node);
                                edge2 = node2.ag();
                            }
                            edgemap.i8(edge2, node);
                        }
                    }
                }
            }
        }
        return edgemap;
    },
    f: function () {
        var edgemap = $A49.a6($A53.d(this._ac.xg()));
        for (var nodecursor = this._ac.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            if (node.ak() > 1) {
                var i1 = 0;
                for (var edge = node.ae(); edge != null; edge = edge.a7()) {
                    var node1 = edge.a2();
                    if (node1.ak() === 1 && node1.ao() === 1)
                        i1++;
                }
                if (i1 > 1) {
                    for (var edge1 = node.ae(); edge1 != null; edge1 = edge1.a7()) {
                        var edge2 = edge1;
                        var node2 = edge2.a2();
                        if (node2.ak() === 1 && node2.ao() === 1) {
                            for (; node2.ak() === 1 && node2.ao() === 1; node2 = edge2.a2()) {
                                edgemap.i8(edge2, node);
                                edge2 = node2.ae();
                            }
                            edgemap.i8(edge2, node);
                        }
                    }
                }
            }
        }
        return edgemap;
    },
    k: function () {
        for (var i1 = 1; i1 < this._ad.length; i1++) {
            var nodelist = this._ad[i1];
            for (var ycursor = nodelist.ah(); ycursor.i1(); ycursor.i2()) {
                var node = ycursor.i6();
                this._n[node.al()] = this.a5(node, nodelist.ay(), node.am(), this._ad[i1 - 1].ay());
                this._n[node.al()] += this._ab[node.al()] / (this._ad[i1 - 1].ay() * 3);
            }
            this.a3(nodelist, this._p);
        }
        return this.a1();
    },
    a5: function (node, i1, edgecursor, j1) {
        var d1 = 0.0;
        if (edgecursor.i7() === 0) {
            d1 = (j1 * this._ab[node.al()]) / i1;
        } else {
            for (; edgecursor.i1(); edgecursor.i2()) {
                var edge = edgecursor.i8();
                if (edge.a2() === node) {
                    d1 += this._ab[edge.a3().al()];
                } else {
                    d1 += this._ab[edge.a2().al()];
                }
            }

            d1 /= edgecursor.i7();
        }
        return d1;
    },
    a7: function (ai1) {
        $A53.f(this._ab, ai1, ai1.length);
    },
    b3: function (ai1) {
        $A53.f(ai1, this._ab, ai1.length);
    },
    r: function () {
        var ai1 = $A53.a(this._ab.length);
        this.a7(ai1);
        return ai1;
    },
    d: function () {
        for (var j1 = 0; j1 < this._ad.length; j1++) {
            var i1 = 0;
            for (var ycursor = this._ad[j1].ah(); ycursor.i1(); ) {
                this._ab[ycursor.i6().al()] = i1;
                ycursor.i2();
                i1++;
            }
        }
    },
    b1: function () {
        for (var i1 = 0; i1 < this._ad.length; i1++) {
            var nodelist = this._ad[i1];
            for (var listcell = nodelist._b; listcell != null; listcell = listcell.a()) {
                var node = listcell.d();
                this._f[this._ab[node.al()]] = node;
            }
            var j1 = 0;
            for (var listcell1 = nodelist._b; listcell1 != null; ) {
                listcell1.c(this._f[j1]);
                listcell1 = listcell1.a();
                j1++;
            }
        }
    },
    a3: function (ylist, comparator) {
        var ycursor = ylist.ah();
        for (var i1 = 0; i1 < ylist.ay(); ycursor.i2()) {
            this._f[i1] = ycursor.i6();
            i1++;
        }
        $A53.s(this._f, ylist.ay(), comparator);
        var j1 = 0;
        for (var listcell = ylist._b; listcell != null; ) {
            listcell.c(this._f[j1]);
            this._ab[this._f[j1].al()] = j1;
            listcell = listcell.a();
            j1++;
        }
    }
});
$A92.b = function (portconstraint, ypoint) {
    if (portconstraint == null)
        return 0;
    var i = portconstraint.a() ? Math.floor(ypoint.x) : 0;
    var j = portconstraint.a() ? Math.floor(ypoint.y) : 0;
    if (portconstraint.e())
        return 10000 - j;
    if (portconstraint.f())
        return -10000 + j;
    if (portconstraint.c())
        return -20000 - i;
    else
        return i;
};
$A92.a = function (portconstraint, ypoint) {
    if (portconstraint == null)
        return 0;
    var i = portconstraint.a() ? Math.floor(ypoint.x) : 0;
    var j = portconstraint.a() ? Math.floor(ypoint.y) : 0;
    if (portconstraint.e())
        return 10000 + j;
    if (portconstraint.f())
        return -10000 - j;
    if (portconstraint.d())
        return -20000 - i;
    else
        return i;
};

var $A89 = function () {
    $A89.superClass.constructor.call(this);
    this._i6 = 0;
    this._i3 = 0x7fffffff;
    this._i0 = 60;
    this._iz = 20;
    this._i2 = 20;
    this._i4 = 20;
    this.i5(false);
    this._i7 = new $A90();
    this._i1 = new $A92();
    this._i8 = new $A94();
};
_twaver.ext($A89, $A67, {
    j2: function () {
        return this._i2;
    },
    i4: function (layoutgraph) {
        return true;
    },
    i3: function (layoutgraph) {
        this._i6 = new Date().getTime();
        $A83.d(layoutgraph, false);
        var nodemap = layoutgraph.xk();
        var nodemap1 = layoutgraph.xk();
        var edgemap = layoutgraph.xl();
        var edgelist = new $A25();
        var a1 = new $A96(layoutgraph, nodemap, nodemap1, edgemap);
        a1.a6(this.j2());
        this._i8.i3(this._iz);
        this._i8.i6(this._i0);
        this._i8.i4(this._i2);
        this._i8.i5(this._i4);
        this._i8.i2(nodemap1);
        var i = this._i7.i1(layoutgraph, nodemap, edgelist);
        for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            edgemap.i7(edge, true);
            var ypoint = layoutgraph.gn(edge);
            layoutgraph.gt(edge, layoutgraph.gk(edge));
            layoutgraph.gz(edge, ypoint);
        }

        this.a2(layoutgraph, nodemap, nodemap1);
        i = a1.a9(i);
        var anodelist = this.j1(layoutgraph, nodemap, i);
        anodelist = a1.a5(anodelist);
        anodelist = a1.b3(anodelist);
        this._i8.i1(layoutgraph, anodelist, nodemap);
        anodelist = a1.g2(anodelist);
        a1.e2(anodelist);
        this.b(layoutgraph, nodemap1);
        this.w(layoutgraph);
        this.a1(layoutgraph, edgelist);
        a1.e1();
        layoutgraph.xj(edgemap);
        layoutgraph.xi(nodemap1);
        layoutgraph.xi(nodemap);
    },
    j1: function (layoutgraph, nodemap, i) {
        if (this._i1 instanceof $A92) {
            var classiclayersequencer = this._i1;
            var l = new Date().getTime() - this._i6;
            classiclayersequencer.ib(this._i3 - l);
        }
        var anodelist = this._i1.ia(layoutgraph, nodemap, i);
        return anodelist;
    },
    a1: function (layoutgraph, edgelist) {
        for (var edgecursor = edgelist.c1(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var ypoint = layoutgraph.gs(edge);
            var ypoint1 = layoutgraph.gl(edge);
            layoutgraph.x3(edge);
            var ypointpath = layoutgraph.gp(edge);
            layoutgraph.s5(edge, ypointpath.a());
            layoutgraph.gy(edge, ypoint);
            layoutgraph.gx(edge, ypoint1);
        }
    },
    b: function (layoutgraph, nodemap) {
        for (var nodecursor = layoutgraph.x9(); nodecursor.i1(); nodecursor.i2()) {
            var node = nodecursor.i9();
            var edge = nodemap.i1(node);
            if (edge != null && !layoutgraph.xp(edge)) {
                for (var node1 = node.am().i8().a2(); nodemap.i1(node1) != null; node1 = node.am().i8().a2())
                    node = node1;

                layoutgraph.u1(edge);
                var edge1 = node.ae();
                var ylist = new $A35();
                for (; nodemap.i1(edge1.a3()) != null; edge1 = edge1.a3().ag()) {
                    var ypoint = layoutgraph.gs(edge1);
                    ylist.aa(ypoint);
                    ylist.az(layoutgraph.gf(edge1));
                    var ypoint2 = layoutgraph.gl(edge1);
                    if (!ypoint2.equals(ypoint))
                        ylist.aa(ypoint2);
                }

                var ypoint1 = layoutgraph.gs(edge1);
                ylist.aa(ypoint1);
                ylist.az(layoutgraph.gf(edge1));
                var ypoint3 = layoutgraph.gl(edge1);
                if (!ypoint3.equals(ypoint1))
                    ylist.aa(ypoint3);
                layoutgraph.m1(edge, ylist);
            }
        }

        for (var nodecursor1 = layoutgraph.x9(); nodecursor1.i1(); nodecursor1.i2())
            if (nodemap.i1(nodecursor1.i9()) != null)
                layoutgraph.x4(nodecursor1.i9());
    },
    w: function (layoutgraph) {
        for (var edgecursor = layoutgraph.xf(); edgecursor.i1(); edgecursor.i2()) {
            var edge = edgecursor.i8();
            var edgelayout = layoutgraph.g2(edge);
            if (edgelayout.i1() > 0) {
                var vector = new $List();
                var ypointpath = layoutgraph.gc(edge);
                var ycursor = ypointpath.c();
                var ypoint = ycursor.i6();
                ycursor.i2();
                var d = ypoint.x;
                var d1 = ypoint.y;
                if (ycursor.i1()) {
                    var ypoint1 = ycursor.i6();
                    var d2 = ypoint1.x;
                    var d3 = ypoint1.y;
                    ycursor.i2();
                    for (; ycursor.i1(); ycursor.i2()) {
                        var ypoint2 = ycursor.i6();
                        var d5 = ypoint2.x;
                        var d4 = ypoint2.y;
                        var d6 = ((d - d5) * (d3 - d4)) / (d1 - d4) + d5;
                        if (Math.abs(d6 - d2) >= 1) {
                            vector.add(ypoint1);
                            d = d2;
                            d1 = d3;
                        }
                        ypoint1 = ypoint2;
                        d2 = d5;
                        d3 = d4;
                    }

                }
                if (vector.size() < edgelayout.i1())
                    layoutgraph.s5(edge, new $A05(vector));
            }
        }
    },
    a2: function (layoutgraph, nodemap, nodemap1) {
        var edgecursor = layoutgraph.g8().c1();
        edgecursor.i5();
        for (; edgecursor.i1(); edgecursor.i3()) {
            var node = edgecursor.i8().a2();
            var node1 = edgecursor.i8().a3();
            var i = nodemap.i2(node1) - nodemap.i2(node);
            if (i > 1) {
                var node2 = null;
                var edge = null;
                var node3 = node;
                for (; i > 1; i--) {
                    node2 = layoutgraph.xm();
                    layoutgraph.s7(node2, 1.0, 1.0);
                    layoutgraph.s4(node2, $A72._A);
                    edge = layoutgraph.xo(node3, node2);
                    if (node3 === node)
                        layoutgraph.gt(edge, layoutgraph.gn(edgecursor.i8()));
                    nodemap.i7(node2, nodemap.i2(node3) + 1);
                    nodemap1.z1(node2, edgecursor.i8());
                    node3 = node2;
                }

                edge = layoutgraph.xo(node2, node1);
                layoutgraph.gz(edge, layoutgraph.gk(edgecursor.i8()));
                layoutgraph.h1(edgecursor.i8());
            }
        }
    }
});

var $A75 = function (layoutgraph, nodemap, nodemap1, edgemap) {
    this._i = 20;
    this._j = layoutgraph;
    this._g = nodemap;
    this._a = nodemap1;
    this._h = edgemap;
};
_twaver.ext($A75, Object, {
    a1: function (d1) {
        this._i = d1;
    },
    b2: function (node) {
        return this._e == null ? false : this._e.i4(node);
    },
    a3: function (node) {
        return this._f == null ? null : this._f.i1(node);
    },
    d: function () {
        this._j.xi(this._f);
        this._j.xi(this._e);
    }
});

var $A73 = function () {
    this._c = 0;
    this._i = 0;
    this._g = 0;
    this._j = 0;
    this._f = 0;
    this._h = 0;
    this._d = 0;
    this._e = 0;
    this._a = 0;
    this._b = 0;
};
_twaver.ext($A73, Object, {
    a: function () {
        return this._c - this._g - this._f - this._a;
    },
    b: function () {
        return this._i + this._j + this._h + this._b;
    }
});

var $A69 = function () {
    this._d = new $A25();
    this._b = new $A25();
    this._c = new $A25();
    this._e = new $A25();
};
_twaver.ext($A69, Object, {

});

var $A56 = function (nodelist, nodelist1, nodelist2, nodelist3, nodelist4, nodelist5, edgelist, edgelist1) {
    this._d = nodelist;
    this._a = nodelist1;
    this._b = nodelist2;
    this._h = nodelist3;
    this._f = nodelist4;
    this._c = nodelist5;
    this._e = edgelist;
    this._g = edgelist1;
};
_twaver.ext($A56, Object, {

});

var $A53 = {};
$A53.a = function (c, d) {
    var result = [];
    for (var i = 0; i < c; i++)
        result[i] = d || 0;
    return result;
};
$A53.b = function (c) {
    var result = [];
    for (var i = 0; i < c; i++)
        result[i] = false;
    return result;
};
$A53.c = function (a, b) {
    if (a instanceof $A00) {
        if (a.x < b.x)
            return -1;
        if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        return a.y <= b.y ? 0 : 1;
    } else if (a instanceof $A01) {
        if (b.width > a.width)
            return -1;
        if (b.width < a.width)
            return 1;
        if (b.height > a.height)
            return -1;
        return b.height >= a.height ? 0 : 1;
    } else if (a instanceof $A03) {
        if (a.x < b.x)
            return -1;
        if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        if (a.y > b.y)
            return 1;
        if (b.width > a.width)
            return -1;
        if (b.width < a.width)
            return 1;
        if (b.height > a.height)
            return -1;
        return b.height >= a.height ? 0 : 1;
    } else {
        throw 'Unkown Type: ' + a;
    }
};
$A53.d = function (c) {
    var result = [];
    for (var i = 0; i < c; i++)
        result[i] = null;
    return result;
};
$A53.e = function (a, b) {
    var result = [];
    for (var i = 0; i < a; i++)
        result[i] = $A53.a(b);
    return result;
};
$A53.f = function (src, dest, length) {
    for (var i = 0; i < length; i++)
        dest[i] = src[i];
};
$A53.s = function (src, length, compare) {
    var dest = [];
    $A53.f(src, dest, length);
    dest.sort(compare);
    $A53.f(dest, src, length);
};
$A53.n = function (a, b) {
    return a - b;
};

/**
 *
 * make 
 *  ,,modelDefaultParameters, ,id.hidden,editable.
 *  3D2D, 3D
 *  position location rotation 
 *   width height depth
 *
 *  property
 *  id: 
 *  name: label, id
 *  value: 
 *  type: string int number color image
 *  propertyType: field  accessor client style
 *  hidden: true() false()  false,
 *  editable: true() false() true, 
 *  exportable: true() false() true, 
 *  index , 100
 */

if (!window.make) {
    var make = window.make = {};
    //default

    //{id, creator} creator is a function or a string
    var _creatorMap = {};
    var _creatorCategoryMap = {};
    var _categories = [];

    // {description:,name : ,modelDefaultParameters:{},type:,category:,icon:,async:,}
    var _parametersMap = {};
    make.Default = {
        path: './',

        resPath: '',

        getImagePath: function (image) {
            return this.path + this.resPath + 'res/images/' + (image || '');
        },

        register: function (id, creator, parameters) {
            parameters = parameters || {};
            parameters.name = parameters.name || id;
            parameters.modelDefaultParameters = parameters.modelDefaultParameters || {};
            parameters.description = parameters.description || parameters.name;
            if (_creatorMap[id]) {
                console.log(id, ' already exist');
            }
            _creatorMap[id] = creator;
            var category = parameters.category || "";
            var map = _creatorCategoryMap[category] || {};
            map[id] = creator;
            _creatorCategoryMap[category] = map;
            _parametersMap[id] = parameters;
            if (_categories.indexOf(category) == -1) {
                _categories.push(category);
            }
            this.checkModelDefaultParameters(parameters.modelDefaultParameters);
        },

        /**
         *
         * default property name is property id
         * default property value type is make.Default.PARAMETER_TYPE_STRING
         * default property type is make.Default.PARAMETER_PROPERTY_TYPE_CLIENT
         * default property category is 'attributes'
         * default property editable is true
         */
        checkModelDefaultParameters: function (modelDefaultParameters) {

            if (!modelDefaultParameters) {
                return;
            }
            for (var p in modelDefaultParameters) {
                var v = modelDefaultParameters[p];
                if (!(v instanceof Object)) {
                    v = {
                        value: v
                    }
                    modelDefaultParameters[p] = v;
                }
                v.propertyName = p;
                v.hidden = !!v.hidden;
                v.propertyType = v.propertyType || make.Default.PARAMETER_PROPERTY_TYPE_FIELD;
                v.type = v.type || make.Default.PARAMETER_TYPE_STRING;
                v.category = v.category || make.Default.PARAMETER_CATEGORY_DETAIL;
                v.editable = v.editable === undefined ? true : !!v.editable;
                v.index = v.index === undefined ? 100 : parseInt(v.index);
            }
        },

        remove: function (id) {
            if (!_creatorMap[id]) {
                console.log(id, ' not exist');
            } else {
                _creatorMap[id] = undefined;
                delete _creatorMap[id];

                var category = make.Default.getCategory(id);
                var map = _creatorCategoryMap[category];
                delete map[id];

                var count = 0;
                for (var i in map) {
                    if (i) {
                        count++;
                    }
                }
                if (count == 0) {
                    for (var i = 0; i < _categories.length; i++) {
                        var index = _categories.indexOf(category);
                        if (index >= 0) {
                            _categories.splice(index, 1);
                        }
                    }
                }

                delete _parametersMap[id];
            }
        },

        getCategories: function () {
            return _categories;
        },

        getCreatorsForCategory: function (category) {
            return _creatorCategoryMap[category];
        },

        getCreator: function (id) {
            // return this._creators[id];
            return _creatorMap[id];
        },

        getIds: function (filterFunction) {
            var ids = [];
            for (var id in _creatorMap) {
                if (!filterFunction || (filterFunction && filterFunction(this.getParameters(id)))) {
                    ids.push(id);
                }
            }
            return ids;
        },

        getModelDefaultParameters: function (id) {
            var params = this.getParameters(id);
            return params.modelDefaultParameters;
        },

        getDescription: function (id) {
            var params = this.getParameters(id);
            return params.description;
        },

        getName: function (id) {
            var params = this.getParameters(id);
            return params.name;
        },

        getIcon: function (id) {
            var params = this.getParameters(id);
            return this.path + params.icon;
        },

        isAsync: function (id) {
            var params = this.getParameters(id);
            return params.async;
        },

        isCombo: function (id) {
            var params = this.getParameters(id);
            return params.combo;
        },

        getCategory: function (id) {
            var params = this.getParameters(id);
            return params.category;
        },

        getOrder: function (id) {
            var params = this.getParameters(id);
            return params.order || 0;
        },

        getType: function (id) {
            var params = this.getParameters(id);
            return params.type;
        },

        getOtherParameter: function (id, key) {
            var params = this.getParameters(id);
            return params[key];
        },

        registerIcon: function (id, icon) {
            var params = this.getParameters(id);
            if (!params) {
                return;
            }
            params.icon = icon;
            return params.icon;
        },

        registerDescription: function (id, description) {
            var params = this.getParameters(id);
            params.description = description;
            return params.description;
        },

        registerName: function (id, name) {
            var params = this.getParameters(id);
            params.name = name;
            return params.name;
        },

        registerOther: function (id, key, value) {

            var result = params[key];
            var params = this.getParameters(id);
            params[key] = value;
            if (key === 'modelDefaultParameters') {
                console.warn("rewrite modelDefaultParameters: id={0}, oldValue={}, newValue={}", id, result, value);
                this.checkModelDefaultParameters(value);
            }
            return result;
        },

        appendModelDefaultParameter: function (id, name, category, propertyType, type, hidden, editable) {
            var p = {
                name: name,
                category: category,
                propertyType: propertyType,

            }
        },

        getParameters: function (id) {
            return _parametersMap[id] || {};
        },

        load: function (object, callback, options) {
            var self = this;
            var options = options || {};
            var isRelation = options.isRelation;
            var jsonObjects;
            if (callback) {
                var cb = callback;
                callback = function (data) {
                    if (isRelation &&
                        object instanceof Array &&
                        object.length > 1 &&
                        data instanceof Array &&
                        data.length > 1) {
                        this._relation(object, data)
                    }
                    cb(data);
                }
            }
            if (object instanceof Array) {
                var result = {};
                var total = 0;
                if (callback) {
                    var wraperCallback = function (result, data) {
                        var length = object.length;
                        return (function (data) {
                            result.datas = result.datas || [];
                            result.datas.push(data);
                            if (result._total === length) {
                                callback(result.datas);
                            }
                        })(data);
                    };
                    result._total = 0;
                    for (var i = 0; i < object.length; i++) {
                        var child = object[i];
                        this.load(child, function (obj1) {
                            result._total++;
                            wraperCallback(result, obj1);
                        });
                    }
                    return null;
                } else {
                    jsonObjects = [];
                    for (var i = 0; i < object.length; i++) {
                        var child = object[i];
                        var data = this.load(child);
                        if (data) {
                            jsonObjects.push(data);
                        }

                    }
                }
            } else {
                var jsonObj = {};
                if (typeof (object) == 'string') {
                    jsonObj.id = object;
                } else {
                    jsonObj = object;
                }
                jsonObj = this.filterJson(jsonObj);
                if (callback) {
                    this._load(jsonObj, callback);
                } else {
                    jsonObjects = this._load(jsonObj);
                }

            }
            if (isRelation && jsonObjects instanceof Array && jsonObjects.length > 1) {
                this._relation(object, jsonObjects)
            }
            return jsonObjects;
        },

        _relation: function (objects, jsonObjects) {
            var map = {};
            jsonObjects.forEach(function (item) {
                if (item.getId) {
                    map[item.getId()] = item;
                }
            })
            objects.forEach(function (item) {
                if (item.objectId &&
                    item.parentId &&
                    map[item.objectId] &&
                    map[item.parentId] &&
                    map[item.objectId].setParent) {
                    map[item.objectId].setParent(map[item.parentId]);
                }
            })
        },

        _load: function (object, callback) {
            var id = object.id;
            var creator = this.getCreator(id);
            if (creator) {
                if (callback) {
                    creator(object, function (data) {
                        make.Default._setObjectClientId(data, id);
                        callback && callback(data);
                    })
                } else {
                    var createdObject = creator(object);
                    make.Default._setObjectClientId(createdObject, id);
                    return createdObject;
                }
            } else {
                console.log('unknown id: ', id);
                return null;
            }
        },

        _setObjectClientId: function (object, id) {
            if (object && object.setClient) {
                object.setClient('id', id);
            }
        },

        copyArray: function (from, to, ignores) {
            to = [];
            if (from) {
                var item, i = 0,
                    len = from.length;
                for (; i < len; i++) {
                    item = {};
                    this.copyProperties(from[i], item);
                    to.push(item);
                }
            }
            return to;
        },

        copyProperties: function (from, to, ignores) {
            if (from && to) {
                for (var name in from) {
                    if ((ignores && ignores.indexOf(name) >= 0) || name.indexOf('_') == 0) {
                        //ignore.
                    } else {
                        if (to[name] === undefined) {
                            if (from[name] instanceof Array) {
                                to[name] = [];
                            } else if (from[name] instanceof Function) {
                                to[name] = from[name];
                            } else if (from[name] instanceof Object) {
                                to[name] = {};
                            } else {
                                to[name] = from[name];
                            }
                        }
                        //copyfunction,ext
                        if (!(from[name] instanceof Function) && from[name] instanceof Object && to[name] instanceof Object) {
                            make.Default.copyProperties(from[name], to[name]);
                        }
                    }
                }
            }
        },

        getModelDefaultParametersValues: function (id, filter) {
            var modelDefaultParameters = this.getModelDefaultParameters(id);
            var paras = {};
            for (var p in modelDefaultParameters) {
                var pi = modelDefaultParameters[p];
                if (filter && filter(pi)) {
                    continue;
                }
                if (pi.propertyType == make.Default.PARAMETER_PROPERTY_TYPE_CLIENT) {
                    paras.client = paras.client || {};
                    paras.client[p] = pi.value;
                } else if (pi.propertyType == make.Default.PARAMETER_PROPERTY_TYPE_STYLE) {
                    paras.style = paras.style || {};
                    paras.style[p] = pi.value;
                } else {
                    paras[p] = pi.value;
                }
            }
            return paras;
        },

        getModelDefaultParameterProperties: function (id, includeBasic) {

            var self = this;
            var result = [];
            var modelDefaultParameters = this.getModelDefaultParameters(id);
            if (!modelDefaultParameters) {
                return result;
            }
            if (includeBasic && !modelDefaultParameters['id']) {
                modelDefaultParameters['id'] = {
                    propertyName: 'id',
                    name: 'ID',
                    category: make.Default.PARAMETER_CATEGORY_BASIC,
                    editable: false,
                    propertyType: make.Default.PARAMETER_PROPERTY_TYPE_FIELD,
                    type: make.Default.PARAMETER_TYPE_STRING,
                    exportable: false,
                    index: -2,
                }
            }
            if (includeBasic && !modelDefaultParameters['objectId']) {
                modelDefaultParameters['objectId'] = {
                    propertyName: 'objectId',
                    name: 'ID',
                    category: make.Default.PARAMETER_CATEGORY_BASIC,
                    editable: false,
                    propertyType: make.Default.PARAMETER_PROPERTY_TYPE_FIELD,
                    type: make.Default.PARAMETER_TYPE_STRING,
                    exportable: false,
                    index: -1,
                }
            }

            for (var p in modelDefaultParameters) {
                result.push(modelDefaultParameters[p]);
            }

            result.sort(function (o1, o2) {
                return o1.index - o2.index;
            })

            result = result.map(function (item) {
                return self.modelParameterToProperty(item)
            });
            return result;
        },

        _getNameFromPropertyName: function (propertyName) {
            var names = propertyName.split('.');
            var name = '';
            for (var i = 0; i < names.length; i++) {
                if (names[i].length > 0) {
                    name += names[i].substring(0, 1).toUpperCase() + names[i].substring(1, names[i].length);
                }
                if (i < names.length - 1) {
                    name += ' ';
                }
            }
            return name;
        },

        modelParameterToProperty: function (param) {

            var property = new twaver.Property();
            property.setCategoryName(param.category);
            if (!param.name) {
                param.name = this._getNameFromPropertyName(param.propertyName);
            }
            property.setName(param.name);
            property.setEditable(param.editable);
            property.setPropertyType(param.propertyType);
            property.setPropertyName(param.propertyName);
            property.setValueType(param.type);
            property.setEnumInfo(param.enumInfo); //{map:{1:'male', 2:'female'}, values:[1, 2]}  or  ['male', 'female']
            property.isVisible = function () {
                return !param.hidden;
            }
            return property;
        },


        filterJson: function (object) {
            var modelDefaultParameters = this.getModelDefaultParameters(object.id);
            for (var p in modelDefaultParameters) {
                var propertyType = modelDefaultParameters[p].propertyType || 'client';
                var defaultValue = modelDefaultParameters[p].value;
                if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_STYLE) {
                    if (!object.style || object.style[p] === undefined) {
                        object.style = object.style || {};
                        object.style[p] = defaultValue;
                    }
                } else if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_CLIENT) {
                    if (!object.client || object.client[p] === undefined) {
                        object.client = object.client || {};
                        object.client[p] = defaultValue;
                    }
                } else if (object[p] === undefined) {
                    object[p] = defaultValue;
                }
            }
            //object.objectId = object.objectId || make.Default.id()
            return object;

        },

        UNIT_HEIGHT: 4.445,
        EQUIPMENT_WIDTH: 45.5,
        RACK_OFFSET_X: 7.25,
        RACK_OFFSET_Y: 6.655,
        RACK_WIDTH: 60, //this.RACK_OFFSET_X + this.EQUIPMENT_WIDTH + this.RACK_OFFSET_X
        getUnitHeight: function () {
            return this.UNIT_HEIGHT;
        },
        getEquipmentWidth: function () {
            return this.EQUIPMENT_WIDTH;
        },
        getEquipmentHeight: function (size) {
            if (!(parseInt(size) > 0)) {
                console.error('method getEquipmentHeight\'s first argument scale value is zero');
            }
            return this.UNIT_HEIGHT * size;
        },
        getRackWidth: function () {
            return this.RACK_WIDTH
        },
        getRackHeight: function (size) {
            if (!(parseInt(size) > 0)) {
                console.error('method getRackHeight\'s first argument scale value is zero');
            }
            return this.RACK_OFFSET_Y + this.UNIT_HEIGHT * parseInt(size) + this.RACK_OFFSET_Y;
        },

    }

    make.Default.toJson = function (object, filter) {
        if (object && object.getClient) {
            var id = object.getClient('id');
            var params = make.Default.getModelDefaultParameters(id);
            var json = {};
            var value = null,
                defaultValue = null;
            for (var p in params) {
                if (params[p].exportable === false) {
                    continue
                }
                var propertyType = params[p].propertyType;
                var defaultValue = params[p].value;
                if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_ACCESSOR) {
                    value = object[_twaver.getter(p)]()
                    if (!make.Default.equals(value, defaultValue)) {
                        json[p] = value;
                    }
                } else if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_FIELD) {
                    value = object[p]
                    if (!make.Default.equals(value, defaultValue)) {
                        json[p] = value;
                    }
                } else if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_STYLE) {
                    value = object.getStyle(p);
                    if (!make.Default.equals(value, defaultValue)) {
                        json.style = json.style || {};
                        json.style[p] = value;
                    }
                } else if (propertyType == make.Default.PARAMETER_PROPERTY_TYPE_CLIENT) {
                    value = object.getClient(p);
                    if (!make.Default.equals(value, defaultValue)) {
                        json.client = json.client || {};
                        json.client[p] = value;
                    }
                }
            }
            json.id = id;
            if (make.Default.EXPORT_OBJECT_ID) {
                json.objectId = object.getId();
            }
            if (filter) {
                json = filter(json);
            }
            return json;
        } else {
            if (filter) {
                object = filter(object);
            }
            return object;
        }
    }

    /**
     * 
     * datafunction,,json
     * options = {
     *     copyParamCoverage:false  //. false , true  param 
     *     copyDefaultParamCoverage:false //. false , true 
     *     defaultValue: null //, modelDefualtParameter 
     *
     * }
     * @param newId {string} new model id
     * @param oldId {string} old model id
     * @param data {Object} default data
     * @param params {Object} new params
     * @param options {{copyParamCoverage:false}} options
     */
    make.Default.copy = function (newId, oldId, data, params, options) {

        var f = function (newId, oldId, data, params, options) {

            options = options || {};
            var newParams = {};
            var oldParams = {};
            var op = make.Default.getParameters(oldId);
            op = make.Default.clone(op); //,, ,,
            make.Default.copyProperties(op, oldParams);
            if (params instanceof Function) {
                newParams = params(oldParams) || {};
            } else {
                make.Default.copyProperties(params, newParams);
            }
            if (options.copyDefaultParamCoverage) {
                delete oldParams.modelDefaultParameters
            }
            if (!options.copyParamCoverage) {
                make.Default.copyProperties(oldParams, newParams);
            }
            if (options.defaultValue && newParams.modelDefaultParameters) {
                for (var p in options.defaultValue) {
                    if (newParams.modelDefaultParameters[p] !== undefined) {
                        if (newParams.modelDefaultParameters[p] instanceof Object) {
                            newParams.modelDefaultParameters[p].value = options.defaultValue[p];
                        } else {
                            newParams.modelDefaultParameters[p] = options.defaultValue[p];
                        }
                    }
                }
            }
            make.Default.register(newId, function (json, callback) {
                var newData = {
                    id: oldId
                };
                if (data instanceof Function) {
                    data(json);
                } else {
                    make.Default.copyProperties(data, newData);
                }
                make.Default.copyProperties(json, newData);
                var node = make.Default.load(newData, callback);
                return node;
            }, newParams)
        }
        f(newId, oldId, data, params, options);
    }

    /**
     * 
     */
    make.Default.PARAMETER_CATEGORY_BASIC = 'BASIC';
    make.Default.PARAMETER_CATEGORY_DETAIL = 'Detail';

    make.Default.PARAMETER_TYPE_STRING = 'string';
    make.Default.PARAMETER_TYPE_BOOLEAN = 'boolean';
    make.Default.PARAMETER_TYPE_COLOR = 'color';
    make.Default.PARAMETER_TYPE_INT = 'int';
    make.Default.PARAMETER_TYPE_NUMBER = 'number';
    make.Default.PARAMETER_TYPE_IMAGE = 'image';
    make.Default.PARAMETER_TYPE_ARRAY_STRING = 'array.string';
    make.Default.PARAMETER_TYPE_ARRAY_NUMBER = 'array.number';
    make.Default.PARAMETER_TYPE_ARRAY_INT = 'array.int';

    make.Default.PARAMETER_PROPERTY_TYPE_FIELD = 'field';
    make.Default.PARAMETER_PROPERTY_TYPE_ACCESSOR = 'accessor';
    make.Default.PARAMETER_PROPERTY_TYPE_STYLE = 'style';
    make.Default.PARAMETER_PROPERTY_TYPE_CLIENT = 'client';

    String.prototype.replaceAll = function (reallyDo, replaceWith, ignoreCase) {
        if (!RegExp.prototype.isPrototypeOf(reallyDo)) {
            return this.replace(new RegExp(reallyDo, (ignoreCase ? "gi" : "g")), replaceWith);
        } else {
            return this.replace(reallyDo, replaceWith);
        }
    }

    /**
     * ,  
     * '1{}3'.format(2)
     * 1{0}3'.format([2])
     * 1{0}3{1}'.format(2,4)
     * 1{a}3'.format({a:2})
     * @param value
     * @returns {*}
     */
    String.prototype.format = function (value) {
        var patten = this;
        if (arguments.length > 1) {
            var t = [];
            for (var i = 0; i < arguments.length; i++) {
                t.push(arguments[i]);
            }
            value = t;
        }

        if (value) {
            var type = typeof value;
            if (value instanceof Array) {
                value.forEach(function (item, i) {
                    if (item instanceof Object) {
                        item = JSON.stringify(item);
                    }
                    patten = patten.replaceAll('{' + i + '}', item);
                })
            } else if (value instanceof Object) {
                for (var p in value) {
                    var item = value[p];
                    if (item instanceof Object) {
                        item = JSON.stringify(item);
                    }
                    patten = patten.replaceAll('{' + p + '}', item);
                }
            } else {
                return patten.replaceAll('{}', value)
            }
        }
        return patten;
    }

    make.Default.getId = function (data) {
        return data.getClient('id');
    }

    make.Default.objectWrapper = function (object, field, getterFilter, setterFilter) {
        Object.defineProperty(object, field, {
            get: function () {
                var value = object['___' + field];
                if (getterFilter) {
                    value = getterFilter.call(object, value, object, field);
                }
                return value;
            },
            set: function (newValue) {
                var oldValue = object[field];
                if (setterFilter) {
                    newValue = setterFilter.call(object, newValue, object, field);
                }
                if (oldValue !== newValue) {
                    object['___' + field] = newValue;
                    this.firePropertyChange && this.firePropertyChange(field, oldValue, newValue);
                }
            }
        });
    };

    make.Default.equals = function (o1, o2) {

        if (o1 instanceof Object && o2 instanceof Object) {
            return JSON.stringify(o1) == JSON.stringify(o2);
        } else {
            return o1 == o2;
        }
    };

    make.Default.clone = function (o) {
        try {
            return JSON.parse(JSON.stringify(o));
        } catch (e) {
            console.error(e, o);
            throw e;
        }
    }

    make.Default.EXPORT_OBJECT_ID = true;
} else {
    var make = window.make;
}
/* 
 Utils2D2d
 */

make.Utils2D = {
    create2dShapeNode: function (json) {
        var position = json.position || [0, 0, 0];
        var nodeData = json.data;
        var image = json.image;
        var objType = json.objType;
        var objectId = json.objectId;
        var closed = json.closed;

        //ImageShapeNode
        var object2d = new make.Default.WallShapeNode(objectId);
        if (json.objType == 'innerWall') {
            object2d = new make.Default.InnerWallShapeNode(objectId);
        } else if (json.objType == 'floor') {
            object2d = new make.Default.FloorShapeNode(objectId);
        } else if (json.objType == 'cable') {
            object2d = new make.Default.LineWidthShapeNode(objectId);
        }
        var pathObject = make.Default.create2dShapePath(nodeData, position);
        make.Default.objectWrapper(object2d, 'id', function () {

            return this.getClient('id');
        });

        make.Default.objectWrapper(object2d, 'objectId', function () {

            return this.getId();
        });

        object2d.setSegments(pathObject.segments);
        object2d.setPoints(pathObject.points);
        if (closed) object2d.setClient('closed', true);
        if (image) object2d.setClient('imageSrc', image);

        make.Default.setObject2dCSProps(object2d, json);
        /*if(image){
         object2d.setClient($consts.IMAGE_SRC,$utils.Path+image);
         }*/
        // object2d.setClient('label', (json.label || modelLabelMap[json.name]));
        return object2d;
    },

    create2dShapePath: function (nodeData, position) {
        var segments = new twaver.List();
        var pointsList = new twaver.List();
        if (nodeData.length > 0) {
            segments.add('moveto');
            if (nodeData[0] instanceof Array) {
                pointsList.add({
                    x: parseFloat(nodeData[0][0]) + parseFloat(position[0]),
                    y: parseFloat(nodeData[0][1]) + parseFloat(position[2])
                });
                for (var i = 1; i < nodeData.length; i++) {
                    var point = nodeData[i];
                    if (point[0] == 'c') {
                        segments.add('quadto');
                        pointsList.add({
                            x: parseFloat(point[1]) + parseFloat(position[0]),
                            y: parseFloat(point[2]) + parseFloat(position[2])
                        });
                        pointsList.add({
                            x: parseFloat(point[3]) + parseFloat(position[0]),
                            y: parseFloat(point[4]) + parseFloat(position[2])
                        });
                    } else {
                        segments.add('lineto');
                        pointsList.add({
                            x: parseFloat(point[0]) + parseFloat(position[0]),
                            y: parseFloat(point[1]) + parseFloat(position[2])
                        });
                    }
                }
            } else {
                pointsList.add({
                    x: parseFloat(nodeData[0]) + parseFloat(position[0]),
                    y: parseFloat(nodeData[1]) + parseFloat(position[2])
                });
                for (var i = 2; i < nodeData.length; i = i + 2) {
                    segments.add('lineto');
                    pointsList.add({
                        x: parseFloat(nodeData[i]) + parseFloat(position[0]),
                        y: parseFloat(nodeData[i + 1]) + parseFloat(position[2])
                    });
                }
            }

        }
        return {
            segments: segments,
            points: pointsList,
        }

    },

    setObject2dCSProps: function (node, json) {
        var style = json.style;
        var client = json.client;

        if (style) {
            for (var i in style) {
                node.setStyle(i, style[i]);
            }
        }
        if (client) {
            for (var i in client) {
                node.setClient(i, client[i]);
            }
        }
    },

    createBlockObject: function (json, type) {
        var objectId = json.objectId;
        var object2d = new make.Default.Block(objectId);
        if ('door' == type) {
            object2d = new make.Default.Door(objectId);
        } else if ('window' == type) {
            object2d = new make.Default.Window(objectId);
        }
        if (json.width) {
            object2d.setClient('length', json.width);
        }
        var client = json.client || {};
        object2d.setClient('edgeIndex', client.edgeIndex || 1);
        object2d.setClient('offset', client.offset || 0);
        make.Default.setObject2dCSProps(object2d, json);
        return object2d;
    },

    createNode: function (json) {
        var position = json.position || [0, 0, 0];
        var rotation = json.rotation || [0, 0, 0];
        var width = json.width || 50;
        var depth = json.depth || 50;
        var image = json.image;
        var objectId = json.objectId;
        var object2d = new twaver.Follower(objectId);
        var color = json.color || '#CCCCFF';

        make.Default.objectWrapper(object2d, 'id', function () {

            return this.getClient('id');
        });

        make.Default.objectWrapper(object2d, 'objectId', function () {

            return this.getId();
        });

        object2d.setSize(parseFloat(width), parseFloat(depth));
        object2d.setCenterLocation({x: parseFloat(position[0]), y: parseFloat(position[2])});
        object2d.setAngle(rotation[1]);

        object2d.setClient('positionY', position[1]);

        if (typeof image == 'string') {
            object2d.setImageUrl(image);
        } else if (typeof image == 'object') {
            object2d.setImage(image);
        } else {
            object2d.setStyle('body.type', 'vector');
            object2d.setStyle('vector.shape', 'rectangle');
            object2d.setStyle('vector.fill.color', color);
        }
        object2d.setStyle('select.style', 'border');
        object2d.setStyle('select.color', '#F07819');
        object2d.setStyle('select.width', 0.7);
        object2d.setStyle('vector.outline.width', 1);
        object2d.setStyle('vector.outline.color', '#BEC9BE');
        if(object2d.getWidth() > 20){
            object2d.setStyle('label.maxlength', Math.min(object2d.getWidth(), object2d.getHeight()));
        }

        object2d.setStyle('label.position', 'center');
        make.Default.setObject2dCSProps(object2d, json);
        return object2d;
    },

    createFollower: function (json) {
        var args = json;
        var json = {};
        make.Default.copyProperties(args, json);
        json.id = json.objectId || _twaver.id();

        json.scale = json.scale || 1;
        json.depth = json.depth || 5;
        json.position = json.position || [0, 0, 0];
        json.rotation = json.rotation || [0, 0, 0];
        var node = new twaver.Follower(json);

        make.Default.objectWrapper(node, 'id', function () {

            return node.getClient('id');
        });

        make.Default.objectWrapper(node, 'objectId', function () {

            return node.getId();
        });

        make.Default.objectWrapper(node, 'depth');

        make.Default.objectWrapper(node, 'position', null, function (newValue) {
            this.setLocation({x: newValue[0], y: newValue[1]});
            return newValue;
        });
        make.Default.objectWrapper(node, 'rotation', null, function (newValue) {
            this.setAngle(newValue[2]);
            return newValue;
        });

        make.Default.objectWrapper(node, 'scale', null, function (newValue) {
            var size = this.getSize();
            size.width = size.width * newValue;
            size.height = size.height * newValue;
            this.setSize(size);

            var location = this.getLocation();
            location.x = location.x * newValue;
            location.y = location.y * newValue;
            node.setLocation(location);
            return newValue;
        });

        node.depth = json.depth;

        node.position = json.position;

        node.rotation = json.rotation;

        node.scale = json.scale;

        //,position
        node.addPropertyChangeListener(function (e) {

            var property = e.property;
            var source = e.source;
            if (property == 'location') {
                source.position[0] = e.newValue.x;
                source.position[1] = e.newValue.y;
            } else if (property == 'angle') {
                source.rotation[2] = e.newValue;
            }
        }, node);

        //FIXME 
        if (json.x) {
            node.setX(json.x);
        }
        if (json.y) {
            node.setY(json.y);
        }
        node.z = json.z;
        if (json.location) {
            if (json.location instanceof Array) {
                node.setLocation({x: json.location[0], y: json.location[1]});
            } else {
                node.setLocation(json.location);
            }
        }
        if (json.centerLocation) {
            if (json.centerLocation instanceof Array) {
                node.setCenterLocation({x: json.centerLocation[0], y: json.centerLocation[1]});
            } else {
                node.setCenterLocation(json.centerLocation);
            }
        }
        if (json.size) {
            node.setSize(json.size);
        }
        if (json.angle) {
            node.setAngle(json.angle);
        }
        node.setStyle('select.style', 'border');
        node.setStyle('select.color', '#F07819');
        node.setStyle('select.width', 0.7);
        node.setStyle('vector.outline.color', '#BEC9BE');
        make.Default.setObject2dCSProps(node, json);
        return node;
    },

    /**
     * 
     * @param data {twaver.List}
     * @param type {string} up down left right center() middle()
     */
    align: function (data, type) {
        if (!type) {
            return;
        }
        if (!data || data.size() < 2) {
            return;
        }
        var fun = this['_align_' + type];
        if (!fun) {
            return;
        }
        fun.call(this, data);
    },
    _align_up: function (data) {
        var min = data.get(0).getLocation().y;
        for (var i = 1; i < data.size(); i++) {
            min = Math.min(min, data.get(i).getLocation().y);
        }
        data.forEach(function (node) {
            node.setY(min);
        });
    },
    _align_down: function (data) {
        var max = data.get(0).getLocation().y + data.get(0).getSize().height;
        for (var i = 1; i < data.size(); i++) {
            max = Math.max(max, data.get(i).getLocation().y + data.get(i).getSize().height);
        }
        data.forEach(function (node) {
            node.setY(max - node.getSize().height);
        });
    },
    _align_left: function (data) {
        var min = data.get(0).getLocation().x;
        for (var i = 1; i < data.size(); i++) {
            min = Math.min(min, data.get(i).getLocation().x);
        }
        data.forEach(function (node) {
            node.setX(min);
        });
    },
    _align_right: function (data) {
        var max = data.get(0).getLocation().x + data.get(0).getSize().width;
        for (var i = 1; i < data.size(); i++) {
            max = Math.max(max, data.get(i).getLocation().x + data.get(i).getSize().width);
        }
        data.forEach(function (node) {
            node.setX(max - node.getSize().width);
        });
    },
    _align_center: function (data) {
        var sum = 0;
        for (var i = 0; i < data.size(); i++) {
            sum += data.get(i).getCenterLocation().y;
        }
        var avg = sum / data.size();
        data.forEach(function (node) {
            node.setY(avg - node.getSize().height / 2);
        });
    },
    _align_middle: function (data) {
        var sum = 0;
        for (var i = 0; i < data.size(); i++) {
            sum += data.get(i).getCenterLocation().x;
        }
        var avg = sum / data.size();
        data.forEach(function (node) {
            node.setX(avg - node.getSize().width / 2);
        });
    },

    /**
     * 
     * @param data {twaver.List}
     * @param type {string} hor,ver
     * @param padding
     */
    flow: function (data, type, padding) {
        if (!type) {
            return;
        }
        if (!data || data.size() < 2) {
            return;
        }
        var fun = this['_flow_' + type];
        if (!fun) {
            return;
        }
        fun.call(this, data, padding);
    },
    _flow_hor: function (data, padding) {
        //
        this.sort(data, function (n1, n2) {
            return n1.getLocation().y - n2.getLocation().y;
        });
        this.sort(data, function (n1, n2) {
            return n1.getLocation().x - n2.getLocation().x;
        });
        var last = data.get(0);
        for (var i = 1; i < data.size(); i++) {
            var curr = data.get(i);
            var x = last.getLocation().x;
            //var w = last.getSize().width;
            //curr.setX(x + w + padding);
            curr.setX(x + padding);
            last = curr;
        }
    },
    _flow_ver: function (data, padding) {
        //
        this.sort(data, function (n1, n2) {
            return n1.getLocation().x - n2.getLocation().x;
        });
        this.sort(data, function (n1, n2) {
            return n1.getLocation().y - n2.getLocation().y;
        });
        var last = data.get(0);
        for (var i = 1; i < data.size(); i++) {
            var curr = data.get(i);
            var y = last.getLocation().y;
            //var h = last.getSize().height;
            //curr.setY(y + h + padding);
            curr.setY(y + padding);
            last = curr;
        }
    },
    sort: function (data, compare) {
        var size = data.size();
        var a, b, r, t;
        for (var i = 0; i < size; i++) {
            a = data.get(i);
            for (var j = i + 1; j < size; j++) {
                b = data.get(j);
                r = compare ? compare(a, b) : 0;
                if (r > 0) {
                    t = b;
                    b = a;
                    a = t;
                    data.set(i, a);
                    data.set(j, b);
                }
            }
        }
    },

    wrapper: function (object, otherFiled) {

        make.Default.objectWrapper(object, 'id', function () {

            return this.getClient('id');
        });

        make.Default.objectWrapper(object, 'objectId', function () {

            return this.getId();
        });

        //
        make.Default.objectWrapper(object, 'width');
        make.Default.objectWrapper(object, 'height');
        make.Default.objectWrapper(object, 'depth');

        //
        make.Default.objectWrapper(object, 'px');
        make.Default.objectWrapper(object, 'py');
        make.Default.objectWrapper(object, 'pz');

        //
        make.Default.objectWrapper(object, 'rx');
        make.Default.objectWrapper(object, 'ry');
        make.Default.objectWrapper(object, 'rz');

        make.Default.objectWrapper(object, 'position');
        make.Default.objectWrapper(object, 'rotation');

        if (otherFiled) {
            otherFiled.forEach(function (field) {
                make.Default.objectWrapper(object, field);
            })
        }
    },
    //wrapperForTop: function (object, otherFiled) {
    //
    //    this.wrapper(object, otherFiled);
    //    object.addPropertyChangeListener(function (e) {
    //
    //        var property = e.property;
    //        var source = e.source;
    //        //   location,angle
    //        //property  px, py, pz, rx, ry, rz
    //        if (property == 'location') {
    //            source.px = e.newValue.x;
    //            source.pz = e.newValue.y;
    //        } else if (property == 'angle') {
    //            source.ry = e.newValue;
    //        } else if (property == 'px') {
    //            source.position[0] = e.newValue;
    //        } else if (property == 'py') {
    //            source.position[1] = e.newValue;
    //        } else if (property == 'pz') {
    //            source.position[2] = e.newValue;
    //        } else if (property == 'rx') {
    //            source.rotation[0] = e.newValue;
    //        } else if (property == 'ry') {
    //            source.rotation[1] = e.newValue;
    //        } else if (property == 'rz') {
    //            source.rotation[2] = e.newValue;
    //        }
    //    });
    //},
    //wrapperForFront: function (object, otherFiled) {
    //
    //    this.wrapper(object, otherFiled);
    //    object.addPropertyChangeListener(function (e) {
    //
    //        var property = e.property;
    //        var source = e.source;
    //        //   location,angle
    //        //property  px, py, pz, rx, ry, rz
    //        if (property == 'location') {
    //            source.px = e.newValue.x;
    //            source.py = e.newValue.y;
    //        } else if (property == 'angle') {
    //            source.rz = e.newValue;
    //        } else if (property == 'px') {
    //            source.position[0] = e.newValue;
    //        } else if (property == 'py') {
    //            source.position[1] = e.newValue;
    //        } else if (property == 'pz') {
    //            source.position[2] = e.newValue;
    //        } else if (property == 'rx') {
    //            source.rotation[0] = e.newValue;
    //        } else if (property == 'ry') {
    //            source.rotation[1] = e.newValue;
    //        } else if (property == 'rz') {
    //            source.rotation[2] = e.newValue;
    //        }
    //    });
    //},
}

make.Default.register('twaver.cube.top', function (json, callback) {
    var node = make.Utils2D.createNode(json);
    if (callback) callback(node);
    return node;
});

for (var p in make.Utils2D) {
    make.Default[p] = make.Utils2D[p];
}
}();
